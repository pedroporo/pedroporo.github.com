[
{
		"title": "Asignatura de entornos a clientes",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/",
		"content": "type note(function(){return this.inputEl.value}) template\naction Sin título\ntemplater true\n```{ #button-km7s}\n\n[Pagina de github de los apuntes](https://github.com/cipfpbatoi/materials)",
		"tags": ["button-km7s", "note"]
},

{
		"title": "Desarollo Web en entorno servidor",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/",
		"content": "Pagina de github de los apuntes\nphp artisan route:list\n\nphp artisan make:resource JugadoraResource\nphp artisan make:component Pacient\nphp artisan make:model Pacient\nphp artisan make:seeder ZoneSeeder\n\nphp artisan make:factory ZoneFactory -m Zone\n\nphp artisan make:migration add_role_to_users_table --table=users\nphp artisan make:middleware RoleMiddleware\nphp artisan make:policy PatientPolicy --model=Patient\nphp artisan make:request PatientRequest\nphp artisan make:resource PatientResource\n\nphp artisan make:controller Api/JugadoraController --api --model=Jugadora\n\nEjecutar los comandos de db php artisan migrate:fresh --seed\nphp artisan make:resource ContactResource\nphp artisan make:component Contact\nphp artisan make:model Contact\nphp artisan make:seeder ContactSeeder\nphp artisan make:factory ContactFactory -m Contact\nphp artisan make:migration create_table_contacts --create=contacts\nphp artisan make:policy ContactPolicy --model=Contact\nphp artisan make:request ContactRequest\nphp artisan make:resource ContactResource\nphp artisan make:controller Api/ContactController --api --model=Contact\n\nphp artisan make:resource ContactResource\nphp artisan make:component Contact\nphp artisan make:model Contact\nphp artisan make:seeder ContactSeeder\nphp artisan make:factory ContactFactory -m Contact\nphp artisan make:migration create_table_contacts --create=contacts\nphp artisan make:policy ContactPolicy --model=Contact\nphp artisan make:request ContactRequest\n\nphp artisan make:resource CallResource\nphp artisan make:component Call\nphp artisan make:model Call\nphp artisan make:seeder CallSeeder\nphp artisan make:factory CallFactory -m Call\nphp artisan make:migration create_table_calls --create=calls\nphp artisan make:policy CallPolicy --model=Call\nphp artisan make:request CallRequest\n\nphp artisan make:resource AlertResource\nphp artisan make:component Alert\nphp artisan make:model Alert\nphp artisan make:seeder AlertSeeder\nphp artisan make:factory AlertFactory -m Alert\nphp artisan make:migration create_table_alerts --create=alerts\nphp artisan make:policy AlertPolicy --model=Alert\nphp artisan make:request AlertRequest\n\nphp artisan make:resource ReportResource\nphp artisan make:component Report\nphp artisan make:model Report\nphp artisan make:seeder ReportSeeder\nphp artisan make:factory ReportFactory -m Report\nphp artisan make:migration create_table_reports --create=reports\nphp artisan make:policy ReportPolicy --model=Report\nphp artisan make:request ReportRequest\n\nphp artisan make:controller Api/ContactController --api --model=Contact\nphp artisan make:controller Api/CallController --api --model=Call\nphp artisan make:controller Api/AlertController --api --model=Alert\nphp artisan make:controller Api/OperatorController --api --model=User\nphp artisan make:controller Api/ReportController --api --model=Report\n\nphp artisan make:component User\n\nphp artisan make:resource UserResource\nphp artisan make:policy UserPolicy --model=User",
		"tags": [ "note"]
},

{
		"title": "Despliegue de aplicaciones WEB",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/",
		"content": "Hola despliege\nSSH",
		"tags": [ "note","despliege"]
},

{
		"title": "Diseño de interfaces WEB",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/",
		"content": "Hola Diseño\nRepositorio de Diseño",
		"tags": [ "note"]
},

{
		"title": "Indice DAW",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/indice-daw/",
		"content": "Asignaturas\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/ingles/ingles/\">Ingles</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\nHorario:\nempazcm\nPMDM-Pedro-Guillferri\n\nHora\nLunes\nMartes\nMiercoles\nJueves\nViernes\n\n14:55 - 15:50\nEmpresa\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\nEmpresa\n\n15:50 - 16:45\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\nEmpresa\n\n16:45 - 17:40\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\nTutoria\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/ingles/ingles/\">Ingles</a>\n\n17:40 - 18:00\nDescanso\nDescanso\nDescanso\nDescanso\nDescanso\n\n18:00 - 18:55\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/ingles/ingles/\">Ingles</a>\n\n18:55 - 19:50\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n\n19:50 - 20:45\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n\n20:45 - 21:40\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/01-apuntes/daw/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>",
		"tags": [ "note"]
},

{
		"title": "Ingles",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/ingles/ingles/",
		"content": "Profesor:\nagendaweb\n1 feb entregar proyecto\n7 feb examen\n14Feb presentacion",
		"tags": [ "note"]
},

{
		"title": "01-sintaxis",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/DAW/Javascript Teoria Batoi/01-sintaxis/",
		"content": "= en una asignación pero debemos hacerlo siempre igual. Existen muchas guías de estilo y muy buenas: Airbnb, Google, Idiomatic, etc. Para obligarnos a seguir las reglas podemos usar alguna herramienta linter.\n\nTambién es conveniente para mejorar la legibilidad de nuestro código separar las líneas de más de 80 caracteres.\nUsar `",
		"tags": [ "note"]
},

{
		"title": "02.1-objetos",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/02-1-objetos/",
		"content": "Objetos en Javascript\n\nObjetos en Javascript\n\nIntroducción\nPropiedades de un objeto\nMétodos de un objeto\nPropagación de propiedades\nDesestructuración de objetos\nComparación de objetos\nCopia de objetos\nBibliografía\n\nIntroducción\nEn Javascript podemos definir cualquier variable como un objeto declarándola con new (NO se recomienda) o creando un literal object (usando notación JSON). Ejemplo con new (no recomendado):\nconst alumno = new Object()\nalumno.nombre = 'Carlos' // se crea la propiedad 'nombre' y se le asigna un valor\nalumno['apellidos'] = 'Pérez Ortiz' // se crea la propiedad 'apellidos'\nalumno.edad = 19\n\nCreando un literal object (es la forma recomendada) el ejemplo anterior sería:\nconst alumno = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\n\nPropiedades de un objeto\nPodemos acceder a las propiedades con . (punto) o [ ]:\nconsole.log(alumno.nombre) // imprime 'Carlos'\nconsole.log(alumno['nombre']) // imprime 'Carlos'\nlet prop = 'nombre'\nconsole.log(alumno[prop]) // imprime 'Carlos'\n\nSi intentamos acceder a propiedades que no existen no se produce un error, se devuelve undefined:\nconsole.log(alumno.ciclo) // muestra undefined\n\nSin embargo se genera un error si intentamos acceder a propiedades de algo que no es un objeto:\nconsole.log(alumno.ciclo) // muestra undefined\nconsole.log(alumno.ciclo.descrip) // se genera un ERROR\n\nPara evitar ese error antes había que comprobar que existan las propiedades previas:\nconsole.log(alumno.ciclo &amp;&amp; alumno.ciclo.descrip)\n// si alumno.ciclo es un objeto muestra el valor de\n// alumno.ciclo.descrip y si no muestra undefined\n\nCon ES2020 (ES11) se ha incluido el operador de encadenamiento opcional ?. para evitar tener que comprobar esto nosotros:\nconsole.log(alumno.ciclo?.descrip)\n// si alumno.ciclo es un objeto muestra el valor de\n// alumno.ciclo.descrip y si no muestra undefined\n\nPodremos recorrer las propiedades de un objecto con for..in:\nfor (let prop in alumno) {\nconsole.log(prop + ': ' + alumno[prop])\n}\n\nSi el valor de una propiedad es el valor de una variable que se llama como la propiedad no es necesario ponerlo:\nlet nombre = 'Carlos'\n\nconst alumno = {\nnombre, // es equivalente a nombre: nombre\napellidos: 'Pérez Ortiz',\n...\n\nMétodos de un objeto\nUna propiedad de un objeto puede ser una función:\nalumno.getInfo = function() {\nreturn 'El alumno ' + this.nombre + ' ' + this.apellidos + ' tiene ' + this.edad + ' años'\n}\n\nNOTA: No podemos ponerlo con sintaxis arrow function porque no se podría acceder a las propiedades del objeto con this.\nY para llamarlo se hace como con cualquier otra propiedad:\nconsole.log(alumno.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nEJERCICIO: Crea un objeto llamado tvSamsung con las propiedades nombre (&quot;TV Samsung 42&quot;), categoria (&quot;Televisores&quot;), unidades (4), precio (345.95) y con un método llamado importe que devuelve el valor total de las unidades (nº de unidades * precio)\n\nPropagación de propiedades\nEl operador de propagación, ... (3 puntos), permite extraer las propiedades de un objeto. Ejemplo:\nconst personaCarlos = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\nconst alumnoCarlos = {\n...personaCarlos,\nciclo: 'DAW',\ncurso: 2,\n};\n\nEl objeto alumnoCarlos tendrá las propiedades de personaCarlos y las que se le añadan. Si se repiten las propiedades se sobreescriben:\nconst alumnoCarlos = {\n...personaCarlos,\nciclo: 'DAW',\ncurso: 2,\nedad: 20,\n};\n\nDesestructuración de objetos\nSimilar al anterior, permite extraer directamente a variables sólo las propiedades que necesitemos de un objeto. Ejemplo:\nconst personaCarlos = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\n\nfunction muestraNombre({nombre, apellidos}) {\nconsole.log('El nombre es ' + nombre + ' ' + apellidos)\n}\n\nmuestraNombre(personaCarlos)\n\nAunque a la función se le pasa un objeto esta toma como parámetros sólo 2 de sus propiedades y las asigna a las variables nombre y apellidos.\nTambién podemos asignar valores por defecto:\nfunction miProducto({nombre, apellidos = 'Desconocidos'}) {\n...\n\nComparación de objetos\nEn Javascript los objetos se comparan por referencia, no por valor. Por lo que dos objetos con los mismos valores no son iguales:\nconst a = {id:2, name: 'object 2'}\nconst b = {id:2, name: 'object 2'}\nconsole.log(a === b) // muestra false\n\nCopia de objetos\nCuando copiamos una variable de tipo boolean, string o number o se pasa como parámetro a una función se hace una copia de la misma y si se modifica la variable original no es alterada. Ej.:\nlet a = 54\nlet b = a // a = 54 b = 54\nb = 86 // a = 54 b = 86\n\nSin embargo al copiar objetos (y arrays, que son un tipo de objeto) la nueva variable apunta a la misma posición de memoria que la antigua por lo que los datos de ambas son los mismos:\nconst a = {id:2, name: 'object 2'}\nconst b = a\nb.name = 'object 3' // a = {id:2, name: 'object 3'} b = {id:2, name: 'object 3'}\n\nconst a = [54, 23, 12]\nconst b = a // a = [54, 23, 12] b = [54, 23, 12]\nb[0] = 3 // a = [3, 23, 12] b = [3, 23, 12]\n\nconst fecha1 = new Date('2018-09-23')\nconst fecha2 = fecha1 // fecha1 = '2018-09-23' fecha2 = '2018-09-23'\nfecha2.setFullYear(1999) // fecha1 = '1999-09-23' fecha2 = '1999-09-23'\n\nPara obtener una copia independiente de un array o un objeto podemos usar el operador de propagación ... o el método Object.assign. Ejemplo:\nconst a = {id:2, name: 'object 2'}\nconst b = {...a} // ahora ambos objetos contienen lo mismo pero son diferentes\nb.name = 'object 3' // a = {id:2, name: 'object 2'} b = {id:2, name: 'object 3'}\n\nCon Object.assign haremos:\nconst a = {id:2, name: 'object 2'}\nconst b = Object.assign({}, a) // ahora ambos objetos contienen lo mismo pero son diferentes\n\nSin embargo si el objeto tiene como propiedades otros objetos estos se continúan pasando por referencia. Es ese caso lo más sencillo sería hacer:\nconst a = {id: 2, name: 'object 2', address: {street: 'Rue del Percebe', num: 13} }\nconst copiaDeA = JSON.parse(JSON.stringify(a)) // ahora ambos objetos contienen lo mismo pero son diferentes\n\no bien usar la función structuredClone:\nconst a = {id: 2, name: 'object 2', address: {street: 'Rue del Percebe', num: 13} }\nconst b = structuredClone(a) // ahora ambos objetos contienen lo mismo pero son diferentes\n\nEJERCICIO: Dado el objeto a del último ejemplo copialo a un nuevo objeto b con ... y prueba a cambiar las pripiedades id y street de b. ¿Qué pasa con sus valores en a?.\n\nBibliografía\n\nCurso 'Programación con JavaScript'. CEFIRE Xest. Arturo Bernal Mayordomo",
		"tags": [ "note"]
},

{
		"title": "02.2-arrays",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/02-2-arrays/",
		"content": "Arrays\n\nArrays\n\nIntroducción\n\nArrays de objetos\n\nOperaciones con Arrays\n\nlength\nAñadir elementos\nEliminar elementos\nsplice\nslice\nArrays y Strings\nsort\nOtros métodos comunes\n\nFunctional Programming\n\nfilter\nfind\nfindIndex\nevery / some\nmap\nreduce\nforEach\nincludes\nArray.from\n\nRest y Spread\nDesestructuración de arrays\nCopia de arrays\nMap\nSet\n\nIntroducción\nSon un tipo de objeto y no tienen tamaño fijo sino que podemos añadirle elementos en cualquier momento.\nSe recomienda crearlos usando notación JSON:\nconst a = []\nconst b = [2,4,6]\n\naunque también podemos crearlos como instancias del objeto Array (NO recomendado):\nconst a = new Array() // a = []\nconst b = new Array(2,4,6) // b = [2, 4, 6]\n\nSus elementos pueden ser de cualquier tipo, incluso podemos tener elementos de tipos distintos en un mismo array. Si no está definido un elemento su valor será undefined. Ej.:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconsole.log(a[0]) // imprime 'Lunes'\nconsole.log(a[4]) // imprime 6\na[7] = 'Juan' // ahora a = ['Lunes', 'Martes', 2, 4, 6, , , 'Juan']\nconsole.log(a[7]) // imprime 'Juan'\nconsole.log(a[6]) // imprime undefined\nconsole.log(a[10]) // imprime undefined\n\nAcceder a un elemento de un array que no existe no provoca un error (devuelve undefined) pero sí lo provoca acceder a un elemento de algo que no es un array. Con ES2020 (ES11) se ha incluido el operador ?. para evitar tener que comprobar nosotros que sea un array:\nconsole.log(alumnos?.[0])\n// si alumnos es un array muestra el valor de su primer\n// elemento y si no muestra undefined pero no lanza un error\n\nArrays de objetos\nEs habitual almacenar datos en arrays en forma de objetos, por ejemplo:\nconst alumnos = [\n{\nid: 1,\nname: 'Marc Peris',\ncourse: '2nDAW',\nage: 21\n},\n{\nid: 2,\nname: 'Júlia Tortosa',\ncourse: '2nDAW',\nage: 23\n},\n]\n\nOperaciones con Arrays\nVamos a ver los principales métodos y propiedades de los arrays.\nlength\nEsta propiedad devuelve la longitud de un array:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconsole.log(a.length) // imprime 5\n\nPodemos reducir el tamaño de un array cambiando esta propiedad, aunque es una forma poco clara de hacerlo:\na.length = 3 // ahora a = ['Lunes', 'Martes', 2]\n\nAñadir elementos\nPodemos añadir elementos al final de un array con push o al principio con unshift:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\na.push('Juan') // ahora a = ['Lunes', 'Martes', 2, 4, 6, 'Juan']\na.unshift(7) // ahora a = [7, 'Lunes', 'Martes', 2, 4, 6, 'Juan']\n\nEliminar elementos\nPodemos borrar el elemento del final de un array con pop o el del principio con shift. Ambos métodos devuelven el elemento que hemos borrado:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst ultimo = a.pop() // ahora a = ['Lunes', 'Martes', 2, 4] y ultimo = 6\nconst primero = a.shift() // ahora a = ['Martes', 2, 4] y primero = 'Lunes'\n\nsplice\nPermite eliminar elementos de cualquier posición del array y/o insertar otros en su lugar. Devuelve un array con los elementos eliminados. Sintaxis:\nArray.splice(posicion, num. de elementos a eliminar, 1º elemento a insertar, 2º elemento a insertar, 3º...)\n\nEjemplo:\nlet a = ['Lunes', 'Martes', 2, 4, 6]\nlet borrado = a.splice(1, 3) // ahora a = ['Lunes', 6] y borrado = ['Martes', 2, 4]\na = ['Lunes', 'Martes', 2, 4, 6]\nborrado = a.splice(1, 0, 45, 56) // ahora a = ['Lunes', 45, 56, 'Martes', 2, 4, 6] y borrado = []\na = ['Lunes', 'Martes', 2, 4, 6]\nborrado = a.splice(1, 3, 45, 56) // ahora a = ['Lunes', 45, 56, 6] y borrado = ['Martes', 2, 4]\n\nEJERCICIO: Guarda en un array la lista de la compra con Peras, Manzanas, Kiwis, Plátanos y Mandarinas. Haz los siguiente con splice:\n\nElimina las manzanas (debe quedar Peras, Kiwis, Plátanos y Mandarinas)\nAñade detrás de los Plátanos Naranjas y Sandía (debe quedar Peras, Kiwis, Plátanos, Naranjas, Sandía y Mandarinas)\nQuita los Kiwis y pon en su lugar Cerezas y Nísperos (debe quedar Peras, Cerezas, Nísperos, Plátanos, Naranjas, Sandía y Mandarinas)\n\nslice\nDevuelve un subarray con los elementos indicados pero sin modificar el array original (sería como hacer un substr pero de un array en vez de una cadena). Sintaxis:\nArray.slice(posicion, num. de elementos a devolver)\n\nEjemplo:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst subArray = a.slice(1, 3) // ahora a = ['Lunes', 'Martes', 2, 4, 6] y subArray = ['Martes', 2, 4]\n\nEs muy útil para hacer una copia de un array:\nconst a = [2, 4, 6]\nconst copiaDeA = a.slice() // ahora ambos arrays contienen lo mismo pero son diferentes arrays\n\nArrays y Strings\nCada objeto (y los arrays son un tipo de objeto) tienen definido el método .toString() que lo convierte en una cadena. Este método es llamado automáticamente cuando, por ejemplo, queremos mostrar un array por la consola. En realidad console.log(a) ejecuta console.log(a.toString()). En el caso de los arrays esta función devuelve una cadena con los elementos del array dentro de corchetes y separados por coma.\nAdemás podemos convertir los elementos de un array a una cadena con .join() especificando el carácter separador de los elementos. Ej.:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst cadena = a.join('-') // cadena = 'Lunes-Martes-2-4-6'\n\nEste método es el contrario del m .split() que convierte una cadena en un array. Ej.:\nconst notas = '5-3.9-6-9.75-7.5-3'\nconst arrayNotas = notas.split('-') // arrayNotas = [5, 3.9, 6, 9.75, 7.5, 3]\nconst cadena = 'Que tal estás'\nconst arrayPalabras = cadena.split(' ') // arrayPalabras = ['Que`, 'tal', 'estás']\nconst arrayLetras = cadena.split('') // arrayLetras = ['Q','u','e`,' ','t',a',l',' ','e',s',t',á',s']\n\nsort\nOrdena alfabéticamente los elementos del array. Cambia el array además de devolverlo. Ejemplo:\nlet a = ['hola','adios','Bien','Mal',2,5,13,45]\nlet b = a.sort() // b = [13, 2, 45, 5, &quot;Bien&quot;, &quot;Mal&quot;, &quot;adios&quot;, &quot;hola&quot;], pero a también queda ordenado\n\nTambién podemos pasarle una función que le indique cómo ordenar, que devolverá un valor negativo si el primer elemento es mayor, positivo si es mayor el segundo o 0 si son iguales. Ejemplo: ordenar un array de cadenas sin tener en cuenta si son mayúsculas o minúsculas:\nlet a = ['hola','adios','Bien','Mal']\nlet b = a.sort(function(elem1, elem2) {\nif (elem1.toLocaleLowerCase &gt; elem2.toLocaleLowerCase)\nreturn -1\nif (elem1.toLocaleLowerCase &lt; elem2.toLocaleLowerCase)\nreturn 1\nreturn 0\n}) // b = [&quot;adios&quot;, &quot;Bien&quot;, &quot;hola&quot;, &quot;Mal&quot;]\n\nComo más se utiliza esta función es para ordenar arrays de objetos. Por ejemplo si tenemos un objeto alumno con los campos name y age, para ordenar un array de objetos alumno por su edad haremos:\nlet alumnosOrdenado = alumnos.sort(function(alumno1, alumno2) {\nreturn alumno1.age - alumno2.age\n})\n\nUsando arrow functions quedaría más sencillo:\nlet alumnosOrdenado = alumnos.sort((alumno1, alumno2) =&gt; alumno1.age - alumno2.age)\n\nSi que queremos ordenar por un campo de texto en vez de numérico debemos usar la función toLocaleCompare:\nlet alumnosOrdenado = alumnos.sort((alumno1, alumno2) =&gt; alumno1.name.localeCompare(alumno2.name))\n\nEJERCICIO: Haz una función que ordene las notas de un array pasado como parámetro. Si le pasamos [4,8,3,10,5] debe devolver [3,4,5,8,10]. Pruébalo en la consola\n\nOtros métodos comunes\nOtros métodos que se usan a menudo con arrays son:\n\n.concat(): concatena arrays\n\nlet a = [2, 4, 6]\nlet b = ['a', 'b', 'c']\nlet c = a.concat(b) // c = [2, 4, 6, 'a', 'b', 'c']\n\n.reverse(): invierte el orden de los elementos del array\n\nlet a = [2, 4, 6]\nlet b = a.reverse() // b = [6, 4, 2]\n\n.indexOf(): devuelve la primera posición del elemento pasado como parámetro o -1 si no se encuentra en el array\n.lastIndexOf(): devuelve la última posición del elemento pasado como parámetro o -1 si no se encuentra en el array\n\nFunctional Programming\nSe trata de un paradigma de programación (una forma de programar) donde se intenta que el código se centre más en qué debe hacer una función que en cómo debe hacerlo. El ejemplo más claro es que intenta evitar los bucles for y while sobre arrays o listas de elementos. Normalmente cuando hacemos un bucle es para recorrer la lista y realizar alguna acción con cada uno de sus elementos. Lo que hace functional programing es que a la función que debe hacer eso se le pasa como parámetro la función que debe aplicarse a cada elemento de la lista.\nDesde la versión 5.1 javascript incorpora métodos de functional programing en el lenguaje, especialmente para trabajar con arrays:\nfilter\nDevuelve un nuevo array con los elementos que cumplen determinada condición del array al que se aplica. Su parámetro es una función, habitualmente anónima, que va interactuando con los elementos del array. Esta función recibe como primer parámetro el elemento actual del array (sobre el que debe actuar). Opcionalmente puede tener como segundo parámetro su índice y como tercer parámetro el array completo. La función debe devolver true para los elementos que se incluirán en el array a devolver como resultado y false para el resto.\nEjemplo: dado un array con notas devolver un array con las notas de los aprobados. Esto usando programación imperativa (la que se centra en cómo se deben hacer las cosas) sería algo como:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = []\nfor (let i = 0 i++ i &lt; arrayNotas.length) {\nlet nota = arrayNotas[i]\nif (nota &gt; = 5) {\naprobados.push(nota)\n}\n} // aprobados = [5.2, 6, 9.75, 7.5]\n\nUsando functional programming (la que se centra en qué resultado queremos obtener) sería:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(function(nota) {\nif (nota &gt; = 5) {\nreturn true\n} else {\nreturn false\n}\n}) // aprobados = [5.2, 6, 9.75, 7.5]\n\nPodemos refactorizar esta función para que sea más compacta:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(function(nota) {\nreturn nota &gt; = 5 // nota &gt; = 5 se evalúa a 'true' si es cierto o 'false' si no lo es\n})\n\nY usando funciones lambda la sintaxis queda mucho más simple:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(nota =&gt; nota &gt; = 5)\n\nLas 7 líneas del código usando programación imperativa quedan reducidas a sólo una.\n\nEJERCICIO: Dado un array con los días de la semana obtén todos los días que empiezan por 'M'\n\nfind\nComo filter pero NO devuelve un array sino el primer elemento que cumpla la condición (o undefined si no la cumple nadie). Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst primerAprobado = arrayNotas.find(nota =&gt; nota &gt; = 5) // primerAprobado = 5.2\n\nEste método tiene más sentido con objetos. Por ejemplo, si queremos encontrar la persona con DNI '21345678Z' dentro de un array llamado personas cuyos elementos son objetos con un campo 'dni' haremos:\nconst personaBuscada = personas.find(persona =&gt; persona.dni = = = '21345678Z') // devolverá el objeto completo\n\nEJERCICIO: Dado un array con los días de la semana obtén el primer día que empieza por 'M'\n\nfindIndex\nComo find pero en vez de devolver el elemento devuelve su posición (o -1 si nadie cumple la condición). En el ejemplo anterior el valor devuelto sería 0 (ya que el primer elemento cumple la condición). Al igual que el anterior tiene más sentido con arrays de objetos.\n\nEJERCICIO: Dado un array con los días de la semana obtén la posición en el array del primer día que empieza por 'M'\n\nevery / some\nLa primera devuelve true si TODOS los elementos del array cumplen la condición y false en caso contrario. La segunda devuelve true si ALGÚN elemento del array cumple la condición. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst todosAprobados = arrayNotas.every(nota =&gt; nota &gt; = 5) // false\nconst algunAprobado = arrayNotas.some(nota =&gt; nota &gt; = 5) // true\n\nEJERCICIO: Dado un array con los días de la semana indica si algún día empieza por 'S'. Dado un array con los días de la semana indica si todos los días acaban por 's'\n\nmap\nPermite modificar cada elemento de un array y devuelve un nuevo array con los elementos del original modificados. Ejemplo: queremos subir un 10% cada nota:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayNotasSubidas = arrayNotas.map(nota =&gt; nota + nota * 10%)\n\nEJERCICIO: Dado un array con los días de la semana devuelve otro array con los días en mayúsculas\n\nreduce\nDevuelve un valor calculado a partir de los elementos del array. En este caso la función recibe como primer parámetro el valor calculado hasta ahora y el método tiene como 1º parámetro la función y como 2º parámetro al valor calculado inicial (si no se indica será el primer elemento del array).\nEjemplo: queremos obtener la suma de las notas:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst sumaNotas = arrayNotas.reduce((total,nota) =&gt; total + = nota, 0) // total = 35.35\n// podríamos haber omitido el valor inicial 0 para total\nconst sumaNotas = arrayNotas.reduce((total,nota) =&gt; total + = nota) // total = 35.35\n\nEjemplo: queremos obtener la nota más alta:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst maxNota = arrayNotas.reduce((max,nota) =&gt; nota &gt; max ? nota : max) // max = 9.75\n\nEn el siguiente ejemplo gráfico tenemos un &quot;array&quot; de verduras al que le aplicamos una función map para que las corte y al resultado le aplicamos un reduce para que obtenga un valor (el sandwich) con todas ellas:\n\nEJERCICIO: Dado el array de notas anterior devuelve la nota media\n\nforEach\nEs el método más general de los que hemos visto. No devuelve nada sino que permite realizar algo con cada elemento del array.\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\narrayNotas.forEach((nota, indice) =&gt; {\nconsole.log('El elemento de la posición ' + indice + ' es: ' + nota)\n})\n\nincludes\nDevuelve true si el array incluye el elemento pasado como parámetro. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\narrayNotas.includes(7.5) // true\n\nEJERCICIO: Dado un array con los días de la semana indica si algún día es el 'Martes'\n\nArray.from\nDevuelve un array a partir de otro al que se puede aplicar una función de transformación (es similar a map). Ejemplo: queremos subir un 10% cada nota:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayNotasSubidas = Array.from(arrayNotas, nota =&gt; nota + nota * 10%)\n\nPuede usarse para hacer una copia de un array, igual que slice:\nconst arrayA = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayB = Array.from(arrayA)\n\nTambién se utiliza mucho para convertir colecciones en arrays y así poder usar los métodos de arrays que hemos visto. Por ejemplo si queremos mostrar por consola cada párrafo de la página que comience por la palabra 'If' en primer lugar obtenemos todos los párrafos con:\nconst parrafos = document.getElementsByTagName('p')\n\nEsto nos devuelve una colección con todos los párrafos de la página (lo veremos más adelante al ver DOM). Podríamos hacer un for para recorrer la colección y mirar los que empiecen por lo indicado pero no podemos aplicarle los métodos vistos aquí porque son sólo para arrays así que hacemos:\nconst arrayParrafos = Array.from(parrafos)\n// y ya podemos usar los métodos que queramos:\narrayParrafos.filter(parrafo =&gt; parrafo.textContent.startsWith('If'))\n.forEach(parrafo =&gt; alert(parrafo.textContent))\n\nIMPORTANTE: desde este momento se han acabado los bucles for en nuestro código para trabajar con arrays. Usaremos siempre estas funciones!!!\n\nRest y Spread\nPermiten extraer a parámetros los elementos de un array o string (spread) o convertir en un array un grupo de parámetros (rest). El operador de ambos es ... (3 puntos).\nPara usar rest como parámetro de una función debe ser siempre el último parámetro.\nEjemplo: queremos hacer una función que calcule la media de las notas que se le pasen como parámetro y que no sabemos cuántas són. Para llamar a la función haremos:\nconsole.log(notaMedia(3.6, 6.8))\nconsole.log(notaMedia(5.2, 3.9, 6, 9.75, 7.5, 3))\n\nLa función convertirá los parámetros recibidos en un array usando rest:\nfunction notaMedia(...notas) {\nlet total = notas.reduce((total,nota) =&gt; total + = nota)\nreturn total/notas.length\n}\n\nSi lo que queremos es convertir un array en un grupo de elementos haremos spread. Por ejemplo el objeto Math proporciona métodos para trabajar con números como .max que devuelve el máximo de los números pasados como parámetro. Para saber la nota máxima en vez de .reduce como hicimos en el ejemplo anterior podemos hacer:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\n\nlet maxNota = Math.max(...arrayNotas) // maxNota = 9.75\n// si hacemos Math.max(arrayNotas) devuelve NaN porque arrayNotas es un array y no un número\n\nDesestructuración de arrays\nIgual que vimos con las propiedades de los objetos podemos extraer los elementos del array directamente a variables y viceversa. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst [primera, segunda, tercera] = arrayNotas // primera = 5.2, segunda = 3.9, tercera = 6\nconst [primera, , , cuarta] = arrayNotas // primera = 5.2, cuarta = 9.75\nconst [primera, ...resto] = arrayNotas // primera = 5.2, resto = [3.9, 6, 9.75, 3]\n\nTambién se pueden asignar valores por defecto:\nconst preferencias = ['Javascript', 'NodeJS']\nconst [lenguaje, backend = 'Laravel', frontend = 'VueJS'] = preferencias // lenguaje = 'Javascript', backend = 'NodeJS', frontend = 'VueJS'\n\nCopia de arrays\nComo vimos al hablar de objetos (y un array es un tipo particular de objeto) por defecto al asignarlos o pasarlos como parámetro a una función se pasan por referencia, NO se copian por lo que los datos de ambas son los mismos:\nconst a = [54, 23, 12]\nconst b = a // a = [54, 23, 12] b = [54, 23, 12]\nb[0] = 3 // a = [3, 23, 12] b = [3, 23, 12]\n\nSi queremos obtener una copia de un array que sea independiente del original podemos usar ...o Object.assign como vimos con los objetos, pero también podemos obtener una copia con slice o con Array.from:\nconst a = [2, 4, 6]\nconst copiaDeA = [...a]\nconst copiaDeA = a.slice()\nconst otraCopiaDeA = Array.fom(a)\n\nEn todos los casos los arrays contienen lo mismo pero son diferentes y al modificar uno no afectará al resto.\n\nEJERCICIO: Dado el array arr1 con los días de la semana haz un array arr2 que sea igual al arr1. Elimina de arr2 el último día y comprueba quá ha pasado con arr1. Repita la operación con un array llamado arr3 pero que crearás haciendo una copia de arr1.\n\nMap\nEs una colección de parejas de [clave,valor]. Un objeto en Javascript es un tipo particular de Map en que las claves sólo pueden ser texto o números. Se puede acceder a una propiedad con . o [propiedad]. Ejemplo:\nconst persona = {\nnombre: 'John',\napellido: 'Doe',\nedad: 39\n}\nconsole.log(persona.nombre) // John\nconsole.log(persona['nombre']) // John\n\nUn Map permite que la clave sea cualquier cosa (array, objeto, ...). No vamos a ver en profundidad estos objetos pero podéis saber más en MDN o cualquier otra página.\nSet\nEs como un Map pero que no almacena los valores sino sólo la clave. Podemos verlo como una colección que no permite duplicados. Tiene la propiedad size que devuelve su tamaño y los métodos .add (añade un elemento), .delete (lo elimina) o .has (indica si el elemento pasado se encuentra o no en la colección) y también podemos recorrerlo con .forEach.\nUna forma sencilla de eliminar los duplicados de un array es crear con él un Set:\nconst ganadores = ['Márquez', 'Rossi', 'Márquez', 'Lorenzo', 'Rossi', 'Márquez', 'Márquez']\nconst ganadoresNoDuplicados = new Set(ganadores) // {'Márquez, 'Rossi', 'Lorenzo'}\n// o si lo queremos en un array:\nconst ganadoresNoDuplicados = Array.from(new Set(ganadores)) // ['Márquez, 'Rossi', 'Lorenzo']",
		"tags": [ "note"]
},

{
		"title": "03-oop",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/03-oop/",
		"content": "Programación orientada a Objetos en Javascript\n\nProgramación orientada a Objetos en Javascript\n\nIntroducción\nHerencia\nMétodos y propiedades estáticas\nPropiedades y métodos privados y protegidos\nMétodo toString()\nMétodo valueOf()\nOrganizar el código\nEl contexto de this\nMixins\nProgramación orientada a objetos en JS5\nBibliografía\n\nIntroducción\nDesde ES2015 la POO en Javascript es similar a como se hace en otros lenguajes, con clases, herencia, ...:\nclass Alumno {\nconstructor(nombre, apellidos, edad) {\nthis.nombre = nombre\nthis.apellidos = apellidos\nthis.edad = edad\n}\ngetInfo() {\nreturn 'El alumno ' + this.nombre + ' ' + this.apellidos + ' tiene ' + this.edad + ' años'\n}\n}\n\nlet alumno1 = new Alumno('Carlos', 'Pérez Ortiz', 19)\nconsole.log(alumno1.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nNOTA: en las clases no es necesario poner 'use strict' porque por defecto todas las clases ya lo tienen.\n\nEJERCICIO: Crea una clase Productos con las propiedades name, category, units y price y los métodos total que devuelve el importe del producto y getInfo que devolverá: 'Name (category): units uds x price € = total €'. Crea 3 productos diferentes.\n\nHerencia\nUna clase puede heredar de otra utilizando la palabra reservada extends y heredará todas sus propiedades y métodos. Podemos sobrescribirlos en la clase hija (seguimos pudiendo llamar a los métodos de la clase padre utilizando la palabra reservada super -es lo que haremos si creamos un constructor en la clase hija-).\nclass AlumnInf extends Alumno{\nconstructor(nombre, apellidos, edad, ciclo) {\nsuper(nombre, apellidos, edad)\nthis.ciclo = ciclo\n}\ngetInfo() {\nreturn super.getInfo() + ' y estudia el Grado ' + (this.getGradoMedio ? 'Medio' : 'Superior') + ' de ' + this.ciclo\n}\ngetGradoMedio() {\nif (this.ciclo.toUpperCase === 'SMX')\nreturn true\nreturn false\n}\n}\n\nlet cpo = new AlumnInf('Carlos', 'Pérez Ortiz', 19, 'DAW')\nconsole.log(cpo.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años y estudia el Grado Superior de DAW'\n\nEJERCICIO: crea una clase Televisores que hereda de Productos y que tiene una nueva propiedad llamada tamaño. El método getInfo mostrará el tamaño junto al nombre\n\nMétodos y propiedades estáticas\nDesde ES2015 podemos declarar métodos estáticos. Estos métodos se llaman directamente utilizando el nombre de la clase y no tienen acceso al objeto this (ya que no hay objeto instanciado).\nclass User {\n...\nstatic getRoles() {\nreturn [&quot;user&quot;, &quot;guest&quot;, &quot;admin&quot;]\n}\n}\n\nconsole.log(User.getRoles()) // [&quot;user&quot;, &quot;guest&quot;, &quot;admin&quot;]\nlet user = new User(&quot;john&quot;)\nconsole.log(user.getRoles()) // Uncaught TypeError: user.getRoles is not a function\n\nSuelen usarse para crear funciones de la aplicación.\nRecientemente se han introducido también propiedades estáticas, que funcionan directamente desde la clase no desde un objeto, igual que los métodos estáticos. Al ser una adición reciente pueden no funcionar en algunos navegadores.\nPropiedades y métodos privados y protegidos\nA la hora de encapsular el código de las clases es importante el uso de este tipo de elementos pero Javascript sólo los incluye desde ES2019 donde introdujo la sintaxis # para declaralos:\nclass Position {\n#x = 0;\n#y = 0;\n\nconstructor(x, y) {\nthis.#x = x\nthis.#y = y\n}\ngetPosition() {\nreturn { x: this.#x, y: this.#y };\n}\nincreaseX() {\nthis.#x++;\n}\nincreaseY() {\nthis.#y++;\n}\n}\n\nconst myPosition = new Position(20, 10);\nconsole.log(Position.getPosition()); // { x: 20, y: 10 }\nconsole.log(Position.x); // undefined\nconsole.log(Position.y); // undefined\n\nAnteriormente existía una convención de que cualquier propiedad o método que comience por el carácter _ se trata de una propiedad o método protegido y no debería accederse al mismo desde el exterior (aunque en realidad el lenguaje permite hacerlo).\nEstas propiedades y métodos protegidos se heredan como cualquier otro.\nMétodo toString()\nAl convertir un objeto a string (por ejemplo al concatenarlo con un String) se llama al método .toString() del mismo, que por defecto devuelve la cadena [object Object]. Podemos sobrecargar este método para que devuelva lo que queramos:\nclass Alumno {\n...\ntoString() {\nreturn this.apellidos + ', ' + this.nombre\n}\n}\n\nlet carPerOrt = new Alumno('Carlos', 'Pérez Ortiz', 19);\nconsole.log('Alumno:' + carPerOrt) // imprime 'Alumno: Pérez Ortíz, Carlos'\n// en vez de 'Alumno: [object Object]'\n\nEste método también es el que se usará si queremos ordenar una array de objetos (recordad que .sort() ordena alfabéticamente para lo que llama al método .toString() del objeto a ordenar). Por ejemplo, tenemos el array de alumnos misAlumnos que queremos ordenar alfabéticamente. Si la clase Alumno no tiene un método toString habría que hacer como vimos en el tema de Arrays:\nmisAlumnos.sort((alum1, alum2) =&gt; (alum1.apellidos+alum1.nombre).localeCompare(alum2.apellidos+alum2.nombre));\n\nPero con el método toString que hemos definido antes podemos hacer directamente:\nmisAlumnos.sort()\n\nEJERCICIO: modifica las clases Productos y Televisores para que el método que muestra los datos del producto se llame de la manera más adecuada\n\nEJERCICIO: Crea 5 productos y guárdalos en un array. Crea las siguientes funciones (todas reciben ese array como parámetro):\n\nprodsSortByName: devuelve un array con los productos ordenados alfabéticamente\nprodsSortByPrice: devuelve un array con los productos ordenados por importe\nprodsTotalPrice: devuelve el importe total del los productos del array, con 2 decimales\nprodsWithLowUnits: además del array recibe como segundo parámetro un nº y devuelve un array con todos los productos de los que quedan menos de los unidades indicadas\nprodsList: devuelve una cadena que dice 'Listado de productos:' y en cada línea un guión y la información de un producto del array\n\nMétodo valueOf()\nAl comparar objetos (con &gt;, &lt;, ...) se usa el valor devuelto por el método .valueOf() para realizar la comparación:\nclass Alumno {\n...\nvalueOf() {\nreturn this.edad\n}\n}\n\nlet cpo = new Alumno('Carlos', 'Pérez Ortiz', 19)\nlet aat = new Alumno('Ana', 'Abad Tudela', 23)\nconsole.log(cpo &lt; aat) // imprime true ya que 19&lt;23\n\nSi este método no existiera será .toString() el que se usaría.\nOrganizar el código\nLo más conveniente es guardar cada clase en su propio fichero, que llamaremos como la clase con la extensión .class.js. Por ejemplo el fichero de la clase Users seria users.class.js.\nEn dicho fichero exportamos la clase (con export o mejor export default porque sólo hay una) y donde queramos usarla la importamos (import { Users } from 'users.class' o import Users from 'users.class', según cómo la hayamos exportado).\nEl contexto de this\nEl valor de la variable this depende del contexto e que se ejecuta el código. Al crear una instancia de una calse con new this hace referencia a la instancia creada. Pero dentro de una función se crea un nuevo contexto y la variable this pasa a hacer referencia a dicho contexto. Si en el ejemplo anterior hiciéramos algo como esto:\nclass Alumno {\n...\ngetInfo() {\nfunction nomAlum() {\nreturn this.nombre + ' ' + this.apellidos // Aquí this no es la instancia del objeto Alumno\n}\n\nreturn 'El alumno ' + nomAlum() + ' tiene ' + this.edad + ' años'\n}\n}\n\nEste código fallaría porque dentro de la función nomAlum la variable this ya no hace referencia a a instancia del objeto Alumno sino al contexto de la función. Este ejemplo no tiene mucho sentido pero a veces nos pasará en manejadores de eventos.\nSi debemos llamar a una función dentro de un método (o de un manejador de eventos) tenemos varias formas de pasarle el valor de this:\n\nUsando una arrow function que no crea un nuevo contexto por lo que this conserva su valor\n\ngetInfo() {\nconst nomAlum = () =&gt; this.nombre + ' ' + this.apellidos\n\nreturn 'El alumno ' + nomAlum() + ' tiene ' + this.edad + ' años'\n}\n\nPasándole this como parámetro a la función\n\ngetInfo() {\nfunction nomAlum(alumno) {\nreturn alumno.nombre + ' ' + alumno.apellidos\n}\n\nreturn 'El alumno ' + nomAlum(this) +' tiene ' + this.edad + ' años'\n}\n\nGuardando el valor en otra variable (como that)\n\ngetInfo() {\nfunction nomAlum() {\nreturn that.nombre + ' ' + that.apellidos // Aquí this no es el objeto Alumno\n}\n\nlet that = this;\nreturn 'El alumno ' + nomAlum() +' tiene ' + this.edad + ' años'\n}\n\nHaciendo un bind de this (lo veremos de nuevo al hablar de eventos)\n\nclass Alumno {\n...\ngetInfo() {\nfunction nomAlum() {\nreturn this.nombre + ' ' + this.apellidos // Aquí this no es el objeto Alumno\n}\n\nreturn 'El alumno ' + nomAlum.bind(this) + ' tiene ' + this.edad + ' años'\n}\n}\n\nAl llamar a la función nomAlumn le enlazamos (.bind) el valor que queremos que tenga this dentro de ella, en nuestro caso el this de donde hacemos la llamada.\nMixins\nWikipedia define un mixin como una clase que contiene métodos que pueden ser utilizados por otras clases sin necesidad de heredar de ella.\nEn Javascript se trata de un objeto que contiene métodos que podemos aplicar a una clase para datarla de ciertos comportamientos. Por ejemplo:\n// mixin\nlet saludaMixin = {\nsaluda() {\nalert(`Hola, soy ${this.nombre}`)\n}\n}\n\nclass Alumno {\nconstructor(nombre, apellidos, edad) {\n...\n}\n...\n}\n\n// asignamos el mixin a la clase\nObject.assign(Alumno.prototype, saludaMixin);\n\n// Ahora el Alumno puede decir hola\nconst alumno = new User('Carlos', 'Pérez', 25)\nalumno.saluda(); // Hola, soy Carlos\n\nProgramación orientada a objetos en JS5\n\nNOTA: este apartado está sólo para que comprendamos este código si lo vemos en algún programa pero nosotros programaremos como hemos visto antes.\n\nEn Javascript un objeto se crea a partir de otro (al que se llama prototipo). Así se crea una cadena de prototipos, el primero de los cuales es el objeto null.\nLas versiones de Javascript anteriores a ES2015 no soportan clases ni herencia. Si queremos emular en ellas el comportamiento de las clases lo que se hace es:\n\npara crear el constructor se crea una función con el nombre del objeto\npara crear los métodos se aconseja hacerlo en el prototipo del objeto para que no se cree una copia del mismo por cada instancia que creemos:\n\nfunction Alumno(nombre, apellidos, edad) {\nthis.nombre = nombre\nthis.apellidos = apellidos\nthis.edad = edad\n}\nAlumno.prototype.getInfo = function() {\nreturn `El alumno ${this.nombre} ${this.apellidos} tiene ${this.edad} años`\n}\n\nlet cpo = new Alumno('Carlos', 'Pérez Ortiz', 19)\nconsole.log(cpo.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nCada objeto tiene un prototipo del que hereda sus propiedades y métodos (es el equivalente a su clase, pero en realidad es un objeto que está instanciado). Si añadimos una propiedad o método al prototipo se añade a todos los objetos creados a partir de él lo que ahorra mucha memoria.\nBibliografía\n\nCurso 'Programación con JavaScript'. CEFIRE Xest. Arturo Bernal Mayordomo",
		"tags": ["x", "y", "note"]
},

{
		"title": "03.1-vite",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/03-1-vite/",
		"content": "Vite\n\nVite\n\nIntroducción\nCrear un nuevo proyecto\nDesarrollar nuestro proyecto\n\nTrabajar con distintos ficheros de código\n\nNamed export\nDefault export\n\nImágenes\nPaso a producción\nTestear el proyecto\n\nIntroducción\nCuando crece el tamaño de un proyecto y tenemos más ficheros de código (cómo al trabajar con clases) es necesario organizarlos de forma que sea fácil encontrarlos y que no haya problemas de dependencias.\nSin embargo tener muchos ficheros hace que tengamos que importarlos todos, y en el orden adecuado, en nuestro index.html (mediante etiquetas &lt;script src=&quot;...&quot;&gt;) lo que empieza a ser engorroso y reduce el rendimiento al tener el navegador que hacer muchas peticiones HTTP.\nAdemás muchas veces incluimos en el código características del lenguaje que aún no están soportadas por todos los navegadores y cuantos más código usemos más se reduce el número de nevegadores que soportan nuestro código.\nPara evitar este problema se utilizan las herramientas de construcción de proyectos o module bundlers que unen todo el código de los distintos ficheros javascript en un único fichero que es el que se importa en el index.html y hacen los mismo con los ficheros CSS.\nAdemás proporcionan otras ventajas:\n\ntranspilan el código, de forma que podemos usar sentencias javascript que aún no soportan muchos navegadores ya que se convertirán a sentencias que hacen lo mismo pero con código legacy\nminimizan y optimizan el código para que ocupe menos y su carga sea más rápida, reduciendo el nombre de variables y funciones, eliminando espacios en blanco y comentarios, ...\ndicha minimización ofusca el código lo que dificulta que el usuario pueda ver en la consola lo que hace el programa y manipularlo\n\nNosotros usaremos el bundler Vite que, junto con webpack, son los más usados en entorno frontend. Junto a npm tendremos una forma fácil y práctica de empaquetar el código.\nAdemás Vite incorpora un servidor de desarrollo para hacer más cómoda la creación y prueba de nuestros proyectos.\nPara poder usar Vite debemos instalarlo. Como lo usaremos en muchos proyectos lo podemos instalarlo global con\nnpm install -g vite\n\nCrear un nuevo proyecto\nVite necesita Node.js versión 16 o superior aunque lo mejor es tenerlo actualizado para poder utilitzar todas sus plantillas. Para crear un nuevo proyecto haremos:\nnpm create vite@latest\n\n(si no tenemos instalado el paquete create-vite nos preguntará si lo instala)\nAl crear el proyecto nos pregunta qué framework vamos a utilizar (le diremos que Vanilla, es decir, Javascript sin framework) y si como lenguaje usaremos Javascript o Typescript.\nEsto crea el scaffolding de nuestro proyecto que consiste en una carpeta con el mismo nombre que el proyecto y una serie de ficheros en su interior:\nNos preguntará el nombre del proyecto, la plantilla (Vanilla para Javascript sin framework) y el lenguaje que queremos usar (Javascript/Typescript) y se crea una carpeta con el nombre de nuestro proyecto que contiene:\n\nindex.html: html con un div con id app que es donde se cargará la app y una etiqueta script que carga un módulo llamado main.js\nmain.js: es el punto de entrada a la aplicación .Importa los ficheros CSS, imágenes y ficheros JS con funciones o clases y establece el contenido de la página principal\ncounter.js: módulo JS que exporta una función como ejemplo que es usada en el main.js\nstyle.css: fichero donde poner nuestros estilos, con CSS de ejemplo\npublic/: carpeta donde dejar elementos estáticos que no pasarán por vite (como imágenes, ficheros CSS, ...)\nnode_modules: librerías de las dependencias (si usamos alguna)\npackage.json: fichero de configuración del proyecto. Además del nombre y la versión incluye apartados importantes:\n\ndevDependences: dependencias que se usan en desarrollo pero que no se incorporarán al código final\ndependences: dependencias que sí se incluirán en el código final (librerías que estemos usando)\nscripts: para ejecutar el servidor de desarrollo (npm run dev), generar el código final de producción (npm run build) y previsualizarlo en modo producción (npm run preview). Podemos añadir más para tests, etc\n\nSi nuestra aplicación no va a ser muy pequeña como la del ejemplo sino que tendrá diferentes ficheros Javascript, acceso a datos, interfaz de usuario, etc deberíamos organizar en código en carpetas para mejorar su legibilidad. Lo adecuando es dejar en el raíz de nuestro proyecto los ficheros index.html y main.js y crear una carpeta src donde poner el resto de código. En función del tamaño de la aplicación podríamos crear dentro subcarpetas (os propongo un nombre para ellas aunque podéis llamarlas como queráis) para:\n\nmodel: el modelo de datos, es decir, las clases\npages o views: las páginas que tendrá nuestra SPA a las que se navega desde el router (aunque en realidad sólo hay una)\napi: acceso a la API que usemos. Sólo deben conectarse al servidor y transmitir los datos recibidos al resto de la aplicación\ncomponents: web components que usemos para cosntruir las páginas\nservices: métodos síncronos que proporcionan funcionalidad\nsi nuestra aplicación es grande con muchos casos de uso convendría crear una carpeta usecases donde guardarlos. Cada uno debería tener un único método llamado run o execute\ntest: carpeta donde guardar los ficheros de test\n...\n\nNOTA: todos los ficheros javascript de un proyecto con Vite son módulos y en ellos, igual que en las clases, no es necesario poner 'use strict' porque por defecto los módulos ya funcionan así.\nDesarrollar nuestro proyecto\nPara empezar a trabajar ejecutamos desde la terminal el script\nnpm run dev\n\nEsto hace que Vite lance un servidor web en el puerto 5173 donde podemos ver la ejecución de nuestro proyecto.\nTrabajar con distintos ficheros de código\nUna de las razones de usar un bundler es que podemos repartir el código entre varios ficheros de forma que quede más organizado.\nPara que un fichero pueda tener acceso a código de otro fichero hay que hacer 2 cosas:\n\nEl fichero al que queremos acceder debe exportar el código que desea que sea accesible desde otros ficheros\nEl fichero que quiere acceder a ese código debe importarlo a una variable\n\nEsto es lo que hacíamos en el ejercicio de la frase para poder pasar los tests y lo que haremos con los ficheros donde declaremos clases.\nES6 nos proporciona 2 formas de exportar/importar código:\n\nexportar con nombre (named export): export\nexportar por defecto (default export): export default\n\nNamed export\nDe esta manera puedo exportar tantos elementos (funciones, variables, clases, ...) de un fichero como quiera. Por ejemplo, si es un fichero con una única función a exportar:\n// Fichero cuadrado.js\nexport function cuadrado (value) {\nreturn value * value\n}\n\nEn el caso de querer exportar muchas funciones lo más sencillo es exportarlas juntas en un objeto como en el fichero functions.js:\nfunction letras () {\n...\n}\n\nfunction palabras () {\n...\n}\n\nfunction maysc () {\n...\n}\n...\nexport {\n\tletras,\n\tpalabras,\n\tmaysc\n}\n\nSi es un fichero que define una clase la exportamos tal cual:\nexport class Product {\nconstructor() {\n\n}\n...\n}\n\nPara importarlo lo hacemos poniendo lo que queremos importar entre { }. Si se trata de una única función:\nimport { cuadrado } from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + cuadrado(2))\n\nTambién podríamos usar un nombre diferente para lo que importamos:\nimport { cuadrado as cuad} from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + cuad(2))\n\nSi es un fichero con muchas funciones exportadas a un objeto podemos importar sólo las que queramos o todas:\nimport { letras, maysc } from './functions.js'\n\nconsole.log('Las letras de &quot;Hola&quot; son ' + letras(&quot;Hola&quot;))\n\nTambién podemos importarlas todas a un objeto sin indicar sus nombres, con *:\nimport * as MyFunctions from './functions.js'\n\nconsole.log('Las letras de &quot;Hola&quot; son ' + MyFunctions.letras(&quot;Hola&quot;))\n\nPara importar una clase:\nimport { Product } from './product.class'\n\nconst myProd = new Product()\n\nDefault export\nDe esta manera sólo puedo exportar un elemento por fichero, y a la hora de importarlo le doy el nombre que quiera. Por ejemplo, si es un fichero con una única función a exportar:\n// Fichero cuadrado.js\nexport default function cuadrado (value) {\nreturn value * value\n}\n\nY donde vaya a usarlo:\nimport myCuadrado from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + myCuadrado(2))\n\nEn el caso de una clase:\nexport default class Product {\nconstructor() {\n\n}\n...\n}\n\nY para importarla:\nimport Product from './product.class'\n\nconst myProd = new Product()\n\nEn resumen, si exporto con export importo con { } y si exporto con export default importo sin { } pero sólo puedo exportar 1 elemento.\nImágenes\nSi se trata de imágenes estáticas lo más sencillo es ponerlas dentro de la carpeta public y hacer referencia a ellas usando ruta absoluta. Todo lo que está en public se referencia como si estuviera en la raíz de nuestra aplicación:\n&lt;img src=&quot;/vite.png&quot; height=&quot;100px&quot; alt=&quot;Logo de Vite&quot;&gt;\n\nTambién podemos poner las imágenes en la carpeta assets, pero antes de usarlas deberemos imnportarlas. Ejemplo:\nimport viteLogo from './assets/vite.png'\n...\nconst logoHtml = `&lt;img src=&quot;${viteLogo}&quot; height=&quot;100px&quot; alt=&quot;Vite logo&quot;&gt;`\ndocument.body.prepend(logoHtml)\n\nCon Vite también podemos importarlas usando import.meta.url, lo que es útil si no conocemos previamente el nombre del fichero con la imagen (más información en la documentación de Vite):\nfunction getImage(fileName, height, alt) {\nimgUrl = new URL(fileName, import.meta.url).href\nconst imgHtml = `&lt;img src=&quot;${viteLogo}&quot; height=&quot;${height}&quot; alt=&quot;${alt}&quot;&gt;`\n\nreturn logoHtml\n}\n\nPaso a producción\nCuando lo hayamos acabado y queramos subirlo a producción ejecutaremos\nnpm run build\n\nque crea la carpeta /dist con los ficheros que debemos subir al servidor web de producción:\n\nindex.html\ncualquier fichero que tengamos en /public\ncarpeta assets con\n\nfichero JS con todo el código que necesita el proyecto\nfichero CSS con todos los estilos del proyecto\notros ficheros importados en el JS como imágenes, ...\n\nTestear el proyecto\nSi queremos testear el proyecto deberemos usar una herramienta de testing y crear los tests adecuados. Lo más sencillo es usar Vitest que es muy similar a Jest pero preparado para interacutar fácilmente con Vite.\nLo primero es importarlo como dependencia de producción (no lo usaremos en producción)\nnpm install --save-dev vitest\n\no abreviado\nnpm i -D vitest\n\nDebemos añadir un nuevo script en el package.json que le indique a vite que queremos usarlo para testear:\n&quot;scripts&quot;: {\n\t\t...\n&quot;test&quot;: &quot;vitest&quot;\n},\n\nCrearemos los tests en una carpeta en la raíz de nuestro proyecto llamada /test y en ella crearemos los diferentes fichero cuya extensión será .spec.js o .test.js. Cada vez que queramos pasar los tests ejecutaremos\nnpm run test\n\nPodéis obtener más información en infinidad de páginas de internet, como el Curso DWEC de Jose Castillo, y en la web oficial de vite.",
		"tags": [ "note"]
},

{
		"title": "03.1-webpack",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/03-1-webpack/",
		"content": "Webpack\nCuando trabajamos con clases la mejor forma de organizar el código es poniendo cada clase un su propio fichero javascript. Esto reduce el acoplamiento de nuestro código y nos permite reutilizar una clase en cualquier proyecto en que la necesitemos.\nSin embargo tener muchos ficheros hace que tengamos que importarlos todos, y en el orden adecuado, en nuestro index.html (mediante etiquetas &lt;script src=&quot;...&quot;&gt;) lo que empieza a ser engorroso.\nPara evitar este problema se utilizan los module bundlers o empaquetadores de código que unen todo el código de los distintos ficheros javascript en un único fichero que es el que se importa en el index.html.\nAdemás proporciona otras ventajas:\n\ntranspila el código, de forma que podemos usar sentencias javascript que aún no soportan muchos navegadores ya que se convertirán a sentencias que hacen lo mismo pero con código legacy\nminimiza y optimiza el código para que ocupe menos y su carga sea más rápida\nofusca el código al minimizarlo lo que dificulta que el usuario pueda ver en la consola lo que hace el programa y manipularlo\n\nNosotros usaremos el bundler *webpack que es el más usado en entorno frontend. Junto a npm tendremos una forma fácil y práctica de empaquetar el código.\nTrabajar con distintos ficheros\nPara que un fichero pueda tener acceso a código de otro fichero hay que hacer 2 cosas:\n\nEl fichero al que queremos acceder debe exportar el código que desea que sea accesible desde otros ficheros\nEl fichero que quiere acceder a ese código debe importarlo a una variable\n\nEsto es lo que hacíamos en el ejercicio de la frase para poder pasar los tests y lo que haremos con los ficheros donde declaramos clases.\nExportamos el código\nEn el caso de un fichero con una función a exportar será lo que exportaremos. Por ejemplo:\n// Fichero cuadrado.js\nconst cuadrado = (value) =&gt; value * value\nmodule.exports = cuadrado\n\nEn el caso de querer exportar muchas funciones lo más sencillo es exportarlas juntas en un objeto como en el fichero functions.js:\nmodule.exports = {\n\tletras,\n\tpalabras,\n\tmaysc,\n\ttitulo,\n\tletrasReves,\n\tpalabrasReves,\n\tpalindromo\n}\n\nAquí estamos exportando un objeto que contiene una serie de funciones\nSi es un fichero que define una clase la exportamos tal cual:\nclass Product {\nconstructor() {\n\n}\n...\n}\nmodule.exports = Product\n\nLo importamos donde queramos usarlo\nEn el fichero donde vayamos a usar dicho código lo importamos a una variable. Si se trata de una única función:\nconst cuadrado = require('./cuadrado.js')\nconsole.log('El cuadrado de 2 es ' + cuadrado(2))\n\nSi es un fichero con muchas funciones exportadas a un objeto podemos importar sólo las que queramos o todas:\nconst functions = require('./functions.js')\nconsole.log('Las letras de &quot;Hola&quot; son ' + functions.letras(&quot;Hola&quot;) + ' y al revés es ' + functions.letrasReves('Hola'))\n\no bien\nconst { letras, letrasReves } = require('./functions.js')\nconsole.log('Las letras de &quot;Hola&quot; son ' + letras(&quot;Hola&quot;) + ' y al revés es ' + letrasReves('Hola'))\n\nPara usar una clase la importamos:\nconst Product = require('./product.class')\nconst myProd = new Product()\n\nUsar webpack\nUna vez que tenemos nuestro código correctamente exportado e importado vamos a usar webpack para empaquetarlo.\nLo primero que habría que hacer es crear nuestro proyecto si no lo hemos hecho ya mediante npm init. Esto inicializa el proyecto y crea el fichero package.json. Recuerda escribir jest cuando nos pregunte por los tests.\nPara usar webpack simplemente lo incluímos mediante npm:\nnpm i -D webpack webpack-cli\n\nLa opción -D instala webpack como dependencia de desarrollo, lo que significa que en la versión de producción del código no se incluirá.\nPara instalar todas nuestras dependencias y que se cree la carpeta node_modules ejecutamos npm install.\nAhora ya estamos listos para usar webpack. Como hemos dicho es un module bundler, es decir, un empaquetador de código. Toma el fichero que le indiquemos como fichero principal (por defecto el ./src/index.js), lo junta con todas sus dependencias (sus require y los de sus dependencias) y los transpila a un único fichero (por defecto ./dist/main.js) que es el que se enlaza en el index.html. Además minimiza y optimiza dicho código al generarlo.\nPara generar el código empaquetado ejecutamos\nnpx webpack --mode=development\n\nEste código hay que ejecutarlo cada vez que se hagan cambios en el código. Si no quieres tener que ejecutarlo cada vez se puede lanzar con la opción --watch que deja la consola abierta y ejecuta el comando automáticamente cuando guardamos cualquiera de los ficheros del proyecto:\nnpx webpack --mode=development --watch\n\nSi nuestro fichero principal no es src/index.js lo indicaremos con la opción --entry:\nnpx webpack --entry=scripts/main.js --mode=development\n\nCuando usamos webpack le tenemos que indicar que tipo de código de salida queremos:\n\ndevelopment: webpack permite &quot;seguir&quot; la ejecución del código desde la consola ya que &quot;mapea&quot; el código generado al original de forma que en la consola vemos como si se ejecutara nuestro código (los distintos ficheros) en vez del código generado por webpack que es el que realmente se está ejecutando\nproduction: minimiza y optimiza el código para producción y ya no es posible desde la consola acceder al código original. Es lo que haremos para generar el código que subiremos al servidor de producción (NUNCA subimos el código de desarrollo).\n\nPodéis obtener más información en infinidad de páginas de internet y en la web oficial de webpack. Las diferentes opciones que podemos pasarle a este comando las podemos consultar en la página del CLI de webpack.",
		"tags": [ "note"]
},

{
		"title": "04-DOM",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/04-dom/",
		"content": "Document Object Model (DOM)\n\nDocument Object Model (DOM)\n\nIntroducción\nAcceso a los nodos\nAcceso a nodos a partir de otros\n\nPropiedades de un nodo\n\nManipular el árbol DOM\n\nAñadir nuevos nodos con innerHTML\n\nAtributos de los nodos\n\nEstilos de los nodos\nAtributos de clase\nAtributos de datos\n\nIntroducción\nLa mayoría de las veces que programamos con Javascript es para que se ejecute en una página web mostrada por el navegador. En este contexto tenemos acceso a ciertos objetos que nos permiten interactuar con la página (DOM) y con el navegador (Browser Object Model, BOM).\nEl DOM es una estructura en árbol que representa todos los elementos HTML de la página y sus atributos. Todo lo que contiene la página se representa como nodos del árbol y mediante el DOM podemos acceder a cada nodo, modificarlo, eliminarlo o añadir nuevos nodos de forma que cambiamos dinámicamente la página mostrada al usuario.\nLa raíz del árbol DOM es document y de este nodo cuelgan el resto de elementos HTML. Cada uno constituye su propio nodo y tiene subnodos con sus atributos, estilos y elementos HTML que contiene.\nPor ejemplo, la página HTML:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;title&gt;Página simple&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nse convierte en el siguiente árbol DOM:\n![Árbol DOM](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/domSimple.png)\nCada etiqueta HTML suele originar 2 nodos:\n\nElement: correspondiente a la etiqueta\nText: correspondiente a su contenido (lo que hay entre la etiqueta y su par de cierre)\n\nCada nodo es un objeto con sus propiedades y métodos.\nEl ejemplo anterior está simplificado porque sólo aparecen los nodos de tipo elemento pero en realidad también generan nodos los saltos de línea, tabuladores, espacios, comentarios, etc. En el siguiente ejemplo podemos ver TODOS los nodos que realmente se generan. La página:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;My Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Header&lt;/h1&gt;\n&lt;p&gt;\nParagraph\n&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nse convierte en el siguiente árbol DOM:\n\nAcceso a los nodos\nLos principales métodos para acceder a los diferentes nodos son:\n\n.getElementById(id): devuelve el nodo con la id pasada. Ej.:\n\nlet nodo = document.getElementById('main'); // nodo contendrá el nodo cuya id es _main_\n\n.getElementsByClassName(clase): devuelve una colección (similar a un array) con todos los nodos de la clase indicada. Ej.:\n\nlet nodos = document.getElementsByClassName('error'); // nodos contendrá todos los nodos cuya clase es _error_\n\nNOTA: las colecciones son similares a arrays (se accede a sus elementos con [indice]) pero no se les pueden aplicar sus métodos filter, map, ... a menos que se conviertan a arrays con Array.from()\n\n.getElementsByTagName(etiqueta): devuelve una colección con todos los nodos de la etiqueta HTML indicada. Ej.:\n\nlet nodos = document.getElementsByTagName('p'); // nodos contendrá todos los nodos de tipo _&lt;p&gt;_\n\n.getElementsByName(name): devuelve una colección con todos los nodos que contengan un atributo name con el valor indicado. Ej.:\n\nlet radiosSexo = document.getElementsByName('sexo'); // radiosSexo contendrá todos los nodos con ese atributo (seguramente radiobuttons con name=&quot;sexo&quot;)\n\n.querySelector(selector): devuelve el primer nodo seleccionad por el selector CSS indicado. Ej.:\n\nlet nodo = document.querySelector('p.error'); // nodo contendrá el primer párrafo de clase _error_\n\n.querySelectorAll(selector): devuelve una colección con todos los nodos seleccionados por el selector CSS indicado. Ej.:\n\nlet nodos = document.querySelectorAll('p.error'); // nodos contendrá todos los párrafos de clase _error_\n\nNOTA: al aplicar estos métodos sobre document se seleccionará sobre la página pero podrían también aplicarse a cualquier nodo y en ese caso la búsqueda se realizaría sólo entre los descendientes de dicho nodo.\nTambién tenemos 'atajos' para obtener algunos elementos comunes:\n\ndocument.documentElement: devuelve el nodo del elemento &lt;html&gt;\ndocument.head: devuelve el nodo del elemento &lt;head&gt;\ndocument.body: devuelve el nodo del elemento &lt;body&gt;\ndocument.title: devuelve el nodo del elemento &lt;title&gt;\ndocument.link: devuelve una colección con todos los hiperenlaces del documento\ndocument.anchor: devuelve una colección con todas las anclas del documento\ndocument.forms: devuelve una colección con todos los formularios del documento\ndocument.images: devuelve una colección con todas las imágenes del documento\ndocument.scripts: devuelve una colección con todos los scripts del documento\n\nEJERCICIO: Para hacer los ejercicios de este tema descárgate esta página de ejemplo y ábrela en tu navegador. Obtén por consola, al menos de 2 formas diferentes:\n\nEl elemento con id 'input2'\n\ndocument.getElementById('input2') o document.querySelector('#input2')\n\nLa colección de párrafos\n\ndocument.getElementsByTagName('p') o document.querySelectorAll('p')\n\nLo mismo pero sólo de los párrafos que hay dentro del div 'lipsum'\n\nEl formulario (ojo, no la colección con el formulario sino sólo el formulario)\nTodos los inputs\nSólo los inputs con nombre 'sexo'\nLos items de lista de la clase 'important' (sólo los LI)\n\nAcceso a nodos a partir de otros\nEn muchas ocasiones queremos acceder a cierto nodo a partir de uno dado. Para ello tenemos los siguientes métodos que se aplican sobre un elemento del árbol DOM:\n\nelemento.parentElement: devuelve el elemento padre de elemento\nelemento.children: devuelve la colección con todos los elementos hijo de elemento (sólo elementos HTML, no comentarios ni nodos de tipo texto)\nelemento.childNodes: devuelve la colección con todos los hijos de elemento, incluyendo comentarios y nodos de tipo texto por lo que no suele utilizarse\nelemento.firstElementChild: devuelve el elemento HTML que es el primer hijo de elemento\nelemento.firstChild: devuelve el nodo que es el primer hijo de elemento (incluyendo nodos de tipo texto o comentarios)\nelemento.lastElementChild, elemento.lastChild: igual pero con el último hijo\nelemento.nextElementSibling: devuelve el elemento HTML que es el siguiente hermano de elemento\nelemento.nextSibling: devuelve el nodo que es el siguiente hermano de elemento (incluyendo nodos de tipo texto o comentarios)\nelemento.previousElementSibling, elemento.previousSibling: igual pero con el hermano anterior\nelemento.hasChildNodes: indica si elemento tiene o no nodos hijos\nelemento.childElementCount: devuelve el nº de nodos hijo de elemento\nelemento.closest(selector): devuelve el ancestro más cercano que coincide con el selector. Por ejemplo si el elemento es un &lt;td&gt; de una tabla entonces elemento.closest('table') devolverá la tabla a la que pertenece\n\nIMPORTANTE: a menos que me interesen comentarios, saltos de página, etc siempre debo usar los métodos que sólo devuelven elementos HTML, no todos los nodos.\n![Recorrer el árbol DOM](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/domRelaciones.png)\n\nEJERCICIO: Siguiento con la página de ejemplo obtén desde la consola, al menos de 2 formas diferentes:\n\nEl primér párrafo que hay dentro del div 'lipsum'\nEl segundo párrafo de 'lipsum'\nEl último item de la lista\nLa label de 'Escoge sexo'\n\nPropiedades de un nodo\nLas principales propiedades de un nodo son:\n\nelemento.innerHTML: todo lo que hay entre la etiqueta que abre elemento y la que lo cierra, incluyendo otras etiquetas HTML. Por ejemplo si elemento es el nodo &lt;p&gt;Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;&lt;/p&gt;\n\nlet contenido = elemento.innerHTML; // contenido='Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;'\n\nelemento.textContent: todo lo que hay entre la etiqueta que abre elemento y la que lo cierra, pero ignorando otras etiquetas HTML. Siguiendo con el ejemplo anterior:\n\nlet contenido = elemento.textContent; // contenido='Esta página es muy simple'\n\nelemento.value: devuelve la propiedad 'value' de un &lt;input&gt; (en el caso de un &lt;input&gt; de tipo text devuelve lo que hay escrito en él). Como los &lt;inputs&gt; no tienen etiqueta de cierre (&lt;/input&gt;) no podemos usar .innerHTML ni .textContent. Por ejemplo si elem1 es el nodo &lt;input name=&quot;nombre&quot;&gt; y elem2 es el nodo &lt;input tipe=&quot;radio&quot; value=&quot;H&quot;&gt;Hombre\n\nlet cont1 = elem1.value; // cont1 valdría lo que haya escrito en el &lt;input&gt; en ese momento\nlet cont2 = elem2.value; // cont2=&quot;H&quot;\n\nOtras propiedades:\n\nelemento.innerText: igual que textContent\nelemento.focus: da el foco a elemento (para inputs, etc). Para quitarle el foco elemento.blur\nelemento.clientHeight / elemento.clientWidth: devuelve el alto / ancho visible del elemento\nelemento.offsetHeight / elemento.offsetWidth: devuelve el alto / ancho total del elemento\nelemento.clientLeft / elemento.clientTop: devuelve la distancia de elemento al borde izquierdo / superior\nelemento.offsetLeft / elemento.offsetTop: devuelve los píxels que hemos desplazado elemento a la izquierda / abajo\n\nEJERCICIO: Obtén desde la consola, al menos de 2 formas:\n\nEl innerHTML de la etiqueta de 'Escoge sexo'\nEl textContent de esa etiqueta\nEl valor del primer input de sexo\nEl valor del sexo que esté seleccionado (difícil, búscalo por Internet)\n\nManipular el árbol DOM\nVamos a ver qué métodos nos permiten cambiar el árbol DOM, y por tanto modificar la página:\n\ndocument.createElement('etiqueta'): crea un nuevo elemento HTML con la etiqueta indicada, pero aún no se añade a la página. Ej.:\n\nlet nuevoLi = document.createElement('li');\n\nelemento.append(elementos o texto): añade al DOM los parámetros pasados como últimos hijos de elemento. Se le puede pasar tanto un nodo DOM como una cadena de texto (para la que se creará su nodo de texto correspondiente) y que se le pueden pasar varios parámetros para crear varios nodos. Ej.:\n\nnuevoLi.append('Nuevo elemento de lista'); // añade el texto pasado al elemento LI creado\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nmiPrimeraLista.append(nuevoLi); // añade LI como último hijo de UL, es decir al final de la lista\n\nelemento.prepend(elementos o texto): como el anterior pero en lugar de añadirlos como últimos hijos los añade antes del primer hijo.\n\nconst primerLi = document.createElement('li');\nprimerLi.append('Primer elemento de lista');\nlet miPrimeraLista = document.getElementsByTagName('ul')[0];\nmiPrimeraLista.prepend(nuevoLi);\n\nelemento.after(elementos o texto): como append pero en lugar de añadirlos como últimos hijos los añade como los siguientes hermanos de elemento.\n\nconst otroLi = document.createElement('li');\notroLi.append('Segundo elemento de lista');\nprimerLi.after(otroLi);\n\nelemento.before(elementos o texto): como el anterior pero los añade como los anteriores hermanos de elemento.\nelemento.remove(): borra el nodo elemento del documento.\nelemento.replaceWith(nuevoNodo): reemplaza el nodo elemento con el nuevoNodo pasado\n\nlet primerElementoDeLista = document.getElementsByTagName('ul')[0].firstChild; // selecciona el 1º LI de miPrimeraLista\nprimerElementoDeLista.replaceChild(nuevoLi); // reemplaza el 1º elemento de la lista con nuevoLi\n\nelementoAClonar.cloneNode(boolean): devuelve un clon de elementoAClonar o de elementoAClonar con todos sus descendientes según le pasemos como parámetro false o true. Luego podremos insertarlo donde queramos.\n\nOtros métodos menos usados son:\n\ndocument.createTextNode('texto'): crea un nuevo nodo de texto con el texto indicado, que luego tendremos que añadir a un nodo HTML. Normalmente no se usa porque append y el resto de métodos anteriores ya lo crean automáticamente. Ej.:\n\nlet textoLi = document.createTextNode('Nuevo elemento de lista');\n\nelemento.appendChild(nuevoNodo): añade nuevoNodo como último hijo de elemento y lo devuelve. Se diferencia con append en que sólo permite un parámetro y éste debe ser un nodo, no puede ser texto. Por eso no suele usarse. Ejemplo:\n\nnuevoLi.appendChild(textoLi); // añade el texto creado al elemento LI creado\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nmiPrimeraLista.appendChild(nuevoLi); // añade LI como último hijo de UL, es decir al final de la lista\n\nelemento.insertBefore(nuevoNodo, nodo): añade nuevoNodo como hijo de elemento antes del hijo nodo. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.insertBefore(nuevoLi, primerElementoDeLista); // añade LI al principio de la lista\n\nelemento.removeChild(nodo): borra nodo de elemento y por tanto se elimina de la página. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.removeChild(primerElementoDeLista); // borra el primer elemento de la lista\n// También podríamos haberlo borrado sin tener el padre con:\nprimerElementoDeLista.parentElement.removeChild(primerElementoDeLista);\n\nelemento.replaceChild(nuevoNodo, viejoNodo): reemplaza viejoNodo con nuevoNodo como hijo de elemento. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.replaceChild(nuevoLi, primerElementoDeLista); // reemplaza el 1º elemento de la lista con nuevoLi\n\nOJO: Si añado con el método append o appendChild un nodo que estaba en otro sitio se elimina de donde estaba para añadirse a su nueva posición. Si quiero que esté en los 2 sitios deberé clonar el nodo y luego añadir el clon y no el nodo original.\nAñadir nuevos nodos con innerHTML\nSupongamos que tenemos un DIV cuya id es myDiv al que queremos añadir al final dos párrafos, el último de ellos con un texto en negrita. El código podría ser:\nlet miDiv = document.getElementById('myDiv');\nlet nuevoParrafo = document.createElement('p');\nnuevoParrafo.textContent = 'Párrafo añadido al final';\nlet ultimoParrafo = document.createElement('p');\nconst textoNegrita = document.createElement('strong');\ntextoNegrita.textContent = 'con texto en negrita';\nultimoParrafo.append('Último párrafo ', textoNegrita);\nmiDiv.append(nuevoParrafo, ultimoParrafo);\n\nSi utilizamos la propiedad innerHTML el código a usar es mucho más simple:\nlet miDiv = document.getElementById('myDiv');\nmiDiv.innerHTML += '&lt;p&gt;Párrafo añadido al final&lt;/p&gt;&lt;p&gt;Último párrafo &lt;strong&gt;con texto en negrita&lt;/strong&gt;&lt;/p&gt;';\n\nOJO: La forma de añadir el último párrafo (línea #3: miDiv.innerHTML+='&lt;p&gt;Párrafo añadido al final&lt;/p&gt;';) aunque es válida no es muy eficiente ya que obliga al navegador a volver a pintar TODO el contenido de miDIV.\nPodemos ver más ejemplos de creación y eliminación de nodos en W3Schools.\n\nEJERCICIO: Añade a la página:\n\nUn nuevo párrafo al final del DIV 'lipsum' con el texto &quot;Nuevo párrafo añadido por javascript&quot; (fíjate que una palabra está en negrita)\nUn nuevo elemento al formulario tras el 'Dato 1' con la etiqueta 'Dato 1 bis' y el INPUT con id 'input1bis' que al cargar la página tendrá escrito &quot;Hola&quot;\n\nAtributos de los nodos\nPodemos ver y modificar los valores de los atributos de cada elemento HTML y también añadir o eliminar atributos:\n\nelemento.attributes: devuelve un array con todos los atributos de elemento\nelemento.hasAttribute('nombreAtributo'): indica si elemento tiene o no definido el atributo nombreAtributo\nelemento.getAttribute('nombreAtributo'): devuelve el valor del atributo nombreAtributo de elemento. Para muchos elementos este valor puede directamente con elemento.atributo.\nelemento.setAttribute('nombreAtributo', 'valor'): establece valor como nuevo valor del atributo nombreAtributo de elemento. También puede cambiarse el valor directamente con elemento.atributo=valor.\nelemento.removeAttribute('nombreAtributo'): elimina el atributo nombreAtributo de elemento\n\nA algunos atributos comunes como id, title o className (para el atributo class) se puede acceder y cambiar como si fueran una propiedad del elemento (elemento.atributo). Ejemplos:\nelemento.id = 'primera-lista';\n// es equivalente ha hacer:\nelemento.setAttribute('id', 'primera-lista');\n\nEstilos de los nodos\nLos estilos están accesibles como el atributo style. Cualquier estilo es una propiedad de dicho atributo pero con la sintaxis camelCase en vez de kebab-case. Por ejemplo para cambiar el color de fondo (propiedad background-color) y ponerle el color rojo al elemento miPrimeraLista haremos:\nmiPrimeraLista.style.backgroundColor = 'red';\n\nDe todas formas normalmente NO CAMBIAREMOS ESTILOS a los elementos sino que les pondremos o quitaremos clases que harán que se le apliquen o no los estilos definidos para ellas en el CSS.\nAtributos de clase\nYa sabemos que el aspecto de la página debe configurarse en el CSS por lo que no debemos aplicar atributos style al HTML. En lugar de ello les ponemos clases a los elementos que harán que se les aplique el estilo definido para dicha clase.\nComo es algo muy común en lugar de utilizar las instrucciones de elemento.setAttribute('className', 'destacado') o directamente elemento.className='destacado' podemos usar la propiedad classList que devuelve la colección de todas las clases que tiene el elemento. Por ejemplo si elemento es &lt;p class=&quot;destacado direccion&quot;&gt;...:\nlet clases=elemento.classList; // clases=['destacado', 'direccion'], OJO es una colección, no un Array\n\nAdemás dispone de los métodos:\n\n.add(clase): añade al elemento la clase pasada (si ya la tiene no hace nada). Ej.:\n\nelemento.classList.add('primero'); // ahora elemento será &lt;p class=&quot;destacado direccion primero&quot;&gt;...\n\n.remove(clase): elimina del elemento la clase pasada (si no la tiene no hace nada). Ej.:\n\nelemento.classList.remove('direccion'); // ahora elemento será &lt;p class=&quot;destacado primero&quot;&gt;...\n\n.toogle(clase): añade la clase pasada si no la tiene o la elimina si la tiene ya. Ej.:\n\nelemento.classList.toogle('destacado'); // ahora elemento será &lt;p class=&quot;primero&quot;&gt;...\nelemento.classList.toogle('direccion'); // ahora elemento será &lt;p class=&quot;primero direccion&quot;&gt;...\n\n.contains(clase): dice si el elemento tiene o no la clase pasada. Ej.:\n\nelemento.classList.contains('direccion'); // devuelve true\n\n.replace(oldClase, newClase): reemplaza del elemento una clase existente por una nueva. Ej.:\n\nelemento.classList.replace('primero', 'ultimo'); // ahora elemento será &lt;p class=&quot;ultimo direccion&quot;&gt;...\n\nTened en cuenta que NO todos los navegadores soportan classList por lo que si queremos añadir o quitar clases en navegadores que no lo soportan debemos hacerlo con los métodos estándar, por ejemplo para añadir la clase 'rojo':\nlet clases = elemento.className.split(&quot; &quot;);\nif (clases.indexOf('rojo') == -1) {\nelemento.className += ' ' + 'rojo';\n}\n\nAtributos de datos\nHTML5 permite agregar atributos personalizados no visuales a las etiquetas utilizando data-*. Estos atributos pueden ser accesibles a través de JavaScript usando dataset.\n&lt;article\nid=&quot;electriccars&quot;\ndata-columns=&quot;3&quot;\ndata-index-number=&quot;12314&quot;\ndata-parent=&quot;cars&quot;&gt;\n...\n&lt;/article&gt;\n\nlet article = document.getElementById('electriccars');\nconsole.log(article.dataset.columns); // 3\nconsole.log(article.dataset.indexNumber); // 12314\n\nFuente: Curso DWEC de José Castillo",
		"tags": ["3", "note"]
},

{
		"title": "04.1-MVC",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/04-1-mvc/",
		"content": "El patrón Modelo-Vista-Controlador\nModelo-vista-controlador (MVC) es un patrón de arquitectura de software muy utilizado en la actualidad en desarrollo web (y también en muchas aplicaciones de escritorio). Este patrón propone separar la aplicación en componentes distintos: el modelo, la vista y el controlador:\n\nEl modelo representa y gestiona los datos o información con la que trabaja la aplicación que normalmente serán variables extraidas de una base de datos. Normalmente el modelo no tiene conocimiento de las otras partes de la aplicación.\nLa vista muestra al usuario el modelo (información y lógica de negocio) en un formato adecuado para interactuar con él (usualmente la interfaz de usuario). Es la intermediaria entre la aplicación y el usuario\nEl controlador es el encargado de coordinar el funcionamiento de la aplicación. Responde a los eventos del usuario para lo que hace peticiones al modelo (para obtener o cambiar la información) y a la vista (para que muestre al usuario dicha información).\n\nAdemás de etos componentes usualmente tendremos otros como:\n\nLos servicios que controlan la comunicación con el servidor y otras fuentes externas de datos. Gestionan los accesos a la información, tanto consultas como actualizaciones, implementando también los privilegios de acceso que se hayan descrito en las especificaciones de la aplicación (lógica de negocio).\nLas rutas gestionan la navegación y las rutas de la aplicación en SPA.\n\nEste patrón de arquitectura de software se basa en las ideas de reutilización de código y la separación de conceptos, características que buscan facilitar la tarea de desarrollo de aplicaciones y su posterior mantenimiento.\nUna aplicación sin MVC\nSi una aplicación no utiliza este modelo la función que modifique los datos debe además reflejar dicha modificación en la página para que la vea el usuario. Por ejemplo vamos a hacer una aplicación para gestionar un almacén. Entre otras muchas cosas tendrá una función (podemos llamarle addProduct) que se encargue de añadir un nuevo producto al almacén y dicha función deberá realizar:\n\nañadir el nuevo producto al almacén (por ejemplo añadiéndolo a un array de productos)\npintar en la página ese nuevo producto (por ejemplo añadiendo una nueva línea a una tabla donde se muestran los productos)\n\n// La función que se ejecuta cuando el usuario envía el\n// formulario para añadir un producto debería hacer:\ndocument.getElementById('product-form').addEventListener('submit', async (event) =&gt; {\nevent.preventDefault()\n// Coge los datos del formlario\nconst name = document.getElementById('product-form-name').value\nconst price = document.getElementById('product-form-name').price\n...\n// Valida cada dato\nif (!name || name.length &lt; 5 || ...)\n...\n// Añade el producto a la BBDD\nconst prod = await addProductToDatabase(payload)\nlet newProd = new Product(prod.id, prod.name, prod.price, prod.units)\nthis.products.push(newProd)\n...\n// Pinta en la página el nuevo producto\nconst DOMproduct = document.createElement('tr')\nDOMproduct.innerHTML = `\n&lt;td&gt;${newProd.id}&lt;/td&gt;\n&lt;td&gt;${newProd.name}&lt;/td&gt;\n&lt;td&gt;${newProd.price}&lt;/td&gt;\n&lt;td&gt;${newProd.units}&lt;/td&gt;`\ndocument.getElementById('products-table').apendChild(DOMproduct)\n// Gestiona los posibles errores producidos en todo este proceso\n...\n})\n\nComo vemos, se va a convertir en una función muy grande y que se encarga de muchas cosas distintas por lo que va a ser difícil mantener ese código. Además toda la función es muy dependiente del HTML (en muchas partes se buscan elementos por su id).\nNuestro patrón MVC\nEn una aplicación muy sencilla podemos no seguir este modelo pero en cuanto la misma se complica un poco es imprescindible programar siguiendo buenas prácticas ya que si no lo hacemos nuestro código se volverá rápidamente muy difícil de mantener.\nHay muchas formas de implementar este modelo. Si estamos haciendo un proyecto con OOP podemos seguir el patrón MVC usando clases. Si sólo usamos programación estructurada será igual pero en vez de clases y métodos tendremos funciones.\nPara organizar el código crearemos subcarpetas dentro de la carpeta src:\n\nmodel: aquí incluiremos las clases que constituyen el modelo de nuestra aplicación\nview: aquí crearemos un fichero JS que será el encargado de la GUI de nuestra aplicación, el único dependiente del HTML. Nuestro fichero será una clase que representa toda la vista aunque en aplicaciones mayores lo normal es tener clases para cada página, etc\ncontroller: aquí crearemos el fichero JS que contendrá el controlador de la aplicación\nservices: aquí crearemos el fichero JS que se encargará de comunicarse con el servidor y proporcionar los datos al modelo\n\nDe este forma, si quiero cambiar la forma en que se muestra algo voy directamente a la vista y modifico la función que se ocupa de ello.\nLa vista será una clase cuyas propiedades serán elementos de la página HTML a los que accedamos frecuentemente, para no tener que buscarlos cada vez y para que estén disponibles para el controlador. Contendrá métodos para renderizar los distintos elementos de la vista.\nEl controlador será una clase cuyas propedades serán el modelo y la vista, de forma que pueda acceder a ambos elementos. Tendrá métodos para las distintas acciones que pueda hacer el usuario (y que se ejecutarán como respuesta a dichas acciones, como veremos en el tema de eventos). Cada uno de esos métodos llamará a métodos del modelo (para obtener o cambiar la información necesaria) y posteriormente de la vista (para reflejar esos cambios en lo que ve el usuario).\nPor su parte el modelo gestionará los datos de la aplicación llamando a los servicios para obtener datos del servidor o guardar en él las modificaciones pertinentes.\nEl fichero principal de la aplicación instanciará un controlador y lo inicializará.\nPor ejemplo, siguiendo con la aplicación para gestionar un almacén. El modelo constará de la clase Store que es nuestro almacén de productos (con métodos para añadir o eliminar productos, etc) y la clase Product que gestiona cada producto del almacén (con métodos para crear un nuevo producto, etc).\nEl fichero principal sería algo como:\n\nmain.js\n\nconst storeApp = new Controller()\t\t// crea el controlador\nstoreApp.init()\t\t\t\t// lo inicializa\n\n// En desarrollo podemos añadir algunas líneas que luego quitaremos para\n// imitar acciones del usuario y así ver el funcionamiento de la aplicación:\nstoreApp.addProductToStore({ name: 'Portátil Acer Travelmate E2100', price: 523.12 })\nstoreApp.changeProduct({ id: 1, price: 515.95 })\nstoreApp.deleteProduct(1)\n\ncontroller/index.js\n\nexport default class Controller {\nconstructor() {\nthis.store = new Store(1)\t\t// crea el modelo, un Store con id 1\nthis.view = new View()\t\t// crea la vista\n}\n\ninit() {\n// inicializa la vista y el modelo, si es necesario\nthis.store.init()\nthis.view.init()\t\t\t\n\n// Le indica a la vista qué funciones callback se encargarán\n// de responder a los eventos del usuario (siguiente tema)\nthis.view.setSubmitHandler(this.handleSubmitProductForm.bind(this))\n}\n\t\nhandleSubmitProductForm(payload) {\n// haría las comprobaciones necesarias sobre los datos\nif (!payload.name || payload.name.length &lt; 5 || ...) {\nthis.view.showErrorMessage('error', 'Datos incorrectos')\nreturn\n}\n...\n// y luego dice al modelo que añada el producto\ntry {\nconst newProd = this.store.addProduct(prod)\n// si lo ha hecho le dice a la vista que lo pinte\t\nthis.view.renderNewProduct(newProd)\t\n} catch(err) {\nthis.view.showErrorMessage('error', 'Error al añadir el producto')\n}\n}\n...\n}\n\nmodel/store.class.js\n\nexport default class Store {\nconstructor (id) {\nthis.id=Number(id)\nthis.products=[]\n}\n\naddProduct(payload) {\n// llama a métodos de los servicios para que añada el producto\nconst prod = await addProductToDatabase(payload)\nlet newProd = new Product(prod.id, prod.name, prod.price, prod.units)\nthis.products.push(newProd)\nreturn newProd\n}\n...\n}\n\nmodel/product.class.js\n\nexport default class Product {\nconstructor (id, name, price, units) {\nthis.id = id\nthis.name = name\nthis.price = price\nthis.units = units\n}\n...\n}\n\nview/index.js\n\nexport default class View {\nconstructor {\nthis.messageDiv = document.getElementById('messages')\nthis.productForm = document.getElementById('product-form')\nthis.productsList = document.getElementById('products-table')\n}\n\ninit() {\n...\t\t\t// inicializa la vista, si es necesario\n}\n\nsetSubmitHandler(callback) {\n// código para que el controlador llame a la función callback\n// cuando se envíe el formulario de añadir un producto\nthis.productForm.addEventListener('submit', (event) =&gt; {\nevent.preventDefault()\nconst name = document.getElementById('product-form-name').value\nconst price = document.getElementById('product-form-name').price\n...\ncallback({ name, price, ... })\n})\n}\n\nrenderNewProduct(prod) {\n// código para añadir a la tabla el producto pasado añadiendo una nueva fila\nconst DOMproduct = document.createElement('tr')\nDOMproduct.innerHTML = `\n&lt;td&gt;${newProd.id}&lt;/td&gt;\n&lt;td&gt;${newProd.name}&lt;/td&gt;\n&lt;td&gt;${newProd.price}&lt;/td&gt;\n&lt;td&gt;${newProd.units}&lt;/td&gt;`\nthis.productsList.apendChild(DOMproduct)\n}\n\nshowMessage(type, message) {\n// código para mostrar mensajes al usuario y no tener que usar los alert\nconst DOMmessage = document.createElement('div')\n...\nthis.messageDiv.apendChild(DOMmessage)\n}\n}\n\nPodéis obtener más información y ver un ejemplo más completo en https://www.natapuntes.es/patron-mvc-en-vanilla-javascript/",
		"tags": [ "note"]
},

{
		"title": "05-BOM",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/05-bom/",
		"content": "Browser Object Model (BOM)\n\nBrowser Object Model (BOM)\n\nIntroducción\nTimers\nObjetos del BOM\n\nObjeto window\n\nDiálogos\n\nObjeto location\nObjeto history\nObjeto navigator\nOtros objetos\n\nIntroducción\nEn este tema veremos cómo acceder a objetos que nos permitan interactuar con el navegador (Browser Object Model, BOM).\nUsando los objetos BOM podemos:\n\nAbrir, cambiar y cerrar ventanas\nEjecutar código en cierto tiempo (timers)\nObtener información del navegador\nVer y modificar propiedades de la pantalla\nGestionar cookies, ...\n\nTimers\nPermiten ejecutar código en el futuro (cuando transcurran los milisegundos indicados). Hay 2 tipos:\n\nsetTimeout(función, milisegundos): ejecuta la función pasada como parámetro una sóla vez, cuando transcurran los milisegundos indicados\nsetInterval(función, milisegundos): ejecuta la función cada vez que transcurran los milisegundos indicados, hasta que sea cancelado el timer. A ambas se le pueden pasar más parámetros tras los milisegundos y serán los parámetros que recibirá la función a ejecutar.\n\nAmbas funciones devuelven un identificador que nos permitirá cancelar la ejecución del código usando:\n\nclearTiemout(identificador)\nclearInterval(identificador)\n\nEjemplo:\nconst idTimeout = setTimeout(() =&gt; alert('Timeout que se ejecuta al cabo de 1 seg.'), 1000);\n\nlet i = 1;\nconst idInterval = setInterval(() =&gt; {\n\talert('Interval cada 3 seg. Ejecución nº: '+ i++);\nif (i === 5) {\nclearInterval(idInterval);\nalert('Fin de la ejecución del Interval');\n\t}\n}, 3000);\n\nEJERCICIO: Ejecuta en la consola cada una de esas funciones\n\nEn lugar de definir la función a ejecutar podemos llamar a una función que ya exista:\nfunction showMessage() {\nalert('Timeout que se ejecuta al cabo de 1 seg.')\n}\n\nconst idTimeout=setTimeout(showMessage, 1000);\n\nPero en ese caso hay que poner sólo el nombre de la función, sin () ya que si los ponemos se ejecutaría la función en ese momento y no transcurrido el tiempo indicado.\nSi necesitamos pasarle algún parámetro a la función lo añadiremos como parámetros de setTimeout o setInterval después del intervalo:\nfunction showMessage(msg) {\nalert(msg)\n}\n\nconst idTimeout = setTimeout(showMessage, 1000, 'Timeout que se ejecuta al cabo de 1 seg.');\n\nObjetos del BOM\nAl contrario que para el DOM, no existe un estándar de BOM pero es bastante parecido en los diferentes navegadores.\nObjeto window\nRepresenta la ventana del navegador y es el objeto principal. De hecho puede omitirse al llamar a sus propiedades y métodos, por ejemplo, el método setTimeout() es en realidad window.setTimeout().\nSus principales propiedades y métodos son:\n\n.name: nombre de la ventana actual\n.status: valor de la barra de estado\n.screenX/.screenY: distancia de la ventana a la esquina izquierda/superior de la pantalla\n.outerWidth/.outerHeight: ancho/alto total de la ventana, incluyendo la toolbar y la scrollbar\n.innerWidth/.innerHeight: ancho/alto útil del documento, sin la toolbar y la scrollbar\n.open(url, nombre, opciones): abre una nueva ventana. Devuelve el nuevo objeto ventana. Las principales opciones son:\n\n.toolbar: si tendrá barra de herramientas\n.location: si tendrá barra de dirección\n.directories: si tendrá botones Adelante/Atrás\n.status: si tendrá barra de estado\n.menubar: si tendrá barra de menú\n.scrollbar: si tendrá barras de desplazamiento\n.resizable: si se puede cambiar su tamaño\n.width=px/.height=px: ancho/alto\n.left=px/.top=px: posición izq/sup de la ventana\n\n.opener: referencia a la ventana desde la que se abrió esta ventana (para ventanas abiertas con open)\n.close(): la cierra (pide confirmación, a menos que la hayamos abierto con open)\n.moveTo(x,y): la mueve a las coord indicadas\n.moveBy(x,y): la desplaza los px indicados\n.resizeTo(x,y): la da el ancho y alto indicados\n.resizeBy(x,y): le añade ese ancho/alto\n.pageXoffset / pageYoffset: scroll actual de la ventana horizontal / vertical\nOtros métodos: .back(), .forward(), .home(), .stop(), .focus(), .blur(), .find(), .print(), …\nNOTA: por seguridad no se puede mover una ventana fuera de la pantalla ni darle un tamaño menor de 100x100 px ni tampoco se puede mover una ventana no abierta con .open() o si tiene varias pestañas\n\nEJERCICIO: Ejecuta desde la consola:\n\nabre una nueva ventana de dimensiones 500x200px en la posición (100,200)\nescribe en ella (con document.write) un título h1 que diga 'Hola'\nmuévela 300 px hacia abajo y 100 a la izquierda\nciérrala\n\nPuedes ver un ejemplo de cómo abrir ventanas en este vídeo.\n\nEJERCICIO: Haz que a los 2 segundos de abrir la página se abra un popup con un mensaje de bienvenida. Esta ventana tendrá en su interior un botón Cerrar que permitirá que el usuario la cierre haciendo clic en él. Tendrá el tamaño justo para visualizar el mensaje y no tendrá barras de scroll, ni de herramientas, ni de dirección... únicamente el mensaje.\n\nDiálogos\nHay 3 métodos del objeto window que ya conocemos y que nos permiten abrir ventanas de diálogo con el usuario:\n\nwindow.alert(mensaje): muestra un diálogo con el mensaje indicado y un botón de 'Aceptar'\nwindow.confirm(mensaje): muestra un diálogo con el mensaje indicado y botones de 'Aceptar' y 'Cancelar'. Devuelve true si se ha pulsado el botón de aceptar del diálogo y false si no.\nwindow.prompt(mensaje [, valor predeterminado]): muestra un diálogo con el mensaje indicado, un cuadro de texto (vacío o co el valor predeterminado indicado) y botones de 'Aceptar' y 'Cancelar'. Si se pulsa 'Aceptar' devolverá un string con el valor que haya en el cuadro de texto y si se pulsa 'Cancelar' o se cierra devolverá null.\n\nObjeto location\nContiene información sobre la URL actual del navegador y podemos modificarla. Sus principales propiedades y métodos son:\n\n.href: devuelve la URL actual completa\n.protocol, .hostname, .port: devuelve el protocolo, host y puerto respectivamente de la URL actual\n.pathname, hash, search: devuelve la ruta al recurso actual, el gragmento (#...) y la cadena de búsqueda (?...) respectivamente\n.reload(): recarga la página actual\n.assign(url): carga la página pasada como parámetro\n.replace(url): ídem pero sin guardar la actual en el historial\n\nEJERCICIO: Ejecuta en la consola\n\nmuestra la ruta completa de la página actual\nmuestra el servidor de esta página\ncarga la página de Google usando el objeto location\n\nObjeto history\nPermite acceder al historial de páginas visitadas y navegar por él:\n\n.length: muestra el número de páginas almacenadas en el historial\n.back(): vuelve a la página anterior\n.forward(): va a la siguiente página\n.go(num): se mueve num páginas hacia adelante o hacia atrás (si num es negativo) en el historial\n\nEJERCICIO: desde la consola vuelve a la página anterior\n\nObjeto navigator\nNos da información sobre el navegador y el sistema en que se ejecuta:\n\n.userAgent: muestra información sobre el navegador que usamos\n.language: muestra el idioma del navegador\n.languages: muestra los idiomas instalados en el navegador\n.appVersion: versión del navegador\n.appName: nombre del navegador\n.appCodeName: nombre en código del navegador\n.product: producto del navegador\n.platform: sistema en el que se ejecuta el navegador\n...\n\nTambién incluye objetos con sus propias API para poder interactuar con el sistema:\n\n.geolocation: devuelve un objeto con la localización del dispositivo (sólo funciona en https)\n.storage: permite acceder a los datos almacenados en el navegador (los veremos en detalle más adelante)\n.clipboard: permite copiar texto al portapapeles del usuario con .writeText() (sólo funciona en https)\n.mediaDevices: permite acceder a los dispositivos multimedia del usuario\n.serviceWorker: permite trabajar con service workers\n...\n\nEJERCICIO: desde la consola muestra la información del navegador, su lenguaje y del sistema en que se ejecuta\n\nOtros objetos\nOtros objetos que incluye BOM son:\n\nscreen: nos da información sobre la pantalla\n\n.width/.height: ancho/alto total de la pantalla (resolución)\n.availWidth/.availHeight: igual pero excluyendo la barra del S.O.\n...\n\nEJERCICIO: obtén desde la consola todas las propiedades width/height y availWidth/availHeight del objeto scrren. Compáralas con las propiedades innerWidth/innerHeight y outerWidth/outerHeight de window.",
		"tags": [ "note"]
},

{
		"title": "06-eventos",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/06-eventos/",
		"content": "Eventos\n\nEventos\n\nIntroducción\nCómo escuchar un evento\n\nEvent listeners\n\nTipos de eventos\n\nEventos de página\nEventos de ratón\nEventos de teclado\nEventos de toque\nEventos de formulario\n\nLos objetos this y event\n\nBindeo del objeto this\n\nPropagación de eventos\ninnerHTML y escuchadores de eventos\nDelegación de eventos\nEventos personalizados\n\nIntroducción\nNos permiten detectar acciones que realiza el usuario o cambios que suceden en la página y reaccionar en respuesta a ellas. Existen muchos eventos diferentes (podéis ver la lista en w3schools) aunque nosotros nos centraremos en los más comunes.\nJavascript nos permite ejecutar código cuando se produce un evento (por ejemplo el evento click del ratón) asociando al mismo una función. Hay varias formas de hacerlo.\nCómo escuchar un evento\nLa manera tradicional de asociar código a un evento era añadiendo un atributo con el nombre del evento a escuchar (con 'on' delante) en el elemento HTML. Por ejemplo, para ejecutar código al producirse el evento 'click' sobre un botón se escribía:\n&lt;input type=&quot;button&quot; id=&quot;boton1&quot; onclick=&quot;alert('Se ha pulsado');&quot; /&gt;\n\nUna mejora era llamar a una función que contenía el código:\n&lt;input type=&quot;button&quot; id=&quot;boton1&quot; onclick=&quot;clicked()&quot; /&gt;\n\nfunction clicked() {\nalert('Se ha pulsado');\n}\n\nComo se trata de poner un atributo al elemento podemos usar DOM para evitar &quot;ensuciar&quot; con código la página HTML:\ndocument.getElementById('boton1').onclick = function () {\nalert('Se ha pulsado');\n}\n\nIMPORTANTE: si asociamos un evento a un elemento que aún no existe (porque aún no lo ha renderizado el navegador) no se produce ningún error pero cuando posteriormente se renderice ese elemento no tendrá asociado el evento. Para evitarlo siempre es conveniente poner los escuchadores de los eventos dentro de una función que se ejecute cuando sepamos que ya se ha renderizado toda la página, es decir tras producirse:\n\nel evento load de la ventana: se produce cuando se han cargado todos los elementos HTML de la página (incluyendo imágenes, ficheros, etc) y se ha creado el árbol DOM\nel evento DOMContentLoaded del documento: se produce cuando se ha creado el árbol DOM pero no se han cargado imágenes, hojas de estilo, ni subframes. Es el ideal para realizar acciones del DOM sin tener que esperar a que se carguen las imágenes y el CSS\n\nLo mismo habría que hacer con cualquier código que modifique el árbol DOM. El código correcto sería:\nwindow.onload = function() {\ndocument.getElementById('boton1').onclick = function() {\nalert('Se ha pulsado');\n}\n}\n\no mejor\ndocument.onDOMContentLoaded = () =&gt; {\ndocument.getElementById('boton1').onclick = function() {\nalert('Se ha pulsado');\n}\n}\n\nEvent listeners\nPero esta forma tradicional de poner escuchadores a los eventos lo es la más adecuada. La forma recomendada de hacerlo es usando el modelo avanzado de registro de eventos del W3C, mediante el método addEventListener que recibe como primer parámetro el nombre del evento a escuchar (sin 'on') y como segundo parámetro la función a ejecutar cuando se produzca (OJO, sin paréntesis):\ndocument.getElementById('boton1').addEventListener('click', pulsado);\n...\nfunction pulsado() {\nalert('Se ha pulsado');\n}\n\nHabitualmente se usan funciones anónimas ya que no necesitan ser llamadas desde fuera del escuchador:\ndocument.getElementById('boton1').addEventListener('click', () =&gt; {\nalert('Se ha pulsado');\n});\n\nSi queremos pasarle algún parámetro a la función manejadora (cosa bastante poco usual) debemos usar obligatoriamente funciones anónimas como escuchadores de eventos:\n\nNOTA: igual que antes debemos estar seguros de que se ha creado el árbol DOM antes de poner un escuchador por lo que se recomienda ponerlos siempre dentro una función asociada a window.addEventListener(&quot;load&quot;, ...) o mejor a document.addEventListener(&quot;DOMContentLoaded&quot;, ...).\nUna ventaja de esta forma de poner escuchadores es que podemos poner varios escuchadores para el mismo evento y se ejecutarán todos ellos. Para eliminar un escuchador se usa el método removeEventListener.\ndocument.getElementById('boton1').removeEventListener('click', pulsado);\n\nNOTA: no se puede quitar un escuchador si hemos usado una función anónima, para quitarlo debemos usar como escuchador una función con nombre.\nTipos de eventos\nSegún qué o dónde se produce un evento estos se clasifican en:\nEventos de página\nSe producen en el documento HTML:\n\nload: se produce cuando termina de cargarse la página. Es útil para hacer acciones que requieran que la página esté cargada\nDOMContentLoaded: se produce cuando se ha cargado el árbol DOM pero no se han cargado imágenes, hojas de estilo, ni subframes. Es el ideal para realizar acciones del DOM sin tener que esperar a que se carguen las imágenes y el CSS\nunload: al destruirse el documento (ej. cerrar)\nbeforeUnload: antes de destruirse (podríamos mostrar un mensaje de confirmación)\nresize: si cambia el tamaño del documento (porque se redimensiona la ventana)\n\nEventos de ratón\nLos produce el usuario con el ratón:\n\nclick / dblclick: cuando se hace click/doble click sobre un elemento\nmousedown / mouseup: al pulsar/soltar cualquier botón del ratón\nmouseover / mouseout: cuando el puntero del ratón entra/sale del elemento (tb. podemos usar mouseenter / mouseleave)\nmousemove: se produce continuamente mientras el puntero se mueva dentro del elemento\n\nNOTA: si hacemos doble click sobre un elemento la secuencia de eventos que se produciría es: mousedown -&gt; mouseup -&gt; click -&gt; mousedown -&gt; mouseup -&gt; click -&gt; dblclick\n\nEJERCICIO: Pon un escuchador desde la consola al botón 1 de la página de ejemplo de DOM para que al hacer click se muestre el un alert con 'Click sobre botón 1'. Ponle otro para que al pasar el ratón sobre él se muestre 'Entrando en botón 1'.\n\nEventos de teclado\nLos produce el usuario al usar el teclado:\n\nkeydown: se produce al presionar una tecla y se repite continuamente si la tecla se mantiene pulsada\nkeyup: cuando se deja de presionar la tecla\nkeypress: acción de pulsar y soltar (sólo se produce en las teclas alfanuméricas)\n\nNOTA: el orden de secuencia de los eventos es:\nkeyDown -&gt; keyPress -&gt; keyUp\nEventos de toque\nSe producen al usar una pantalla táctil:\n\ntouchstart: se produce cuando se detecta un toque en la pantalla táctil\ntouchend: cuando se deja de pulsar la pantalla táctil\ntouchmove: cuando un dedo es desplazado a través de la pantalla\ntouchcancel: cuando se interrumpe un evento táctil.\n\nEventos de formulario\nSe producen en los formularios:\n\nfocus / blur: al obtener/perder el foco el elemento\nchange: al perder el foco un &lt;input&gt; o &lt;textarea&gt; si ha cambiado su contenido o al cambiar de valor un &lt;select&gt; o un &lt;checkbox&gt;\ninput: al cambiar el valor de un &lt;imput&gt; o &lt;textarea&gt; (se produce cada vez que escribimos una letra es estos elementos)\nselect: al cambiar el valor de un &lt;select&gt; o al seleccionar texto de un &lt;imput&gt; o &lt;textarea&gt;\nsubmit / reset: al enviar/recargar un formulario\n\nLos objetos this y event\nAl producirse un evento se generan automáticamente en su función manejadora 2 objetos:\n\nthis: siempre hace referencia al elemento que contiene el código en donde se encuentra la variable this. En el caso de una función manejadora será el elemento que tiene el escuchador que ha recibido el evento. OJO: se sobreescribe el valor anterior de this por lo que si queremos conservarlo debemos guardarlo en otra variable antes de entrar en la función manejadora.\nevent: es un objeto y la función manejadora lo recibe como parámetro. Tiene propiedades y métodos que nos dan información sobre el evento, como:\n\n.type: qué evento se ha producido (click, submit, keyDown, ...)\n.target: el elemento donde se produjo el evento (puede ser this o un descendiente de this, como en el ejemplo siguiente)\n.currentTarget: el elemento que contiene el escuchador del evento lanzado (normalmente el mismo que this). Por ejemplo si tenemos un &lt;p&gt; al que le ponemos un escuchador de 'click' que dentro tiene un elemento &lt;span&gt;, si hacemos click sobre el &lt;span&gt; event.target será el &lt;span&gt; que es donde hemos hecho click (está dentro de &lt;p&gt;) pero tanto &lt;this&gt; como event.currentTarget será &lt;p&gt; (que es quien tiene el escuchador que se está ejecutando).\n.relatedTarget: en un evento 'mouseover' event.target es el elemento donde ha entrado el puntero del ratón y event.relatedTarget el elemento del que ha salido. En un evento 'mouseout' sería al revés.\n.cancelable: si el evento puede cancelarse. En caso afirmativo se puede llamar a event.preventDefault() para cancelarlo\n.preventDefault(): si un evento tiene un escuchador asociado se ejecuta el código de dicho escuchador y después el navegador realiza la acción que correspondería por defecto al evento si no tuviera escuchador (por ejemplo un escuchador del evento click sobre un hiperenlace hará que se ejecute su código y después saltará a la página indicada en el href del hiperenlace). Este método cancela la acción por defecto del navegador para el evento. Por ejemplo si el evento era el submit de un formulario éste no se enviará o si era un click sobre un hiperenlace no se irá a la página indicada en él.\n.stopPropagation: un evento se produce sobre un elemento y todos su padres. Por ejemplo si hacemos click en un &lt;span&gt; que está en un &lt;p&gt; que está en un &lt;div&gt; que está en el BODY el evento se va propagando por todos estos elementos y saltarían los escuchadores asociados a todos ellos (si los hubiera). Si alguno llama a este método el evento no se propagará a los demás elementos padre.\ndependiento del tipo de evento tendrá más propiedades:\n\neventos de ratón:\n\n.button: qué botón del ratón se ha pulsado (0: izq, 1: rueda; 2: dcho).\n.screenX / .screenY: las corrdenadas del ratón respecto a la pantalla\n.clientX / .clientY: las coordenadas del ratón respecto a la ventana cuando se produjo el evento\n.pageX / .pageY: las coordenadas del ratón respecto al documento (si se ha hecho un scroll será el clientX/Y más el scroll)\n.offsetX / .offsetY: las coordenadas del ratón respecto al elemento sobre el que se produce el evento\n.detail: si se ha hecho click, doble click o triple click\n\neventos de teclado: son los más incompatibles entre diferentes navegadores. En el teclado hay teclas normales y especiales (Alt, Ctrl, Shift, Enter, Tab, flechas, Supr, ...). En la información del teclado hay que distinguir entre el código del carácter pulsado (e=101, E=69, €=8364) y el código de la tecla pulsada (para los 3 caracteres es el 69 ya que se pulsa la misma tecla). Las principales propiedades de event son:\n\n.key: devuelve el nombre de la tecla pulsada\n.which: devuelve el código de la tecla pulsada\n.keyCode / .charCode: código de la tecla pulsada y del carácter pulsado (según navegadores)\n.shiftKey / .ctrlKey / .altKey / .metaKey: si está o no pulsada la tecla SHIFT / CTRL / ALT / META. Esta propiedad también la tienen los eventos de ratón\n\nNOTA: a la hora de saber qué tecla ha pulsado el usuario es conveniente tener en cuenta:\n\npara saber qué carácter se ha pulsado lo mejor usar la propiedad key o charCode de keyPress, pero varía entre navegadores\npara saber la tecla especial pulsada mejor usar el key o el keyCode de keyUp\ncaptura sólo lo que sea necesario, se producen muchos eventos de teclado\npara obtener el carácter a partir del código: String fromCharCode(codigo);\n\nLo mejor para familiarizarse con los diferentes eventos es consultar los ejemplos de w3schools.\n\nEJERCICIO: Pon desde la consola un escuchador al BODY de la página de ejemplo para que al mover el ratón en cualquier punto de la ventana del navegador, se muestre en algún sitio (añade un DIV o un P al HTML) la posición del puntero respecto del navegador y respecto de la página.\n\nEJERCICIO: Pon desde la consola un escuchador al BODY de la página de ejemplo para que al pulsar cualquier tecla nos muestre en un alert el key y el keyCode de la tecla pulsada. Pruébalo con diferentes teclas\n\nBindeo del objeto this\nEn ocasiones no queremos que this sea el elemento sobre quien se produce el evento sino que queremos conservar el valor que tenía antes de entrar a la función manejadora. Por ejemplo, si la función manejadora es un método de una clase en this tenemos el objeto de la clase sobre el que estamos actuando pero al entrar en la función manejadora del evento se sobreescribe esta variable.\nPodríamos guardarla en otra variable antes de entrar en la función manejadora como vimos en el tema de POO, por ejemplo:\nlet that = this;\ndocument.getElementById('acepto').addEventListener('click', function() {\n// Aquí dentro this será el elemento sobre el que se ha hecho click\n// y that será el objeto que tenía antes de entrar en la función manejadora\n});\n\nPero también podemos usar el método .bind(), que nos permite pasarle a una función el valor que queremos darle a la variable this dentro de dicha función:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(variable));\n\nEn este ejemplo el valor de this dentro de la función aceptado será _variable_en lugar de event.currentTarget.\nEn el ejemplo que habíamos comentado de un manejador dentro de una clase, para mantener el valor de this y que haga referencia al objeto sobre el que estamos actuando haríamos:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(this));\n\npor lo que el valor de this dentro de la función aceptado será el mismo que tenía fuera, es decir, la instancia del objeto.\nEsto es lo que hacíamos en la práctica de DOM cuando le pasábamos a las funciones manejadoras del submit y el click del formulario en la vista métodos del controlador con el objeto this bindeado:\nthis.view.setBookSubmitHandler(this.handleSubmitBook.bind(this));\nthis.view.setBookRemoveHandler(this.handleRemoveBook.bind(this));\n\nSin ese bindeo esos métodos perderían la referencia a la instancia del controlador y no podrían acceder a sus propiedades y métodos.\nPodemos bindear, es decir, pasarle a la función manejadora más variables declarándolas como parámetros de bind. El primer parámetro será el valor de this y los demás serán parámetros que recibirá la función antes de recibir el parámetro event que será el último. Por ejemplo:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(var1, var2));\n...\nfunction aceptado(param1, param2, event) {\n// Aquí dentro tendremos los valores\n// this = var1\n// param1 = var2\n// param2 = var3\n// event es el objeto con la información del evento producido\n}\n\nPropagación de eventos\nNormalmente en una página web los elementos HTML se solapan unos con otros, por ejemplo, un &lt;span&gt; está en un &lt;p&gt; que está en un &lt;div&gt; que está en el &lt;body&gt;. Si ponemos un escuchador del evento click a todos ellos se ejecutarán todos ellos, pero ¿en qué orden?.\nPues el W3C establecíó un modelo en el que primero se disparan los eventos de fuera hacia dentro (primero el &lt;body&gt;) y al llegar al más interno (el &lt;span&gt;) se vuelven a disparar de nuevo pero de dentro hacia afuera. La primera fase se conoce como fase de captura y la segunda como fase de burbujeo (bubbling). Cuando ponemos un escuchador con addEventListener el tercer parámetro indica en qué fase debe dispararse:\n\ntrue: en fase de captura\nfalse (valor por defecto): en fase de burbujeo\n\nPor tanto, por defecto se disparará el escuchador más interno (el del &lt;span&gt;) y continuará el resto hasta el más externo (&lt;body&gt;) como si fuera una burbuja que sale afuera desde el interior.\nPodéis ver un ejemplo en:\n\nSin embargo si al método .addEventListener le pasamos un tercer parámetro con el valor true el comportamiento será el contrario, lo que se conoce como captura y el primer escuchador que se ejecutará es el del &lt;body&gt; y el último el del &lt;span&gt; (podéis probarlo añadiendo ese parámetro a los escuchadores del ejemplo anterior).\nEn cualquier momento podemos evitar que se siga propagando el evento ejecutando el método .stopPropagation() en el código de cualquiera de los escuchadores.\nPodéis ver las distintas fases de un evento en la página domevents.dev.\ninnerHTML y escuchadores de eventos\nComo los escuchadores de eventos se asocian a un elemento, si lo borramos desaparecerá el escuchador aunque luego lo volvamos a pintar no tendrá escuchador a menos que se lo pongamos de nuevo.\nPor ejemplo, si cambiamos el contenido de la propiedad innerHTML de un elemento todos los escuchadores de eventos de sus elementos hijos desaparecen ya que es como eliminar su contenido y volverlo a renderizar.\nEso pasaría en este ejemplo en que tenemos una tabla de datos donde al hacer dobleclick en cada fila se muestra su id. La función que añade una nueva fila podría ser:\nfunction renderNewRow(data) {\nlet miTabla = document.getElementById('tabla-datos');\nlet nuevaFila = `&lt;tr id=&quot;${data.id}&quot;&gt;&lt;td&gt;${data.dato1}&lt;/td&gt;&lt;td&gt;${data.dato2}...&lt;/td&gt;&lt;/tr&gt;`;\nmiTabla.innerHTML += nuevaFila;\ndocument.getElementById(data.id).addEventListener('dblclick', event =&gt; alert('Id: '+ event.target.id));\n\nSin embargo así sólo la última fila añadida tendría escuchador ya que la línea miTabla.innerHTML += nuevaFila borra todo el contenido de myTabla y lo vuelve a renderizar pero ya no tendría escuchadores, excepto el de nuevaFila que lo ponemos después de renderizarlo.\nLa forma correcta de hacerlo sería:\nfunction renderNewRow(data) {\nlet miTabla = document.getElementById('tabla-datos');\nlet nuevaFila = document.createElement('tr');\nnuevaFila.id = data.id;\nnuevaFila.innerHTML = `&lt;td&gt;${data.dato1}&lt;/td&gt;&lt;td&gt;${data.dato2}...&lt;/td&gt;`;\nnuevaFila.addEventListener('dblclick', event =&gt; alert('Id: ' + event.target.id) );\nmiTabla.appendChild(nuevaFila);\n\nDe esta forma además mejoramos el rendimiento ya que el navegador sólo tiene que renderizar el nodo correspondiente a la nuevaFila y no todas las filas de la tabla como pasaba con el primer código.\nDelegación de eventos\nEs un patrón de diseño que nos permite no tener que poner un escuchador a cada elemento sino uno global que haga el trabajo de todos.\nPor ejemplo si queremos escuchar cuándo hacemos click en cada celda de la tabla en lugar de poner un escuchador en cada una (que podría tener cientos) pongo sólo 1 en la tabla y mediante la propiedad event.target puedo saber sobre qué celda en concreto se ha hecho click. Esto además seguirá funcionando si dinámicamente añado nuevas celdas a la tabla ya que no son ellas las que tienen el escuchador sino la propia tabla.\nNOTA: ten en cuenta que a veces el evento se produce en alguna etiqueta interna al elemento por lo que event.target no sería el elemento que buscamos sino su descendiente. Por ejemplo si hay una imagen en la celda el event.target podría ser la &lt;img&gt; y no la &lt;td&gt;. Para asegurarnos de llegar al elemento deseado podemos usar el selector closest() que vimos en el DOM (tdClicked = event.target.closest('td')).\nPodéis ver más ejemplos de delegación de eventos en El Tutorial de JavaScript Moderno.\nEventos personalizados\nTambién podemos mediante código lanzar manualmente cualquier evento sobre un elemento con el método dispatchEvent() e incluso crear eventos personalizados, por ejemplo:\nconst event = new Event('build');\n\n// Listen for the event.\nelem.addEventListener('build', (e) =&gt; { /* ... */ });\n\n// Dispatch the event.\nelem.dispatchEvent(event);\n\nIncluso podemos añadir datos al objeto event si creamos el evento con new CustomEvent(). Podéis obtener más información en la página de MDN.",
		"tags": [ "note"]
},

{
		"title": "07-globales",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/DAW/Javascript Teoria Batoi/07-globales/",
		"content": "==",
		"tags": [ "note"]
},

{
		"title": "08-forms",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/08-forms/",
		"content": "Validación de formularios\nÍndice:\n\nValidación de formularios\n\nIntroducción\n\nValidación del navegador incorporada en HTML5\nValidación mediante la API de validación de formularios\n\nEjemplo\n\nyup\n\nExpresiones regulares\n\nPatrones\nMétodos\n\nIntroducción\nEn este tema vamos a ver cómo realizar una de las acciones principales de Javascript que es la validación de formularios en el lado cliente.\nSe trata de una verificación útil porque evita enviar datos al servidor que sabemos que no son válidos pero NUNCA puede sustituir a la validación en el lado servidor ya que en el lado cliente se puede manipular el código desde la consola para que se salte las validaciones que le pongamos.\nPodéis encontrar una guía muy completa de validación de formularios en el lado cliente el la página de MDN web docs que ha servido como base para estos apuntes.\nAdemás, al final de este tema, veremos una pequeña introducción a las expresiones regulares en Javascript.\nBásicamente tenemos 2 maneras de validar un formulario en el lado cliente:\n\nusar la validación incorporada en HTML5 y dejar que sea el navegador quien se encargue de todo\nrealizar nosotros la validación mediante Javascript\n\nLa ventaja de la primera opción es que no tenemos que escribir código sino simplemente poner unos atributos a los INPUT que indiquen qué se ha de validar. La principal desventaja es que no tenemos ningún control sobre el proceso, lo que provocará cosas como:\n\nel navegador valida campo a campo: cuando encuentra un error en un campo lo muestra y hasta que no se soluciona no valida el siguiente lo que hace que el proceso sea molesto para el usuario que no ve todo lo que hay mal de una vez\nlos mensajes son los predeterminados del navegador y en ocasiones pueden no ser muy claros para el usuario\nlos mensajes se muestran en el idioma en que está configurado el navegador, no en el de nuestra página\n\nValidación del navegador incorporada en HTML5\nFunciona añadiendo atributos a los campos del formulario que queremos validar. Los más usados son:\n\nrequired: indica que el campo es obligatorio. La valdación fallará si no hay nada escrito en el input. En el caso de un grupo de radiobuttons se pone sobre cualquiera de ellos (o sobre todos) y obliga a que haya seleccionada una opción cualquiera del grupo\npattern: obliga a que el contenido del campo cumpla la expresión regular indicada. Por ejemplo para un código postal sería pattern=&quot;^[0-9]{5}$&quot;\nminlength / maxlength: indica la longitud mínima/máxima del contenido del campo\nmin / max: indica el valor mínimo/máximo del contenido de un campo numérico\n\nTambién producen errores de validación si el contenido de un campo no se adapta al type indicado (email, number, ...) o si el valor de un campo numérico no cumple con el step indicado.\nCuando el contenido de un campo es valido dicho campo obtiene automáticamente la pseudoclase :valid y si no lo es tendrá la pseudoclase :invalid lo que nos permite poner reglas en nuestro CSS para destacar dichos campos, por ejemplo:\ninput:invalid {\nborder: 2px dashed red;\n}\n\nAdemás de las anteriores tenemos las pseudoclases :required, :optional, que nos permiten poner reglas de estilo a los campos obligatorios o no, y :focus para el campo con el foco.\nLa validación del navegador se realiza al enviar el formulario. Si encuentra un error lo muestra, se detiene la validación del resto de campos y no se envía el formulario.\nValidación mediante la API de validación de formularios\nMediante Javscript tenemos acceso a todos los campos del formulario por lo que podemos hacer la validación como queramos, pero es una tarea pesada, repetitiva y que provoca código spaguetti difícil de leer y mantener más adelante.\nPara hacerla más simple podemos usar la API de validación de formularios de HTML5 que permite que sea el navegador quien se encargue de comprobar la validez de cada campo pero las acciones (mostrar mensajes de error, no enviar el formulario, ...) las realizamos desde Javascript.\nEsto nos da la ventaja de:\n\nlos requisitos de validación de cada campo están como atributos HTML de dicho campo por lo que son fáciles de ver\nnos evitamos la mayor parte del código dedicada a comprobar si el contenido del campo es válido. Nosotros mediante la API sólo preguntamos si se cumplen o no y tomamos las medidas adecuadas\naprovechamos las pseudo-clases :valid o :invalid que el navegador pone automáticamente a los campos por lo que no tenemos que añadirles clases para desacarlos\n\nLas principales propiedades y métodos que nos proporciona esta API son:\n\ncheckValidity(): método booleano que nos dice si el campo al que se aplica es o no válido. También se puede aplicar al formulario para saber si es válido o no\nvalidationMessage: en caso de que un campo no sea válido esta propiedad contiene el texto del error de validación proporcionado por el navegador. Si es válido esta propiedad es una cadena vacía\nsetCustomValidity(mensaje): añade un error personalizado al campo (que ahora ya NO será válido para el navegador) con el mensaje pasado como parámetro. Por ejemplo podemos usarlo para indicar que el nick elegido no es válido porque ya está en uso por otro usuario. Para quitar este error se hace setCustomValidity('')\nvalidity: es un objeto que tiene propiedades booleanas para saber qué requisito del campo es el que falla:\n\nvalueMissing: indica si no se cumple el atributo required (es decir, valdrá true si el campo tiene el atributo required pero no se ha introducido nada en él)\ntypeMismatch: indica si el contenido del campo no cumple con su atributo type (ej. type=&quot;email&quot;)\npatternMismatch: indica si no se cumple con el pattern indicado en su atributo\ntooShort / tooLong: indican si no se cumple el atributo minlength o maxlength respectivamente\nrangeUnderflow / rangeOverflow: indica si no se cumple el atributo min / max\nstepMismatch: indica si no se cumple el atributo step del campo\ncustomError: indica al campo se le ha puesto un error personalizado con setCustomValidity\nvalid: indica si es campo es válido\n\n...\n\nEn la página de W3Schools podéis ver algún ejemplo básico de esto. También a continuación tenéis un ejemplo simple del valor de las diferentes propiedades involucradas en la validación de un campo de texto que es obligatorio y cuyo tamaño debe estar entre 5 y 50 caracteres:\n\nPara validar un formulario nosotros pero usando esta API debemos añadir a la etiqueta &lt;form&gt; el atributo novalidate que hace que no se encargue el navegador de mostrar los mensajes de error ni de decidir si se envía o no el formulario (aunque sí valida los campos) sino que lo haremos nosotros.\nEjemplo\nUn ejemplo sencillo de validación de un formulario podría ser:\n\nindex.html\n\n&lt;form novalidate&gt;\n&lt;label for=&quot;nombre&quot;&gt;Por favor, introduzca su nombre (entre 5 y 50 caracteres): &lt;/span&gt;\n&lt;input type=&quot;text&quot; id=&quot;nombre&quot; name=&quot;nombre&quot; required minlength=&quot;5&quot; maxlength=&quot;50&quot;&gt;\n&lt;span class=&quot;error&quot;&gt;&lt;/label&gt;\n&lt;br /&gt;\n&lt;label for=&quot;mail&quot;&gt;Por favor, introduzca una dirección de correo electrónico: &lt;/label&gt;\n&lt;input type=&quot;email&quot; id=&quot;mail&quot; name=&quot;mail&quot; required minlength=&quot;8&quot;&gt;\n&lt;span class=&quot;error&quot;&gt;&lt;/span&gt;\n&lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;\n&lt;/form&gt;\n\nmain.js\n\nconst form = document.getElementsByTagName('form')[0];\n\nconst nombre = document.getElementById('nombre');\nconst nombreError = document.querySelector('#nombre + span.error');\nconst email = document.getElementById('mail');\nconst emailError = document.querySelector('#mail + span.error');\n\nform.addEventListener('submit', (event) =&gt; {\nif(!form.checkValidity()) {\nevent.preventDefault();\n}\nnombreError.textContent = nombre.validationMessage;\nemailError.textContent = email.validationMessage;\n});\n\nstyle.css\n\n.error {\ncolor: red;\n}\n\ninput:invalid {\nborder: 2px dashed red;\n}\n\nEstamos usando\n\nvalidationMessage para mostrar el posible error de cada campo, o quitar el error cuando el campo sea válido\ncheckValidity() para no enviar/procesar el formulario si contiene errores\n\nSi no nos gusta el mensaje del navegador y queremos personalizarlo podemos hacer una función que reciba un &lt;input&gt; y usando su propiedad validity devuelva un mensaje en función del error detectado:\nfunction customErrorValidationMessage(input) {\nif (input.checkValidity()) {\nreturn ''\n}\nif (input.validity.valueMissing) {\nreturn 'Este campo es obligatorio'\n}\nif (input.validity.tooShort) {\nreturn `Debe tener al menos ${input.minLength} caracteres`\n}\n// Y seguiremos comprobando cada atributo que hayamos usado en el HTML\nreturn 'Error en el campo' // por si se nos ha olvidado comprobar algo\n}\n\nY ahora en vez de nombreError.textContent = nombre.validationMessage haremos nombreError.textContent = customErrorValidationMessage(nombre).\nSi tenemos que validar algo que no puede hacerse mediante atributos HTML (por ejemplo si el nombre de usuario ya está en uso) deberemos hacer la validación &quot;a mano&quot; y en caso de no ser válido ponerle un error con .setCustomValidity(), pero debemos recordar quitar el error si todo es correcto o el formulario siempre será inválido. Modificando el ejemplo:\nconst nombre = document.getElementById('nombre');\nconst nombreError = document.querySelector('#nombre + span.error');\n\nform.addEventListener('submit', (event) =&gt; {\nif (nombreEnUso(nombre.value)) {\nnombre.setCustomValidity('Ese nombre de usuario ya está en uso')\n} else {\nnombre.setCustomValidity('') // Se quita el error personalizado\n}\n\nif(!form.checkValidity()) {\n...\n}\n})\n\nFicheros en formularios\nHay infinidad de páginas donde poder consultar cómo validar ficheros e imágenes en un formulario. Os recomiendo:\n\nCurso DWEC de José Castillo\nw3schools\ndeveloper.mozilla.org.\n\nyup\nExisten múltiples librerías que facilitan enormenmente el tedioso trabajo de validar un formulario. Un ejemplo es yup.\nExpresiones regulares\nLas expresiones regulares permiten buscar un patrón dado en una cadena de texto. Se usan mucho a la hora de validar formularios o para buscar y reemplazar texto. En Javascript se crean poniéndolas entre caracteres / (o instanciándolas de la clase RegExp, aunque es mejor de la otra forma):\nlet cadena='Hola mundo';\nlet expr=/mundo/;\nexpr.test(cadena); // devuelve true porque en la cadena se encuentra la expresión 'mundo'\n\nPatrones\nLa potencia de las expresiones regulares es que podemos usar patrones para construir la expresión. Los más comunes son:\n\n[..] (corchetes): dentro se ponen varios caracteres o un rango y permiten comprobar si el carácter de esa posición de la cadena coincide con alguno de ellos. Ejemplos:\n\n[abc]: cualquier carácter de los indicados ('a' o 'b' o 'c')\n[^abc]: cualquiera excepto los indicados\n[a-z]: cualquier minúscula (el carácter '-' indica el rango entre 'a' y 'z', incluidas)\n[a-zA-Z]: cualquier letra\n\n( | ) (pipe): debe coincidir con una de las opciones indocadas:\n\n(x|y): la letra x o la y (sería equivalente a [xy]\n(http|https): cualquiera de las 2 palabras\n\nMetacaracteres:\n\n. (punto): un único carácter, sea el que sea\n\\d: un dígito (\\D: cualquier cosa menos dígito)\n\\s: espacio en blanco (\\S: lo opuesto)\n\\w: una palabra o carácter alfanumérico (\\W lo contrario)\n\\b: delimitador de palabra (espacio, ppio, fin)\n\\n: nueva línea\n\nCuantificadores:\n\n+: al menos 1 vez (ej. [0-9]+ al menos un dígito)\n*: 0 o más veces\n?: 0 o 1 vez\n{n}: n caracteres (ej. [0-9]{5} = 5 dígitos)\n{n,}: n o más caracteres\n{n,m}: entre n y m caracteres\n^: al ppio de la cadena (ej.: ^[a-zA-Z] = empieza por letra)\n$: al final de la cadena (ej.: [0-9]$ = que acabe en dígito)\n\nModificadores:\n\n/i: que no distinga entre Maysc y minsc (Ej. /html/i = buscará html, Html, HTML, ...)\n/g: búsqueda global, busca todas las coincidencias y no sólo la primera\n/m: busca en más de 1 línea (para cadenas con saltos de línea)\n\nEJERCICIO: contruye una expresión regular para lo que se pide a continuación y pruébala con distintas cadenas:\n\nun código postal\nun NIF formado por 8 números, un guión y una letra mayúscula o minúscula\nun número de teléfono y aceptamos 2 formatos: XXX XX XX XX o XXX XXX XXX. EL primer número debe ser un 6, un 7, un 8 o un 9\n\nMétodos\nLos usaremos para saber si la cadena coincide con determinada expresión o para buscar y reemplazar texto:\n\nexpr.test(cadena): devuelve true si la cadena coincide con la expresión. Con el modificador /g hará que cada vez que se llama busque desde la posición de la última coincidencia. Ejemplo:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/g;\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime false, hay solo dos coincidencias\n\nlet reg2 = /am/gi; // ahora no distinguirá mayúsculas y minúsculas\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true. Ahora tenemos 3 coincidencias con este nuevo patrón\n\nexpr.exec(cadena): igual pero en vez de true o false devuelve un objeto con la coincidencia encontrada, su posición y la cadena completa:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/gi;\nconsole.log(reg.exec(str)); // Imprime [&quot;am&quot;, index: 2, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime [&quot;am&quot;, index: 5, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime [&quot;Am&quot;, index: 15, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime null\n\ncadena.match(expr): igual que exec pero se aplica a la cadena y se le pasa la expresión. Si ésta tiene el modificador /g devolverá un array con todas las coincidencis:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/gi;\nconsole.log(str.match(reg)); // Imprime [&quot;am&quot;, &quot;am&quot;, &quot;Am&quot;}\n\ncadena.search(expr): devuelve la posición donde se encuentra la coincidencia buscada o -1 si no aparece\ncadena.replace(expr, cadena2): devuelve una nueva cadena xon las coincidncias de la cadena reemplazadas por la cedena pasada como 2º parámetro:\n\nlet str = &quot;I am amazed in America&quot;;\nconsole.log(str.replace(/am/gi, &quot;xx&quot;)); // Imprime &quot;I xx xxazed in xxerica&quot;\n\nconsole.log(str.replace(/am/gi, function(match) {\nreturn &quot;-&quot; + match.toUpperCase() + &quot;-&quot;;\n})); // Imprime &quot;I -AM- -AM-azed in -AM-erica&quot;\n\nNo vamos a profundizar más sobre las expresiones regulares. Es muy fácil encontrar por internet la que necesitemos en cada caso (para validar un e-mail, un NIF, un CP, ...). Podemos aprender más en:\n\nw3schools\nregular-expressions.info\nhtml5pattern atributo\ny muchas otras páginas\n\nTambién, hay páginas que nos permiten probar expresiones regulares con cualquier texto, como regexr.",
		"tags": [ "note"]
},

{
		"title": "09-ajax",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/09-ajax/",
		"content": "Ajax\n\nAjax\n\nIntroducción\n\nMétodos HTTP\nJson Server\nREST client\n\nEl objeto XMLHttpRequest\n\nEventos de XMLHttpRequest\nEjemplos de envío de datos\n\nEnviar datos al servidor en formato JSON\nEnviar datos al servidor en formato URIEncoded\nEnviar ficheros al servidor con FormData\n\nCallbakcs, Promesas y Async/Await\n\nSi Ajax fuera síncrono...\nSolución mala\nAlgo mejor: Funciones callback\nSolución buena: Promesas\nLa mejor solución: usar Async/Await\n\nfetch\n\nPropiedades y métodos de la respuesta de fetch\nGestión de errores con fetch\nOtros métodos de petición con fetch\n\nHacer varias peticiones simultáneamente. Promise.all\nOrganizar bien el código\n\nEl fichero .env\nDistintas peticiones, distintos ficheros\n\nSingle Page Application\nResumen de llamadas asíncronas\nCORS\n\nIntroducción\nAJAX es el acrónimo de Asynchronous Javascript And XML (Javascript asíncrono y XML) y es lo que usamos para hacer peticiones asíncronas al servidor desde Javascript. Cuando hacemos una petición al servidor no nos responde inmediatamente (la petición tiene que llegar al servidor, procesarse allí y enviarse la respuesta que llegará al cliente).\nLo que significa asíncrono es que la página no permanecerá bloqueada esperando esa respuesta sino que continuará ejecutando su código e interactuando con el usuario, y en el momento en que llegue la respuesta del servidor se ejecutará la función que indicamos al hacer la llamada Ajax. Respecto a XML, es el formato en que se intercambia la información entre el servidor y el cliente, aunque actualmente el formato más usado es JSON que es más simple y legible.\nBásicamente Ajax nos permite poder mostrar nuevos datos enviados por el servidor sin tener que recargar la página, que continuará disponible mientras se reciben y procesan los datos enviados por el servidor en segundo plano.\n\nSin Ajax cada vez que necesitamos nuevos datos del servidor la página deja de estar disponible para el usuario hasta que se recarga con lo que envía el servidor. Con Ajax la página está siempre disponible para el usuario y simplemente se modifica (cambiando el DOM) cuando llegan los datos del servidor:\n\nFuente Uniwebsidad\nMétodos HTTP\nLas peticiones Ajax usan el protocolo HTTP (el mismo que utiliza el navegador para cargar una página). Este protocolo envía al servidor unas cabeceras HTTP (con información como el userAgent del navegador, el idioma, etc), el tipo de petición y, opcionalmente, datos o parámetros (por ejemplo en la petición que procesa un formulario se envían los datos del mismo).\nHay diferentes tipos de petición que podemos hacer:\n\nGET: suele usarse para obtener datos sin modificar nada (equivale a un SELECT en SQL). Si enviamos datos (ej. la ID del registro a obtener) suelen ir en la url de la petición (formato URIEncoded). Ej.: locahost/users/3, https://jsonplaceholder.typicode.com/users o www.google.es?search=js\nPOST: suele usarse para añadir un dato en el servidor (equivalente a un INSERT). Los datos enviados van en el cuerpo de la petición HTTP (igual que sucede al enviar desde el navegador un formulario por POST)\nPUT: es similar al POST pero suele usarse para actualizar datos del servidor (como un UPDATE de SQL). Los datos se envían en el cuerpo de la petición (como en el POST) y la información para identificar el objeto a modificar en la url (como en el GET). El servidor hará un UPDATE sustituyendo el objeto actual por el que se le pasa como parámetro\nPATCH: es similar al PUT pero la diferencia es que en el PUT hay que pasar todos los campos del objeto a modificar (los campos no pasados se eliminan del objeto) mientras que en el PATCH sólo se pasan los campos que se quieren cambiar y en resto permanecen como están\nDELETE: se usa para eliminar un dato del servidor (como un DELETE de SQL). La información para identificar el objeto a eliminar se envía en la url (como en el GET)\nexisten otros tipos que no veremos aquí (como HEAD, PATCH, etc)\n\nEl servidor acepta la petición, la procesa y le envía una respuesta al cliente con el recurso solicitado y además unas cabeceras de respuesta (con el tipo de contenido enviado, el idioma, etc) y el código de estado. Los códigos de estado más comunes son:\n\n2xx: son peticiones procesadas correctamente. Las más usuales son 200 (ok) o 201 (created, como respuesta a una petición POST satisfactoria)\n3xx: son códigos de redirección que indican que la petición se redirecciona a otro recurso del servidor, como 301 (el recurso se ha movido permanentemente a otra URL) o 304 (el recurso no ha cambiado desde la última petición por lo que se puede recuperar desde la caché)\n4xx: indican un error por parte del cliente, como 404 (Not found, no existe el recurso solicitado) o 401 (Not authorized, el cliente no está autorizado a acceder al recurso solicitado)\n5xx: indican un error por parte del servidor, como 500 (error interno del servidor) o 504 (timeout, el servidor no responde).\n\nEn cuanto a la información enviada por el servidor al cliente normalmente serán datos en formato JSON o XML (cada vez menos usado) que el cliente procesará y mostrará en la página al usuario. También podría ser HTML, texto plano, ...\nEl formato JSON es una forma de convertir un objeto Javascript en una cadena de texto para poderla enviar, por ejemplo el objeto\nlet alumno = {\nid: 5,\nnombre: Marta,\napellidos: Pérez Rodríguez\n}\n\nse transformaría en la cadena de texto\n{ &quot;id&quot;: 5, &quot;nombre&quot;: &quot;Marta&quot;, &quot;apellidos&quot;: &quot;Pérez Rodríguez&quot; }\n\ny el array\nlet alumnos = [\n{\nid: 5,\nnombre: &quot;Marta&quot;,\napellidos: &quot;Pérez Rodríguez&quot;\n},\n{\nid: 7,\nnombre: &quot;Joan&quot;,\napellidos: &quot;Reig Peris&quot;\n},\n]\n\nen la cadena:\n[{ &quot;id&quot;: 5, &quot;nombre&quot;: Marta, &quot;apellidos&quot;: Pérez Rodríguez }, { &quot;id&quot;: 7, &quot;nombre&quot;: &quot;Joan&quot;, &quot;apellidos&quot;: &quot;Reig Peris&quot; }]\n\nPara convertir objetos en cadenas de texto JSON y viceversa Javascript proporciona 2 funciones:\n\nJSON.stringify(objeto): recibe un objeto JS y devuelve la cadena de texto correspondiente. Ej.: const cadenaAlumnos = JSON.stringify(alumnos)\nJSON.parse(cadena): realiza el proceso inverso, convirtiendo una cadena de texto en un objeto. Ej.: const alumnos = JSON.parse(cadenaAlumnos)\n\nEJERCICIO: Vamos a realizar diferentes peticions HTTP a la API https://jsonplaceholder.typicode.com, en concreto trabajaremos contra la tabla todos con tareas para hacer. Las peticiones GET podríamos hacerlas directamente desde el navegador pero para el resto debemos instalar alguna de las extensiones de cliente REST en nuestro navegador. Por tanto instalaremos dicha extensión (por ejemplo Advanced Rest Client para Chrome o Rested para Firefox y haremos todas las peticiones desde allí (incluyendo los GET) lo que nos permitirá ver los códigos de estado devueltos, las cabeceras, etc.\nLo que queremos hacer en este ejercicio es:\n\nobtener todas las tareas (devuelve un array con todas las tareas y el código devuelto será 200 - Ok)\n![GET all](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Ajax-GETall.png)\n\nobtener la tarea con id 55 (devuelve el objeto de la tarea 55 y el código devuelto será 200 - Ok)\n![GET one](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Ajax-GETone.png)\n\nobtener la tarea con id 201 (como no existe devolverá un objeto vacío y como código de error 404 - Not found)\n![GET Non Existent](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Ajax-GETnonExistent.png)\n\ncrear una nueva tarea. En el cuerpo de la petición le pasaremos sus datos: userID: 1, title: Prueba de POST y completed: false. No se le pasa la id (de eso se encarga la BBDD). La respuesta debe ser un código 201 (created) y el nuevo registro creado con todos sus datos incluyendo la id. Como es una API de prueba en realidad no lo está añadiendo a la BBDD por lo que si luego hacemos una petición buscando esa id nos dirá que no existe.\n![POST](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Ajax-POST.png)\n\nmodificar con un PATCH la tarea con id 55 para que su title sea 'Prueba de POST'. Devolverá el nuevo registro con un código 200. Como veis al hacer un PATCH los campos que no se pasan se mantienen como estaban\n![PATCH](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Ajax-PATCH.png)\n\nmodificar con un PUT la tarea con id 55 para que su title sea 'Prueba de POST'. Devolverá el nuevo registro con un código 200. Como veis en esta API los campos que no se pasan se eliminan; en otras los campos no pasados se mantienen como estaban\n![PUT](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Ajax-PUT.png)\n\neliminar la tarea con id 55. Como veis esta API devuelve un objeto vacío al eliminar; otras devuelven el objeto eliminado\n![DELETE](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Ajax-DELETE.png)\n\nJson Server\nLas peticiones Ajax se hacen a un servidor que proporcione una API. Como ahora no tenemos ninguno podemos utilizar Json Server que es un servidor API-REST que funciona bajo Node.js (que ya tenemos instalado para usar NPM) y que utiliza un fichero JSON como contenedor de los datos en lugar de una base de datos.\nPara instalarlo en nuestra máquina (lo instalaremos global para poderlo usar en todas nuestras prácticas) ejecutamos:\nnpm install -g json-server\n\nPara que sirva un fichero datos.json:\njson-server datos.json\n\nLe podemos poner la opción --watch ( o -w) para que actualice los datos si se modifica el fichero .json externamente (si lo editamos).\nEl fichero datos.json será un fichero que contenga un objeto JSON con una propiedad para cada &quot;tabla&quot; de nuestra BBDD. Por ejemplo, si queremos simular una BBDD con las tablas users y posts vacías el contenido del fichero será:\n{\n&quot;users&quot;: [],\n&quot;posts&quot;: []\n}\n\nLa API escucha en el puerto 3000 y servirá los diferentes objetos definidos en el fichero .json. Por ejemplo:\n\nhttp://localhost:3000/users: devuelve un array con todos los elementos de la tabla users del fichero .json\nhttp://localhost:3000/users/5: devuelve un objeto con el elemento de la tabla users cuya propiedad id valga 5\n\nTambién pueden hacerse peticiones más complejas como:\n\nhttp://localhost:3000/users?rol=3: devuelve un array con todos los elementos de users cuya propiedad rol valga 3\n\nPara más información: https://github.com/typicode/json-server.\nSi queremos acceder a la API desde otro equipo (no desde localhost) tenemos que indicar la IP de la máquina que ejecuta json-server y que se usará para acceder, por ejemplo si vamos a ejecutarlo en la máquina 192.168.0.10 pondremos:\njson-server --host 192.168.0.10 datos.json\n\nY la ruta para acceder a la API será http://192.168.0.10:3000.\n\nEJERCICIO: instalar json-server en tu máquina. Ejecútalo indicando un nombre de fichero que no existe: como verás crea un fichero json de prueba con 3 tablas: posts, comments y profiles. Ábrelo en tu navegador para ver los datos\n\nREST client\nPara probar las peticiones GET podemos poner la URL en la barra de direcciones del navegador pero para probar el resto de peticiones debemos instalar en nuestro navegador una extensión que nos permita realizar las peticiones indicando el método a usar, las cabeceras a enviar y los datos que enviaremos a servidor, además de la URL.\nExisten multitud de aplicaciones para realizar peticiones HTTP, como Advanced REST client. Cada navegador tiene sus propias extensiones para hacer esto, como Advanced Rest Client para Chrome o RestClient para Firefox.\nEl objeto XMLHttpRequest\nHasta ahora hemos hecho un repaso a lo que es el protocolo HTTP. Ahora que lo tenemos claro y hemos instalado un servidor que nos proporciona una API (json-server) vamos a realizar peticiones HTTP en nuestro código javascript usando Ajax.\nPara hacer una petición debemos crear una instancia del objeto XMLHttpRequest que es el que controlará todo el proceso. Los pasos a seguir son:\n\nCreamos la instancia del objeto: const peticion=new XMLHttpRequest()\nPara establecer la comunicación con el servidor ejecutamos el método .open() al que se le pasa como parámetro el tipo de petición (GET, POST, ...) y la URL del servidor: peticion.open('GET', 'https://jsonplaceholder.typicode.com/users')\nOPCIONAL: Si queremos añadir cabeceras a la petición HTTP llamaremos al método .setRequestHeader(). Por ejemplo si enviamos datos con POST hay que añadir la cabecera Content-type que le indica al servidor en qué formato van los datos: peticion.setRequestHeader('Content-type', 'application/x-www-form-urlencoded)\nEnviamos la petición al servidor con el método .send(). A este método se le pasa como parámetro los datos a enviar al servidor en el cuerpo de la petición (si es un POST, PUT o PATCH le pasaremos una cadena de texto con los datos a enviar: peticion.send('dato1='+encodeURIComponent(dato1)+'&amp;dato2='+encodeURIComponent(dato2))). Si es una petición GET o DELETE no le pasaremos datos (peticion.send())\nPonemos un escuchador al objeto peticion para saber cuándo está disponible la respuesta del servidor\n\nEventos de XMLHttpRequest\nTenemos diferentes eventos que el servidor envía para informarnos del estado de nuestra petición y que nosotros podemos capturar. El evento readystatechange se produce cada vez que el servidor cambia el estado de la petición. Cuando hay un cambio en el estado cambia el valor de la propiedad readyState de la petición. Sus valores posibles son:\n\n0: petición no iniciada (se ha creado el objeto XMLHttpRequest)\n1: establecida conexión con el servidor (se ha hecho el open)\n2: petición recibida por el servidor (se ha hecho el send)\n3: se está procesando la petición\n4: petición finalizada y respuesta lista (este es el evento que nos interesa porque ahora tenemos la respuesta disponible)\nA nosotros sólo nos interesa cuando su valor sea 4 que significa que ya están los datos. En ese momento la propiedad status contiene el estado de la petición HTTP (200: Ok, 404: Not found, 500: Server error, ...) que ha devuelto el servidor. Cuando readyState vale 4 y status vale 200 tenemos los datos en la propiedad responseText (o responseXML si el servidor los envía en formato XML).\n\nEl siguiente ejemplo nos enseña cómo se producen los distintos eventos en una petición asíncrona:\nconst peticion = new XMLHttpRequest();\nconsole.log(&quot;Estado inicial de la petición: &quot; + peticion.readyState);\npeticion.open('GET', 'https://jsonplaceholder.typicode.com/users');\nconsole.log(&quot;Estado de la petición tras el 'open': &quot; + peticion.readyState);\npeticion.send();\nconsole.log(&quot;Petición hecha&quot;);\npeticion.addEventListener('readystatechange', function() {\nconsole.log(&quot;Estado de la petición: &quot; + peticion.readyState);\nif (peticion.readyState === 4) {\nif (peticion.status === 200) {\nconsole.log(&quot;Datos recibidos:&quot;);\nlet usuarios = JSON.parse(peticion.responseText); // Convertirmos los datos JSON a un objeto\nconsole.log(usuarios);\n} else {\nconsole.log(&quot;Error &quot; + peticion.status + &quot; (&quot; + peticion.statusText + &quot;) en la petición&quot;);\n}\n}\n})\nconsole.log(&quot;Petición acabada&quot;);\n\nEl resultado de ejecutar ese código es el siguiente:\n![Ejemplo 1: consola](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/ajax-ej1.png)\nFijaos cuándo cambia de estado (readyState) la petición:\n\nvale 0 al crear el objeto XMLHttpRequest\nvale 1 cuando abrimos la conexión con el servidor\nluego se envía al servidor y es éste el que va informando al cliente de cuándo cambia su estado\n\nMUY IMPORTANTE: notad que la última línea ('Petición acabada') se ejecuta antes que las de 'Estado de la petición'. Recordad que es una petición asíncrona y la ejecución del programa continúa sin esperar a que responda el servidor.\nComo normalmente no nos interesa cada cambio en el estado de la petición sino que sólo queremos saber cuándo ha terminado de procesarse tenemos otros eventos que nos pueden ser de utilidad:\n\nload: se produce cuando se recibe la respuesta del servidor. Equivale a readyState===4. En status tendremos el estado de la respuesta\nerror: se produce si sucede algún error al procesar la petición (de red, de servidor, ...)\ntimeout: si ha transcurrido el tiempo indicado y no se ha recibido respuesta del servidor. Podemos cambiar el tiempo por defecto modificando la propiedad timeout antes de enviar la petición\nabort: si se cancela la petición (se hace llamando al método .abort() de la petición)\nloadend: se produce siempre que termina la petición, independientemente de si se recibe respuesta o sucede algún error (incluyendo un timeout o un abort)\n\nEste es un ejemplo de código que sí podríamos usar para este tipo de peticiones:\nconst peticion=new XMLHttpRequest();\npeticion.open('GET', 'https://jsonplaceholder.typicode.com/users');\npeticion.send();\npeticion.addEventListener('load', function() {\nif (peticion.status===200) {\nlet usuarios=JSON.parse(peticion.responseText);\n// procesamos los datos que tenemos en usuarios\n} else {\nmuestraError(peticion);\n}\n})\npeticion.addEventListener('error', muestraError);\npeticion.addEventListener('abort', muestraError);\npeticion.addEventListener('timeout', muestraError);\n\nfunction muestraError(peticion) {\nif (peticion.status) {\nconsole.log(&quot;Error &quot;+peticion.status+&quot; (&quot;+peticion.statusText+&quot;) en la petición&quot;);\n} else {\nconsole.log(&quot;Ocurrió un error o se abortó la conexión&quot;);\n}\n}\n\nRecuerda que tratamos con peticiones asíncronas por lo que tras la línea\npeticion.addEventListener('load', function() {\n\nno se ejecuta la línea siguiente\nif (peticion.status===200) {\n\nsino la de\npeticion.addEventListener('error', muestraError);\n\nUna petición asíncrona es como pedir una pizza: tras llamar por teléfono lo siguiente no es ir a la puerta a recogerla sino que seguimos haciendo cosas por casa y cuando suena el timbre de casa entonces vamos a la puerta a por ella.\nEjemplos de envío de datos\nPodemos enviar datos al servidor en el cuerpo de la petición http. Siempre deberemos indicar en una cabecera de la petición en qué formato enviamos los datos y en función de dicho formato se hace la petición de diferente manera.\nVamos a ver algunos ejemplos de envío de datos al servidor con POST. Supondremos que tenemos una página con un formulario para dar de alta nuevos productos:\n&lt;form id=&quot;addProduct&quot;&gt;\n&lt;label for=&quot;name&quot;&gt;Nombre: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;descrip&quot;&gt;Descripción: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;descrip&quot; id=&quot;descrip&quot; required&gt;&lt;br&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Añadir&lt;/button&gt;\n&lt;/form&gt;\n\nEnviar datos al servidor en formato JSON\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst newProduct={\nname: document.getElementById(&quot;name&quot;).value,\ndescrip: document.getElementById(&quot;descrip&quot;).value,\n}\nconst peticion=new XMLHttpRequest();\npeticion.open('POST', 'https://localhost/products');\npeticion.setRequestHeader('Content-type', 'application/json'); // Siempre tiene que estar esta línea si se envían datos\npeticion.send(JSON.stringify(newProduct)); // Hay que convertir el objeto a una cadena de texto JSON para enviarlo\npeticion.addEventListener('load', function() {\n// procesamos los datos\n...\n})\n})\n\nPara enviar el objeto hay que convertirlo a una cadena JSON con la función JSON.stringify(). Siempre que enviamos datos al servidor debemos decirle el formato que tienen en la cabecera de Content-type:\npeticion.setRequestHeader('Content-type', 'application/json');\n\nEnviar datos al servidor en formato URIEncoded\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst name=document.getElementById(&quot;name&quot;).value;\nconst descrip=document.getElementById(&quot;descrip&quot;).value;\n\nconst peticion=new XMLHttpRequest();\npeticion.open('GET', 'https://localhost/products');\npeticion.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\npeticion.send('name='+encodeURIComponent(name)+'&amp;descrip='+encodeURIComponent(descrip));\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nEn este caso los datos se envían como hace el navegador por defecto en un formulario. Recordad siempre codificar lo que introduce el usuario para evitar problemas con caracteres no estándar y ataques SQL Injection u otros.\nEnviar ficheros al servidor con FormData\nFormData es una interfaz de XMLHttpRequest que permite construir fácilmente pares de clave=valor para enviar los datos de un formulario. Se envían en el mismo formato en que se enviarían directamente desde un formulario (&quot;multipart/form-data&quot;) por lo que no hay que poner encabezado de 'Content-type'.\nDe esta manera podemos enviar ficheros al servidor, no sólo valores de texto.\nVamos a añadir al formulario un campo donde el usuario pueda subir la foto del producto:\n&lt;form id=&quot;addProduct&quot;&gt;\n&lt;label for=&quot;name&quot;&gt;Nombre: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;descrip&quot;&gt;Descripción: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;descrip&quot; id=&quot;descrip&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;photo&quot;&gt;Fotografía: &lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;photo&quot; id=&quot;photo&quot; required&gt;&lt;br&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Añadir&lt;/button&gt;\n&lt;/form&gt;\n\nPodemos enviar al servidor todo el contenido del formulario:\ndocument.getElementById('addProduct').addEventListener('submit', (event) =&gt; {\n...\nconst peticion=new XMLHttpRequest();\nconst datosForm = new FormData(document.getElementById('addProduct'));\n// Automáticamente ha añadido todos los inputs, incluyendo tipo 'file', blob, ...\n// Si quisiéramos añadir algún dato más haríamos:\nformData.append('otrodato', 12345);\n// Y lo enviamos\npeticion.open('POST', 'https://localhost/products');\npeticion.send(datosForm);\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nTambién podemos enviar sólo los campos que queramos:\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst formData=new FormData(); // creamos un formData vacío\nformData.append('name', document.getElementById('name').value);\nformData.append('descrip', document.getElementById('descrip').value);\nformData.append('photo', document.getElementById('photo').files[0]);\n\nconst peticion=new XMLHttpRequest();\npeticion.open('POST', 'https://localhost/products');\npeticion.send(formData);\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nPodéis ver más información de cómo usar formData en MDN web docs.\nCallbakcs, Promesas y Async/Await\nPara ver un ejemplo real de cómo e haría una llamada a Ajax vamos a hacer una página que muestre en una tabla los posts del usuario indicado en un input. En resumen lo que hacemos es:\n\nEl usuario de nuestra aplicación introduce el código del usuario del que queremos ver sus posts\nTenemos un escuchador para que al introducir un código de un usuario llamamos a una función getPosts() que:\n\nSe encarga de hacer la petición Ajax al servidor\nSi se produce un error se encarga de informar al usuario de nuestra aplicación\n\nCuando se reciben los datos del servidor deben pintarse en la tabla\n\nSi Ajax fuera síncrono...\nSi Ajax no fuera una petición asíncrona el código de todo esto será algo como el siguiente (ATENCIÓN, este código NO FUNCIONA):\n\nPero esto no funciona porque el valor de posts siempre es undefined. Esto es porque cuando se llama a getPosts esta función no devuelve nada (por eso posts es undefined) sino que devuelve los datos tiempo después, cuando el servidor contesta, pero entonces ya no hay nadie escuchando.\nSolución mala\nLa solución es que todo el código, no sólo de la petición Ajax sino también el de qué hacer con los datos cuando llegan, se encuentre en la función que pide los datos al servidor:\n\nEste código sí que funcionaría pero tiene una pega: tenemos que tratar los datos (en este caso pintarlos en la tabla) en la función que gestiona la petición porque es la que sabe cuándo están disponibles esos datos. Y sabemos que una función no debería tener 2 responsabilidades diferentes (obtener los datos del servidor y renderizarlos en la página).\nAlgo mejor: Funciones callback\nEsto se podría mejorar usando una función callback. La idea es que creamos una función que procese los datos (renderPosts) y se la pasamos a getPosts para que la llame cuando tenga los datos:\n\nHemos creado una función que se ocupa de renderizar los datos y se la pasamos a la función que gestiona la petición para que la llame cuando los datos están disponibles. Utilizando la función callback hemos conseguido que getPosts() se encargue sólo de obtener los datos y cuando los tenga los pasa a la encargada de pintarlos en la tabla.\nSolución buena: Promesas\nSin embargo hay una forma más limpia de resolver una función asíncrona y que el código se parezca al primero que hicimos que no funcionaba, donde la función getPosts() sólo debía ocuparse de obtener los datos y devolverlos a quien se los pidió. Ese código era:\n...\nlet idUser = document.getElementById('id-usuario').value;\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número');\n} else {\nconst posts = getPosts(idUser);\n// y aquí usamos los datos recibidos, en este caso para pintar los posts\n}\n...\n\nComo dijimos esto NO funciona, a menos que convirtamos a getPosts() en una promesa. Cuando se realiza una llamada a una promesa quien la llama puede usar unos métodos (.then() y .catch()) que NO SE EJECUTARÁN hasta que la promesa se haya resuelto (es decir, hasta que el servidor haya contestado):\n\n.then(_function(datos) { ... }_): se ejecuta cuando la promesa se haya resuelto satisfactoriamente. Su parámetro es una función que recibe como parámetro los datos que haya devuelto la promesa (que serán los datos pedidos al servidor)\n.catch(function(datos) { ... }): se ejecuta cuando se haya rechazado la promesa (si ha fallado, normalmente porque se ha recibido una respuesta errónea del servidor). Esta función recibe como parámetro la información pasada por la promesa al ser rechazada (que será información sobre el error producido).\n\nDe esta manera nuestro código quedaría:\n...\nlet idUser = document.getElementById('id-usuario').value\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número')\n} else {\ngetPosts(idUser)\n.then((posts) =&gt; { // aquí ya tenemos los datos en 'posts'\ntbody.innerHTML = ''\nposts.forEach((post) =&gt; {\nconst newPost = document.createElement('tr')\nnewPost.innerHTML = `\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;`\ntbody.appendChild(newPost)\n})\ndocument.getElementById('num-posts').textContent = posts.length\n})\n// en el .catch() está el tratamiento de errores\n.catch((error) =&gt; console.error(error))\n}\n\nPara convertir a getPosts() en una promesa sólo tenemos que &quot;envolverla&quot; en la instrucción\nreturn new Promise((resolve, reject) =&gt; {\n// Aquí el contenido de GetPosts()\n})\n\nEsto hace que devuelva un objeto de tipo Promise (return new Promise()) cuyo parámetro es una función que recibe 2 parámetros:\n\nresolve: función callback a la que se llamará cuando se resuelva la promesa satisfactoriamente\nreject: función callback a la que se llamará si se resuelve la promesa con errores\n\nEl funcionamiento es:\n\ncuando la promesa se resuelva satisfactoriamente getPosts llama a la función resolve() y le pasa los datos recibidos por el servidor. Esto hace que se ejecute el método then de la llamada a la promesa que recibirá como parámetro esos datos\nsi se produce algún error se rechaza la promesa llamando a la función reject() y pasando como parámetro la información del fallo producido y esto hará que se ejecute el .catch en la función que llamó a la promesa\n\nPor tanto nuestra función getPosts ahora quedará así:\nfunction getPosts(idUser) {\nreturn new Promise((resolve, reject) =&gt; {\nconst peticion = new XMLHttpRequest();\npeticion.open('GET', SERVER + '/posts?userId=' + idUser);\npeticion.send();\npeticion.addEventListener('load', () =&gt; {\nif (peticion.status === 200) {\nresolve(JSON.parse(peticion.responseText));\n} else {\nreject(&quot;Error &quot; + peticion.status + &quot; (&quot; + peticion.statusText + &quot;) en la petición&quot;);\n}\n})\npeticion.addEventListener('error', () =&gt; reject('Error en la petición HTTP'));\n})\n}\n\nFijaos que el único cambio es la primera línea donde convertimos nuestra función en una promesa, y que luego para &quot;devolver&quot; los datos en lugar de hacer un return, que ya hemos visto que no funciona, se hace un resolve si todo ha ido bien o un reject si ha fallado.\nDesde donde llamamos a la promesa nos suscribimos a ella usando los métodos .then() y .catch() que hemos visto anteriormente.\nBásicamente lo que nos van a proporcionar las promesas es un código más claro y mantenible ya que el código a ejecutar cuando se obtengan los datos asíncronamente estará donde se piden esos datos y no en una función escuchadora o en una función callback.\nUtilizando promesas vamos a conseguir que la función que pide los datos sea quien los obtiene y los trate o quien informa si hay un error.\nEl código del ejemplo de los posts usando promesas sería el siguiente:\n\nNOTA: Fijaos que los errores del servidor SIEMPRE llegan a la consola. En el ejemplo anterior me aparecerán 2 veces: la primera que es el error original y la segunda donde lo pinto yo con el console.error.\nPodéis consultar aprender más en MDN web docs.\nLa mejor solución: usar Async/Await\nLas promesas son una mejora respecto a los callbacks pero aún así el código puede ser difícil de leer y mantener. Para solucionar esto se introdujeron en ES2017 las palabras reservadas async y await que permiten escribir código asíncrono de una manera más clara y sencilla.\nLa palabra reservada async se pone delante de una función e indica que esa función va a devolver una promesa. La palabra reservada await se pone delante de una llamada a una promesa y le indica a Javascript que espere a que esa promesa se resuelva antes de continuar con la ejecución del código.\nUsando esto sí funcionaría el primer ejemplo que hicimos:\nlet idUser = document.getElementById('id-usuario').value;\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número');\n} else {\nconst posts = await getPosts(idUser);\n// y aquí SÍ recibimos los datos porque ponemos AWAIT, en este caso para pintar los posts\n}\n\nY la función getPosts() quedaría igual que la que hicimos con promesas.\nAquí el tratamiento de errores se hace con un try/catch:\ntry {\nconst posts = await getPosts(idUser);\n} catch (error) {\nconsole.error(error);\n}\n\nUsando async/await nuestro código se asemeja a un código síncrono ya que no continuan ejecutándose las instrucciones que hay después de un await hasta que esa petición se ha resuelto. Podemos anteponer un await a cualquier llamada a una función asíncrona, como una promesa, un setTimeout, ...\nCualquier función que realice un await pasa a ser asíncrona ya que no se ejecuta al instante toda ella sino que se espera un tiempo. Para indicarlo debemos anteponer la palabra async a su declaración function. Al hacer esto automáticamente se &quot;envuelve&quot; esa función en una promesa (o sea que esa función pasa a devolver una promesa, a la que podríamos ponerle un await o un .then()).\nPodéis ver algunos ejemplos del uso de async / await en la página de MDN.\nfetch\nComo el código a escribir para hacer una petición Ajax es largo y siempre igual, la API Fetch permite realizar una petición Ajax genérica que directamente devuelve una promesa.\nBásicamente lo que hace es encapsular en una función todo el código que se repite siempre en una petición AJAX (crear la petición, hacer el open, el send, escuchar los eventos, ...). La función fetch se similar a la función getPosts que hemos creado antes pero genérica para que sirva para cualquier petición pasándole la URL. Lo que internamente hace es algo similar a:\nfunction fetch(url) {\nreturn new Promise((resolve, reject) =&gt; {\nconst peticion = new XMLHttpRequest();\npeticion.open('GET', url);\npeticion.send();\npeticion.addEventListener('load', () =&gt; {\nresolve(peticion.responseText);\n})\npeticion.addEventListener('error', () =&gt; reject('Network Error'));\n})\n}\n\nFijaos en 2 cosas que cambian respecto a nuestra función getPosts():\n\nfetch devuelve los datos &quot;en crudo&quot; por lo que si la respuesta está en formato JSON habrá con convertirlos. Para ello dispone de un método (.json()) que hace el JSON.parse. Este método devuelve una nueva promesa a la que nos suscribimos con un nuevo .then. Ejemplo.:\n\nfetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser)\n.then(response =&gt; response.json()) // los datos son una cadena JSON\n.then(myData =&gt; { // ya tenemos los datos en _myData_ como un objeto o array\n// Aquí procesamos los datos (en nuestro ejemplo los pintaríamos en la tabla)\nconsole.log(myData)\n})\n.catch(err =&gt; console.error(err));\n\nEse mismo ejemplo usando async/await sería:\ntry {\nconst response = await fetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser);\nconst myData = await response.json();\nconsole.log(myData);\n} catch (err) {\nconsole.error(err);\n}\n\nfetch llama a resolve siempre que el servidor conteste, sin comprobar si la respuesta es de éxito (200, 201, ...) o de error (4xx, 5xx). Por tanto siempre se ejecutará el then excepto si se trata de un error de red y el servidor no responde\n\nPropiedades y métodos de la respuesta de fetch\nLa respuesta devuelta por fetch() tiene las siguientes propiedades y métodos:\n\nstatus: el código de estado devuelto por el servidor (200, 404, ...)\nstatusText: el texto correspondiente a ese código (Ok, Not found, ...)\nok: booleano que vale true si el status está entre 200 y 299 y false en caso contrario\njson(): devuelve una promesa que se resolverá con los datos de la respuesta convertidos a un objeto (les hace un JSON.parse())\notros métodos para convertir los datos según el formato que tengan: text(), blob(), formData(), ... Todos devuelven una promesa con los datos de distintos formatos convertidos.\n\nEl ejemplo que hemos visto con las promesas, usando fetch quedaría:\n\nEste ejemplo fallaría si hubiéramos puesto mal la url: contestaría con un 404 pero se ejecutaría el then intentando pintar unos posts que no tenemos.\nEl ejemplo con async/await y fetch sería:\n\nGestión de errores con fetch\nSegún MDN la promesa devuelta por la API fetch sólo es rechazada en el caso de un error de red, es decir, el .catch sólo saltará si no hemos recibido respuesta del servidor; en caso contrario la promesa siempre es resuelta.\nPor tanto para saber si se ha resuelto satisfactoriamente o no debemos comprobar la propiedad .ok de la respuesta. El código correcto del ejemplo anterior gestionando los posibles errores del servidor sería:\ntry {\nconst response = await fetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser);\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst myData = await response.json();\nconsole.log(myData);\n} catch (err) {\nconsole.error(err);\n}\n\nEn este caso si la respuesta del servidor no es ok lanzamos un error que es interceptado por nuestro propio catch\nOtros métodos de petición con fetch\nLos ejemplos anteriores hacen peticiones GET al servidor. Para peticiones que no sean GET la función fetch() admite un segundo parámetro con un objeto con la información a enviar en la petición HTTP. Ej.:\nfetch(url, {\nmethod: 'POST', // o 'PUT', 'GET', 'DELETE'\nbody: JSON.stringify(data), // los datos que enviamos al servidor en el 'send'\nheaders:{\n'Content-Type': 'application/json'\n}\n}).then(...)\n\nEjemplo de una petición para añadir datos:\nfetch(url, {\nmethod: 'POST',\nbody: JSON.stringify(data), // los datos que enviamos al servidor en el 'send'\nheaders:{\n'Content-Type': 'application/json'\n}\n})\n.then(response =&gt; {\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nreturn response.json()\n})\n.then(datos =&gt; {\nalert('Datos recibidos')\nconsole.log(datos)\n})\n.catch(err =&gt; {\nalert('Error en la petición HTTP: ' + err.message);\n})\n\nPodéis ver mś ejemplos en MDN web docs y otras páginas.\nHacer varias peticiones simultáneamente. Promise.all\nEn ocasiones necesitamos hacer más de una petición al servidor. Por ejemplo para obtener los productos y sus categorías podríamos hacer:\nfunction getData() {\ngetTable('/categories')\n.then((categories) =&gt; categories.forEach((category) =&gt; renderCategory(category)))\n.catch((error) =&gt; renderErrorMessage(error))\ngetTable('/products')\n.then((products) =&gt; products.forEach((product) =&gt; renderProduct(product)))\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\nfunction getTable(table) {\nreturn new Promise((resolve, reject) =&gt; {\nfetch(SERVER + table)\n.then(response =&gt; {\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nreturn response.json()\n})\n.then((data) =&gt; resolve(data))\n.catch((error) =&gt; reject(error))\n})\n}\n\nPero si para renderizar los productos necesitamos tener las categorías este código no nos lo garantiza ya que el servidor podría devolver antes los productos aunque los pedimos después.\nUna solución sería no pedir los productos hasta tener las categorías:\nfunction getData() {\ngetTable('/categories')\n.then((categories) =&gt; {\ncategories.forEach((category) =&gt; renderCategory(category))\ngetTable('/products')\n.then((products) =&gt; products.forEach((product) =&gt; renderProduct(product)))\n.catch((error) =&gt; renderErrorMessage(error))\n})\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\npero esto hará más lento nuestro código al no hacer las 2 peticiones simultáneamente. La solución es usar el método Promise.all() al que se le pasa un array de promesas a hacer y devuelve una promesa que:\n\nse resuelve en el momento en que todas las promesas se han resuelto satisfactoriamente o\nse rechaza en el momento en que alguna de las promesas es rechazada\n\nEl código anterior de forma correcta sería:\nfunction getData() {\nPromise.all([\ngetTable('/categories')\ngetTable('/products')\n])\n.then(([categories, products]) =&gt; {\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n})\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\nLo mismo pasa si en vez de promesas usamos async/await. Si hacemos:\nasync function getTable(table) {\nconst response = await fetch(SERVER + table)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync function getData() {\nconst responseCategories = await getTable('/categories');\nconst responseProducts = await getTable('/products');\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n}\n\ntenemos el problema de que no comienza la petición de los productos hasta que se reciben las categorías. La solución con Promise.all() sería:\nasync function getData() {\nconst [categories, products] = await Promise.all([\ngetTable('/categories')\ngetTable('/products')\n])\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n}\n\nOrganizar bien el código\nEl fichero .env\nEn los ejemplos anteriores estamos guardando la URL a la que hacer la petición a la API en una constante a la que estamos llamando SERVER. Esto plantea algunos problemas:\n\nsi tenemos varios ficheros que hacen peticiones a la API deberemos declararla en todos ellos\nsi cambia hay que cambiarla en todos los ficheros y en ese caso tenemos que cambiar nuestro código\n\nPara evitarlo podemos almacenar ete tipo de cosas en el fichero .env. Se trata de un fichero donde guardar las configuraciones de la aplicación, como la URL de la API.\nPor medio de Vite podemos acceder a todas las variables de .env que comiencen por VITE_ por medio del objeto import.meta.env por lo que en nuestro código en vez de darle el valor a SERVER podríamos haber puesto:\nconst SERVER = import.meta.env.VITE_URL_API\n\nY en el fichero .env ponemos\nVITE_URL_API=http://localhost:3000\n\nEl fichero .env por defecto se sube al repositorio por lo que no debemos poner información sensible (como usuarios o contraseñas). Para ello tenemos un fichero .env.local que no se sube, o bien debemos añadir al .gitignore dicho fichero. Si el fichero con la configuración no lo subimos al repositorio es conveniente tener un fichero .env.exemple, que sí se sube, con valores predeterminados para las distintas variables, que quien quiera desplegar nuestra aplicación deberá cambiar por sus valores adecuados en producción. Además del .env y el .env.local también hay distintos ficheros que son usados en desarrollo (.env.development) y en producción (.env.production) y que pueden tener distintos datos según el entorno en que nos encontramos. Por ejemplo en el de desarrollo el valor de VITE_URL_API podría ser &quot;http://localhost:3000&quot; si usamos json-server mientras que en el de producción tendríamos la ruta del servidor de producción de la API.\nDistintas peticiones, distintos ficheros\nLas peticiones a la API deberíamos ponerlas en un fichero aparte para tener nuestro código organizado. Y peticiones a diferentes tipos de datos también deberían estar en ficheros diferentes. Por ejemplo si necesitamos obtener datos de posts y de usuarios podríamos crear una carpeta /repositories y dentro los ficheros posts.repository.js y users.repository.js.\nDentro de cada fichero haremos diferentes funciones y métodos para los diferentes tipos de petición, por ejemplo:\nconst SERVER = import.meta.env.VITE_URL_API\n\nasync getAllPosts() {\nconst response = await fetch(SERVER + '/posts')\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync getPostById(idPost) {\nconst response = await fetch(SERVER + `/posts/${idPost}`)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync insertPost(newPost) {\nconst response = await fetch(SERVER + '/posts', {\nmethod: 'POST',\nbody: JSON.stringify(newPost),\nheaders:{\n'Content-Type': 'application/json'\n}\n})\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nexport {\ngetAllPosts,\ngetPostById,\ninsertPost\n}\n\nY donde necesitemos los datos haremos:\nimport { getAllPosts } from &quot;../repositories/posts.repositories&quot;\n\nconst posts = await getAllPosts()\n\nUsando clases el ejemplo quedaría:\nconst SERVER = import.meta.env.VITE_URL_API\n\nexport default class PostsRepository {\nasync getAllPosts() {\nconst response = await fetch(SERVER + '/posts')\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync getPostById(idPost) {\nconst response = await fetch(SERVER + `/posts/${idPost}`)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync insertPost(newPost) {\nconst response = await fetch(SERVER + '/posts', {\nmethod: 'POST',\nbody: JSON.stringify(newPost),\nheaders:{\n'Content-Type': 'application/json'\n}\n})\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n}\n\nY donde necesitemos los datos haremos:\nimport PostsRepository from &quot;../repositories/posts.repositories&quot;\n\nconst repository = new PostsRepository()\nconst posts = await repository.getAllPosts()\n\nSingle Page Application\nAjax es la base para construir SPAs que permiten al usuario interactuar con una aplicación web como si se tratara de una aplicación de escritorio (sin &quot;esperas&quot; que dejen la página en blanco o no funcional mientras se recarga desde el servidor).\nEn una SPA sólo se carga la página de inicio (es la única página que existe) que se va modificando y cambiando sus datos como respuesta a la interacción del usuario. Para obtener los nuevos datos se realizan peticiones al servidor (normalmente Ajax). La respuesta son datos (JSON, XML, …) que se muestran al usuario modificando mediante DOM la página mostrada (o podrían ser trozos de HTML que se cargan en determinadas partes de la página, o ...).\nResumen de llamadas asíncronas\nUna llamada Ajax es un tipo de llamada asíncrona que podemos hacer en Javascript aunque hay muchas más, como un setTimeout() o las funciones manejadoras de eventos. Como hemos visto, para la gestión de las llamadas asíncronas tenemos varios métodos y los más comunes son:\n\nfunciones callback (no recomendado)\npromesas\nasync / await\nlibrerías, como axios\n\nCuando se produce una llamada asíncrona el orden de ejecución del código no es el que vemos en el programa ya que el código de respuesta de la llamada no se ejecutará hasta completarse esta. Podemos ver un ejemplo de esto extraído de todoJS usando funciones callback.\nAdemás, si hacemos varias llamadas tampoco sabemos el qué orden se ejecutarán sus respuestas ya que depende de cuándo el servidor finalice cada una, como podemos ver en este otro ejemplo.\nSi usamos funciones callback y necesitamos que cada función no se ejecute hasta que haya terminado la anterior debemos llamarla en la respuesta a la función anterior lo que provoca un tipo de código difícil de leer llamado callback hell.\nPara evitar esto surgieron las promesas que permiten evitar las funciones callback tan difíciles de leer. Podemos ver el primer ejemplo usando promesas. Y si necesitamos ejecutar secuencialmente las funciones evitaremos la pirámide de llamadas callback como vemos en este ejemplo.\nAún así el código no es muy claro. Para mejorarlo surgió async y await como vemos en este ejemplo. Estas funciones forman parte del estándar ES2017 por lo que no están soportadas por navegadores muy antiguos (aunque siempre podemos transpilar con Babel).\nFuente: todoJs: Controlar la ejecución asíncrona\nCORS\nCross-Origin Resource Sharing (CORS) es un mecanismo de seguridad que incluyen los navegadores y que por defecto impiden que se pueden realizar peticiones Ajax desde un navegador a un servidor con un dominio diferente al de la página cargada originalmente.\nSi necesitamos hacer este tipo de peticiones necesitamos que el servidor al que hacemos la petición añada en su respuesta la cabecera Access-Control-Allow-Origin donde indiquemos el dominio desde el que se pueden hacer peticiones (o * para permitirlas desde cualquier dominio).\nEl navegador comprobará las cabeceras de respuesta y si el dominio indicado por ella coincide con el dominio desde el que se hizo la petición, esta se permitirá.\nComo en desarrollo normalmente no estamos en el dominio de producción (para el que se permitirán las peticiones) podemos instalar en el navegador la extensión allow CORS que al activarla deshabilita la seguridad CORS en el navegador.\nPodéis ampliar la información en numerosaas páginas web como &quot;Entendiendo CORS y aplicando soluciones&quot;.",
		"tags": [ "note"]
},

{
		"title": "10-apis",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/10-apis/",
		"content": "APIs HTML5: Drag And Drop. Local Storage. Geolocalización. API de Google Maps\n\nAPIs HTML5: Drag And Drop. Local Storage. Geolocalización. API de Google Maps\n\nIntroducción\nHTML Drag And Drop API\nAlmacenamiento en el cliente: API Storage\n\nA tener en cuenta\nStorage vs cookies\nCookies\n\nGeolocation API\nGoogle Maps API\n\nIntroducción\nEn este tema varemos diferentes APIs incluidas en HTML5 (como la de Local Storage) y otras que se han hecho muy populares como la de Google Maps.\nHTML5 incluye un buen número de APIs que facilitan el trabajo con cosas complejas, como\n\nAPIs para manejo de audio y vídeo\nAPIs para manejo de formularios\nAPI de dibujo canvas (en el módulo de DIW)\n\nAquí comentaremos Storage, Drag&amp;Drop, Geolocation, File Access, Communication, Web Workers, History y Offline\nHTML Drag And Drop API\nCon HTML5 es muy sencillo arrastrar y soltar elementos en una página web. Podemos arrastrar y soltar cualquier nodo DOM (una imagen, un archivo, enlaces, texto seleccionado, ...). Para ello sólo es necesario que ese elemento tenga el atributo dragable=&quot;true&quot;. Si le ponemos false no se podrá arrastrar y si no definimos el atributo podrá o no arrastrarse según el valor predeterminado del navegador (en la mayoría son dragables las imágenes, los links y las selecciones de texto).\nAl arrastrar y soltar intervienen 2 elementos diferentes:\n\nel elemento que estamos arrastrando\nel elemento sobre el cual lo soltamos\n\nPara poder realizar la operación event tiene una propiedad llamada dataTransfer que es un objeto en el que almacenamos qué elemento estamos arrastrando (o cualquier otra cosa que queramos) y así cuando se suelte sobre el elemento destino éste último pueda saber quién se le ha soltado.\nLos pasos para arrastrar y soltar un elemento son:\n\nEl elemento debe ser draggable\nCapturamos el evento dragstart. Este evento se produce sobre un elemento cuando comenzamos a arrastrarlo. Deberemos almacenar en el dataTransfer quién está siendo arrastrado (si no guardamos nada se guarda automáticamente su src si es una imagen o su href si es un enlace). Indicaremos el tipo del dato que estamos almacenando (texto plano, HTML, fichero, etc) y su valor. Ej.:\n\n&lt;img id=&quot;imgGoogle&quot; src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Google.png/320px-Google.png&quot;&gt;\n&lt;div id=&quot;zonaDrop1&quot; class=&quot;drop&quot;&gt;\n&lt;p&gt;Puedes soltar aquí la imagen&lt;/p&gt;\n&lt;/div&gt;\n&lt;div id=&quot;zonaDrop2&quot; class=&quot;drop&quot;&gt;\n&lt;p&gt;Y también aquí&lt;/p&gt;\n&lt;/div&gt;\n\ndocument.getElementById('imgGoogle').addEventListener('dragstart', (event) =&gt; {\nevent.dataTransfer.setData('text/plain', event.target.id); // Estamos guardando el texto 'imgGoogle'\n})\n\nCapturamos el evento dragover. Este evento se produce cada pocas décimas de segundo sobre elemento sobre el que se está arrastrando algo. Por defecto no se puede soltar un elemento en ningún sitio así que capturamos este evento para evitar que el navegador haga la acción por defecto e impida que se suelte lo que estamos arrastrando. Ej.:\n\ndocument.getElementById('zonaDrop1').addEventListener('dragover', (event) =&gt; {\nevent.preventDefault();\n})\ndocument.getElementById('zonaDrop2').addEventListener('dragover', (event) =&gt; {\nevent.preventDefault();\n})\n\nCapturamos el evento drop. Este evento se produce sobre elemento sobre el que se suelta lo que estábamos arrastrando. Lo que haremos es evitar el comportamiento por defecto del navegador (que en caso de imágenes o enlaces es cargarlos en la página), obtener quién se ha soltado a partir del objeto dataTransfer y realizar lo que queramos, que normalmente será añadir el objeto arrastrado como hijo del objeto sobre el que se ha hecho el drop. Ej.:\n\ndocument.getElementById('zonaDrop1').addEventListener('drop', (event) =&gt; {\nevent.preventDefault();\nconst data=event.dataTransfer.getData(&quot;text/plain&quot;); // Obtenemos ìmgGoogle'\nevent.target.appendChild(document.getElementById(data));\n})\ndocument.getElementById('zonaDrop2').addEventListener('drop', (event) =&gt; {\nevent.preventDefault();\nconst data=event.dataTransfer.getData(&quot;text/plain&quot;); // Obtenemos ìmgGoogle'\nevent.target.appendChild(document.getElementById(data));\n})\n\nPodéis ver el funcionamiento de este ejemplo:\n\nNOTA: si hacemos draggable un elemento, por ejemplo un párrafo, ya no se puede seleccionar con el ratón ya que al pinchar y arrastrar se mueve, no se selecciona. Para poder seleccionarlo debemos pinchar y arrastrar el ratón con las teclas Ctrl+Alt pulsadas o hacerlo con el teclado. Ejemplo:\n\nPodemos obtener más información de esta API MDN web docs.\n\nEJERCICIO: mira y modifica el ejemplo de w3schools para entender bien el funcionamiento del Drag&amp;Drop (ten en cuenta que en vez de .addEventListener() las llamadas a los escuchadores están puestas como atributos del HTML pero el funcionamiento es el mismo).\n\nAlmacenamiento en el cliente: API Storage\nAntes de HTML5 la única manera que tenían los programadores de guardar algo en el navegador del cliente (como sus preferencias, su idioma predeterminado para nuestra web, etc) era utilizando cookies. Las cookies tienen muchas limitaciones y es engorroso trabajar con ellas.\nHTML5 incorpora la API de Storage para subsanar esto. Además existen otros métodos de almacenamiento en el cliente más avanzados como IndexedDB (es un estándar del W3C pero aún con poco soporte entre los navegadores).\nEl funcionamiento de la API Storage es muy sencillo: dentro del objeto window tendremos los objetos localStorage y sessionStorage donde podremos almacenar información en el espacio de almacenamiento local (5 o 10 MB por sitio web según el navegador, que es mucho más de lo que teníamos con las cookies). La principal diferencia entre ellos es que la información almacenada en localStorage nunca expira, permanece allí hasta que la borremos (nosotros o el usuario) mientras que la almacenada en sessionStorage se elimina automáticamente al cerrar la sesión el usuario.\nSólo los navegadores muy antiguos (Internet Explorer 7 y anteriores) no soportan esta característica. Puedo saber si el navegador soporta o no esta API simplemente mirando su typeof:\nif (typeof(Storage) === 'undefined') // NO está soportado\n\nTanto localStorage como sessionStorage son como un objeto global al que tengo acceso desde el código. Lo que puedo hacer con ellos es:\n\nGuardar un dato: localStorage.setItem('dato', 'valor') o también localStorage.dato = 'valor'\nRecuperar un dato: let miDato=localStorage.getItem('dato') o también let miDato = localStorage.dato\nBorrar datos: localStorage.removeItem('dato') para borrar 'dato'. Si quiero borrar TODO lo que tengo localStorage.clear()\nSaber cuántos datos tenemos: localStorage.length\n\nSólo podemos guardar objetos primitivos (cadenas, números, ...) por lo que si queremos guardar un objeto o un array hay que convertirlo a una cadena JSON con localStorage.setItem('dato', JSON.stringify('objeto')). Para recuperar el objeto haremos let miObjeto = JSON.parse(localStorage.getItem('dato')).\nCada vez que cambia la información que tenemos en nuestro localStorage se produce un evento storage. Si, por ejemplo, queremos que una ventana actualice su información si otra cambia algún dato del storage haremos:\nwindow.addEventListener(&quot;storage&quot;, actualizaDatos);\n\ny la función 'actualizaDatos' podrá leer de nuevo lo que hay y actuar en consecuencia.\n\nEJERCICIO: comprueba qué tienes almacenado en el localStorage y el sessionStorage de tu navegador. Guarda y recupera algunas variables. Luego cierra el navegador y vuelve a abrir la página. ¿Están las variables guardadas en localStorage? ¿Y las de sessionStorage?\n\nPuedes ver un ejemplo en este vídeo de cómo almacenar en el Storage datos del usuario.\nA tener en cuenta\nlocalStorage, sessionStorage y cookies almacenan información en un navegador específico del cliente, y por tanto:\n\nNo podemos asegurar que permanece ahí\nPuede ser borrada/manipulada\nPuede ser leída, por lo que NO es adecuada para almacenar información sensible pero sí para preferencias del usuario, marcadores de juegos, etc\n\nPodríamos usar localStorage para almacenar localmente los datos con los que trabaja una aplicación web. Así conseguiríamos minimizan los accesos al servidor y que la velocidad de la aplicación sea mucho mayor al trabajar con datos locales. Pero periódicamente debemos sincronizar la información con el servidor.\nStorage vs cookies\nVentajas de localStorage:\n\n5 o 10 MB de almacenamiento frente a 4 KB de las cookies\nTodas las cookies del dominio se envían al servidor con cada petición al mismo lo que aumenta el tráfico innecesariamente\n\nVentajas de las cookies:\n\nSoportadas por navegadores muy antiguos\nLas cookies ofrecen algo de protección frente a XSS (Cross-Site Scripting) y Script injection\n\nCookies\nSon pequeños ficheros de texto y tienen las siguientes limitaciones:\n\nMáximo 300 cookies, si hay más se borran las antiguas\nMáximo 4 KB por cookie, si nos pasamos se truncará\nMáximo 20 cookies por dominio\n\nCada cookie almacena los siguientes datos:\n\nNombre de la cookie (obligatorio)\nValor de la misma\nexpires: timestamp en que se borrará (si no pone nada se borra al salir del dominio)\nmax-age: en lugar de expires podemos indicar aquí los segundos que durará la cookie antes de expirar\npath: ruta desde dónde es accesible (/: todo el dominio, /xxx: esa carpeta y subcarpetas). Si no se pone nada sólo lo será desde la carpeta actual\ndomain: dominio desde el que es accesible. Si no ponemos nada lo será desde este dominio y sus subdominios\nsecure: si aparece indica que sólo se enviará esta cookie con https\n\nUn ejemplo de cookie sería:\nusername=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC;\n\nSe puede acceder a las cookies desde document.cookie que es una cadena con las cookies de nuestras páginas. Para trabajar con ellas conviene que creemos funciones para guardar, leer o borrar cookies, por ejemplo:\n\nCrear una nueva cookie\n\nfunction setCookie(cname, cvalue, cexpires, cpath, cdomain, csecure) {\ndocument.cookie = cname + '=' + cvalue +\n(cexpires?';expires='+cexpires.toUTCString():'') +\n(cpath?';path='+cpath:'') +\n(cdomain?';domain='+cdomain:'') +\n(csecure?';secure':'')\n}\n\nLeer una cookie\n\nfunction getCookie(cname) {\nif(document.cookie.length &gt; 0){\nstart = document.cookie.indexOf(cname + '=')\nif (start != -1) { // Existe la cookie, busquemos dónde acaba su valor\n//El inicio de la cookie, el nombre de la cookie mas les simbolo '='\nstart = start + nombre.length + 1\n//Buscamos el final de la cookie (es el simbolo ';')\nend = document.cookie.indexOf(';', start + cname.length + 1)\nif (end === -1) { // si no encuentra el ; es que es la última cookie\nend = document.cookie.length;\n}\nreturn document.cookie.substring(start + cname.length + 1, end)\n}\n}\nreturn '' // Si estamos aquí es que no hemos encontrado la cookie\n}\n\nBorrar una cookie\n\nfunction delCookie(cname) {\nreturn document.cookie = cname + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;'\n}\n\nPodéis ver en este vídeo un ejemplo de cómo trabajar con cookies, aunque como ya hemos dicho lo recomendable es trabajar con Storage.\nGeolocation API\nEsta API permite a la aplicación web acceder a la localización del usuario si éste da su permiso. Muchos navegadores sólo permiten usarlo en páginas seguras (https).\nPodemos acceder a esta API mediante el objeto geolocation de navigator. Para saber si nuestro navegador soporta o no la API podemos hacer:\nif (geolocation in navigator) // devuelve true si está soportado\n\nPara obtener la posición este objeto proporciona el método navigator.geolocation.getCurrentPosition() que hace una petición asíncrona. Cuando se reciba la posición se ejecutará la función callback que pasemos como parámetro y que recibirá las coordenadas de la localización. Podemos pasar otra como segundo parámetro que se ejecutará si se produce algú error y que recibirá un objeto con la propiedad code que indica el error producido. Ej.:\nnavigator.geolocation.getCurrentPosition(\n(position) =&gt; {\npinta_posicion(position.coords.latitude, position.coords.longitude)\n},\n(error) =&gt; {\nswitch(error.code) {\ncase error.PERMISSION_DENIED: // El usuario no autoriza al navegador a acceder a la localización\nmsg = 'El usuario ha denegado la petición de geolocalización'\nbreak\ncase error.POSITION_UNAVAILABLE: // No se puede obtener la localización\nmsg = 'La información de localización no está disponible.'\nbreak\ncase error.TIMEOUT: // Ha expirado el tiempo para obtener la localización\nmsg = 'Ha expirado el tiempo para obtener la localización'\nbreak\ncase error.UNKNOWN_ERROR:\nmsg = 'Se ha producido un error desconocido.'\nbreak\n}\nmuestra_error(msg)\n}\n)\n\nSi queremos ir obteniendo continuamente la posición podemos usar el método .watchPosition() que tiene los mismos parámetros y funciona igual pero se ejecuta repetidamente. Este método devuelve un identificador para que lo podemos detener cuando queremos con .clearWatch(ident). Ej.:\nconst watchIdent = navigator.geolocation.watchPosition(\n(position) =&gt; pinta_posicion(position.coords.latitude, position.coords.longitude),\n(error) =&gt; muestra_error(error)\n)\n...\n// Cuando queremos dejar de obtener la posición haremos\nnavigator.geolocation.clearWatch(watchIdent)\n\nLas principales propiedades del objeto de localización (algunas sólo estarán disponible cuando usemos un GPS) son:\n\ncoords.latitude: latitud\ncoords.longitude: longitud\ncoords.accuracy: precisión (en metros)\ncoords.altitude: altitud (en metros, sobre el nivel del mar)\ncoords.altitudeAccuracy: precisión de la altitud\ncoords.heading: orientación (en grados)\ncoords.speed: velocidad (en metros/segundo)\ntimestamp: tiempo de respuesta UNIX\n\nPodemos pasarle como tercer parámetro al método getCurrentPosition un objeto JSON con una o más de estas propiedades:\n\nenableHighAccuracy: true/false que indica si el dispositivo debe usar todo lo posible para obtener la posición con mayor precisión (por defecto false porque consume más batería y tiempo)\ntimeout: milisegundos a esperar para obtener la posición antes de lanzar un error (por defecto es 0, espera indefinidamente)\nmaximumAge: milisegundos que guarda la última posición en caché. Si se solicita una nueva posición antes de expirar el\ntiempo, el navegador devuelve directamente el dato almacenado\n\nPodemos obtener más información de esta API en MDN web docs y ver y modificar ejemplos en w3schools y muchas otras páginas. i\nGoogle Maps API\nPara poder utilizar la API en primer lugar debemos obtener una API KEY de Google.\nUna vez hecho para incluir un mapa en nuestra web debemos cargar la librería para lo que incluiremos en nuestro código el script:\n&lt;script async defer\nsrc=&quot;https://maps.googleapis.com/maps/api/js?key=ESCRIBE_AQUI_TU_API_KEY&amp;callback=initMap&quot;&gt;\n&lt;/script&gt;\n\n(el parámetro callback será el encargado de llamar a la función initMap() que inicie el mapa)\nAhora incluir un mapa es tán sencillo como crear un nuevo objeto de tipo Map que recibe el elemento DOM donde se pintará (un div normalmente) y un objeto con los parámetros del mapa (como mínimo su centro y el zoom):\nlet map\nfunction initMap() {\nmap = new google.maps.Map(document.getElementById('map'), {\ncenter: { lat: 38.6909085, lng: -0.4963000000000193 },\nzoom: 12\n})\n}\n\nPor su parte añadir un marcador es igual de simple. Creamos una instancia de la clase Marker a la que le pasamos al menos la posición, el mapa en que se creará y un título para el marcador:\nlet marker = new google.maps.Marker({\nposition: { lat: 38.6909085, lng: -0.4963000000000193 },\nmap: map,\ntitle: 'CIP FP Batoi'\n})\n\nAquí tenéis el ejemplo anterior:\n\nPodemos obtener más información de esta API en Google Maps Plataform, en el tutorial de w3schools y en muchas otras páginas.",
		"tags": [ "note"]
},

{
		"title": "11-mas",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/11-mas/",
		"content": "Más cosas a aprender en Javascript\n\nMás cosas a aprender en Javascript\n\nIntroducción\nWebComponents\nWebSockets\nWebWorkers\nTypescript\njQuery\n\nIntroducción\nHace unos años Javscript era considerado un lenguaje de programación de segunda categoría, que se usaba para hacer molestas páginas web. Hoy en día el navegador es la aplicación más importante de un equipo y con él, además de navegar, se ejecutan todo tipo de aplicaciones. Además HTML5 y JavaScript han pasado de estar solo en nuestro navegador a ser un pilar básico de las plataformas móviles, de aplicaciones de escritorio e incluso JavaScript lo encontramos en servidores (con Node.js) o como lenguaje estándar de algunos entornos de escritorio (como GNOME para Linux).\nPor ello HTML5 y Javascript siguen su contínuo crecimiento... y su contínua evolución que les permite hacer cada vez más cosas. En esta página vamos a hablar muy brevemente de algunas de las características que están incorporando.\nWebComponents\nSon distintas tecnologías que podemos usar (todas o alguna de ellas) para crear componentes reutilizables para nuestras páginas HTML. Las tecnologías que hay tras los Web Components son:\n\nCustom Elements: permite crear elementos HTML personalizados, es decir, nuevas etiquetas definidas por nosotros con funcionalidad propia. Por ejemplo\n\n&lt;comp-calendar\nmode=&quot;month&quot;\ndate=&quot;2020-02-23&quot;\non-select=&quot;dateSelected()&quot; &gt;\n&lt;/comp-calendar&gt;\n\nHTML Templates: la etiqueta &lt;template&gt; permite definir fragmentos de código HTML que no serán renderizados y que usaremos más adelante. Pueden incluir slots o huecos a los que se pasa un contenido\nShadow DOM: permite asociar un DOM oculto a un elemento. Esto permite que tenga su propio código JS y estilos CSS aislados del resto del DOM\nES Modules: Es el estándar de ECMAScript para importar módulos Javascript.\n\nUn WebComponent es un elemento que creamos y que tiene su propia representación (HTML) y funcionalidad (establecida con Javascript). Este elemento es reusable y compartible y se contruye sin librerías externas, sólo con HTML5, ES6 y CSS3.\nAlgunos ejemplos de componentes útiles que podríamos usar son:\n\ncomponente para loguearnos mediante Google, Facebook, etc\ncomponente que me muestre el tiempo en una ciudad\ncomponente para hacer un modal\n...\n\nHay infinidad de páginas donde podemos aprender más sobre WebComponents y cómo crear nuestro propio componente, como:\n\nWeb Components | MDN\nIntroduction - webcomponents.org\n¿Qué son los WebComponents? - Javascript en español\nCarlos Azaustre - Cómo crear un WebComponent de forma nativa\n...\n\nEn resumen debemos crear un fichero donde definimos la clase de nuestro componente que debe heredar de HTMLElement. Es conveniente que su nombre (y por tanto el de la etiqueta que usaremos para mostrarlo) tenga al menos 2 palabras para evitar que pueda entrar en conflicto con posibles futuras etiquetas de HTML (por ejemplo podría ser &lt;social-login&gt; o &lt;my-weather&gt;). En esta clase definiremos el HTML y el estilo que tendrá nuestro componente, así como su comportamiento.\nActualmente no todos los navegadores ofrecen soporte para WebComponents. Esto junto al hecho de que frameworks como Vue, Angular o React ofrecen soluciones con sus propios componentes han hecho que el uso de los WebComponents no acabe de despegar. A pesar de ello hay lugares como WebComponents.org donde podemos encontrar un catálogo de componentes hechos y que podemos usar en nuestras páginas.\nPor su parte Google ha desarrollado la librería Polymer para ayudarnos a crear nuestros propios componentes basados en WebComponents y los principales frameworks JS como Angular o Vue permiten crear sus propios componentes de forma muy sencilla, com veremos en el bloque de Vue.\nWebSockets\nWebSockets es una tecnología basada en el protocolo ws que permite establecer una conexión continua full-duplex entre un cliente (puede ser un navegador) y un servidor. La conexión siempre la abre el cliente pero una vez abierta no se cierra por lo que el servidor puede comunicar en cualquier momento con el cliente y enviarle información.\nEjemplo:\nlet exampleSocket=new WebSocket(uri);\nexampleWebsocjet.onopen=function(event) {\nconsole.log('Se ha establecido la conexión');\n}\nexampleSocket.onclose=function(event) {\nconsole.log('Se ha cerrado la conexión');\n}\nexampleSocket.onerror=function(event) {\nconsole.log('Se ha producido un error en la conexión');\n}\nexampleSocket.onmessage=function(event) {\nconsole.log('Se ha recibido el mensaje:' + event.data);\n}\n\nEl uri de la conexión deberá usar el protocolo ws (o wss), no http (ej. &quot;ws://miservidor.com/socketserver&quot;). El evento open se produce cuando la propiedad readyState cambia a OPEN y el close cuando cambia su valor a CLOSED. Cada vez que se reciba algo del servidor se produce el evento message y en la propiedad data del mismo tendremos lo que se nos ha enviado.\nPara enviar algo al servidor usamos el mátodo .send. Lo que le enviamos ex texto en formato utf-8 (o un objeto convertido a JSON):\nexampleSocket.send('Your message');\nexampleSocket.send(JSON.stringify(msg));\n\nTambién podemos enviar (y recibir) imágenes (convertidas a ArrayBuffer) o ficheros como un objeto Blob.\nPara cerrar la conexión llamamos al método .close():\nexampleSocket.close();\nconsole.log('Conexión cerrada');\n\nPara programar la parte del servidor podemos usar librerías que nos ayudan como PHP-WebSockets, SocketIO, ...\nLas aplicaciones de esta tecnología son muchas:\n\nJuegos multjugador\nAplicaciones de chat\nActualización en tiempo real de cotizaciones de bolsa, recursos en uso o cualquier otra información\n...\n\nPodemos practicar con www.websocket.org que tiene un servidor websocket que devuelve lo que le enviamos. En esta web también tenemos ejemplos de aplicaciones.\nSaber más:\n\nMDN: Escribiendo aplicaciones con WebSockets\nWebSocket - El Tutorial de JavaScript Moderno\nCarlos Azaustre: Crear chat con WebSockets\n\nWebWorkers\nEn principio Javascript se ejecuta en un único hilo de ejecución pero esta tecnología permite ejecutar scripts en segundo plano en hilos separados que se ejecutan en segundo plano y se comunican con la tarea que los crea mediante el envío de mensajes.\nCuando se está ejecutando un script la página no responde hasta que finaliza su ejecución. Si el script lo ejecuta un web worker la página será funcional (podemos interactuar con ella) ya que le ejecución del script se realiza en segundo plano en otro hilo.\nHay 3 tipos de WebWorkers:\n\nDedicated Workers: Estos son los más comunes y se ejecutan en un hilo dedicado al contexto del script que los creó. No comparten recursos con otros scripts y son útiles para tareas intensivas que requieren mucho procesamiento.\nShared Workers: Pueden ser compartidos por varios scripts ejecutándose en diferentes ventanas, pestañas o iframes dentro del mismo dominio. Son ideales para aplicaciones que necesitan coordinar tareas entre múltiples instancias de la misma aplicación web.\nService Workers: Actúan como servidores proxy que se ejecutan en segundo plano y gestionan eventos de red como las peticiones HTTP. Son esenciales para crear aplicaciones web progresivas (PWAs) que funcionen sin conexión y mejoren la velocidad de carga.\n\nPodéis ver un ejemplo de cómo crear un WebWorker para generar números primos en el Curso DWEC de Jose Castillo\nSaber más:\n\nCurso DWEC de Jose Castillo\nMDN - Usando WebWorkers\nw3schools - HTML5 Web Workers\n\nTypescript\nTypeScript es un lenguaje de programación libre y de código abierto desarrollado y mantenido por Microsoft. Es un superconjunto de JavaScript, que esencialmente añade tipado estático y objetos basados en clases. TypeScript extiende la sintaxis de JavaScript, por tanto cualquier código JavaScript existente debería funcionar sin problemas.\nPuede que la principal diferencia entre ambos es que Typescript obliga al tipado de las variables (y por supuesto no permite cambios de tipo) lo que evita muchos errores a la hora de programar.\nAlgunos frameworks y librerías, como Angular, utilizan TS en lugar de JS como lenguaje, que luego es transpilado a JS a la hora de generar la aplicación para producción.\nQuizá el inconveniente es que es algo más difícil que JS pero como está basado en él y la sintaxis es prácticamente igual el esfuerzo de aprender TS para un programador JS es muy pequeño.\nSaber más:\n\nWikipedia - Typescript\nTypescriptlang\n\njQuery\nSe trata de una biblioteca que nos facilita enormemente el trabajo con el DOM ya que tiene &quot;atajos&quot; para muchas instrucciones, por ejemplo para poner 'Hola mundo' como contenido de un elemento cuya id es mensaje:\n// Código con Javascript sólo\ndocument.getElementById('mensaje').textContent = 'Hola mundo'\n\n// Código con jQuery\n$('#mensaje').text('Hola mundo')\n\nOtra ventaja de jQuery es que permite trabajar con conjuntos de elementos sin tener que hacer un forEach (lo hace internamente). Por ejemplo para poner un escuchador que muestre un alert 'Párrafo pinchado' al hacer click sobre cualquier párrafo de la clase 'importante' tendríamos que hacer:\n// Código con Javascript sólo\nArray.from(document.querySelectorAll('p.importante'))\n.forEach(parrafo =&gt; parrafo.addEventListener('click', () =&gt; alert('Párrafo pinchado'))\n\n// Código con jQuery\n$('p.importante').click(() =&gt; alert('Párrafo pinchado'))\n\nComo vemos, básicamente nos permite hacer lo mismo pero escribiendo mucho menos código. También incluye funciones para cosas que en Javascript requieren varias líneas de código como animaciones o Ajax. Por ejemplo una pertición para mostrar en una tabla con id posts todos los posts del servidor jsonplaceholder tendremos que hacer:\n// Código con Javascript sólo\nconst SERVER = 'https://jsonplaceholder.typicode.com';\n\nfunction getPosts() { // Función que pide los datos al servidor\nreturn new Promise(function(resolve, reject) {\nlet peticion = new XMLHttpRequest();\npeticion.open('GET', SERVER + '/posts');\npeticion.send();\npeticion.addEventListener('load', function() {\nif (peticion.status === 200) {\nresolve(JSON.parse(peticion.responseText));\n} else {\nreject(&quot;Error &quot; + this.status + &quot; (&quot; + this.statusText + &quot;) en la petición&quot;);\n}\n})\npeticion.addEventListener('error', () =&gt; reject('Error en la petición HTTP'));\n})\n}\n\nfunction renderPosts() { // Función que los muestra en la página\ngetPosts(idUser)\n.then((posts) =&gt; {\ndocument.querySelector('#posts tbody').innerHTML = ''; // borramos su contenido\nposts.forEach((post) =&gt; {\nconst newPost = document.createElement('tr');\nnewPost.innerHTML = `\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;`;\ndocument.querySelector('#posts tbody').appendChild(newPost);\n})\n})\n.catch((error) =&gt; console.error(error))\n}\n\nUsando jQuery es mucho más sencillo. En primer lugar no hay que hacer la función que hace la petición al servidor porque hay uns función que hace eso: $.ajax y sus derivadas $.get, $.post, ... Además la parte de pintar los datos es también mucho más corta:\n// Código con jquery\nconst SERVER = 'https://jsonplaceholder.typicode.com';\n\nfunction renderPosts() { // Función que los muestra en la página\n$.get(SERVER + '/posts')\n.done((posts) =&gt; {\n$('#posts tbody').text(''); // borramos el contenido de la tabla\nposts.forEach(post =&gt; $('#posts tbody').append(\n`&lt;tr&gt;\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;\n&lt;/tr&gt;`\n))\n})\n.fail((error) =&gt; console.error(error))\n}\n\nEncontraréis infinidad de tutoriales por Internet donde aprender jQuery, por ejemplo unos vídeos de Didacticode que podéis encontrar en https://didacticode.com/curso/curso-de-jquery/ (tenéis que registraros para tener acceso a muchos cursos de Javascript y &quot;derivados&quot; pero vale la pena) o directamente en su canal de Youtube.",
		"tags": [ "note"]
},

{
		"title": "12-tests",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/12-tests/",
		"content": "Testing\nTabla de contenidos\n\nTesting\n\nIntroducción al testing\n\nTesting en Javascript\n\nInstalar npm\nInstalar jest\nTranspilar nuestro código\n\nUsando Babel con Jest\n\nUsando Webpack\n\nInstalar webpack\nEjecutar webpack\nEnlazar el fichero generado en el HTML\n\nTestear la UI\n\nUsar jest\n\nMatchers\nTest suites\nMocks\nTestear promesas\nHooks de Jest\n\nDesarrollo guiado por pruebas (TDD)\n\nIntroducción al testing\nEs fundamental que nuestro código tenga un cierto nivel de calidad para minimizar los fallos del programa, más cuanto más compleja es la aplicación que estamos desarrollando. Para ello debemos testearlo y dicho testeo seguramente incluirá test automáticos. Dichos test nos permiten:\n\ncomprobar que nuestro código responde como se espera de él\nevitar los errores de regresión (fallos tras incluir una nueva funcionalidad en cosas que antes funcionaban en nuestro programa)\nincluso mejoran la documentación del proyecto ya que el test indica cómo debe funcionar mi código\n\nComo ya sabéis existen varios tipos de tests:\n\nunitarios: prueban un trozo de código que sólo hace una cosa (habitualmente una función)\nde integración: prueban que varias partes del código funcionan bien juntas\nde aceptación: prueba que el código permite hacer algo que el cliente quiere qu pueda hacerse\n\nDe momento desarrollaremos tests unitarios. Estos tienen 3 partes:\n\nPreparación (Arrange): perparamos el código para poder probarlo, por ejemplo, creamos las variables u objetos a probar\nActuación (Act): realizamos la acción, por ejemplo, llamamos a la función\nAserción (Assert): comprobamos que el resultado es el esperado\n\nEjemplo:\ntest('wordCount() returns 2 when the input is &quot;Hello world&quot;', () =&gt; {\n// Arrange\nconst string = 'Hello world';\n\n// Act\nconst result = wordCount(string);\n\n// Assert\nexpect(result).toBe(2);\n});\n\nTesting en Javascript\nTenemos muchas herramientas para hacer tests unitarios. Usaremos una llamada Jest. Para instalarla usaremos el gestor de paquetes npm que es el más utlizado para usar bibliotecas y sus dependencias en el FrontEnd.\nInstalar npm\nnpm es el gestor de dependencias de nodejs y aprenderemos más de él en el bloque de Vue. Debemos instalar NodeJS para tener npm. Esto podemos hacerlo desde el repositorio de nuestra distribución (con apt install nodejs) pero no se instalará la última versión. Es mejor seguir las indicaciones de la página oficial de NodeJS. Aquí tenéis cómo hacerlo para distribuciones basadas en Debian/Ubuntu.\nInstalar jest\nUna vez instalado npm crearemos una carpeta para cada proyecto que vayamos a hacer y lo inicializamos ejecutando dentro de ella:\nnpm init\n\nEste comando crea un nuevo proyecto y nos pedirá información sobre el mismo. Cuando nos pregunten por la herramienta para hacer tests escribiremos jest. Tras ello tendremos ya creado el fichero package.json de nuestra aplicación (es el fichero donde se configura el proyecto y sus dependencias). En el apartado de scripts encontramos uno llamado test que lo que hace es ejecutar jest:\n&quot;scripts&quot;: {\n&quot;test&quot;: &quot;jest&quot;\n}\n\nAhora falta instalar jest, lo que haremos con:\nnpm install --save-dev jest\n\nEstamos instalando jest sólo como dependencia de desarrollo ya que no lo necesitaremos en producción (lo mismo abreviado sería npm i -D jest).\nAunque, como vamos a utilizar jest en muchos proyectos distintos, es más conveniente instalarlo globalmente con\nnpm i -g jest\n\nDe esta forma no tendremos que instalar jest en cada nuevo proyecto, sólo hacer el npm init.\nLas dependencias que instalemos están en el directorio node_modules. Si estamos usando git debemos asegurarnos de incluir este directorio en nuestro fichero .gitignore (si no tenemos ese fichero podemos crearlo simplemente con echo &quot;node_modules&quot; &gt; .gitignore).\nTranspilar nuestro código\nVamos a crear las funciones de nuestro código en un fichero JS y para que se puedan usar el otro fichero Javascript (el de los tests) debemos exportarlas con module.exports. El fichero de test deberá importarlas con require (se explica más adelante, en el apartado de Usar Jest). Por ejemplo, tenemos un fichero llamado suma.js que contiene la función add que suma 2 números pasados por parámetro:\nfunction add(a, b) {\nreturn a + b;\n}\nmodule.exports = add;\n\nEl fichero de test, suma.test.js (normalmente le llamaremos igual pero anteponiendo .test a la extensión .js) contiene los test a ejecutar:\nconst add = require('./suma')\n\ndescribe('Addition', () =&gt; {\ntest('given 3 and 7 as inputs, should return 10', () =&gt; {\nconst expected = 10;\nconst actual = add(3,7);\nexpect(actual).toEqual(expected)\n});\n\ntest('given -4 and 2 as inputs, should return -2', () =&gt; {\nconst expected = -2;\nconst actual = add(-4,2);\nexpect(actual).toEqual(expected)\n});\n});\n\nLo que hace es:\n\nimporta la función que exporta suma.js y la almacena en la constante add. Ya pude llamar a esa función\nel bloque describe permite agrupar varios tests relacionados bajo un mismo nombre\ncada sentencia test es un test que se realizará\n\nSi ejecutamos los tests en la terminal (npm run test) muestra un error ya que Jest no sabe cómo gestionar las sentencias ECMAScript import y export. Para solucionarlo debemos transpilar nuestro código de manera que Jest pueda entenderlo. Podemos hacerlo de 2 maneras:\n\ninstalando el transpilador Babel y configurando Jest para que transpile el código\nutilizando un bundler como Webpack. En este caso no sólo transpilamos el código sino que juntamos todos nuestros ficheros JS en uno sólo que será el que enlazaremos en el fichero HTML de nuestra aplicación. Es la solución si queremos que nuestro código funcione en el navegador además de poder pasar los tests.\n\nUsando Babel con Jest\nSi queremos sólo poder pasar los tests pero no vamos a usar ese código en el navegador sólo tenemos que instalar el transpilador Babel:\nnpm add jest babel-jest @babel/core @babel/preset-env\n\nY crear 2 ficheros para configurarlo y que sepa trabajar junto a Jest:\n\njest.config.json\n\n{\n&quot;transform&quot;: {\n&quot;^.+\\\\.jsx?$&quot;: &quot;babel-jest&quot;\n}\n}\n\n.babelrc\n\n{\n&quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n}\n\nAhora ya podemos ejecutar los test y comprobar que nuestro código los pasa.\nEn la siguiente página explica cómo configurar npm y jest con babel (sin usar webpack) e integrarlo con Travis-CI, la herramienta de integracion continua de GitHub:\n\nAutomate NPM releases with Jest, codecov.io, Semantic Release, and TravisCI\n\nUsando Webpack\nCon la configuración anterior nuestro código es transpilado para ejecutar los tests, pero dará error si intentamos ejecutarlo en el navegador porque allí no está transpilado. Podemos solucionarlo usando webpack para empaquetar y transpilar el código (por tanto no sería necesario realizar lo indicado en al apartado anterior).\nWebpack el un bundler o empaquetador de código que además puede usar transpiladores para convertir nuestro código que usa versiones modernas de ECMAscript en otro soportado por la mayoría de navegadores.\nPor tanto nos va a permitir, entre otras cosas:\n\nTener en nuestro index.html una sóla entrada de script (&lt;script src=&quot;./dist/main.js'&gt;) en lugar de una para cada archivo que estemos utilizando (index.js, functions.js, ...)\nAdemás podremos usar instrucciones como module.exports para exportar funciones o require para importarlas en otro fichero Javascript, que sin traspilar provocarían errores en el navegador\n\nExisten infinidad de páginas que nos enseñan las mil posibilidades que tiene webpack, pero nosotros por ahora sólo necesitamos:\nInstalar webpack\nTenemos que instalar webpack y webpack-cli. Como son dependencias de desarrollo (en producción no las necesitaremos) ejecutamos:\nnpm i -D webpack webpack-cli\n\nEjecutar webpack\nSe ejecuta con el comando npx webpack y hay que indicarle:\n\ncuál es nuestro archivo Javascript principal de nuestro código (si no lo ponemos supondrá que es ./src/index.js)\ncuál será el archivo que creará de salida (por defecto ./dist/main.js)\nsi estamos en desarrollo o en producción, para permitir o no depurar el código generado\n\nSiguiendo con el ejemplo anterior de la suma crearemos un fichero index.js dentro de src/ que importará el fichero suma.js (con el comando requirecomo se hace en el fichero de tests) y que contendrá el resto de código de la aplicación (como pedir al usuario los números a sumar, mostrar el resultado, ...). Para que webpack empaquete y transpile esos 2 ficheros (index.js y suma.js) ejecutaremos en la terminal:\nnpx webpack --mode=development\n\nEnlazar el fichero generado en el HTML\nPor último, en nuestro index.html debemos incluir sólo el main.js generado por webpack &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;\nTestear la UI\nSi queremos hacer tests unitarios de los cambios que produce nuestro código en la página web hay varios frameworks que podemos usar, pero también podemos hacerlo sin usar ninguno, usando sólo los módulos de Node que ya tenemos instalados y Jest, en concreto su herramienta jsdom que usa para emular un navegador.\nPara usarlo debemos instalar la librería Testing Library. Para ello, tras configurar nuestro proyecto con Babel como hemos visto antes, instalaremos para desarrollo los paquetes @testing-library/dom y @testing-library/jest-dom:\nnpm i -D @testing-library/dom @testing-library/jest-dom\n\nEn el fichero de test debemos poner al principio:\nconst { fireEvent, getByText } = require('@testing-library/dom')\nimport '@testing-library/jest-dom/extend-expect'\nimport { JSDOM } from 'jsdom'\nimport fs from 'fs'\nimport path from 'path'\n\ny antes de ejecutar cada test cargamos nuestra página HTML con:\nconst html = fs.readFileSync(path.resolve(__dirname, '../index.html'), 'utf8');\n\nOJO: sólo debemos cargar así la página si confiamos totalmente en el código que vamos a probar (en este caso es nuestro código) y no deberíamos hacerlo para código de terceros.\nLuego ya podemos acceder al HTML y mirar si existen ciertas etiquetas o su contenido, como en este ejemplo:\nconst { fireEvent, getByText } = require('@testing-library/dom')\nimport '@testing-library/jest-dom/extend-expect'\nimport { JSDOM } from 'jsdom'\nimport fs from 'fs'\nimport path from 'path'\n\nconst html = fs.readFileSync(path.resolve(__dirname, '../index.html'), 'utf8');\n\nlet dom\nlet container\n\ndescribe('index.html', () =&gt; {\nbeforeEach(() =&gt; {\n// Constructing a new JSDOM with this option is the key\n// to getting the code in the script tag to execute.\n// This is indeed dangerous and should only be done with trusted content.\n// https://github.com/jsdom/jsdom#executing-scripts\ndom = new JSDOM(html, { runScripts: 'dangerously' })\ncontainer = dom.window.document.body\n})\n\nit('renders a heading element', () =&gt; {\nexpect(container.querySelector('h1')).not.toBeNull()\nexpect(getByText(container, 'Almacén central - ACME SL')).toBeInTheDocument()\n})\n})\n\nAdemás de getByText para comprobar los elementos de la página tenemos otras queries que podemos utilizar.\nFuente: How to Unit Test HTML and Vanilla JavaScript Without a UI Framework\nUsar jest\nLa documentación oficial proporciona muy buena información de cómo usarlo. En resumen, en los ficheros con las funciones que vayamos a testear debemos 'exportar' esas funciones para que las pueda importar el fichero de test. Lo haremos con module.exports:\nfunction suma(a, b) {\nreturn a + b;\n}\nmodule.exports = suma;\n\nSi tenemos varias funciones podemos exportar un objeto con todas ellas:\nmodule.exports:\nfunction suma(a, b) {\nreturn a + b;\n}\nmodule.exports = { suma, resta, multiplica, divide };\n\nEn el fichero de test (que normalmente se llamará como el original más test antes de la extensión, por ejemplo funciones.test.js) importamos esas funciones con un require:\nconst suma = require('./funciones');\n\ny ya podemos acceder llamar a la función 'suma' desde el fichero de test. Si queremos importar varias funciones haremos:\nconst funciones = require('./funciones');\n\ny accederemos a cada una como 'funciones.suma', ...\nYa podemos crear nuestro primer test para probar la función suma:\ntest('Suma 1 + 1 devuelve 2', () =&gt; {\nexpect(funciones.suma(1, 1)).toBe(2);\n});\n\nPara crear un test usamos la instrucción test (o it) a la que le pasamos como primer parámetro un nombre descriptivo de lo que hace y como segundo parámetro la función que realiza el test. En general usaremos expect y le pasamos como parámetro la llamada a la función a testear y comparamos el resultado devuelto usando un matcher.\nMatchers\nLos más comunes son:\n\ntoBe(): compara el resultado del expect con lo que le pasamos como parámetro. Sólo sirve para valores primitivos (number, string, boolean, ...) no para arrays ni objetos\ntoBeCLoseTo(): se usa para números de punto flotante. expect(0.1 + 0.2).toBe(0.3) fallaría por el error de redondeo\ntoEqual(): como el anterior pero para objetos y arrays. Comprueba cada uno de los elementos el objeto o array\ntoBeLessThan, toBeLessThanOrEqual, toBeGreaterThan, toBeGreaterThanOrEqual: para comparaciones &lt;, &lt;=, &gt;, &gt;=\ntoBeTruthy: el valor devuelvo es verdadero o asimilable a verdadero (si fuera la condición de un if se ejecutaría el then)\ntoBeFalsy: el valor devuelvo es falso o asimilable a falso (si fuera la condición de un if se ejecutaría el else)\ntoBeUndefined: el valor es undefined\ntoBeDefined: el valor NO es undefined\ntoBeNull: el valor devuelto es null\ntoMatch: el valor devuelto debe cumplir con la expresión regular pasada\ntoContain: el array devuelto debe contener el elemento pasado como parámetro\ntoHaveLength: el array o el string devueltos debe tener la longitud indicada\n\nPara comprobar si una función ha lanzado una excepción se usa toThrow. Podemos comprobar sólo que haya lanzado un error, que sea de un tipo determinado, el mensaje exacto que tiene o si el mensaje cumple con una expresión regular:\nfunction compileAndroidCode() {\nthrow new Error('you are using the wrong JDK');\n}\n\ntest('compiling android goes as expected', () =&gt; {\nexpect(compileAndroidCode).toThrow();\nexpect(compileAndroidCode).toThrow(Error);\nexpect(compileAndroidCode).toThrow('you are using the wrong JDK');\nexpect(compileAndroidCode).toThrow(/JDK/);\n});\n\nPodemos obtener la lsita completa de matchers en al documentación oficial de Jest.\nTest suites\nEn muchas ocasiones no vamos a pasar un único test sino un conjunto de ellos. En ese caso podemos agruparlos en un test suite que definimos con la instruacción describe a la que pasamos un nombre que la describa y una función que contiene todos los tests a pasar:\ndescribe('Funciones aritméticas', () =&gt; {\ntest('Suma 1 + 1 devuelve 2', () =&gt; {\nexpect(funciones.suma(1, 1)).toBe(2);\n});\n\ntest('Resta 2 - 1 devuelve 1', () =&gt; {\nexpect(funciones.resta(2, 1)).toBe(1);\n});\n});\n\nMocks\nMuchas veces debemos testear partes del código que llaman a otras funciones pero no nos interesa que se ejecuten esas funciones sino simplemente saber si se han llamado o no y con qué parámetros. Para eso se definen las fuciones mock. Consiste en declarar en nuestro fichero de test una función a la que llama el código como función de jest.\nPor ejemplo, tenemos un método de un controlador llamado addProduct que llama a otro de la vista llamado renderProduct para renderizar algo. Nosotros sólo queremos testear que se llama a la vista y que el parámetro que se le pasa es el adecuado. En nuestro test haremos:\nrenderProduct = jest.fn();\n\ntest('renderProduct called once with product {id: 1, name: &quot;Prod 1&quot;, price: 49.99}', () =&gt; {\nconst product = {id: 1, name: &quot;Prod 1&quot;, price: 49.99};\n\nrenderProduct(product);\nrenderProduct({});\n\n\texpect(renderProduct.mock.calls.length).toBe(2);\n\texpect(renderProduct.mock.calls[0][0]).toEqual(newProd);\n\texpect(renderProduct.mock.calls[1][0]).toEqual({});\n})\n\nEn realidad no se llama a la función real sino a la definida por el mock y podemos ver las veces que ha sido llamada (fn.mock.calls.length) o el primer parámetro pasado en la primera llamada (fn.mock.calls[0][0]) o en la segunda (fn.mock.calls[1][0]).\nPodéis obtener toda la información en la documentación de jest.\nTambién podemos encontrar muchos ejemplos en otras webs, como en adalab\nTestear promesas\nPara testear una función que devuelve una promesa debemos hacerlo de diferente manera. Por ejemplo tenemos una función 'getData' que devuelve una promesa. Para testearla:\ntest('getData devuelve un arrya de 3 elementos', () =&gt; {\nreturn getData().then(data =&gt; expect(data).toHaveLength(3) );\n});\n\nNo olvidéis poner el 'return', si no el test acabará sin esperar a que se resuelva la promesa. Si lo que queremos es comprobar que la promesa es rechazada haremos:\ntest('getData devuelve un arrya de 3 elementos', () =&gt; {\nexpect.assertions(1);\nreturn getData().catch(err =&gt; expect(err).toMatch('404');\n});\n});\n\nEn este caso esperamos que devuelva un error que contenga '404'. Hay que poner la línea de expect.assertions para evitar que una promesa cumplida no haga que falle el test.\nEn la documentación oficial de Jest podemos encontrar información de cómo probar todo tipo de llamadas asíncronas (callback, async/await, ...).\nHooks de Jest\nPermiten ejecutar código antes o depués de pasar cada test o el conjunto de ellos. Son:\n\nafterEach(): Después de cada prueba.\nafterAll(): Después de todas las pruebas.\nbeforeEach(): Antes de cada prueba.\nbeforeAll(): Antes de todas las pruebas.\n\nPor ejemplo podemos querer inicializar la base de datos antes de pasar cada test:\nbeforeAll(() =&gt; {\ninitializeCityDatabase();\n});\n\nSi se trata de una función asíncrona habrá que añadirle un 'return' igual que hacíamos con las promesas:\nbeforeAll(() =&gt; {\nreturn initializeCityDatabase();\n});\n\nafterAll(() =&gt; {\nreturn clearCityDatabase();\n});\n\ntest('city database has Vienna', () =&gt; {\nexpect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () =&gt; {\nexpect(isCity('San Juan')).toBeTruthy();\n});`\n\nDesarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y luego el código que las pase. Por último deberíamos refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el test (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).",
		"tags": [ "note"]
},

{
		"title": "README",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/readme/",
		"content": "BLOQUE 1 - El lenguaje Javascript\nEn este primer bloque vamos a conocer el lenguaje Javascript. El bloque se divide en:\n\nIntroducción a Javascript\n1-Sintaxis: Variables. Funciones. Estructuras y bucles. Tipos de datos. Buenas prácticas\n\nIntroducción a los test en Javascript\n\n2.1-Objetos: Introducción a los objetos en Javascript\n2.2-Arrays: Métodos. Functional Programming. Referencia vs copia. Rest y Spread. Desestructuración de arrays. Map. Set\n\nVite: Cómo usar vite\nWebpack: Cómo usar webpack\n\n3-Programación Orientada a Objetos: Introducción. Clases. POO en JS5\n4-Browser Object Model - BOM: Timers. Objetos del BOM (window,\n5-Ajax. Promesas. SPA\n6-Document Object Model - DOM: Acceso a nodos. Acceso desde otros nodos. Manipular el árbol DOM. Atributos de los nodos\n\n6.1-MVC: Cómo usaremos el patrón MVC para crear la UI de nuestra aplicación\nlocation, history, otros objetos)\n\n7-Eventos: Escuchadores. Tipos de eventos. Los objetos this y event. Propagación de eventos (bubbling)\n8-Objetos nativos: Funciones globales. Objetos nativos del lenguaje: Math, Date, RegExp, ...\n9-Validación de formularios: Validación de formularios. La API de validación de formularios. Expresiones regulares\n\n10-APIs HTML5: Drag and drop. API Storage. Geolocalización. API de Google Maps\n11-Más cosas a aprender...: WebComponents. WebSockets. WebWorkers. Typescript.\n12-Tests: Testear JS con Jest\n\nIntroducción a Javascript\n\nBLOQUE 1 - El lenguaje Javascript\nIntroducción a Javascript\n\nIntroducción\n\nUn poco de historia\nSoporte en los navegadores\n\nHerramientas\n\nLa consola del navegador\nEditores\nEditores on-line\n\nIncluir javascript en una página web\nMostrar información\n\nBibliografía\n\nIntroducción\nEn las páginas web el elemento fundamental es el fichero HTML con la información a mostrar en el navegador. Posteriormente surgió la posibilidad de &quot;decorar&quot; esa información para mejorar su apariencia, lo que dio lugar al CSS. Y también se pensó en dar dinamismo a las páginas y apareció el lenguaje Javascript.\nEn un primer momento las 3 cosas estaban mezcladas en el fichero HTML pero eso complicaba bastante el poder leer esa página a la hora de mantenerla por lo que se pensó en separar los 3 elementos básicos:\n\nHTML: se encarga de estructurar la página y proporciona su información, pero es una información estática\nCSS: es lo que da forma a dicha información, permite mejorar su apariencia, permite que se adapte a distintos dispositivos, ...\nJavascript: es el que da vida a un sitio web y le permite reaccionar a las acciones del usuario\n\nPor tanto nuestras aplicaciones tendrán estos 3 elementos y lo recomendable es que estén separados en distintos ficheros:\n\nEl HTML lo tendremos habitualmente en un fichero index.html, normalmente en una carpeta llamada public\nEl CSS lo tendremos en uno o más ficheros con extensión .css dentro de una carpeta llamada styles\nEL JS estará en ficheros con extensión .js en un directorio llamado scripts\n\nLas características principales de Javascript son:\n\nes un lenguaje interpretado, no compilado\nse ejecuta en el lado cliente (en un navegador web), aunque hay implementaciones como NodeJS para el lado servidor\nes un lenguaje orientado a objetos (podemos crear e isntanciar objetos y usar objetos predefinidos del lenguaje) pero basado en prototipos (por debajo un objeto es un prototipo y nosotros podemos crear objetos sin instanciarlos, haciendo copias del prototipo)\nse trata de un lenguaje débilmente tipado, con tipificación dinámica (no se indica el tipo de datos de una variable al declararla e incluso puede cambiarse)\n\nLo usaremos para:\n\nCambiar el contenido de la página\nCambiar los atributos de un elemento\nCambiar la apariencia de algo\nValidar datos de formularios\n...\n\nSin embargo, por razones de seguridad, Javascript no nos permite hacer cosas como:\n\nAcceder al sistema de ficheros del cliente\nCapturar datos de un servidor (puede pedirlo y el servidor se los servirá, o no)\nModificar las preferencias del navegador\nEnviar e-mails de forma invisible o crear ventanas sin que el usuario lo vea\n...\n\nUn poco de historia\nJavascript es una implementación del lenguaje ECMAScript (el estándar que define sus características). El lenguaje surgió en 1997 y todos los navegadores a partir de 2012 soportan al menos la versión ES5.1 completamente. En 2015 se lanzó la 6ª versión, inicialmente llamada ES6 y posteriormente renombrada como ES2015, que introdujo importantes mejoras en el lenguaje y que es la versión mínima que usaremos nosotros. Desde entonces van saliendo nuevas versiones cada año que introducen cambios pequeños. La última es la ES2024.\nLas principales mejoras que introdujo ES2015 son: clases de objetos, let, for..of, Map, Set, Arrow functions, Promesas, spread, destructuring, ...\nSoporte en los navegadores\nLos navegadores no se adaptan inmediatamente a las nuevas versiones de Javascript por lo que puede ser un problema usar una versión muy moderna ya que puede haber partes de los programas que no funcionen en los navegadores de muchos usuarios. En la página de Kangax podemos ver la compatibilidad de los diferentes navegadores con las distintas versiones de Javascript. También podemos usar CanIUse para buscar la compatibilidad de un elemento concreto de Javascript así como de HTML5 o CSS3.\nSi queremos asegurar la máxima compatibilidad debemos usar la versión ES5 (pero nos perdemos muchas mejoras del lenguaje) o mejor, usar la ES6 (o posterior) y después transpilar nuestro código a la version ES5. De esto se ocupan los transpiladores (Babel es el más conocido) por lo que no suponen un esfuerzo extra para el programador.\nHerramientas\nLa consola del navegador\nEs la herramienta que más nos va a ayudar a la hora de depurar nuestro código. Abrimos las herramientas para el desarrollador (en Chrome y Firefox pulsando la tecla F12) y vamos a la pestaña Consola:\n![Consola](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Consola.png)\nAllí vemos mensajes del navegador como errores y advertencias que genera el código y todos los mensajes que pongamos en el código para ayudarnos a depurarlo (usando los comandos console.log y console.error).\nAdemás en ella podemos escribir instrucciones Javascript que se ejecutarán mostrando su resultado. También la usaremos para mostrar el valor de nuestras variables y para probar código que, una vez que funcione correctamente, lo copiaremos a nuestro programa.\nPodemos obtener ayuda sobre el funcionamiento de la consola en la web de Mozilla.\n\nEJERCICIO: abre la consola y prueba las funciones alert, confirm y prompt.\n\nSiempre depuraremos los programas desde aquí (ponemos puntos de interrupción, vemos el valor de las variables, ...).\n![Consola - depurar](/img/user/01 Apuntes/DAW/Javascript Teoria Batoi/img/Consola-depurar.png)\nEs fundamental dedicar tiempo a saber utilizar la consola porque nos facilitará enormemente la tarea de depurar nuestro código. Podéis encontrar infinidad de páginas en internet donde nos explican en profundidad el uso de la consola, como Debugging en el navegador.\nEditores\nPodemos usar el que más nos guste, desde editores tan simples como NotePad++ hasta complejos IDEs. La mayoría soportan las últimas versiones de la sintaxis de Javascript (Netbeans, Eclipse, Visual Studio, Sublime, Atom, Kate, Notepad++, ...). Yo voy a utilizar Visual Studio Code o Sublime text por su sencillez y por los plugins que incorpora para hacer más cómodo mi trabajo. En Visual Studio Code instalaré algún plugin como:\n\nSonarLint: es más que un linter y me informa de todo tipo de errores pero también del código que no cumple las recomendaciones (incluye gran número de reglas). Marca el código mientras lo escribimos y además podemos ver todas las advertencias en el panel de Problemas (Ctrl+\nVetur: lo instalaremos en el segundo bloque. Necesario para trabajar con los ficheros de Vue\n\nEditores on-line\nSon muy útiles porque permiten ver el código y el resultado a la vez. Normalmente tienen varias pestañas o secciones de la página donde poner el código HTML, CSS yJavascript y ver su resultado.\nAlgunos de los más conocidos son Codesandbox, Fiddle, Plunker, CodePen, ...aunque hay muchos más.\n\nEjemplo de 'Hello World' en Fiddle:\n\nEjemplo de 'Hello World' en CodePen:\n\nSee the Pen\nHello World Codepen by Kevin Schweickhardt (@kscatcensus)\non CodePen.\n\nIncluir javascript en una página web\nEl código Javascript va entre etiquetas &lt;script&gt;. Puede ponerse en el &lt;head&gt; o en el &lt;body&gt;. Funciona como cualquier otra etiqueta y el navegador la interpreta cuando llega a ella (va leyendo y ejecutando el fichero línea a línea). Podéis ver en este vídeo un ejemplo muy simple de cómo se ejecuta el código en el HEAD y en el BODY.\nLo mejor en cuanto a rendimiento es ponerla al final del &lt;body&gt; para que no se detenga el renderizado de la página mientras se descarga y se ejecuta el código. También podemos ponerlo en el &lt;head&gt; pero usando los atributos async y/o defer (en Internet encontraréis mucha información sobre esta cuestión, por ejemplo aquí.\nComo se ve en el primer vídeo, es posible poner el código directamente entre la etiqueta &lt;script&gt; y su etiqueta de finalización pero lo correcto es que esté en un fichero externo (con extensión .js) que cargamos mediante el atributo src de la etiqueta. Así conseguimos que la página HTML cargue más rápido (si lo ponemos al final del BODY o usamos async) y además no mezclar HTML y JS en el mismo fichero, lo mejora la legibilidad del código y facilita su mantenimento:\n&lt;script src=&quot;./scripts/main.js&quot;&gt;&lt;/script&gt;\n\nMostrar información\nJavascript permite mostrar al usuario ventanas modales para pedirle o mostrarle información. Las funciones que lo hacen son:\n\nwindow.alert(mensaje): Muesta en una ventana modal mensaje con un botón de Aceptar para cerra la ventana.\nwindow.confirm(mensaje): Muesta en una ventana modal mensaje con botones de Aceptar y Cancelar. La función devuelve true o false en función del botón pulsado por el usuario.\nwindow.prompt(mensaje [, valor predeterminado]): Muesta en una ventana modal mensaje y debajo tiene un campo donde el usuario puede escribir, junto con botones de Aceptar y Cancelar. La función devuelve el valor introducido por el usuario como texto (es decir que si introduce 54 lo que se obtiene es &quot;54&quot;) o false si el usuario pulsa Cancelar.\n\nTambién se pueden escribir las funciones sin window. (es decir alert('Hola') en vez de window.alert('Hola')) ya que en Javascript todos los métodos y propiedades de los que no se indica de qué objeto son se ejecutan en el objeto window.\nSi queremos mostrar una información para depurar nuestro código no utilizaremos alert(mensaje) sino console.log(mensaje) o console.error(mensaje). Estas funciones muestran la información pero en la consola del navegador. La diferencia es que console.error la muestra como si fuera un error de Javascript.\nBibliografía\n\nCurso &quot;Programación con JavaScript&quot;. CEFIRE Xest. Arturo Bernal Mayordomo\nCurso de JavaScript y TypeScript de Arturo Bernal en Youtube\nMDN Web Docs. Moz://a. https://developer.mozilla.org/es/docs/Web/JavaScript\nIntroducción a JavaScript. Librosweb. http://librosweb.es/libro/javascript/\nCurso de Javascript (Desarrollo web en entorno cliente). Ada Lovecode - Didacticode (90 vídeos) de Laura Folgado\nApuntes Desarrollo Web en Entorno Cliente (DWEC). Sergi García Barea",
		"tags": [ "note"]
},

{
		"title": "TDD-mocha",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/tdd-mocha/",
		"content": "Desarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y después refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el est (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).\nUsar TDD en Javascript\nLo más sencillo es usar alguna librería como Mocha. Se trata de un gramework que se ejecuta sobre Node.js y permite crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado. Luego creamos una carpeta para nuestro proyecto y dentro ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
},

{
		"title": "ejercicios",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/ejercicios/",
		"content": "Ejercicios de Javascript\n\nTable of Contents generated with DocToc\n\nEjercicios de Javascript\n\n1.- Sintaxis\n\n1.1 Frase\n\n2.- Arrays\n3.- POO\n\n3.1.- Productos de un almacén\n3.2.- Carro de compra\n\n4.- DOM\n5.- BOM\n6.- Eventos\n7.- Objetos globales\n8.- Ajax\n9.- APIs\n\n1.- Sintaxis\n1.1 Frase\nVamos a pedir al usuario que introduzca una frase y a continuación mostraremos en la consola:\n\nel número de letras y de palabras que tiene\nla frase en mayúsculas\nla frase con la primera letra de cada palabra en mayúsculas\nla frase escrita con las letras al revés\nla frase escrita con las palabras al revés\nsi es o no un palíndromo (si se lee igual al revés) pero omitiendo espacios en blanco y sin diferenciar mayúsculas y minúsculas.\n\nEj.: con la frase introducida “La ruta nos aporto otro paso natural” se mostraría\n\n36 letras y 7 palabras\nLA RUTA NOS APORTO OTRO PASO NATURAL\nLa Ruta Nos Aporto Otro Paso Natural\nlarutan osap orto otropa son atur aL\nnatural paso otro aporto nos ruta La\nSí es un palíndromo\n\nIntenta usar en cada caso el bucle más adecuado. Las funciones split y join (lo opuesto) de String y Array nos pueden ayudar a algunas cosas.\nRECUERDA:\n\nel código deberá estar en un fichero externo y se incluirá al final del body\ndebes comentarlo para tener claro qué hace\ntanto el código JS como el HTML deben estar correctamente indentados\nten en cuenta los datos que pueden “estropearnos” el programa: introducir un dato de un tipo que no te esperas, omitir algún parámetro, ...\nusa las recomendaciones indicadas: 'use strict', ...\nel código debe ser lo más limpio y claro posible, sin variables o código innecesario\nsiempre es bueno refactorizar el código: cuando nuestro programa ya funciona bien le damos un “repaso” para mejorar su claridad (y lo volvemos a probar)\n\n2.- Arrays\nVamos a hacer un programa que va pidiendo al usuario que introduzca las notas de un examen y las va guardando en un array. El usuario puede introducir una sóla nota o varias separadas por un guión (ej. 4,5 - 6 - 8,75) y se continuará pidiendo notas al usuario hasta que éste pulse 'Cancelar'. Recuerda que en Javascript el símbolo decimal es el punto pero el usuario puede introducir decimales con la coma.\nCada nota introducida se almacenará en un array y una vez que estén todas se mostrará por la consola:\n\nel array con los datos suministrados por el usuario\nel array &quot;limpiado&quot;: quitaremos del mismo todo lo que no sean números o no estén entre 0 y 10\nel nº total de aprobados y sus notas\nel nº total de suspensos y sus notas\nla nota del 1º suspenso y su posición en el array\nla nota media del examen\n\nSiempre que sea posible utilizaremos métodos de arrays en lugar de bucles.\n3.- POO\n3.1.- Productos de un almacén\nEn este ejercicio vamos a trabajar con los productos de un almacén, para lo que crearemos las clases:\n\nProduct: cada producto será un objeto con las propiedades cod, name, price y units (las unidades que tenemos de ese producto). Si no le pasamos unidades al constructor su número por defecto será 1. Esta clase tendrá los siguientes métodos:\n\nchangeUnits: recibe la cantidad a aumentar (positiva o negativa) e incrementa (o decrementa) las unidades en la cantidad recibida. Si se intentan restar más unidades de las que hay no hace nada y devuelve false y en otro caso cambia las unidades y devuelve true\nproductImport: devuelve el importe total del producto (su precio multiplicado por el nº de unidades)\nademás si se intenta imprimir el producto se mostrará su descripción, sus unidades entre paréntesis, su precio y el importe total, como en el siguiente ejemplo: TV Samsung MP45 (5): 235,95 €/u =&gt; 1179,75 €\n\nStore: es el almacén de productos y tendrá las propiedades id (código numérico que nos pasan al crear el almacén) y products (array de productos que al crearlo estará vacío) y los métodos:\n\nfindProduct: recibe un código de producto y devuelve el producto que tiene dicho código o null si ese código no existe en el almacén\naddProduct: recibe como parámetro el código y unidades a añadir y, opcionalmente, el nombre y precio (si se trata de un producto nuevo) y lo añade al almacén. Si ya existe el código suma al producto las unidades indicadas y si no existe crea un nuevo producto en el array. Devuelve true\ndelProduct: recibe como parámetro el código y las unidades a quitar de un producto y lo resta del almacén. Devuelve true a menos que haya menos unidades de las que quieren restarse, en cuyo caso no hace nada y devuelve false\ntotalImport: devuelve el valor total de los productos del almacén\norderByDescrip: devuelve el array de productos ordenado por el nombre\norderByUnits: devuelve el array de productos ordenado por unidades descendente\n\nPara probar que funciona correctamente ejecutaremos en nuestro fichero main.js:\nlet almacen=new Store(1);\nalmacen.addProduct(1, 4, 'TV Samsung MP45', 345.95);\nalmacen.addProduct(2, 8, 'Portátil Acer Travelmate 200', 245.95);\nalmacen.addProduct(3, 15, 'Impresora Epson LX-455', 45.95);\nalmacen.addProduct(4, 25, 'USB Kingston 16GB', 5.95);\n\nconsole.log('LISTADO DEL ALMACÉN');\nalmacen.products.forEach(prod=&gt;console.log(prod.toString()));\n\nalmacen.addProduct(5, 15, 'USB Kingston 64GB', 15.95);\nalmacen.delProduct(3, 11);\nalmacen.delProduct(3, 7);\nalmacen.addProduct(1, 9);\n\nconsole.log('LISTADO DEL ALMACÉN');\nalmacen.products.forEach(prod=&gt;console.log(prod.toString()));\n\nAdemás en nuestro main.js haremos que se muestren por consola todos los productos de los que tenemos menos de 5 unidades en stock o cuyo importe es inferior a 150 €.\n3.2.- Carro de compra\nVamos a permitir que los usuarios hagan compras on-line para lo que crearemos una clase para los carritos de la compra:\n\nCart: esta clase la usaremos para crear carritos de compra con los productos a comprar. Es como la clase Store pero tiene además la propiedad user con el identificador del usuario que hace la compra y que nos lo pasarán al crear el carrito. Respecto a sus métodos son igual que los de la clase Store pero:\n\nel método delProduct eliminará el producto del array de productos si sus unidades son 0\ntendrá dos nuevos métodos addToCart y removeFromCart que nos permitan añadir y quitar productos del carro y que recibirán como parámetros el código del producto y las unidades a añadir o quitar.\n\nNOTA: la variable del almacén será una variable global en el fichero main.js\n4.- DOM\nVamos a mostrar en una tabla los products de nuestro almacén. Cada fila corresponderá a un producto y se mostrará su código, nombre, unidades, precio por unidad e importe. Debajo de la tabla mostraremos el importe total del almacén. En el fichero index.html crearemos la tabla vacía y el párrafo para poner el importe total.\nPara simplificar nuestro código a la clase Product le añadiremos el método toTR que devolverá el código HTML para mostrar una fila con los datos del producto y a la clase Store le añadiremos el método toHTML que devolverá el código HTML que insertaremos dentro de la tabla del almacén.\nAdemás cada vez que creemos un carrito se mostrará en la página una nueva UL con su código y su usuario. Cada artículo del carro será una LI de la UL y al final habrá una LI con el importe total del carro. Ej.:\n\nCarro 2 - juan\n\n1 x TV Samsung MP45 (345.95 €) = 345.95 €\n3 x USB Kingston 16GB (5.95 €) = 17.85 €\nImporte total: 353.80 €\n\nNOTA: podemos hacer algo para que sea más fácil crear los elementos del DOM tal y como hems hecho para crear la tabla???.\nOPCIONAL: mejorar la presentación usando bootstrap. Pondremos la tabla del almacén y debajo los carritos, 2 por fila.\n5.- BOM\n6.- Eventos\nBotones y enlaces para el ejercicio del almacén\n7.- Objetos globales\nFechas, ...\n8.- Ajax\nLeer y guardar el almacén (y los carritos?)\n9.- APIs",
		"tags": [ "note"]
},

{
		"title": "xx-tests",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/javascript-teoria-batoi/xx-tests/",
		"content": "Usar TDD en Javascript\nLo más sencillo es usar alguna librería como Jest, Mocha o Vitests (una adaptación de Jest para Vite). Se trata de librerías que se ejecutan sobre Node.js y permiten crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado.\nUso de Vitest\nPodéis obtener información sobre cómo hacer test con Vitest en muchas páginas de Internet como:\n\nCurso DWEC de Jose Castillo\nVitest\n\nUso de Mocha\nPara instalarlo ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
},

{
		"title": "1. Arquitecturas WEB",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/1-arquitecturas-web/1-arquitecturas-web/",
		"content": "Arquitectures Web\nUna arquitectura web defineix l'estructura i el comportament dels components d'una aplicació web, incloent com es comuniquen entre ells i amb els usuaris finals. Aquesta arquitectura pot abastar des de la interfície d'usuari en el client fins als serveis de backend i bases de dades en el servidor.\nLes arquitectures web són fonamentals en el desenvolupament d'aplicacions web modernes per diverses raons:\n\nEscalabilitat: Les arquitectures ben dissenyades permeten que les aplicacions web gestionen un nombre creixent d'usuaris i dades sense sacrificar el rendiment. Per exemple, una arquitectura de microserveis facilita l'escalabilitat horitzontal, ja que cada servei es pot escalar independentment.\nMantenibilitat: Una bona arquitectura facilita el manteniment i l'actualització de les aplicacions. Mitjançant la separació de preocupacions (per exemple, en una arquitectura de tres capes), es poden fer canvis en una part del sistema sense afectar altres parts.\nSeguretat: Les arquitectures web poden incorporar diverses capes de seguretat per protegir les dades i les comunicacions. Això inclou mesures com l'autenticació, l'autorització, la xifratge de dades, i la protecció contra atacs comuns com les injeccions SQL i el cross-site scripting (XSS).\nRendiment: L'arquitectura de l'aplicació web afecta directament el seu rendiment. Una arquitectura ben dissenyada optimitza el temps de resposta i la gestió de recursos, millorant l'experiència de l'usuari. L'ús de tècniques com la caché, el balanç de càrrega, i la compressió de contingut són exemples d'estratègies per millorar el rendiment.\nFlexibilitat i Adaptabilitat: Les arquitectures modernes permeten l'ús de diverses tecnologies i eines per a diferents parts del sistema, proporcionant flexibilitat i permetent una adaptació ràpida als canvis tecnològics. Això és especialment rellevant amb l'adopció de pràctiques DevOps i l'ús de contenidors i orquestradors com Docker i Kubernetes.\nCol·laboració i Desplegament: Un bon disseny arquitectònic facilita la col·laboració entre equips de desenvolupament, ja que clarifica les responsabilitats i els punts d'integració. També permet un desplegament més eficient i automatitzat, reduint els riscos d'errors i millorant el temps de lliurament.\n\n1.Tipus d'Arquitectures Web\nA continuació, es descriuen alguns dels principals tipus d'arquitectures web, cadascun amb les seves pròpies característiques, avantatges i desavantatges:\nArquitectura Client-Servidor\nEn aquest model, el client (generalment un navegador web) envia sol·licituds al servidor, que processa aquestes sol·licituds i envia les respostes corresponents.\nDiagrama:\n\nCaracterístiques:\n\nEl client és responsable de la interfície d'usuari.\nEl servidor maneja la lògica d'aplicació i l'accés a les dades.\n\nAvantatges:\n\nSeparació de responsabilitats.\nFacilita el manteniment i la seguretat.\n\nDesavantatges:\n\nPot tenir problemes de rendiment amb moltes sol·licituds simultànies.\n\nArquitectura de Tres Capes\nAquesta arquitectura divideix l'aplicació en tres nivells: la capa de presentació, la capa de lògica d'aplicació, i la capa de dades.\nDiagrama:\n\nCaracterístiques:\n\nLa capa de presentació gestiona la interfície d'usuari.\nLa capa de lògica d'aplicació processa les dades i executa la lògica de negoci.\nLa capa de dades emmagatzema i recupera la informació.\n\nAvantatges:\n\nFacilita l'escalabilitat.\nMillora la seguretat, ja que les dades no són directament accessibles des del client.\n\nDesavantatges:\n\nPot ser més complexa de desenvolupar i mantenir.\n\nArquitectura de Microserveis\nEls microserveis descomponen una aplicació en una sèrie de serveis petits i independents, cadascun executant una funció específica.\nDiagrama:\n\nCaracterístiques:\n\nCada microservei es pot desplegar, actualitzar, i escalar independentment.\nUtilitzen protocols lleugers com HTTP/REST o gRPC per comunicar-se.\n\nAvantatges:\n\nMillora l'escalabilitat i la flexibilitat.\nFacilita l'ús de diferents tecnologies per a diferents serveis.\n\nDesavantatges:\n\nPot ser complexa de gestionar i coordinar.\nRequereix una infraestructura de desplegament i monitorització més robusta.\n\nRecursos Addicionals\n\nDocumentació sobre Arquitectures de Software: Software Architecture Guide\nTutorial de Microserveis: Microservices Tutorial\n\nResum\nLes arquitectures web són fonamentals per al desenvolupament d'aplicacions eficients i escalables. La selecció de l'arquitectura adequada depèn de les necessitats específiques del projecte, incloent-hi consideracions de rendiment, escalabilitat, seguretat i mantenibilitat.\n2. Pàgines Web Estàtiques vs. Dinàmiques\nPàgines estàtiques\nLes pàgines web estàtiques són aquelles en què el contingut no canvia en funció de les accions de l'usuari. Estan construïdes amb HTML i CSS, i cada pàgina es carrega de manera independent des del servidor.\nAvantatges\n\nSenzillesa: Fàcils de crear i mantenir.\nRendiment: Temps de càrrega ràpid perquè no requereixen processament addicional.\nSeguretat: Menys vulnerabilitats, ja que no hi ha lògica de servidor ni bases de dades.\n\nDesavantatges\n\nFlexibilitat: Difícils de modificar a gran escala sense eines automatitzades.\nInteractivitat: Limitada, ja que no poden respondre a les accions de l'usuari de manera dinàmica.\n\nExemple Pràctic\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Pàgina Estàtica&lt;/title&gt;\n&lt;style&gt;\nbody { font-family: Arial, sans-serif; }\n.content { margin: 20px; }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;content&quot;&gt;\n&lt;h1&gt;Benvingut!&lt;/h1&gt;\n&lt;p&gt;Aquesta és una pàgina web estàtica.&lt;/p&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nPàgines dinàmiques\nLes pàgines web dinàmiques són aquelles en què el contingut pot canviar en funció de les accions de l'usuari o altres factors. Utilitzen llenguatges de guions o d'scripting. Els llenguatges de guions sovint s’utilitzen per ampliar les prestacions que ofereix un altre llenguatge, entorn o aplicació. En aquest sentit són molt utilitzats en el desenvolupament d’aplicacions web:\n\nScripts de navegadors web. S’utilitzen per ampliar les capacitats de l’HTML i per inserir accions en pàgines web. Permeten crear efectes especials i aporten interactivitat. Els scripts són interpretats i executats en la màquina client pel navegador web, el qual ha d’incorporar l’intèrpret del llenguatge. Un exemple de llenguatge d’aquest tipus molt utilitzat és JavaScript.\nScripts de servidor. Són programes que permeten donar funcionalitats a les pàgines web que no es poden resoldre només amb els scripts de navegador. Els scripts de servidor permeten dotar de certa “intel·ligència” els llocs web, la qual cosa fa que generin pàgines diferents segons les circumstàncies. Exemples de llenguatges de servidor són PHP, Python, Node.js, entre altres.\n\nAvantatges\nActualització en Temps Real\n\nDescripció: Les pàgines es poden actualitzar automàticament sense necessitat de recarregar tota la pàgina.\nCas d'Ús: Un portal de notícies que mostra articles nous sense necessitat de recarregar la pàgina.\n\nPersonalització del Contingut\n\nDescripció: Permet adaptar el contingut a les preferències i el comportament de l'usuari.\nCas d'Ús: Una botiga en línia que mostra recomanacions de productes basades en l'historial de navegació i compres de l'usuari.\n\nInteractivitat Avançada\n\nDescripció: Facilita la creació d'aplicacions web interactives que poden respondre a les accions de l'usuari en temps real.\nCas d'Ús: Aplicacions de xarxes socials que mostren actualitzacions i notificacions en temps real.\n\nGestió Eficient de Contingut\n\nDescripció: Permet gestionar grans quantitats de contingut de manera més eficient, mostrant només el contingut rellevant en funció de la sol·licitud de l'usuari.\nCas d'Ús: Un sistema de gestió de continguts (CMS) que permet als administradors editar i publicar articles de manera dinàmica.\n\nDesavantatges\n\nComplexitat: Més difícils de crear i mantenir, ja que requereixen programació tant al client com al servidor.\nRendiment: Poden ser més lentes a causa de la necessitat de processament al servidor.\nSeguretat: Exposades a més vulnerabilitats, com injeccions SQL, si no es prenen les precaucions adequades.\n\nImpacte en Aplicacions Modernes\nMillora de l'Experiència d'Usuari\n\nLes aplicacions modernes utilitzen la generació dinàmica de pàgines per oferir una experiència més fluida i responsiva. Per exemple, aplicacions com Gmail i Google Docs permeten als usuaris interactuar amb el contingut en temps real sense interrupcions.\n\nOptimització del Rendiment\n\nLa generació dinàmica de pàgines permet carregar només el contingut necessari, reduint la càrrega inicial i millorant el rendiment general de l'aplicació. Això és especialment útil en aplicacions complexes amb molta interactivitat.\n\nCapacitat de Resposta a les Sol·licituds de l'Usuari\n\nAplicacions com Facebook i Twitter utilitzen la generació dinàmica per actualitzar el feed en temps real, oferint als usuaris informació actualitzada immediatament.\n\nExemple Pràctic (PHP)\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Pàgina Dinàmica&lt;/title&gt;\n&lt;style&gt;\nbody { font-family: Arial, sans-serif; }\n.content { margin: 20px; }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;content&quot;&gt;\n&lt;h1&gt;Benvingut!&lt;/h1&gt;\n&lt;p&gt;Aquesta pàgina ha estat generada a les &lt;?php echo date('H:i:s'); ?&gt;.&lt;/p&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nComparativa entre Pàgines Web Estàtiques i Dinàmiques\n\nCaracterística\nPàgines Web Estàtiques\nPàgines Web Dinàmiques\n\nContingut\nFix, no canvia\nVariable, pot canviar\n\nComplexitat\nBaixa\nAlta\n\nInteractivitat\nLimitada\nAlta\n\nRendiment\nAlt\nPot ser baix\n\nSeguretat\nAlta\nDepèn de la implementació\n\nFlexibilitat\nBaixa\nAlta\n\nSEO\nBona\nDepèn de la implementació\n\nTemps de Desenvolupament\nCurt\nLlarg\n\nActualització del Contingut\nManual\nAutomàtica\n\nCost de Manteniment\nBaix\n\nRecursos Addicionals\n\nArticle sobre els avantatges de les pàgines dinàmiques\nCurs sobre generació dinàmica de pàgines web\nDocumentació de HTML: MDN HTML Guide\nDocumentació de CSS: MDN CSS Guide\nDocumentació de PHP: PHP Documentation\nDocumentació de JavaScript (MDN): MDN JavaScript Guide\nDocumentació de Node.js: Node.js Documentation\nDocumentació de React: React Documentation\n\nResum\nLes pàgines web estàtiques són adequades per a llocs web senzills amb contingut fix, mentre que les pàgines web dinàmiques són necessàries per a aplicacions més complexes que requereixen interactivitat i contingut variable. La decisió entre utilitzar una pàgina estàtica o dinàmica dependrà de les necessitats específiques del projecte i dels recursos disponibles. Les SPA ofereixen una experiència d'usuari molt rica però poden tenir desavantatges en termes de SEO i temps de càrrega inicial.\n3. Models d'Execució\nEls models d'execució de codi en el desenvolupament web es poden dividir principalment en dos tipus: execució al client i execució al servidor. Cada model té les seves pròpies característiques, avantatges i desavantatges que cal considerar a l'hora de dissenyar una aplicació web.\nExecució de Codi al Client (FrontEnd)\nL'execució de codi al client es realitza al navegador web de l'usuari. Els llenguatges utilitzats principalment per a l'execució al client són HTML, CSS i JavaScript.\nAvantatges\n\nInteractivitat: Permet la creació d'experiències d'usuari riques i interactives.\nReducció de la càrrega del servidor: El processament es fa al dispositiu de l'usuari, disminuint la càrrega del servidor.\nActualització instantània: Canvis en l'UI poden ser reflectits immediatament sense necessitat de recarregar la pàgina.\n\nDesavantatges\n\nSeguretat: El codi del client és visible i modificable pels usuaris, la qual cosa pot representar un risc de seguretat.\nCompatibilitat: Pot haver-hi diferències en la manera com diferents navegadors interpreten el codi.\n\nExemple de codi\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Exemple Client&lt;/title&gt;\n&lt;style&gt;\nbody { font-family: Arial, sans-serif; }\n.content { margin: 20px; }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;content&quot;&gt;\n&lt;h1&gt;Hola, món!&lt;/h1&gt;\n&lt;button onclick=&quot;mostrarMissatge()&quot;&gt;Fes clic aquí&lt;/button&gt;\n&lt;p id=&quot;missatge&quot;&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\nfunction mostrarMissatge() {\ndocument.getElementById('missatge').innerText = 'Has fet clic al botó!';\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nExecució de Codi al Servidor (BackEnd)\nL'execució de codi al servidor es realitza al servidor web abans que els resultats es retornin al navegador del client. Els llenguatges habituals inclouen PHP, Python, Ruby, Node.js, entre altres.\nAvantatges\n\nSeguretat: El codi del servidor no és accessible pels usuaris finals, la qual cosa augmenta la seguretat.\nPotència: Els servidors solen ser més potents que els dispositius dels usuaris, permetent processar operacions més complexes.\n\nDesavantatges\n\nLatència: Les sol·licituds al servidor poden ser lentes a causa de la distància física i la càrrega del servidor.\nEscalabilitat: Pot ser necessari més esforç per escalar una aplicació a mesura que augmenta el nombre d'usuaris.\n\nExemple de codi\n// server.js\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) =&gt; {\nres.statusCode = 200;\nres.setHeader('Content-Type', 'text/plain');\nres.end('Hola, món!\\n');\n});\n\nserver.listen(port, hostname, () =&gt; {\nconsole.log(`El servidor s'està executant a http://${hostname}:${port}/`);\n});\n\nSingle Page Application (SPA)\nUna Single Page Application (SPA) és un tipus d'aplicació web que carrega una única pàgina HTML i dinàmicament actualitza el contingut a mesura que l'usuari interactua amb l'aplicació, utilitzant JavaScript per a gestionar la lògica i les actualitzacions de la interfície d'usuari.\nAvantatges\n\nExperiència d'usuari millorada: Les SPA ofereixen una navegació més ràpida i fluida, similar a una aplicació d'escriptori.\nMenys càrrega del servidor: Menys sol·licituds al servidor ja que només es carrega una pàgina inicialment.\nDesenvolupament modular: Facilita la creació de components reutilitzables.\n\nDesavantatges\n\nSEO: Les SPA poden ser menys amigables amb els motors de cerca.\nCarregada inicial: Pot requerir una major càrrega inicial de recursos, afectant el temps de càrrega inicial.\nGestió de l'estat complexa: Pot ser més complicat gestionar l'estat de l'aplicació.\n\nExemple Pràctic (React)\n// index.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Exemple SPA&lt;/title&gt;\n&lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n// index.js\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction App() {\nconst [message, setMessage] = useState('');\n\nconst handleClick = () =&gt; {\nsetMessage('Has fet clic al botó!');\n};\n\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Hola, món!&lt;/h1&gt;\n&lt;button onClick={handleClick}&gt;Fes clic aquí&lt;/button&gt;\n&lt;p&gt;{message}&lt;/p&gt;\n&lt;/div&gt;\n);\n}\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('root'));\n\nComparativa entre Execució de Codi al Client,al Servidor i el SPA\n\nCaracterística\nClient-Side\nServer-Side\nSingle Page Application (SPA)\n\nExecució\nNavegador del client\nServidor\nNavegador del client\n\nLlenguatges\nJavaScript, HTML, CSS\nPHP, Node.js, Python, Java\nJavaScript, HTML, CSS\n\nTemps de Resposta\nImmediata (després de la càrrega)\nDepèn de la comunicació amb el servidor\nBaixa (després de la càrrega inicial)\n\nSeguretat\nMés exposat a vulnerabilitats\nMés controlat\nMitjana\n\nRecursos\nLimitats pels recursos del client\nRecursos del servidor\nLimitats pels recursos del client\n\nAccés a Dades\nNo pot accedir directament a bases de dades\nAccés directe a bases de dades\nGeneralment via API\n\nInteractivitat\nElevada, pot respondre ràpidament a les accions de l'usuari\nMés difícil d'aconseguir sense Ajax o websockets\nMolt Alta\n\nProcessament\nMenys capacitat de procés\nAlta capacitat de procés\nProcessament distribuit\n\nCarrega del servidor\nBaixa\nAlta\nBaixa\n\nLatència\nBaixa\nPot ser alta\nBaixa (després de la càrrega inicial)\n\nAccés a recursos locals\nLimitat al navegador\nComplet accés al sistema del servidor\nLimitat al navegador\n\nSEO\nMitjana\nAlta\nBaixa\n\nTemps de càrrega inicial\nRàpid\nDepèn de la complexitat\nPot ser lent\n\nComparativa entre desenvolupadors\n\nPerfil\nFerramenta\nTecnologia\n\nFront-end / client\nNavegador Web\nHTML + CSS + JavaScript\n\nBack-end / servidor\nServidor Web + BBDD\nPHP, Python, Ruby, Java / JSP, .Net / .asp\n\n!!! tip &quot;Perfil Full-stack&quot;\nEn les ofertes de treball quan fan referència a un Full-stack developer, estan buscant un perfil que domina tant el front-end com el back-end.\nRecursos addicionals\n\nDocumentació de JavaScript (MDN): MDN JavaScript Guide\nGuia de Node.js: Node.js Documentation\nDocumentació de React: React Documentation\n\nResum\nLa decisió sobre si utilitzar l'execució de codi al client, al servidor o una SPA depèn de les necessitats específiques de l'aplicació i els recursos disponibles. Comprendre les diferències clau i els avantatges de cada model ajudarà a prendre decisions informades i a desenvolupar aplicacions web eficients i segures.\n4. Servidors Web\nUn servidor web és un programa que serveix contingut web estàtic com HTML, CSS, JavaScript, imatges i altres fitxers als clients a través del protocol HTTP o HTTPS. El servidor web gestiona les sol·licituds entrants dels clients (navegadors web) i retorna les respostes adequades.\nFuncionalitats dels Servidors Web\nServei de Contingut Estàtic\n\nDescripció: Proporciona fitxers estàtics com HTML, CSS, JavaScript, imatges i altres recursos directament als clients.\nExemple: Quan un usuari sol·licita una pàgina HTML, el servidor web envia el fitxer HTML corresponent al navegador de l'usuari.\n\nGestió de Peticions HTTP\n\nDescripció: Maneja sol·licituds HTTP de clients, com GET, POST, PUT, DELETE, i retorna les respostes adequades amb els codis d'estat corresponents.\nExemple: Un servidor web processa una sol·licitud GET per una pàgina web i retorna el contingut de la pàgina amb un codi d'estat 200 (OK).\n\nRedirecció i Reescriptura d'URLs\n\nDescripció: Permet la redirecció de peticions a diferents URLs i la reescriptura d'URLs per millorar l'accessibilitat i la SEO.\nExemple: Reescriptura d'URLs amigables per als usuaris, com convertir example.com/page?id=123 a example.com/page/123.\n\nSuport per a HTTPS\n\nDescripció: Proporciona connexions segures utilitzant el protocol HTTPS, que xifra les dades entre el client i el servidor.\nExemple: Un servidor web configurat amb un certificat SSL/TLS que permet connexions segures a través de HTTPS.\n\nExemples de Servidors Web\nApache HTTP Server\n\nDescripció: Un servidor web de codi obert molt utilitzat, conegut per la seva flexibilitat i extensibilitat.\nFuncionalitats: Suport per a mòduls que afegeixen funcionalitats com l'autenticació, la reescriptura d'URLs i la compressió de contingut.\n\nNginx\n\nDescripció: Un servidor web i servidor intermediari de codi obert, dissenyat per gestionar moltes connexions simultànies amb un ús eficient dels recursos.\nFuncionalitats: Actua com a servidor proxy invers, equilibrador de càrrega i servidor de fitxers estàtics.\n\nMicrosoft Internet Information Services (IIS)\n\nDescripció: Un servidor web i d'aplicacions de Microsoft per a plataformes Windows.\nFuncionalitats: Suport per a aplicacions ASP.NET, autenticació integrada i eines de gestió robustes.\n\nMecanismes d'Execució de Codi en Servidors Web\nLlenguatges interpretats: PHP, Python\nEl codi es processa línia per línia en temps real, permetent una major flexibilitat durant el desenvolupament, ja que els canvis poden ser implementats i testats immediatament sense necessitat de recompilar tot el projecte.\n&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;&lt;?php echo &quot;Hola, món!&quot;; ?&gt;&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nLlenguatges compilats: Java\nEl codi es compila abans de ser executat, el que significa que és transformat en un format executable per la màquina abans de la seva execució. Això sol millorar el rendiment, ja que el codi compilat s'executa més ràpidament que el codi interpretat.\n// Exemple simplificat d'un servlet Java\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class HelloWorldServlet extends HttpServlet {\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\nthrows ServletException, IOException {\nresponse.setContentType(&quot;text/html&quot;);\nPrintWriter out = response.getWriter();\nout.println(&quot;&lt;h1&gt;Hola, món!&lt;/h1&gt;&quot;);\n}\n}\n\nIntermediari: Node.js\nPermet la programació asíncrona i escalable amb JavaScript, oferint la capacitat de gestionar moltes connexions simultànies de manera eficient. Això és especialment útil per a aplicacions que necessiten alta concurrència, com aplicacions en temps real.\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) =&gt; {\nres.send('Hola, món!');\n});\n\napp.listen(3000, () =&gt; {\nconsole.log('Servidor escoltant a http://localhost:3000');\n});\n\nLlenguatges i Tecnologies de Programació Web en Entorn Servidor\nEls mecanismes d'execució de codi en els servidors web permeten que les aplicacions generin contingut dinàmic, gestionin dades i interaccions d'usuaris de manera eficient. A continuació es descriuen diversos llenguatges i com funcionen en el context del servidor.\nPHP\n\nDescripció: PHP és un llenguatge interpretat popularment utilitzat per a la creació de pàgines web dinàmiques.\nMecanisme: El codi PHP s'incrusta dins dels fitxers HTML i es processa en temps real pel servidor web abans de ser enviat al client.\n\nNode.js\n\nDescripció: Node.js permet la programació asíncrona i escalable amb JavaScript.\nMecanisme: Utilitza un model basat en esdeveniments que permet la gestió de moltes connexions simultànies sense bloquejar-se.\n\nJava (JSP/Servlets)\n\nDescripció: Java s'utilitza per a aplicacions empresarials amb alta complexitat i escalabilitat.\nMecanisme: El codi Java es compila abans d'executar-se, millorant el rendiment. Els servlets i JSP gestionen les sol·licituds HTTP i generen contingut dinàmic.\n\nPython (Django/Flask)\n\nDescripció: Python és conegut per la seva sintaxi clara i les seves biblioteques extensives. Django i Flask són frameworks populars.\nMecanisme: Django utilitza un ORM per interactuar amb bases de dades, mentre que Flask és més lleuger i flexible.\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\nreturn 'Hola, món!'\n\nif __name__ == '__main__':\napp.run()\n\nRuby (Ruby on Rails)\n\nDescripció: Ruby és apreciat per la seva elegància i facilitat d'ús. Ruby on Rails és un framework popular.\nMecanisme: Ruby on Rails segueix el patró MVC, facilitant el desenvolupament d'aplicacions web estructurades.\n\nclass WelcomeController &lt; ApplicationController\ndef index\nrender plain: &quot;Hola, món!&quot;\nend\nend\n\nGo\n\nDescripció: Go és un llenguatge de programació desenvolupat per Google, conegut per la seva eficiència i concurrència.\nMecanisme: Go permet la creació de servidors web ràpids i escalables, utilitzant goroutines per gestionar múltiples connexions de manera eficient.\n\npackage main\n\nimport (\n&quot;fmt&quot;\n&quot;net/http&quot;\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\nfmt.Fprintf(w, &quot;Hola, món!&quot;)\n}\n\nfunc main() {\nhttp.HandleFunc(&quot;/&quot;, helloHandler)\nhttp.ListenAndServe(&quot;:8080&quot;, nil)\n}\n\nComparativa entre llenguatges\n\nLlenguatge\nAvantatges\nDesavantatges\nUsos Comuns\n\nPHP\nAmplament utilitzat, gran comunitat, fàcil d'aprendre\nSeguretat (cal bones pràctiques), rendiment inferior a altres llenguatges\nAplicacions web, CMS com WordPress\n\nPython\nSenzillesa i llegibilitat, gran quantitat de biblioteques, potent per a prototips\nRendiment inferior en algunes àrees, gestió de concurrència\nAplicacions web (Django, Flask), anàlisi de dades\n\nNode.js\nAlta velocitat, no bloqueig (event-driven), gran ecosistema (NPM)\nPot ser complicat per a grans aplicacions, gestió de callbacks\nAplicacions en temps real, serveis web\n\nJava\nRendiment elevat, robustesa, seguretat, escalabilitat\nVerborrea, aprenentatge més complex\nAplicacions empresarials, sistemes grans, Android\n\nRecursos Addicionals:\n\nClient-side vs Server-side\nApache HTTP Server Documentation\nNginx Official Documentation\nMicrosoft IIS Documentation\nW3Schools: PHP Tutorial\nNode.js Documentation\nDjango Documentation\nFlask Documentation\nRuby on Rails Guides\nGo Documentation\nComparació de llenguatges\nCriteris per apendre un llenguatge de programació\n\nResum\nUn servidor web serveix contingut estàtic com HTML, CSS, JavaScript i imatges als clients a través de HTTP o HTTPS. Gestiona sol·licituds entrants i retorna respostes adequades. Exemples de servidors web inclouen Apache, Nginx i Microsoft IIS, cadascun amb funcionalitats úniques com la redirecció d'URLs, suport per a HTTPS i gestió de peticions HTTP. A més, utilitzen llenguatges interpretats (PHP, Python), compilats (Java) i intermediaris (Node.js) per executar codi.\n5. Servidors d'Aplicacions\nUn servidor d'aplicacions és un tipus de servidor dissenyat per executar aplicacions web dinàmiques i gestionar la lògica de negoci d'una aplicació. Aquest servidor actua com una capa intermèdia entre el client (navegador web) i les bases de dades o altres serveis de backend, proporcionant un entorn d'execució per a aplicacions web.\nPrincipals Funcionalitats dels Servidors d'Aplicacions\nGestió de Sessions\n\nDescripció: Manteniment de l'estat de l'usuari durant la seva interacció amb l'aplicació.\nExemple: Sessions PHP que emmagatzemen informació de l'usuari.\n\nConcurrència\n\nDescripció: Capacitat per gestionar múltiples peticions simultànies de manera eficient.\nExemple: Node.js gestiona peticions de manera asíncrona.\n\nSeguretat\n\nDescripció: Autenticació i autorització dels usuaris per accedir a diferents parts de l'aplicació.\nExemple: Utilització de JWT (JSON Web Tokens) per autenticar usuaris en una aplicació Node.js.\n\nRelació entre Servidors Web i Servidors d'Aplicacions\nIntegració i Col·laboració\nEls servidors web treballen conjuntament amb els servidors d'aplicacions per gestionar les sol·licituds de manera eficient. Mentre que el servidor web maneja les sol·licituds HTTP i serveix contingut estàtic, el servidor d'aplicacions processa la lògica de negoci i genera contingut dinàmic.\nExemple de Configuració\n\nServidor Web (Nginx): Actua com a proxy invers, encaminant les sol·licituds dinàmiques al servidor d'aplicacions.\nServidor d'Aplicacions (Node.js): Gestiona les sol·licituds dinàmiques, executa la lògica de negoci i retorna les respostes al servidor web.\n\nConfiguració de Nginx com a Proxy Invers\nserver {\nlisten 80;\nserver_name example.com;\n\nlocation / {\nproxy_pass http://localhost:3000;\nproxy_set_header Host $host;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\n}\n}\n\nConfiguració servidor d'aplicacions Node.js\n\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) =&gt; {\nres.send('Hola, món!');\n});\n\napp.listen(3000, () =&gt; {\nconsole.log('Servidor escoltant a http://localhost:3000');\n});\n\nAquesta col·laboració permet una gestió eficient de les sol·licituds i una millor distribució de la càrrega, millorant el rendiment i l'escalabilitat de les aplicacions web.\nExemples de Servidors d'Aplicacions\nApache Tomcat\n\nDescripció: Un servidor d'aplicacions de codi obert per a aplicacions web Java.\nFuncionalitats: Suporta servlets Java i JavaServer Pages (JSP), facilitant l'execució d'aplicacions Java.\n\nMicrosoft Internet Information Services (IIS)\n\nDescripció: Un servidor web i d'aplicacions de Microsoft per a plataformes Windows.\nFuncionalitats: Suporta aplicacions ASP.NET, autenticació integrada, i eines de gestió robustes.\n\nJBoss EAP (Enterprise Application Platform)\n\nDescripció: Un servidor d'aplicacions Java EE de codi obert desenvolupat per Red Hat.\nFuncionalitats: Proporciona un entorn robust per a la implementació d'aplicacions empresarials amb suport per a diversos frameworks Java.\n\nNode.js\n\nDescripció: Una plataforma per a l'execució de codi JavaScript en el servidor.\nFuncionalitats: Permet la programació asíncrona, ideal per a aplicacions en temps real i escalables com xats i jocs multijugador.\n\n!!! info\nTant els servidors web com els servidors d'aplicacions s'estudien en el mòdul de &quot;Desplegament d'Aplicacions Web&quot;.\nRecursos addicionals\n\nWhat is an Application Server?\nApache Tomcat Documentation\nJBoss Documentation\nGlassFish Documentation\nSpring Framework Documentation\n\nResum\nEls servidors d'aplicacions executen aplicacions dinàmiques i proporcionen serveis empresarials. Es diferencien dels servidors web en què no només serveixen contingut estàtic, sinó que també processen lògica d'aplicació i interaccions de base de dades. Exemples inclouen Apache Tomcat, JBoss i GlassFish, utilitzats per a aplicacions Java. També donen suport a tecnologies com servlets, JSP, EJB i frameworks com Spring, facilitant la construcció d'aplicacions robustes i escalables.\n6.Frameworks de Programació en Entorn Servidor\nUn framework és una plataforma de desenvolupament que proporciona una estructura estandarditzada per a la creació d'aplicacions web. Facilita i accelera el procés de desenvolupament oferint biblioteques de codi preescrit, components reutilitzables i un conjunt de bones pràctiques. Els frameworks ajuden els desenvolupadors a centrar-se en la funcionalitat de l'aplicació en lloc de preocupar-se pels aspectes bàsics i repetitius de la programació.\nPrincipals Frameworks en Entorn Servidor\nExpress.js\n\nDescripció: Express.js és un framework web minimalista per a Node.js. Proporciona eines senzilles i flexibles per a la creació d'aplicacions web i API.\nCaracterístiques:\n\nMiddleware per a gestionar peticions HTTP.\nSistema d'enrutament senzill i modular.\nSuport per a motors de plantilles com Pug i EJS.\n\nAvantatges:\n\nLleuger i flexible.\nGran comunitat de suport i moltes extensions disponibles.\n\nInconvenients:\n\nRequereix més configuració manual comparat amb altres frameworks.\n\nDjango\n\nDescripció: Django és un framework de programació web d'alt nivell per a Python que permet un desenvolupament ràpid i un disseny net i pragmàtic.\nCaracterístiques:\n\nInclou un ORM (Object-Relational Mapping) potent.\nSistema d'administració automàtic.\nSeguretat integrada.\n\nAvantatges:\n\nPromou les bones pràctiques de desenvolupament.\nMolt complet, amb moltes funcionalitats &quot;out-of-the-box&quot;.\n\nInconvenients:\n\nPot ser massa gran per a aplicacions petites.\n\nLaravel\n\nDescripció: Laravel és un framework PHP elegant i expressiu que ofereix un conjunt complet d'eines i recursos per a construir aplicacions web.\nCaracterístiques:\n\nSistema d'enrutament senzill i potent.\nEloquent ORM per a una interacció fàcil amb bases de dades.\nSistema de templates Blade.\n\nAvantatges:\n\nGran comunitat i abundant documentació.\nFacilitat per a desenvolupar aplicacions robustes i escalables.\n\nInconvenients:\n\nPot tenir una corba d'aprenentatge per als nous desenvolupadors.\n\nComparativa dels Frameworks\n\nCaracterística\nExpress.js\nDjango\nLaravel\n\nIdioma de programació\nJavaScript\nPython\nPHP\n\nORM\nNo integrat, però es pot utilitzar Sequelize o Mongoose\nSí (integrat)\nSí (integrat, Eloquent ORM)\n\nSistema d'enrutament\nSí\nSí\nSí\n\nMotor de plantilles\nSuport per Pug, EJS, etc.\nSí (Django Templates)\nSí (Blade)\n\nSistema d'administració\nNo\nSí\nNo\n\nComunitat\nGran\nGran\nGran\n\nFacilitat d'aprenentatge\nModerada\nModerada\nModerada\n\nDocumentació\nExcel·lent\nExcel·lent\nExcel·lent\n\nSeguretat\nDepèn de la configuració\nAlta, amb funcions integrades\nAlta, amb funcions integrades\n\nCom Trieu un Framework?\nLa selecció del framework adequat per a un projecte depèn de diversos factors:\n\nTipus de Projecte: Aplicacions en temps real, aplicacions CRUD, aplicacions amb necessitats específiques de seguretat, etc.\nIdioma de Programació: Si el teu equip està més familiaritzat amb JavaScript, Python o PHP, per exemple.\nEscalabilitat i Rendiment: Alguns frameworks són més adequats per a aplicacions petites, mentre que altres gestionen millor aplicacions de gran escala.\nEcosistema i Comunitat: La disponibilitat de biblioteques, plugins i la mida de la comunitat poden influir en la decisió.\nFacilitat d'ús i Documentació: Un bon framework ha de tenir una documentació clara i fàcil d'entendre, així com una corba d'aprenentatge adequada per al teu equip.\n\nRecursos Addicionals:\n\nNode.js Official Documentation: Node.js\nExpress.js Official Documentation: Express.js\nDjango Official Documentation: Django\nLaravel Documentation: Laravel\n\n7. Entorn de treball\nEntorn de desenvolupament integrat (IDE)\nEn este curso utilitzarem Visual Studio Code com a editor de codi. Existixen altres alternatives, com PHP Storm.\nGitHub Classroom\nUs haureu de registrar ja que l'utilitzarem durant el curs per la còpia de repositoris i entrega de treballs.\nMetodologia de treball amb el github classroom\n\nSe proporcionarà a l'alumnat un enllaç amb la invitació.\nAccedint a l'enllaç a cada alumne se li crearà un repositori individual en l'organització.\nL'alumnat treballa en el seu repositori assignat. Se'l pot baixar per treballar en local.\nInicialment, l'alumne crea una branca nova sobre la que va a treballar.\nQuan vullga sol.licitar ajuda o revisió del professor, l'alumne genera una pull request a la branca principal del seu repositori en la que cita al professor per tal que reba una notificació.\nEl profesor proporciona retroalimentació mitjançant comentaris en la pull request o en un determinat commit individual.\nOpcionalment es poden utilitzar els issues y les cites d'usuari per sol·licitar la intervenció del profesor.\nQuan l'alumne finalitza la tasca, genera una últim pull request\nEl profesor revisa la pull request i opcionalment fa comentaris.\n\nEntorns de desenvolupament local\nPera fer correr les aplicacions de servidor ens cal, com a mínim, un servidor web, l'interpret de php i un motor de base de dades. Hem de distinguir l'entorn de desenvolupament, on anem a programar i mantindre la nostra aplicació, de l'entorn de producció, on anem a executar-la.\nNormalment el primer depén de nosaltres mentre que el segon pot dependre de l'empresa on s'allotjarà la nostra web. Per a preparar el nostre entorn de desenvolupament podem optar per:\n\nQualsevol solució LAMP (Linux, Apache, Mysql, PHP). Als que haurem d'afegir, una vegada els projectes es facen grans composer, git i les opcions de la part de client.\nUna màquina virtual ja configurada.\nUna solució docker.\n\nLa primera solució és senzilla d'implementar però no hauria de ser la nostra primera opció per:\n\nEstem possant en funcionament en la nostra màquina una sèrie de serveis que normalment no fariem, baixant el rendiment de la màquina i obrint vulnerabilitats.\nSi treballem en grup, les instal·lacions i el funcionament no són iguals, depenen del sistema operatiu que té instal·lat cadascú. Allò que li funciona a ú pot ser no li funciona a un altre. Això és inevitable quan el projecte es complica i es perd molt de temps.\nPassa el mateix quan passem a l'entorn de producció.\n\nLa segona solució soluciona els dos primers problemes, doncs tots els desenvolupadors poden tindre virtualitzada, la mateixa màquina. Encara que si la màquina no la fem nosaltres sinó que utilitzem alguna ja configurada (vagrant) o si ens cal instal·lar alguna cosa més, ho hauria de fer tot l'equip.\nAixí i tot, tindriem les següents desaventatges:\n\nA l'instal·lar una maquina virtual sencera ocupa recursos del sistema.\nLa màquina instal·la més coses de les necessàries habitualment.\nNo reprodueix l'entorn de producció.\n\nLa tercera opció té les següents característiques:\n\nAl principi és més difícil de possar en funcionamet ja que calen coneixements de docker.\nTots els desenvolupadors comparteixen entorn encara que utilitzen màquines o sistemes operatius diferents.\nSi hi ha algun canvi de configuració de l'entorn és fácilment transladable a tots els desenvolupadors.\nEs poden crear tants entorns de desenvolupament com projectes diferents hi hajen.\nEls contenidors ocupen pocs recursos.\nEls projectes es poden possar en producció utilitzan una solució docker de manera inmediata.\n\nXAMPP\nXAMPP (https://www.apachefriends.org/es/index.html) és una distribució composta amb el programari necessari per a desenvolupar en entorn servidor. Es compon de les següents eines sobre la base de les seues sigles:\nDes de la pròpia pàgina es pot descarregar l'arxiu executable per al sistema operatiu del nostre ordinador. Es recomana llegir la FAQ de cada sistema operatiu amb instruccions per a la seua posada en marxa.\n!!! note &quot;Acrònim&quot;\n* X per al sistema operatiu (d'aquí ve que es conega altrament com LAMP o WAMP).\n* A per a Apatxe.\n* M per a MySQL / MariaDB. També inclou phpMyAdmin per a l'administració de la base de dades des d'una interfície web.\n* P per a PHP.\n* P per a Perl.\n!!! note &quot;XAMPP en Windows&quot;\nSi treballes amb el teu propi ordinador, XAMPP és una solució més senzilla que Docker, sobretot si treballes amb Windows com a sistema operatiu.\nDocker\nDocker (https://www.docker.com) és un gestor de contenidors, considerant un contenidor com un mètode de virtualització del sistema operatiu.\nL'ús de contenidors requereix menys recursos que una màquina virtual, per tant, el seu llançament i detenció són més ràpids que les màquines virtuals.\nAixí doncs, Docker permet crear, provar i implementar aplicacions ràpidament, a partir d'una sèrie de plantilles que es coneixen com a imatges de Docker.\nPer a això, instal·larem Docker Desktop (https://www.docker.com/products/docker-desktop) en els nostres entorns de desenvolupament (el qual ja inclou en nucli de Docker i l'eina docker compose).\nAl llarg del curs anirem creant diferents contenidors amb els serveis necessaris, de manera que cada vegada només treballem amb el programari mínim.\n!!! note &quot;Docker en windows&quot;\nPer a instal·lar-ho en Windows, és necessari instal·lar prèviament WSL 2, el qual és un subsistema de Linux dins de Windows.\nPlantilla Inicial : Servidor Web nginx + PHP + MySQL + phpMyAdmin\nDocker es basa en l'ús d'imatges per a crear contenidors. Docker Compose simplifica el treball amb múltiples contenidors, i per això, per a facilitar l'arranc, ens centrarem en Docker Compose utilitzant una plantilla que únicament contindrà com a serveis Nginx i PHP.\nPer a facilitar la posada en marxa, us facilite un repositori, disponible per a la seua descarrega mitjançant el git clone.\n\nGrup A: github classroom Nginx/PHP\nGrup B: github classroom Nginx/PHP\n\nL'haureu de possar en un directori fàcilment localitzable i amb un nom significatiu, ja que serà el vostre directori de treball.\nDins d'este repositori, el fitxer 'docker-compose.yaml' indica quines màquines ha de montar i té el següent aspecte\n=== &quot;Nginx i PHP&quot;\n``` yaml\n# Services\nservices:\n# Nginx Service\nnginx:\nimage: nginx:1.19\nports:\n- 80:80\nvolumes:\n- ./src:/var/www/php\n- ./.docker/nginx/conf.d:/etc/nginx/conf.d\ndepends_on:\n- php\n# PHP Service\nphp:\nbuild: ./.docker/php/\nworking_dir: /var/www/php\nexpose:\n- 9000\nvolumes:\n- ./src:/var/www/php\n- ./.docker/php/conf.d/Xdebug.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n- ./.docker/php/conf.d/error_reporting.ini:/usr/local/etc/php/conf.d/error_reporting.ini\n```\nPer arrencar les màquines o podem fer des de la consola amb\ndocker compose up -d\n\nSi volem accedir a un terminal interactiu dins del contenidor:\ndocker exec -it nombreContenedor bash\n\nAltres comandos que podem arribar a utilitzar són:\n\ndocker ps: Veure els contenidors que es estan executant\ndocker ps -a: Veure tots els contenidors\ndocker start nombreContenedor: Arrancar un contenidor\ndocker images: Veure les imatges que tenim descarregades\n\n!!! tip &quot;Docker stack&quot;\nExisteixen diverses opcions mitjançant Docker que ofereixen solucions completes i empaquetes per a tot el stack de desenvolupament. Com a exemple tenim Devilbox (http://devilbox.org) i Laradock (https://laradock.io)\nUna altra forma més senzilla per a llançar de nou els contenidors i gestionar-los una vegada creats és utilitzar la interfície gràfica que ofereix Docker Desktop:\n\nArranc de contenidor mitjançant Docker Desktop\n\n!!! note &quot;Tot funciona&quot;\nHeu de comprovar que a l'accedir a http://localhost/phpinfo.php en el vostre navegador se us obre una pàgina amb la configuració de php.\nTambé si accediu a http://localhost:8000 veureu la pàgina d'accès a phpmyadmin.\n!!! important &quot;Directoris de php&quot;\nSi us fixeu en les carpetes que us ha creat el repositori veureu que les pàgines que pot executar (directori arrel de la nostra web) es troba a php/src. Les pàgines que anem a crear , de moment, les haureu de ficar ahí.\n8. Referències\nLlibres Recomanats\n\nWeb Architecture: Core Concepts de Richard N. Taylor, Nenad Medvidovic i Eric Dashofy\n\nAquest llibre ofereix una visió profunda sobre els conceptes bàsics i els principis fonamentals de les arquitectures web, incloent-hi patrons de disseny i les millors pràctiques.\n\nRESTful Web APIs de Leonard Richardson i Mike Amundsen\n\nSe centra en el disseny i la construcció d'APIs web RESTful, un component essencial de les arquitectures modernes basades en serveis web.\n\nBuilding Microservices: Designing Fine-Grained Systems de Sam Newman\n\nExplora el disseny de microserveis, una arquitectura emergent que permet crear aplicacions escalables i flexibles.\n\nDocumentació Oficial i Guies\n\nThe Twelve-Factor App\n\nUna metodologia per construir aplicacions web modernes que són fàcilment escalables i mantenibles.\n\nDocumentació de l'Arquitectura de PWA (Progressive Web Apps)\n\nGuia detallada sobre el disseny i la implementació d'aplicacions web progressives, que combinen el millor de les aplicacions web i mòbils.\n\nCursos en Línia\n\nCoursera - Web Application Architectures\n\nCurs que proporciona una visió general de les arquitectures d'aplicacions web, incloent-hi clients i servidors, HTTP, i serveis web.\n\nUdacity - Full Stack Web Developer Nanodegree\n\nAquest programa cobreix temes com arquitectures de servidor, autenticació, i API RESTful.\n\nRecursos Addicionals\n\nMicroservices.io\n\nRecursos sobre patrons de microserveis, arquitectures i millors pràctiques per implementar microserveis amb èxit.\n\nMartin Fowler's Blog\n\nUn blog que cobreix diversos aspectes de l'arquitectura del programari, incloent-hi articles sobre disseny de microserveis i altres arquitectures emergents.\n\nExemples i Tutorials\n\nDigitalOcean Community Tutorials\n\nOfereix tutorials pràctics sobre una àmplia gamma de temes relacionats amb l'arquitectura web, des de configuració de servidors fins a desplegament d'aplicacions.\n\nMozilla Developer Network (MDN) Web Docs\n\nUn recurs complet per aprendre sobre tecnologies del costat del servidor, protocols web, i altres conceptes clau de les arquitectures web.\n\nRepositoris de Codi\n\nAwesome Scalability\n\nUna col·lecció de recursos i exemples sobre escalabilitat, arquitectures web i disseny de sistemes distribuits.\n\nGitHub Microservices Examples\n\nRepositoris de codi font en GitHub que il·lustren com implementar microserveis i altres arquitectures web modernes.\n\n9.AutoAvaluació\nExercici 1: Models d'execució de codi\nPregunta:\nExplica les principals diferències entre el model d'execució de codi en client i en servidor.\nOpcions:\n\na) El codi en client s'executa al servidor, mentre que el codi en servidor s'executa al navegador del client.\n\nb) El codi en client s'executa al navegador del client, mentre que el codi en servidor s'executa al servidor.\n\nc) Ambdós s'executen al servidor.\n\nd) Ambdós s'executen al navegador del client.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0, length = radios.length; i < length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) El codi en client s'executa al navegador del client, mentre que el codi en servidor s'executa al servidor.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Avantatges de la generació dinàmica de pàgines\nPregunta:\nQuins són els avantatges de la generació dinàmica de pàgines web? Selecciona totes les que apliquen.\nOpcions:\n\na) Reducció de la càrrega del servidor.\n\nb) Personalització del contingut per usuari.\n\nc) Major interactivitat amb l'usuari.\n\nd) Menor temps de càrrega inicial de la pàgina.\n\nfunction checkAnswer2() {\nvar correctAnswers = [\"b\", \"c\"];\nvar checkboxes = document.getElementsByName('question2');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són b) Personalització del contingut per usuari i c) Major interactivitat amb l'usuari.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Mecanismes d'execució de codi en els servidors web\nPregunta:\nQuins dels següents són mecanismes d'execució de codi en els servidors web?\nOpcions:\n\na) CGI (Common Gateway Interface).\n\nb) API Gateway.\n\nc) Servlets.\n\nd) Totes les anteriors.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"d\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0, length = radios.length; i < length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és d) Totes les anteriors.\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Funcionalitats dels servidors d'aplicacions\nPregunta:\nQuines són algunes de les funcionalitats proporcionades pels servidors d'aplicacions?\nOpcions:\n\na) Gestió de sessions.\n\nb) Autenticació d'usuaris.\n\nc) Generació de pàgines estàtiques.\n\nd) Gestió de transaccions.\n\nfunction checkAnswer4() {\nvar correctAnswers = [\"a\", \"b\", \"d\"];\nvar checkboxes = document.getElementsByName('question4');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Gestió de sessions, b) Autenticació d'usuaris, d) Gestió de transaccions.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Llenguatges i tecnologies relacionades amb la programació web en entorn servidor\nPregunta:\nQuins dels següents llenguatges i tecnologies són utilitzats en la programació web en entorn servidor?\nOpcions:\n\na) PHP.\n\nb) SQL.\n\nc) HTML.\n\nd) JavaScript.\n\ne) Java.\n\nfunction checkAnswer5() {\nvar correctAnswers = [\"a\", \"b\", \"e\"];\nvar checkboxes = document.getElementsByName('question5');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) PHP, b) SQL, e) Java.\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Integració dels llenguatges de marques amb els llenguatges de programació\nPregunta:\nCom s'integren els llenguatges de marques com HTML amb els llenguatges de programació com PHP?\nOpcions:\n\na) Utilitzant etiquetes especials de PHP dins del codi HTML.\n\nb) Convertint tot el codi HTML a PHP.\n\nc) No es poden integrar.\n\nd) Utilitzant un altre llenguatge de programació per connectar-los.\n\nfunction checkAnswer6() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question6');\nvar userAnswer;\nfor (var i = 0, length = radios.length; i < length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Utilitzant etiquetes especials de PHP dins del codi HTML.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Eines i frameworks de programació en entorn servidor\nPregunta:\nQuines són algunes de les eines i frameworks més utilitzats en la programació web en entorn servidor?\nOpcions:\n\na) Laravel.\n\nb) Django.\n\nc) React.\n\nd) Node.js.\n\ne) Spring Boot.\n\nfunction checkAnswer7() {\nvar correctAnswers = [\"a\", \"b\", \"d\", \"e\"];\nvar checkboxes = document.getElementsByName('question7');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Laravel, b) Django, d) Node.js, e) Spring Boot.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": [ "note","PHP"]
},

{
		"title": "1.1 Entornos de desarrollo",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/1-arquitecturas-web/1-1-entornos-de-desarrollo/",
		"content": "Entorn de desenvolupament\nPera fer correr les aplicacions de servidor ens cal, com a mínim, un servidor web, l'interpret de php i un motor de base de dades. Hem de distinguir l'entorn de desenvolupament, on anem a programar i mantindre la nostra aplicació, de l'entorn de producció, on anem a executar-la.\nNormalment el primer depén de nosaltres mentre que el segon pot dependre de l'empresa on s'allotjarà la nostra web. Per a preparar el nostre entorn de desenvolupament podem optar per:\n\nQualsevol solució LAMP (Linux, Apache, Mysql, PHP). Als que haurem d'afegir, una vegada els projectes es facen grans composer, git i les opcions de la part de client.\nUna màquina virtual ja configurada.\nUna solució docker.\n\nLa primera solució és senzilla d'implementar però no hauria de ser la nostra primera opció per:\n\nEstem possant en funcionament en la nostra màquina una sèrie de serveis que normalment no fariem, baixant el rendiment de la màquina i obrint vulnerabilitats.\nSi treballem en grup, les instal·lacions i el funcionament no són iguals, depenen del sistema operatiu que té instal·lat cadascú. Allò que li funciona a ú pot ser no li funciona a un altre. Això és inevitable quan el projecte es complica i es perd molt de temps.\nPassa el mateix quan passem a l'entorn de producció.\n\nLa segona solució soluciona els dos primers problemes, doncs tots els desenvolupadors poden tindre virtualitzada, la mateixa màquina. Encara que si la màquina no la fem nosaltres sinó que utilitzem alguna ja configurada (vagrant) o si ens cal instal·lar alguna cosa més, ho hauria de fer tot l'equip.\nAixí i tot, tindriem les següents desaventatges:\n\nA l'instal·lar una maquina virtual sencera ocupa recursos del sistema.\nLa màquina instal·la més coses de les necessàries habitualment.\nNo reprodueix l'entorn de producció.\n\nPot ser molt útil, per exemple, quan la fem servir per desenvolupar en un framework, que ja ve configurat per fer-lo funcionar inmediatament i amb totes les característiques instal·lades.\nLa tercera opció té les següents característiques:\n\nAl principi és més difícil de possar en funcionamet ja que calen coneixements de docker.\nTots els desenvolupadors comparteixen entorn encara que utilitzen màquines o sistemes operatius diferents.\nSi hi ha algun canvi de configuració de l'entorn és fácilment transladable a tots els desenvolupadors.\nEs poden crear tants entorns de desenvolupament com projectes diferents hi hajen.\nEls contenidors ocupen pocs recursos.\nEls projectes es poden possar en producció utilitzan una solució docker de manera inmediata.\n\nXAMPP\nXAMPP (https://www.apachefriends.org/es/index.html) és una distribució composta amb el programari necessari per a desenvolupar en entorn servidor. Es compon de les següents eines sobre la base de les seues sigles:\n\nX per al sistema operatiu (d'aquí ve que es conega altrament com LAMP o WAMP).\nA per a Apatxe.\nM per a MySQL / MariaDB. També inclou phpMyAdmin per a l'administració de la base de dades des d'una interfície web.\nP per a PHP.\nl'última P per a Perl.\n\nDes de la pròpia pàgina es pot descarregar l'arxiu executable per al sistema operatiu del nostre ordinador. Es recomana llegir la FAQ de cada sistema operatiu amb instruccions per a la seua posada en marxa.\n!!! note &quot;XAMPP en Windows&quot;\nSi treballes amb el teu propi ordinador, XAMPP és una solució més senzilla que Docker, sobretot si treballes amb Windows com a sistema operatiu.\nDocker\nDocker (https://www.docker.com) és un gestor de contenidors, considerant un contenidor com un mètode de virtualització del sistema operatiu.\nL'ús de contenidors requereix menys recursos que una màquina virtual, per tant, el seu llançament i detenció són més ràpids que les màquines virtuals.\nAixí doncs, Docker permet crear, provar i implementar aplicacions ràpidament, a partir d'una sèrie de plantilles que es coneixen com a imatges de Docker.\nPer a això és necessari tindre instal·lat Docker Desktop (https://www.docker.com/products/docker-desktop) en els nostres entorns de desenvolupament (el qual ja inclou en nucli de Docker i l'eina docker compose). Per a instal·lar-ho en Windows, és necessari instal·lar prèviament WSL 2, el qual és un subsistema de Linux dins de Windows.\nAl llarg del curs anirem creant diferents contenidors amb els serveis necessaris, de manera que cada vegada només treballem amb el programari mínim.\n!!! caution &quot;Versions&quot;\nAl llarg del curs usarem PHP 8.1. Respecte a Docker, per a escriure les anotacions hem utilitzat la versio 20.10 i la versio 2.19 de docker compose. Finalment, la versió de Docker Desktop que hem utilitzat és la 4.0.\nInstal·lació de docker\nLa instal·lació de docker dependrà del sistema operatiu que estem utilitzant. Ací anem a vore la que efecturan els que utilitzen linux, amb el sistema operatiu linux-mint o ubuntu , que és el que ve instal·lat en les imatges suministrades. Per a mac o windows s'haurà de mirar la pàgina web de docker\nEns donem privilegis\nsudo su\n\nUtilitzant els repositoris de docker l'instal·lem:\necho &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable&quot; | tee /etc/apt/sources.list.d/docker.list\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -\n\napt update\n\napt install docker-ce docker-ce-cli containerd.io pigz\n\nDonem permisos a l'usuari afegint-lo al grup de docker\nusermod -aG docker $USER\n\nOn $USER és el teu usuari.\nTambé haurem d'instal·lar el docker-compose\ncurl -SL &quot;https://github.com/docker/compose/releases/download/v2.10.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n\nchmod +x /usr/local/bin/docker-compose\n\nI provem\ndocker --version\n\nFaltarà engegar el servei de docker per a poder executar contenidors\nsudo systemctl start docker.service\n\nPlantilla Servidor Web + PHP\nDocker es basa en l'ús d'imatges per a crear contenidors. Docker Compose simplifica el treball amb múltiples contenidors, i per això, per a facilitar l'arranc, ens centrarem en Docker Compose utilitzant una plantilla que únicament contindrà com a serveis Nginx i PHP.\nPer a facilitar la posada en marxa, us facilite un repositori en github classroom Nginx/PHP disponible per a la seua descàrrega. L'haureu de possar en un directori fàcilment localitzable i amb un nom significatiu, ja que serà el vostre directori de treball.\nDins d'este repositori, el fitxer 'docker-compose.yaml' indica quines màquines ha de montar i té el següent aspecte\n=== &quot;Nginx i PHP&quot;\n``` yaml\n# Services\nservices:\n# Nginx Service\nnginx:\nimage: nginx:1.19\nports:\n- 80:80\nvolumes:\n- ./src:/var/www/php\n- ./.docker/nginx/conf.d:/etc/nginx/conf.d\ndepends_on:\n- php\n# PHP Service\nphp:\nbuild: ./.docker/php/\nworking_dir: /var/www/php\nexpose:\n- 9000\nvolumes:\n- ./src:/var/www/php\n- ./.docker/php/conf.d/Xdebug.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n- ./.docker/php/conf.d/error_reporting.ini:/usr/local/etc/php/conf.d/error_reporting.ini\n# Más info en\n# https://tech.osteel.med/posts/docker-for-local-web-development-part-1-a-basic-lemp-stack\n# Lanzar con\n# docker-compose up -d\n# Ver los logs con\n# docker-compose logs -f\n```\nPer arrencar les màquines o podem fer des de la consola amb\ndocker compose up -d\n\nSi volem accedir a un terminal interactiu dins del contenidor:\ndocker exec -it nombreContenedor bash\n\nAltres comandos que podem arribar a utilitzar són:\n\ndocker ps: Veure els contenidors que es estan executant\ndocker ps -a: Veure tots els contenidors\ndocker start nombreContenedor: Arrancar un contenidor\ndocker images: Veure les imatges que tenim descarregades\n\nUna altra forma més senzilla per a llançar de nou els contenidors i gestionar-los una vegada creats és utilitzar la interfície gràfica que ofereix Docker Desktop:\n\n!!! tip &quot;Docker stack&quot;\nExisteixen diverses opcions mitjançant Docker que ofereixen solucions completes i empaquetes per a tot el stack de desenvolupament. En posteriors sessions utilitzarem tant Devilbox (http://devilbox.org) com Laradock (https://laradock.io)\n!!! question &quot;Però vull saver com funciona...&quot;\nEn el mòdul de Desplegament d'aplicacions estudiareu en profunditat, a més de Docker, Apatxe i altres serveis que ens serviran d'ajuda per al desenvolupament en entorn servidor.\nTot funciona\nHeu de comprovar que a l'accedir a http://localhost en el vostre navegador se us obre una pàgina de salutació.\nEntorn de desenvolupament\nEn este curso utilitzarem PHP Storm com a entorn de desenvolupament. Existixen altres alternatives, com Visual Studio Code.\nInstal·lació\nPodem fer-ho de manera automàtica utilitzant snap. Per fer-ho amb linux-mint\nsudo rm /etc/apt/preferences.d/nosnap.pref\nsudo apt update\nsudo apt install snapd\nsudo snap install phpstorm --classic\n\nTambé es pot instal·lar baixant-se el paquet de la pàgina web.\nLlicència\nPodeu sol·licitar una llicència a i.gomismullor@edu.gva.es\nEntorn de proves\nLa màquina docker ve configurada amb codeception i una col·leció de proves per als exercicis que desenvoluparem al llarg de les primeres unitats.\nS'ha creat un shell per executar totes les proves\nsh test.sh\n\nGitHub Classroom\nUs podeu registrar\nMetodologia de treball amb el github classroom\n\nSe proporcionarà a l'alumnat un enllaç amb la invitació.\nAccedint a l'enllaç a cada alumne se li crearà un repositori individual en l'organització.\nL'alumnat treballa en el seu repositori assignat. Se'l pot baixar per treballar en local.\nInicialment, l'alumne crea una branca nova sobre la que va a treballar.\nQuan vullga sol.licitar ajuda o revisió del professor, l'alumne genera una pull request a la branca principal del seu repositori en la que cita al professor per tal que reba una notificació.\nEl profesor proporciona retroalimentació mitjançant comentaris en la pull request o en un determinat commit individual.\nOpcionalment es poden utilitzar els issues y les cites d'usuari per sol·licitar la intervenció del profesor.\nQuan l'alumne finalitza la tasca, genera una últim pull request\nEl profesor revisa la pull request i opcionalment fa comentaris.\n\nReferències\n\nCurs de introducció a Docker, per Sergi García Barea : https://sergarb1.github.io/CursoIntroduccionADocker/\nArticle Arquitectures Web i sa evolució\n\nVideos\n\nTriar un llenguatge de programació\n\nInstal.Lació entorn de desenvolupament",
		"tags": [ "note","PHP"]
},

{
		"title": "Introducción a PHP",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/DAW/PHP Teoria Batoi/2. Introduccion a PHP/Introducción a PHP/",
		"content": "=, `",
		"tags": [ "note"]
},

{
		"title": "Programación en Web",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/3-programacion-en-web/programacion-en-web/",
		"content": "Programació Web\n1. Mecanismes per al Manteniment de la Informació en Aplicacions Web\nHTTP és un protocol stateless, sense estat. En les aplicacions web modernes, és essencial gestionar l'estat del client per proporcionar una experiència d'usuari fluida i personalitzada.\nPer això, se simula l'estat mitjançant l'ús de cookies, tokens o la sessió. L'estat és necessari per a processos com ara el carret de la compra, operacions associades a un usuari, etc...\nA continuació es detallen diversos mecanismes per mantenir aquesta informació, així com els seus avantatges i desavantatges.\nCookies\nLes cookies són petits fitxers de text emmagatzemats al navegador de l'usuari. Són àmpliament utilitzades per mantenir l'estat del client entre sol·licituds HTTP, ja que HTTP és un protocol sense estat.\nAvantatges de les Cookies\n\nPersistència: Les cookies poden mantenir-se durant períodes llargs definits per l'atribut expires o max-age.\nAccessibilitat: Es poden accedir des de qualsevol pàgina del mateix domini.\nSimplicitat: Fàcils d'implementar i gestionar.\n\nDesavantatges de les Cookies\n\nSeguretat: Poden ser objectiu d'atacs com XSS (Cross-Site Scripting) si no es gestionen correctament.\nLimitacions de mida: Les cookies estan limitades a 4KB de dades.\nPrivadesa: Les dades de l'usuari poden ser vulnerables si no es protegeixen adequadament.\n\nMillors Pràctiques\n\nUtilitzar l'atribut HttpOnly per evitar l'accés a les cookies des de JavaScript.\nConfigurar SameSite per prevenir atacs CSRF.\nEmmagatzemar únicament informació essencial i no sensible.\n\nSessions\nLes sessions són un mecanisme que permet associar dades a un usuari durant una sessió específica. Aquestes dades s'emmagatzemen al servidor, mentre que el client només guarda un identificador de sessió.\nAvantatges de les Sessions\n\nSeguretat: Les dades sensibles es mantenen al servidor.\nCapacitat d'emmagatzematge: No limitades per la mida de les cookies.\nCompartició de dades: Facilita la compartició d'estat entre diferents components d'una aplicació web.\n\nDesavantatges de les Sessions\n\nEscalabilitat: Requereix memòria addicional al servidor, la qual cosa pot ser problemàtica amb molts usuaris.\nPersistència limitada: Normalment només duren mentre el navegador està obert, tret que es configuri d'una altra manera.\n\nMillors Pràctiques\n\nEmmagatzemar únicament referències o identificadors a la sessió.\nUtilitzar eines com Redis per a una gestió eficient de sessions en entorns escalables.\n\nWeb Storage\nEl Web Storage és una API del navegador que permet emmagatzemar dades al client de manera més senzilla i amb més capacitat que les cookies tradicionals. Inclou dos mecanismes principals: localStorage i sessionStorage.\nCaracterístiques del Web Storage\n\nlocalStorage: Permet emmagatzemar dades que persisteixen fins que s'elimina explícitament, fins i tot després de tancar el navegador.\nsessionStorage: Les dades es mantenen només durant la sessió del navegador i s'esborren quan es tanca la pestanya o finestra.\n\nAvantatges\n\nCapacitat d'Emmagatzematge: Ofereix més espai (fins a 5-10MB) que les cookies.\nAPI Simple: Proporciona una interfície senzilla per emmagatzemar i recuperar dades.\n\nUsos Comuns\n\nManteniment de l'Estat del Client: Pot guardar dades de sessió i preferències de l'usuari que no cal enviar al servidor.\nSincronització amb l'Entorn Servidor: Es pot utilitzar per emmagatzemar dades que després es sincronitzen amb el servidor, millorant el rendiment i l'experiència d'usuari.\n\nConsideracions de Seguretat\n\nAccessibilitat: Les dades són accessibles per JavaScript, per la qual cosa s'ha de tenir cura amb les vulnerabilitats XSS.\nDades Sensibles: Evita emmagatzemar dades sensibles o confidencials.\n\nTot i que Web Storage s'executa al costat del client, entendre les seves funcionalitats pot ajudar els desenvolupadors del servidor a dissenyar sistemes més robustos i eficaços, on la cooperació entre client i servidor maximitza l'eficiència de l'aplicació web.\nTokens d'Autenticació\nEls JSON Web Tokens (JWT) són un estàndard obert que defineix una manera compacta i autònoma d'enviar informació entre dues parts de manera segura com a objecte JSON. S'utilitzen habitualment per a l'autenticació en aplicacions web.\nAvantatges dels JWT\n\nEstatut autònom: Porten tota la informació necessària, eliminant la necessitat de mantenir sessions al servidor.\nEscalabilitat: Milloren l'escalabilitat en aplicacions distribuïdes.\nSeguretat: Es poden signar digitalment per assegurar la seva autenticitat.\n\nDesavantatges dels JWT\n\nRevocació complexa: Una vegada emesos, és difícil revocar-los sense mantenir una llista negra.\nSobrecarrega de dades: Si els tokens són grans, poden afectar el rendiment, especialment en xarxes de baixa latència.\n\nMillors Pràctiques\n\nUtilitzar signatura HS256 o RS256 per garantir la integritat del token.\nNo emmagatzemar dades sensibles directament al token.\n\nCache del Navegador\nEl cache del navegador s'utilitza per emmagatzemar còpies temporals de recursos web per millorar el rendiment i reduir la càrrega del servidor.\nAvantatges del Cache\n\nRendiment: Redueix el temps de càrrega dels recursos.\nOptimització: Disminueix l'ample de banda requerit.\n\nDesavantatges del Cache\n\nConsistència: Pot servir dades obsoletes si no es gestiona correctament.\nControl: Requereix configuració per evitar el caching indesitjat de dades dinàmiques.\n\nMillors Pràctiques\n\nConfigurar els encapçalaments HTTP correctament (Cache-Control, ETag) per gestionar l'actualització de recursos.\n\nSincronització Offline\nLa sincronització offline es refereix a la capacitat d'una aplicació web de funcionar sense connexió a Internet, sincronitzant dades quan es recupera la connexió.\nTècniques i Eines\n\nIndexedDB: Emmagatzema grans volums de dades estructurades dins del navegador.\nService Workers: Gestionen peticions de xarxa, proporcionant funcionalitats offline i cache avançat.\n\nMillors Pràctiques\n\nGestionar conflictes de dades quan es torna a estar en línia.\nUtilitzar estratègies de sincronització optimitzades per minimitzar l'ample de banda i el temps de sincronització.\n\nSeguretat de les Cookies i Sessions\nLa seguretat és fonamental en la gestió de cookies i sessions per protegir les dades dels usuaris de possibles atacs.\nPràctiques de Seguretat\n\nCSRF: Utilitzar tokens CSRF per validar sol·licituds d'accions sensibles.\nXSS: Sanear les dades d'entrada i utilitzar capçaleres de seguretat (Content-Security-Policy) per prevenir XSS.\nSecure Flag: Marcar les cookies amb l'atribut Secure perquè només s'enviïn a través de connexions HTTPS.\n\nConclusió\nLa selecció del mecanisme adequat per al manteniment de l'estat en una aplicació web depèn de les necessitats específiques de l'aplicació, el volum de dades, els requisits de seguretat i l'arquitectura del sistema. Avaluar cada tècnica pel que fa a avantatges i desavantatges ajudarà a prendre decisions informades i construir aplicacions web més segures i eficients.\n2.Exemples de Cookies i Sessions en PHP\nCookies\nLes cookies s'emmagatzemen en el array global $_COOKIE. El que col·loquem dins del array, es guardarà en el client. Cal tindre present que el client pot no voler emmagatzemar-les.\nExisteix una limitació de 20 cookies per domini i 300 en total en el navegador.\nEn PHP, per a crear una cookie s'utilitza la funció setcookie:\n&lt;?php\nsetcookie(\n'nom_cookie',\n'valor_cookie',\n[\n'expires' =&gt; time() + 3600, // 1 hora\n'path' =&gt; '/',\n'domain' =&gt; '', // Domini actual\n'secure' =&gt; true, // Només HTTPS\n'httponly' =&gt; true, // Només accessible via HTTP\n'samesite' =&gt; 'Lax' // o 'Strict' o 'None'\n]\n);\n?&gt;\n\nDestacar que el nom no pot contindre espais ni el caràcter ;. Respecte al contingut de la cookie, no pot superar els 4 KB.\nConsideracions de seguretat per a cookies:\nHTTPOnly: Assegura't que les cookies que contenen informació sensible no siguin accessibles per JavaScript utilitzant l'atribut HttpOnly.\nSecure: Utilitza l'atribut Secure per assegurar que les cookies només es transmeten en connexions HTTPS.\nSameSite: Defineix correctament l'atribut SameSite per a prevenir atacs CSRF (Cross-Site Request Forgery).\nPer exemple, mitjançant cookies podem comprovar la quantitat de visites diferents que realitza un usuari:\n&lt;?php\n$accesosPagina = 0;\nif (isset($_COOKIE['accesos'])) { \n$accesosPagina = $_COOKIE['accesos']; // recuperamos una cookie\nsetcookie('accesos', ++$accesosPagina); // le asignamos un valor\n}\n?&gt;\n\n!!! tip &quot;Inspeccionant les cookies&quot;\nSi volem veure que contenen les cookies que tenim emmagatzemades en el navegador, es pot comprovar el seu valor en Dev Tools --&gt; Application --&gt; Storage\nEl temps de vida de les cookies pot ser tan llarg com el lloc web en el qual resideixen. Elles seguiran ací, fins i tot si el navegador està tancat o obert.\nPer a esborrar una cookie es pot posar que expiren en el passat:\n&lt;?php\nsetcookie(nombre, &quot;&quot;, 1) // pasado\n\nO que caduquen dins d'un període de temps deteminado:\n&lt;?php\nsetcookie(nombre, valor, time() + 3600) // Caducan dentro de una hora\n\nS'utilitzen per a:\n\nRecordar els inicis de sessió\nEmmagatzemar valors temporals d'usuari\nSi un usuari està navegant per una llista paginada d'articles, ordenats d'una certa manera, podem emmagatzemar l'ajust de la classificació.\n\nL'alternativa en el client per a emmagatzemar informació en el navegador és l'objecte LocalStorage.\nSessió\nLa sessió afig la gestió de l'estat a HTTP, emmagatzemant en aquest cas la informació en el servidor.\nCada visitant té un ID de sessió únic, el qual per defecte s'emmagatzema en una cookie denominada PHPSESSID.\nSi el client no té les cookies actives, l'ID es propaga en cada URL dins del mateix domini.\nCada sessió té associat un magatzem de dades mitjançant el array global $_SESSION, en el qual podem emmagatzemar i recuperar informació.\nLa sessió comença en executar un script PHP. Es genera un nou ID i es carreguen les dades del magatzem:\n\nLes operacions que podem realitzar amb la sessió són:\n&lt;?php\nsession_start(); // carga la sesión\nsession_regenerate_id(true); // regenera el id\nsession_id() // devuelve el id\n$_SESSION[clave] = valor; // inserción\nsession_destroy(); // destruye la sesión\nunset($_SESSION[clave]; // borrado\n\nVeurem mitjançant un exemple com podem inserir en un pàgina dades en la sessió per a posteriorment en una altra pàgina accedir a aqueixes dades. Per exemple, en sesion.php tindríem\n&lt;?php\n// Iniciar sessió\nsession_start();\nsession_regenerate_id(true);\n\n// Establir valors de sessió\n$_SESSION['usuari'] = 'JohnDoe';\n$_SESSION['rol'] = 'admin';\n\n?&gt;\n\nI posteriorment podem accedir a la sessió en sesion1.php:\n&lt;?php\nsession_start();\n// Recuperar valors de sessió\necho 'Usuari: ' . $_SESSION['usuari'] . '&lt;br&gt;';\necho 'Rol: ' . $_SESSION['rol'] . '&lt;br&gt;';\n\n// Tancar sessió de forma segura\nsession_unset(); // Eliminar totes les variables de sessió\nsession_destroy(); // Destruir la sessió\n?&gt;\n\n[!note] &quot;Configurant la sessió en php.ini&quot;\nLes següent propietats de php.ini permeten configurar alguns aspectes de la sessió: * session.save_handler: controlador que gestiona com s'emmagatzema (files)\n* session.save_path: ruta on s'emmagatzemen els arxius amb les dades (si tenim un clúster, podríem usar /mnt/sessions en tots els servidor de manera que apunten a una carpeta compartida)\n* session.name: nom de la sessió (PHSESSID)\n* session.acte_start: Es pot fer que s'autocarregue amb cada script. Per defecte està deshabilitat\n* session.cookie_lifetime: temps de vida per defecte\n\nMés informació en la documentació oficial.\nSerialització en PHP\nLa serialització és el procés de convertir una estructura de dades o un objecte en una seqüència de caràcters que pot ser fàcilment emmagatzemada o transmesa i després reconstruïda. PHP proporciona dos funcions principals per a això: serialize() i unserialize().\n\nserialize()\nLa funció serialize() en PHP s'utilitza per a convertir una estructura de dades o un objecte en una representació de cadena.\n\n$data = array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n$serialized_data = serialize($data);\necho $serialized_data;\n\nEixida\na:3:{i:0;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;s:1:&quot;c&quot;;}\n\nunserialize()\nLa funció unserialize() en PHP s'utilitza per a convertir la representació de cadena serialitzada de nou en una estructura de dades o un objecte.\n\n$original_data = unserialize($serialized_data);\nprint_r($original_data);\n\nEixida\nArray\n(\n[0] =&gt; a\n[1] =&gt; b\n[2] =&gt; c\n)\n\nUtilitzant amb Sessions\nLes sessions en PHP permeten emmagatzemar informació d'usuari per ser utilitzada en diverses pàgines. Pot ser útil serialitzar dades per a emmagatzemar-les en una sessió:\nIniciant una sessió i emmagatzemant dades serialitzades:\nsession_start();\nsession_regenerate_id(true);\n\n$data = array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n$_SESSION['data_serialitzada'] = serialize($data);\n\nsession_start();\n\nif (isset($_SESSION['data_serialitzada'])) {\n$data = unserialize($_SESSION['data_serialitzada']);\nprint_r($data);\n}\n\nConsideracions de Seguretat:\nÉs crucial entendre que la funció unserialize() pot ser perillosa si s'usa amb dades que no són de confiança, ja que podria portar a l'execució de codi arbitrari. Per això, mai has de deserialitzar dades que vinguen d'una font desconeguda o no fiable sense validar-les prèviament.\n3.Autenticació d'usuaris\nMecanismes d'Autenticació d'Usuaris\n\nMecanisme d'Autenticació\nCaracterístiques\nAvantatges\n\nBàsica (usuari/contrasenya)\nEs requereix un nom d'usuari i una contrasenya per accedir.\nFàcil d'implementar, àmpliament utilitzada.\n\nCookies\nEmmagatzema informació d'autenticació en el navegador de l'usuari.\nPersistència d'inici de sessió, personalització d'experiència.\n\nSessions\nManté l'estat d'autenticació en el servidor amb una identificació de sessió única.\nMajor seguretat, evita la necessitat d'emmagatzemar informació sensible al client.\n\nOAuth\nPermet als usuaris accedir a recursos sense compartir les seves credencials.\nSeguretat millorada, experiència d'usuari simplificada.\n\nJWT (JSON Web Token)\nUtilitza tokens basats en JSON per a l'autenticació.\nLliure d'estat, fàcil de compartir entre diferents serveis.\n\nSAML (Security Assertion Markup Language)\nUtilitza XML per a intercanviar dades d'autenticació entre l'usuari i el servei.\nIntegració amb sistemes d'autenticació empresarial, alt nivell de seguretat.\n\nAutenticació multifactor (MFA)\nRequereix múltiples formes de verificació (per exemple, contrasenya + codi SMS).\nSeguretat augmentada, redueix el risc de compromís de comptes.\n\nExemple amb sessions\nUna sessió estableix una relació anònima amb un usuari particular, de manera que podem saber si és el mateix usuari entre dues peticions diferents. Si preparem un sistema de login, podrem saber qui utilitza la nostra aplicació.\n&lt;?php\n// Llista d'usuaris predefinits amb contrasenyes en text pla\n$users = [\n'user1@example.com' =&gt; 'password1',\n'user2@example.com' =&gt; 'password2',\n];\n\n// Convertir les contrasenyes a un format encriptat\nforeach ($users as $email =&gt; $password) {\n$users[$email] = password_hash($password, PASSWORD_BCRYPT);\n}\n\n// Formulari d'autenticació\nif (isset($_POST['login'])) {\n$email = $_POST['email'];\n$password = $_POST['password'];\n\nif (isset($users[$email]) &amp;&amp; password_verify($password, $users[$email])) {\n// L'usuari està autenticat\nsession_start();\n$_SESSION['user'] = $email;\necho &quot;Login successful. Welcome, &quot; . $email;\n} else {\n// Credencials incorrectes\necho &quot;Invalid email or password.&quot;;\n}\n}\n?&gt;\n&lt;form method=&quot;post&quot;&gt;\nEmail: &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;\nPassword: &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;\n&lt;button type=&quot;submit&quot; name=&quot;login&quot;&gt;Login&lt;/button&gt;\n&lt;/form&gt;\n\nAquest exemple mostra com mantenir l'estat de la sessió d'un usuari una vegada autenticat.\n&lt;?php\nsession_start();\n\nif (!isset($_SESSION['user'])) {\nheader(&quot;Location: login.php&quot;);\nexit();\n}\n\n// Mostra la pàgina només si l'usuari està autenticat\necho &quot;Welcome, &quot; . $_SESSION['user'];\n?&gt;\n\nFinalment, necessitem l'opció de tancar la sessió que col·loquem en logout.php:\n&lt;?php\n// Recuperamos la información de la sesión\nsession_start();\n\n// Y la destruimos\nsession_destroy();\nheader(&quot;Location: index.php&quot;);\n?&gt;\n\n!!! warning &quot;Autenticació en producció&quot;\nEn l'actualitat l'autenticació d'usuari no es realitza gestionant la sessió direcamente, sinó que es realitza mitjançant algun framekwork que abstrau tot el procés o la integració de mecanismes d'autenticació tipus OAuth, com estudiarem en l'última unitat mitjançant Laravel.\nExemple amb cookies\n&lt;?php\n// Llista d'usuaris predefinits amb contrasenyes en text pla\n$users = [\n'user1@example.com' =&gt; 'password1',\n'user2@example.com' =&gt; 'password2',\n];\n\n// Convertir les contrasenyes a un format encriptat\nforeach ($users as $email =&gt; $password) {\n$users[$email] = password_hash($password, PASSWORD_BCRYPT);\n}\n\nif (isset($_POST['login'])) {\n$email = $_POST['email'];\n$password = $_POST['password'];\n\nif (isset($users[$email]) &amp;&amp; password_verify($password, $users[$email])) {\n// Establir una cookie d'autenticació\nsetcookie(&quot;user&quot;, $email, time() + (86400 * 30), &quot;/&quot;); // 86400 = 1 dia\necho &quot;Login successful. Welcome, &quot; . $email;\n} else {\n// Credencials incorrectes\necho &quot;Invalid email or password.&quot;;\n}\n}\n\n// Llegir la cookie\nif (isset($_COOKIE['user'])) {\necho &quot;Welcome back, &quot; . $_COOKIE['user'];\n}\n?&gt;\n&lt;form method=&quot;post&quot;&gt;\nEmail: &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;\nPassword: &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;\n&lt;button type=&quot;submit&quot; name=&quot;login&quot;&gt;Login&lt;/button&gt;\n&lt;/form&gt;\n\n[!warning] &quot;Seguretat en cookies&quot;\nLes cookies són vulnerables a atacs com Cross-Site Scripting (XSS) i Cross-Site Request Forgery (CSRF). Per a protegir-les, s'ha de configurar la cookie com a segura i només accessible a través de la web.\n\nExemple amb JWT\nAquest exemple mostra com generar i verificar un JWT per a l'autenticació.\n&lt;?php\nfunction base64UrlEncode($data) {\nreturn rtrim(strtr(base64_encode($data), '+/', '-_'), '=');\n}\n\nfunction base64UrlDecode($data) {\nreturn base64_decode(strtr($data, '-_', '+/'));\n}\n\nfunction createJWT($header, $payload, $secret) {\n$headerEncoded = base64UrlEncode(json_encode($header));\n$payloadEncoded = base64UrlEncode(json_encode($payload));\n\n$signature = hash_hmac('sha256', &quot;$headerEncoded.$payloadEncoded&quot;, $secret, true);\n$signatureEncoded = base64UrlEncode($signature);\n\nreturn &quot;$headerEncoded.$payloadEncoded.$signatureEncoded&quot;;\n}\n\nfunction verifyJWT($jwt, $secret) {\nlist($headerEncoded, $payloadEncoded, $signatureEncoded) = explode('.', $jwt);\n\n$signature = base64UrlDecode($signatureEncoded);\n$expectedSignature = hash_hmac('sha256', &quot;$headerEncoded.$payloadEncoded&quot;, $secret, true);\n\nif ($signature === $expectedSignature) {\nreturn json_decode(base64UrlDecode($payloadEncoded));\n}\n\nreturn false;\n}\n\n// Exemples d'ús\n$header = ['alg' =&gt; 'HS256', 'typ' =&gt; 'JWT'];\n$payload = ['email' =&gt; 'user1@example.com', 'exp' =&gt; time() + 3600];\n$secret = 'your_secret_key';\n\n$jwt = createJWT($header, $payload, $secret);\necho &quot;JWT: &quot; . $jwt . &quot;\\n&quot;;\n\n$decoded = verifyJWT($jwt, $secret);\nif ($decoded) {\necho &quot;JWT valid: &quot; . json_encode($decoded) . &quot;\\n&quot;;\n} else {\necho &quot;Invalid JWT.\\n&quot;;\n}\n?&gt;\n\nExemple amb MFA\nAquest exemple mostra com afegir una capa addicional d'autenticació amb un codi MFA.\n&lt;?php\nsession_start();\n\nfunction sendMFACode() {\n$code = rand(100000, 999999);\n$_SESSION['mfa_code'] = $code;\n\n// Simular enviament de codi via email o SMS\necho &quot;Verification code: $code&quot;; // En un entorn real, envia el codi per email o SMS.\n}\n\nfunction verifyMFACode($inputCode) {\nreturn isset($_SESSION['mfa_code']) &amp;&amp; $inputCode == $_SESSION['mfa_code'];\n}\n\nif (isset($_POST['send_code'])) {\nsendMFACode();\n}\n\nif (isset($_POST['verify_code'])) {\nif (verifyMFACode($_POST['mfa_code'])) {\necho &quot;MFA successful.&quot;;\n} else {\necho &quot;Invalid verification code.&quot;;\n}\n}\n?&gt;\n&lt;form method=&quot;post&quot;&gt;\n&lt;button type=&quot;submit&quot; name=&quot;send_code&quot;&gt;Send MFA Code&lt;/button&gt;\n&lt;/form&gt;\n&lt;form method=&quot;post&quot;&gt;\nMFA Code: &lt;input type=&quot;text&quot; name=&quot;mfa_code&quot; required&gt;\n&lt;button type=&quot;submit&quot; name=&quot;verify_code&quot;&gt;Verify MFA Code&lt;/button&gt;\n&lt;/form&gt;\n\nExemple amb OAuth\nPer a OAuth, es pot utilitzar un proveïdor extern com Google per autenticar els usuaris. Ho vorem més avant.\n&lt;?php\nrequire_once 'vendor/autoload.php';\n\n$provider = new League\\OAuth2\\Client\\Provider\\Google([\n'clientId' =&gt; 'your-client-id',\n'clientSecret' =&gt; 'your-client-secret',\n'redirectUri' =&gt; 'your-redirect-url',\n]);\n\nif (!isset($_GET['code'])) {\n$authUrl = $provider-&gt;getAuthorizationUrl();\n$_SESSION['oauth2state'] = $provider-&gt;getState();\nheader('Location: ' . $authUrl);\nexit;\n} elseif (empty($_GET['state']) || ($_GET['state'] !== $_SESSION['oauth2state'])) {\nunset($_SESSION['oauth2state']);\nexit('Invalid state');\n} else {\n$token = $provider-&gt;getAccessToken('authorization_code', [\n'code' =&gt; $_GET['code']\n]);\n\n$user = $provider-&gt;getResourceOwner($token);\n$userData = $user-&gt;toArray();\n\n// Mostra la informació de l'usuari\necho 'Hello, ' . $userData['name'];\n}\n?&gt;\n\n4. Referències Addicionals\nA continuació es presenten diverses referències que poden ajudar-te a aprofundir en el tema de la gestió de sessions i cookies en PHP.\nDocumentació Oficial de PHP\n\nSessions a PHP: La documentació oficial de PHP proporciona informació detallada sobre l'ús de sessions, incloent-hi exemples pràctics i consells de millors pràctiques.\n\nSessions a PHP\n\nCookies a PHP: Trobaràs informació oficial sobre com treballar amb cookies en PHP, amb descripcions d'atributs com HttpOnly, Secure i SameSite.\n\nCookies a PHP\n\nArticles i Blocs Tècnics\n\nPHP Sessions: Tips &amp; Tricks: Aquest article discuteix tècniques avançades per gestionar sessions en PHP, amb exemples i millors pràctiques per a la seguretat.\n\nPHP Sessions: Tips &amp; Tricks\n\nHandling Cookies Securely in PHP: Una guia sobre com manejar cookies de manera segura, destacant estratègies per protegir les dades de l'usuari.\n\nHandling Cookies Securely in PHP\n\nLlibres sobre PHP\n\n&quot;Modern PHP: New Features and Good Practices&quot; de Josh Lockhart: Aquest llibre cobreix les novetats de PHP i les millors pràctiques, incloent la seguretat de sessions i cookies.\n\n&quot;PHP Objects, Patterns, and Practice&quot; de M. Zandstra: Proporciona una visió profunda sobre el disseny de programari amb PHP, incloent-hi aspectes de seguretat relacionats amb sessions i cookies.\n\nGuies de Seguretat en Desenvolupament Web\n\nOWASP Secure Coding Practices: Aquesta guia de OWASP ofereix una ràpida referència sobre les millors pràctiques de codificació segura, útils per a protegir les teves aplicacions web.\n\nOWASP Secure Coding Practices\n\nOWASP Cheat Sheet on Session Management: Una fitxa de referència ràpida de OWASP sobre la gestió de sessions, proporcionant consells de seguretat essencials.\n\nOWASP Cheat Sheet on Session Management\n\nConferències i Vídeos Educatius\n\nPHP Conference YouTube Channel: El canal de YouTube de PHP Conference ofereix vídeos de conferències i xerrades que cobreixen una varietat de temes, incloent sessions i seguretat.\n\nPHP Conference YouTube Channel\n\nLaracasts: Ofereix vídeos d'alta qualitat sobre desenvolupament en PHP i Laravel, amb temes rellevants per a sessions i cookies.\n\nLaracasts\n\nTutorials Online i Plataformes Educatives\n\nStack Overflow PHP Sessions Tag: Un lloc de consulta on trobar respostes a preguntes freqüents sobre la gestió de sessions en PHP.\n\nStack Overflow PHP Sessions Tag\n\nCursos a Udemy sobre PHP: Cursos que cobreixen des de conceptes bàsics fins a avançats de PHP, incloent-hi la gestió de sessions i cookies.\n\nCursos a Udemy sobre PHP\n\n5.Exercicis\nBateria d'Exercicis Solucionats per a la Unitat de Programació web\nExercici 1: Crear una sessió\n1.Crea una pàgina PHP que inicialitze una sessió i emmagatzeme el nom i el rol d'un usuari en variables de sessió. Mostra aquests valors a la pàgina web.\n\nSolució\n```php\n&lt;?php\n// Iniciar sessió\nsession_start();\n// Emmagatzemar informació de l'usuari en la sessió\n$_SESSION['nom'] = 'Joan';\n$_SESSION['rol'] = 'Administrador';\necho 'Benvingut, ' . $_SESSION['nom'] . '';\necho 'Rol: ' . $_SESSION['rol'] . '';\n?&gt;\n```\n\nExercici 2: Regenerar l'ID de sessió\n\nModifica l'exercici anterior per regenerar l'ID de sessió just després d'emmagatzemar la informació de l'usuari.\n\nSolució\n```php\n&lt;?php\n// Iniciar sessió\nsession_start();\n// Emmagatzemar informació de l'usuari en la sessió\n$_SESSION['nom'] = 'Joan';\n$_SESSION['rol'] = 'Administrador';\n// Regenerar l'ID de sessió\nsession_regenerate_id(true);\necho 'Benvingut, ' . $_SESSION['nom'] . '';\necho 'Rol: ' . $_SESSION['rol'] . '';\n?&gt;\n```\n\nExercici 3: Tancar la sessió\n\nEscriu un script PHP que elimine totes les variables de sessió i destrueixi la sessió quan l'usuari tanqui sessió.\n\nSolució\n```php\n&lt;?php\n// Iniciar sessió\nsession_start();\n// Eliminar totes les variables de sessió\nsession_unset();\n// Destruir la sessió\nsession_destroy();\n?&gt;\n```\n\nExercici 4: Crear una cookie segura\n\nEscriu un script PHP per crear una cookie que emmagatzeme el nom d'usuari amb els atributs de seguretat HttpOnly, Secure i SameSite.\n\nSolució\nphp &lt;?php // Crear una cookie segura setcookie( 'nom_usuari', 'Joan', [ 'expires' =&gt; time() + 3600, // 1 hora 'path' =&gt; '/', 'domain' =&gt; '', // Domini actual 'secure' =&gt; true, // Només HTTPS 'httponly' =&gt; true, // Només accessible via HTTP 'samesite' =&gt; 'Lax' // o 'Strict' o 'None' ] ); ?&gt;\n\nExercici 5: Llegir i modificar una cookie\n\nCrea una pàgina PHP que llegeixca el valor d'una cookie anomenada nom_usuari i la modifique afegint un prefix de salutació.\n\nSolució\n```php\n&lt;?php\n// Llegir el valor de la cookie\nif (isset($_COOKIE['nom_usuari'])) {\n$nomUsuari = $_COOKIE['nom_usuari'];\necho 'Hola, ' . $nomUsuari;\n// Modificar el valor de la cookie\n$salutacio = 'Hola, ' . $nomUsuari;\nsetcookie('nom_usuari', $salutacio, time() + 3600, '/');\n} else {\necho 'Cookie not found.';\n}\n?&gt;\n```\n\nExercici 6: Aplicació de gestió d'usuaris amb sessions\n\nDesenvolupa una aplicació PHP amb dos scripts: un per iniciar sessió i un altre per tancar sessió. L'aplicació ha de permetre que l'usuari introdueixca el seu nom d'usuari i vega un missatge de benvinguda una vegada haja iniciat sessió.\n\nSolució\n```php\n\n&lt;?php\nsession_start();\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n$nomUsuari = $_POST['nom_usuari'];\n// Emmagatzemar el nom d'usuari en la sessió\n$_SESSION['nom_usuari'] = $nomUsuari;\n// Redireccionar a la pàgina de benvinguda\nheader('Location: welcome.php');\nexit();\n}\n?&gt;\n<!DOCTYPE html>\n\nIniciar Sessió\n\nIniciar Sessió\n\nNom d'usuari:\n\nIniciar Sessió\n\n```\n```php\n\n&lt;?php\nsession_start();\n// Tancar sessió de forma segura\nsession_unset();\nsession_destroy();\n// Redireccionar a la pàgina de login\nheader('Location: login.php');\nexit();\n?&gt;\n```\n```php\n\n&lt;?php\nsession_start();\nif (!isset($_SESSION['nom_usuari'])) {\n// Redireccionar a la pàgina de login si no s'ha iniciat sessió\nheader('Location: login.php');\nexit();\n}\n$nomUsuari = $_SESSION['nom_usuari'];\n?&gt;\n<!DOCTYPE html>\n\nBenvingut\n\nBenvingut, <?php echo htmlspecialchars($nomUsuari); ?>!\nAquesta és la teva pàgina de benvinguda.\nTancar Sessió\n\n```\n\nExercici 7: Aplicació de gestió de preferències amb cookies\n\nCrea una aplicació PHP que permeta als usuaris seleccionar el seu color preferit, emmagatzemant aquesta informació en una cookie. La pàgina hauria de mostrar el color preferit de l'usuari en futures visites.\n\nSolució\n```php\n&lt;?php\n// Llegir el color preferit de la cookie\ncolorPreferit=isset(_COOKIE['color_preferit']) ? $_COOKIE['color_preferit'] : 'blau';\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n$colorPreferit = $_POST['color_preferit'];\n// Emmagatzemar el color preferit en una cookie\nsetcookie('color_preferit', $colorPreferit, time() + 3600, '/');\n}\n?&gt;\n<!DOCTYPE html>\n\nPreferències de Color\n\n\">\nPreferències de Color\n\nColor preferit:\n\n&lt;option value=&quot;blau&quot; <?php if ($colorPreferit === 'blau') echo 'selected'; ?>&gt;Blau\n&lt;option value=&quot;vermell&quot; <?php if ($colorPreferit === 'vermell') echo 'selected'; ?>&gt;Vermell\n&lt;option value=&quot;verd&quot; <?php if ($colorPreferit === 'verd') echo 'selected'; ?>&gt;Verd\n\nGuardar\n\n```\n\nExercicis proposats\nExercici 1: Sistema de Carret de Compres sense Base de Dades\n\nDescripció:\nDesenvolupa una aplicació PHP que permeta als usuaris afegir productes a un carret de compres i mostrar el contingut del carret. Utilitza sessions per a mantindre l'estat del carret entre pàgines.\n\nRequisits:\n\nCrear una pàgina on l'usuari puga seleccionar productes.\nAfegir els productes seleccionats a un carret emmagatzemat en una sessió.\nMostrar un resum del carret amb els productes afegits i les seues quantitats.\nPermetre que l'usuari elimine productes del carret.\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;ca&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;Selecció de productes&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Afegir productes al carret&lt;/h1&gt;\n&lt;form action=&quot;carret.php&quot; method=&quot;POST&quot;&gt;\n&lt;label for=&quot;producte&quot;&gt;Tria un producte:&lt;/label&gt;\n&lt;select name=&quot;producte&quot; id=&quot;producte&quot;&gt;\n&lt;option value=&quot;Poma&quot;&gt;Poma&lt;/option&gt;\n&lt;option value=&quot;Plàtan&quot;&gt;Plàtan&lt;/option&gt;\n&lt;option value=&quot;Taronja&quot;&gt;Taronja&lt;/option&gt;\n&lt;/select&gt;\n&lt;input type=&quot;submit&quot; value=&quot;Afegir al carret&quot;&gt;\n&lt;/form&gt;\n&lt;a href=&quot;carret.php&quot;&gt;Veure carret&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nExercici 2: Autenticació Bàsica d'Usuaris amb Sessions\n\nDescripció:\nCrea una aplicació PHP que permeta als usuaris iniciar sessió mitjançant un formulari. Utilitza sessions per a mantindre l'estat d'autenticació de l'usuari i mostrar missatges personalitzats basats en aquest estat.\n\nRequisits:\n\nCrear un formulari d'inici de sessió que sol·licite el nom d'usuari i la contrasenya.\nEmmagatzemar l'estat d'autenticació en una sessió després de verificar les credencials.\nMostrar una pàgina de benvinguda personalitzada per a l'usuari autenticat.\nProporcionar un enllaç per a tancar sessió i destruir la sessió.\n\nExercici 3: Recordatori d'Usuari amb Cookies\n\nDescripció:\nAfig una funcionalitat de &quot;recordar-me&quot; a l'exercici anterior que emmagatzeme el nom d'usuari en una cookie i permeta a l'usuari ser recordat en futures visites al lloc web.\n\nRequisits:\n\nAfig una opció de &quot;recordar-me&quot; al formulari d'inici de sessió.\nEmmagatzemar el nom d'usuari en una cookie quan l'opció és seleccionada.\nComprovar la cookie en futures visites i iniciar sessió automàticament si la cookie existeix.\nAssegurar que les cookies es configuren amb atributs de seguretat adequats (HttpOnly, Secure, SameSite).\n\nExercici 4: Formulari de Contacte amb Protecció CSRF\n\nDescripció:\nDesenvolupa un formulari de contacte que permeta als usuaris enviar missatges i implementa protecció CSRF per a assegurar que les sol·licituds siguen legítimes.\n\nRequisits:\n\nCrear un formulari de contacte amb camps per al nom, correu electrònic i missatge.\nGenerar i emmagatzemar un token CSRF en una sessió quan es carrega el formulari.\nIncloure el token CSRF com a camp ocult en el formulari.\nVerificar el token CSRF quan s'envia el formulari i mostrar un missatge de confirmació si és vàlid.\nMostrar un missatge d'error si el token CSRF no és vàlid o no existeix.\n\nExercici 5: Seguiment d'Activitat de l'Usuari amb Sessions\n\nDescripció:\nCrea un sistema que registre les pàgines visitades per l'usuari durant una sessió i mostre aquesta informació quan l'usuari visita una pàgina d'activitat.\n\nRequisits:\n\nEmmagatzemar una llista de pàgines visitades per l'usuari en una sessió.\nActualitzar la llista de pàgines cada vegada que l'usuari visite una nova pàgina.\nCrear una pàgina que mostre l'historial de pàgines visitades durant la sessió actual.\nAssegurar que l'historial es restableix quan l'usuari tanca la sessió.\n\nSolucions\n6. Enunciats dels projectes\nPer als dos projectes\n\nAutenticació de Jugadors:\n\nImplementa un sistema d'autenticació bàsic que permeta als jugadors iniciar sessió abans de començar el joc. Utilitza sessions per a mantindre l'estat d'autenticació.\nHa de servir per als dos jocs, &quot;Penjat&quot; i &quot;4 en Ratlla&quot;.\nFes que una vegada autenticar l'usuari puga triar a quin joc vol jugar (en la mateix pàgina).\nProtegeix els jocs per tal que no es puga jugar en cas de no estar autenticat.\n\nProjecte Penjat\n\nManteniment de l'Estat del Joc amb Sessions:\n\nUtilitza sessions per a emmagatzemar l'estat actual del joc, incloent la paraula a endevinar, lletres endevinades, i el nombre d'intents restants.\n\nGestió de la Sessió del Joc:\n\nAfegeix funcionalitats per a reiniciar el joc en qualsevol moment, reinicialitzant les variables de sessió per a començar una nova partida.\nAfegeix una opció per a tancar sessió i finalitzar la partida actual.\nAfegeix un funció per a saver si el joc ha acabat, ja siga perquè s'han endevinat totes les lletres o s'haguen arribat al màxim número d'intents permesos.\nControla el final del joc\n\nCookies per a Recordar Jugadors:\n\nImplementa cookies per a recordar els jugadors entre visites, permetent que l'usuari siga recordat si selecciona una opció de &quot;Recordar-me&quot; durant l'inici de sessió.\n\nSeguretat i Autenticació:\n\nImplementa un sistema d'autenticació bàsic per a garantir que només els jugadors autenticats puguen accedir al joc.\nUtilitza sessions per a mantenir l'estat d'autenticació i controlar l'accés a les funcionalitats del joc.\n\nConsideracions Addicionals\n\nResiliència del Joc: Implementa la lògica necessària per a manejar intents invàlids i mostrar missatges d'error adequats.\nMillores d'Interfície: Afegix un enllaç o botó per a tancar sessió i una opció per a reiniciar el joc.\n\nProjecte &quot;4 en Ratlla&quot;\n\nGestió de l'Estat de la Graella amb Sessions:\n\nUtilitza sessions per a emmagatzemar l'estat actual de la graella i el torn del jugador. Això permet mantenir la partida entre sol·licituds.\n\nManteniment de la Sessió entre Jugadors:\n\nEmmagatzema l'identificador de cada jugador en sessions per a assegurar que el torn actual siga persistent entre sol·licituds.\nAfegeix funcionalitats per a reiniciar el joc en qualsevol moment, reinicialitzant les variables de sessió per a començar una nova partida.\nAfegeix una opció per a tancar sessió i finalitzar la partida actual.\nAfegeix un funció per a saver si el joc ha acabat, ja siga perquè s'ha fet 4 en ratlla o s'haja completat el tauler.\nControla el final del joc.\n\nCookies per a la Persistència d'Usuaris:\n\nPermet l'ús de cookies per a recordar els jugadors entre visites si han seleccionat &quot;Recordar-me&quot;. Utilitza cookies per a emmagatzemar l'últim jugador autenticat.\n\nSeguretat i Autenticació:\n\nImplementa un sistema d'autenticació bàsic per a garantir que només els jugadors autenticats puguen accedir al joc.\nUtilitza sessions per a mantenir l'estat d'autenticació i controlar l'accés a les funcionalitats del joc.\n\nAddicional\n\nImplementa la lògica per tal que el segon jugador siga la màquina (pots adaptar i/o millorar l'algorisme de baix).\nControla el joc per a que no es puga seguir jugant una vegada acabat.\nImplementa un sistema de puntuació que otorgue 2 punts al guanyador i 1 a cadascú en cas d'empat.\n\nfunction jugar(&amp;$graella,$jugadorActual){\n\n$opponent = $jugadorActual === 1 ? 2 : 1;\n\n// Comprovar si pots guanyar\nfor ($col = 1; $col &lt;= COLUMNES; $col++) {\nif (isValidMove($graella, $col)) {\n$tempBoard = $graella;\n$coord = ferMoviment($tempBoard, $col, $jugadorActual);\n\nif (fi_joc($tempBoard, $coord)) {\nreturn ferMoviment($graella,$col,$jugadorActual); // Guanyar immediatament\n}\n}\n}\n\n// Comprovar si l'oponent pot guanyar i bloquejar\nfor ($col = 1; $col &lt;= COLUMNES; $col++) {\nif (isValidMove($graella, $col)) {\n$tempBoard = $graella;\n$coord = ferMoviment($tempBoard, $col, $opponent);\nif (fi_joc($tempBoard, $coord )) {\nreturn ferMoviment($graella,$col,$jugadorActual); // Bloquejar\n}\n}\n}\n\n// Estratègia: buscar el millor moviment\n// Podem afegir més lògica aquí per seleccionar el millor moviment\n$possibles = array();\nfor ($col = 1; $col &lt;= COLUMNES; $col++) {\nif (isValidMove($graella, $col)) {\n$possibles[] = $col;\n}\n}\nif (count($possibles)&gt;2) {\n$random = rand(-1,1);\n}\n$middle = (int) (count($possibles) / 2)+$random;\n$inthemiddle = $possibles[$middle];\nreturn ferMoviment($graella, $inthemiddle, $jugadorActual);\n\nreturn -1; // Totes les columnes estan plenes\n}\n\nConsideracions Addicionals\n\nLògica de Torn de Jugadors: Implementa la lògica necessària per a canviar de torn entre els jugadors utilitzant sessions.\nReinici de Partida: Afegeix una opció per a reiniciar el joc, que ha de restablir les sessions i permetre començar de nou.\nInterfície d'Usuari Amigable: Assegura't que la interfície d'usuari és clara i proporciona indicacions visuals dels moviments i torns dels jugadors.\n\nRúbrica d'Avaluació\n\nCriteri\nExcel·lent (4)\nBé (3)\nAdequat (2)\nInsuficient (1)\n\nFuncionalitat del Joc\nEl joc està completament funcional i sense errors.\nEl joc està majoritàriament funcional amb errors mínims.\nEl joc és funcional, però conté errors significatius.\nEl joc no és funcional o està incomplet.\n\nÚs de Sessions\nSessions ben implementades per a mantenir l'estat del joc.\nSessions utilitzades correctament amb alguns problemes menors.\nSessions utilitzades, però amb deficiències importants.\nNo s'han utilitzat sessions o són incorrectes.\n\nÚs de Cookies\nCookies ben utilitzades per a recordar els jugadors.\nCookies utilitzades adequadament amb algunes millores possibles.\nCookies utilitzades amb limitacions evidents.\nNo s'han utilitzat cookies o són incorrectes.\n\nAutenticació d'Usuaris\nAutenticació segura i efectiva implementada.\nAutenticació implementada amb alguns problemes.\nAutenticació present però amb deficiències notables.\nNo s'ha implementat autenticació o és incorrecta.\n\nInterfície d'Usuari\nInterfície atractiva i fàcil d'utilitzar.\nInterfície clara amb algunes millores possibles.\nInterfície funcional però poc intuïtiva.\nInterfície confusa i difícil d'utilitzar.\n\nSeguretat\nTotes les mesures de seguretat implementades correctament.\nSeguretat adequada amb algunes millores possibles.\nMesures de seguretat bàsiques implementades.\nNo s'han tingut en compte mesures de seguretat.\n\nComentaris i Codi\nCodi ben comentat i fàcilment llegible.\nCodi clar amb comentaris adequats.\nCodi llegible però amb pocs comentaris.\nCodi desordenat i sense comentaris.\n\nInnovació i Creativitat\nEl projecte mostra innovació significativa.\nAlgunes idees creatives han estat implementades.\nAlguna creativitat present, però limitada.\nCap creativitat o innovació en el projecte.\n\nPunts addicionals\n1 punt per cadascúna aconseguida.\n\nExplicació dels Criteris\nFuncionalitat del Joc\n\nExcel·lent (4): El joc funciona completament segons les especificacions, amb totes les funcionalitats implementades i sense errors. Els jugadors poden interaccionar amb el joc tal com s'esperava i totes les accions es realitzen correctament.\n\nInsuficient (1): El joc no és funcional, falten parts importants del codi o el joc no es pot jugar correctament.\n\nÚs de Sessions\n\nExcel·lent (4): Les sessions s'utilitzen eficaçment per a mantenir l'estat del joc i de l'usuari entre sol·licituds. Les dades de la sessió es gestionen de manera adequada per a preservar l'experiència de l'usuari.\n\nInsuficient (1): No s'han utilitzat sessions o la seva implementació és incorrecta, la qual cosa afecta negativament l'experiència de l'usuari.\n\nÚs de Cookies\n\nExcel·lent (4): Les cookies s'utilitzen de manera efectiva per a recordar els jugadors entre sessions, amb la configuració adequada d'atributs de seguretat (HttpOnly, Secure, SameSite).\n\nInsuficient (1): No s'han utilitzat cookies o la seva implementació és incorrecta, amb una configuració de seguretat deficient.\n\nAutenticació d'Usuaris\n\nExcel·lent (4): L'autenticació dels usuaris és segura i eficient, amb mecanismes adequats per a validar les credencials i protegir la informació dels usuaris.\n\nInsuficient (1): No s'ha implementat un sistema d'autenticació o el sistema present és insegur i defectuós.\n\nInterfície d'Usuari\n\nExcel·lent (4): La interfície d'usuari és atractiva, clara i fàcil de navegar, proporcionant una experiència d'usuari òptima.\n\nInsuficient (1): La interfície és confusa, difícil d'utilitzar o inacabada.\n\nSeguretat\n\nExcel·lent (4): Totes les mesures de seguretat necessàries han estat implementades, incloent-hi la validació de dades d'entrada, protecció CSRF i altres pràctiques de seguretat recomanades.\n\nInsuficient (1): No s'han tingut en compte mesures de seguretat, deixant el projecte vulnerable a possibles atacs.\n\nComentaris i Codi\n\nExcel·lent (4): El codi està ben comentat, és llegible i segueix bones pràctiques de programació.\n\nInsuficient (1): El codi està desordenat, difícil de llegir i manca de comentaris explicatius.\n\nInnovació i Creativitat\n\nExcel·lent (4): El projecte mostra un alt grau d'innovació i creativitat, oferint característiques o enfocaments únics que milloren el joc.\n\nInsuficient (1): El projecte manca de creativitat o innovació, seguint únicament les instruccions bàsiques sense cap valor afegit.\n\nNotes Addicionals\n\nConsistència del Codi: S'espera que el codi sigui consistent, utilitzant convencions de noms adequades i estructures de codi clares.\nAdaptació de les Necessitats: Els criteris poden ser adaptats segons les necessitats específiques del curs o dels projectes individuals.\n\n7. Autoavaluació: Gestió de Sessions i Cookies\nExercici 1: Funcions de les Cookies\nPregunta:\nQuina és la funció principal de les cookies en el context del desenvolupament web?\nOpcions:\n\na) Guardar els fitxers de l'usuari al servidor.\n\nb) Emmagatzemar informació del client per personalitzar l'experiència d'usuari.\n\nc) Executar codi al servidor.\n\nd) Controlar la velocitat de la connexió a Internet.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Emmagatzemar informació del client per personalitzar l'experiència d'usuari.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Seguretat de les Cookies\nPregunta:\nQuins atributs de seguretat haurien de tindre les cookies per protegir-les contra atacs?\nOpcions:\n\na) Secure\n\nb) HttpOnly\n\nc) SameSite\n\nd) CrossSite\n\nfunction checkAnswer2() {\nvar correctAnswers = [\"a\", \"b\", \"c\"];\nvar checkboxes = document.getElementsByName('question2');\nvar userAnswers = [];\nfor (var i = 0; i < checkboxes.length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nuserAnswers.sort();\nvar resultText = (JSON.stringify(userAnswers) === JSON.stringify(correctAnswers))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Secure, b) HttpOnly, c) SameSite.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Creació de Sessions en PHP\nPregunta:\nQuin dels següents passos és necessari per iniciar una sessió en PHP?\nOpcions:\n\na) Cridar a la funció session_start().\n\nb) Utilitzar la funció session_open().\n\nc) Assignar un valor a la variable $_SESSION.\n\nd) No es necessita cap funció especial.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Cridar a la funció session_start().\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Manteniment d'Informació en Sessions\nPregunta:\nCom es pot mantindre la informació d'un usuari durant la sessió d'una aplicació web?\nOpcions:\n\na) Utilitzant la variable global $GLOBALS.\n\nb) Utilitzant la variable $_SESSION.\n\nc) Utilitzant la variable $_COOKIE.\n\nd) Utilitzant arxius temporals al servidor.\n\nfunction checkAnswer4() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question4');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Utilitzant la variable $_SESSION.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Funcions de PHP per a Sessions\nPregunta:\nQuina funció de PHP es fa servir per destruir una sessió?\nOpcions:\n\na) session_destroy()\n\nb) session_unset()\n\nc) session_delete()\n\nd) session_end()\n\nfunction checkAnswer5() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question5');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) session_destroy().\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Avantatges de les Sessions\nPregunta:\nQuins són els avantatges d'utilitzar sessions en lloc de cookies per a mantenir l'estat de l'usuari?\nOpcions:\n\na) Les sessions poden emmagatzemar més informació perquè es guarden al servidor.\n\nb) Les sessions són més segures perquè no s'envien al client.\n\nc) Les sessions redueixen la càrrega del servidor.\n\nd) Les sessions no necessiten ser configurades amb atributs de seguretat.\n\nfunction checkAnswer6() {\nvar correctAnswers = [\"a\", \"b\"];\nvar checkboxes = document.getElementsByName('question6');\nvar userAnswers = [];\nfor (var i = 0; i < checkboxes.length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nuserAnswers.sort();\nvar resultText = (JSON.stringify(userAnswers) === JSON.stringify(correctAnswers))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Les sessions poden emmagatzemar més informació perquè es guarden al servidor, b) Les sessions són més segures perquè no s'envien al client.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Autenticació d'Usuaris\nPregunta:\nQuina és la pràctica recomanada per assegurar la identitat d'un usuari en una aplicació web?\nOpcions:\n\na) Utilitzar noms d'usuari i contrasenyes emmagatzemades com a cookies.\n\nb) Utilitzar sessions per mantenir l'estat d'autenticació després d'iniciar sessió.\n\nc) Emmagatzemar la contrasenya de l'usuari a la URL.\n\nd) No utilitzar cap forma d'autenticació.\n\nfunction checkAnswer7() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question7');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Utilitzar sessions per mantenir l'estat d'autenticació després d'iniciar sessió.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": [ "note","PHP"]
},

{
		"title": "1. Concepte de classes i Objectes",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/1-concepte-de-classes-i-objectes/",
		"content": "PHP segueix un paradigma de programació orientada a objectes (POO) basada en classes.\nUn classe és un plantilla que defineix les propietats i mètodes per a poder crear objectes. D'aquest manera, un objecte és una instància d'una classe.\nTant les propietats com els mètodes es defineixen amb una visibilitat (qui pot accedir)\n\nPrivat - private: Només pot accedir la pròpia classe.\nProtegit - protected: Només pot accedir la pròpia classe o els seus descendents.\nPúblico - public: Pot accedir qualsevol altra classe.\n\nPer a declarar una classe, s'utilitza la paraula clau class seguit del nom de la classe. Per a instanciar un objecte a partir de la classe, s'utilitza new:\n&lt;?php\nclass NomClase {\n// propiedades\n// y métodos\n}\n\n$ob = new NomClase();\n\n[!important] &quot;Classes amb majúscula&quot;\nTotes les classes comencen per lletra majúscula.\n\nQuan un projecte creix, és normal modelar les classes mitjançant UML (recordeu Entorns de Desenvolupament?). La classes es representen mitjançant un quadrat, separant el nom, de les propietats i els mètodes:\n![UML|500](/img/user/01 Apuntes/DAW/PHP Teoria Batoi/imagenes/03/uml.png)\nUna vegada que hem creat un objecte, s'utilitza l'operador -&gt; per a accedir a una propietat o un mètode:\n$objeto-&gt;propiedad;\n$objeto-&gt;método(parámetros);\n\nSi des de dins de la classe, volem accedir a una propietat o mètode de la mateixa classe, utilitzarem la referència $this;\n$this-&gt;propiedad;\n$this-&gt;método(parámetros);\n\nAixí doncs, com a exemple, codificaríem una persona en el fitxer Persona.php com:\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function setNombre(string $nom) {\n$this-&gt;nombre=$nom;\n}\n\npublic function imprimir(){\necho $this-&gt;nombre;\necho '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(); // creamos un objeto\n$bruno-&gt;setNombre(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nEncara que es poden declarar diverses classes en el mateix arxiu, és una mala pràctica. Així doncs, cada fitxer contedrá una sola classe, i es nomenarà amb el nom de la classe.",
		"tags": [ "note","PHP"]
},

{
		"title": "10. Documentación con phpDocumentor",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/10-documentacion-con-php-documentor/",
		"content": "phpDocumentor és l'eina per a documentar el codi PHP. És similar en propòsit i funcionament a Javadoc.\nAixí doncs, és un eina que facilita la documentació del codi PHP, creant un lloc web amb l'API de l'aplicació.\nEs basa en l'ús d'anotacions sobre els docblocks. Per a posar-ho en marxa, en el nostre cas ens decantarem per utilitzar la imatge que ja existeix de Docker.\nInstal·lació\nPas 1: Instal·lació amb Docker\nPrimer, cal assegurar-se tenir Docker instal·lat i funcionant al sistema. Després, s'ha de descarregar i executar el contenidor de phpDocumentor utilitzant la següent comanda:\ndocker pull phpdoc/phpdoc\n\nPas 2: Generació de Documentació\nUn cop tinguem la imatge, podem utilitzar-la per generar la documentació. El procés bàsic implica muntar els fitxers de codi dins del contenidor Docker i executar phpDocumentor sobre aquests fitxers.\nAcí hi ha un exemple de com fer-ho:\nEn el cas d'usar Docker, usarem el següent comando per a executar-lo (crea el contenidor, executa el comando que li demanem, i automàticament l'esborra):\ndocker run --rm -v $(pwd):/data phpdoc/phpdoc:latest run -d /data/src -t /data/docs\n\nAquesta comanda fa el següent:\n--rm: Això elimina el contenidor després d'executar-lo, així no es queden contenidors inactius.\n-v (pwd):/data:Muntaeldirectoriactualdelteusistema((pwd)) al directori /data dins del contenidor. Hauràs de reemplaçar $(pwd) amb el camí on està el teu codi font si no estàs executant aquesta comanda des del directori del teu projecte.\n-d /data/src: Especifica el directori dins del contenidor on es troba el teu codi font. Reemplaça /data/src amb el camí corresponent dins del contenidor si és diferent.\n-t /data/docs: Especifica on vols que es generi la documentació dins del contenidor. En aquest cas, es generarà dins de /data/docs.\nPas 3: Accés a la Documentació Generada\nUna vegada generada, la documentació estarà dins del directori que especificat (en aquest cas, docs dins del directori docs de projecte). Pots obrir els fitxers HTML amb qualsevol navegador per veure la documentació.\nDocBlock\nUn docblock és el bloc de codi que es col·loca damunt d'un recurs. El seu format és:\n&lt;?php\n/**\n* Sumari*, una sola línia\n\n* Descripció* que pot utilitzar diverses línies\n* i que ofereix detalls de l'element o referències\n* per a ampliar la informació\n\n* @param string $miArgumento amb una descripció* de l'argument\n* que pot usar diverses línies.\n\n* @return void\n*/\nfunction miFuncion(tipo $miArgumento)\n{\n}\n\nDocumentant el codi\nEn tots els elements, ademas del sumari i/o descripció, posarem:\n\nEn les classes:\n\n@author nom &lt;email&gt;\n@package ruta del namespace\n\nEn les propietats:\n\n@var tipus descripció\n\nEn els mètodes:\n\n@param tipus $nomene descripció\n@throws ClaseException descripció\n@return tipus descripció\n\nVegem-ho amb un exemple. Suposem que tenim una classe que representa un client:\n&lt;?php\n/**\n* Classe que representa un client\n*\n* El client s'encarrega d'emmagatzemar els suports que té llogat,\n* de manera que podem llogar i retornar productes mitjançant les operacions\n* homònimes.\n*\n* @package Dwes\\Videoclub\\Model\n* @author Aitor Medrano &lt;a.medrano@edu.gva.es&gt;\n*/\nclass Cliente {\n\npublic string $nombre;\nprivate string $numero;\n\n/**\n* Colecció de soports alquilats\n* @var array&lt;Soporte&gt;\n*/\nprivate $soportesAlquilados[];\n\n/*\n* Comprova si el suport rebut ja el té llogat el client\n* @param Suport $suporte Suport a comprovar\n* @return bool true si ho té llogat\n/\npublic function tieneAlquilado(Soporte $soporte) : bool {\n// ...\n}\n\nSi generem la documentació i obrim amb un navegador l'arxiu docs/api/index.html podrem navegar fins a la classe `Client:",
		"tags": [ "note","PHP"]
},

{
		"title": "11. Proves amb PHPUNIT",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/11-proves-amb-phpunit/",
		"content": "El curs passat, dins del mòdul de Entorns de Desenvolupament*, estudiarieu la importància de la realització de proves, així com les proves unitàries mitjançant JUnit.\n\nHui dia és de gran importància seguir una bona metodologia de proves, sent el desenvolupament dirigit per les proves (Test Driven Development / TDD) un dels enfocaments més emprats, el qual consisteix en:\n\nEscriure el test, i com no hi ha codi implementat, la prova falle (roig).\nEscriure el codi d'aplicació perquè la prova funcione (verda).\nrefactoritzar el codi de l'aplicació amb l'ajuda de la prova per a comprovar que no trenquem res (refactor).\n\nEn el cas de PHP, l'eina que s'utilitza és PHPUnit (https://phpunit.de/), que com el seu nom indica, està basada en JUnit. La versió actual és la 9.0.\nIntroducció a PHPUnit\nPHPUnit és un framework de proves popular per a PHP que suporta tant proves unitàries com proves d'integració. És àmpliament utilitzat en la comunitat PHP per la seua simplicitat i eficàcia. Les proves unitàries es centren en provar components o mètodes individuals, mentre que les proves d'integració asseguren que les diferents parts del sistema funcionen conjuntament com s'espera.\nInstal·lació\nPer començar a utilitzar PHPUnit, cal instal·lar-lo. La manera recomanada és a través de Composer. Executa la següent comanda en el terminal:\ncomposer require --dev phpunit/phpunit\n\nAquesta comanda afegirà PHPUnit com a dependència de desenvolupament en el teu projecte.\n\n[!tip] &quot;Llibreries de desenvolupament&quot;\nLes llibreries que es col·loquen en require-dev són les de desenvolupament i testing, de manera que no s'instal·laran en un entorn de producció.\n\nUna vegada instal·lat, podem configurar PHPUnit creant un fitxer phpunit.xml en l'arrel del projecte per especificar la configuració de les proves:\n&lt;phpunit bootstrap=&quot;vendor/autoload.php&quot;&gt;\n&lt;testsuites&gt;\n&lt;testsuite name=&quot;Application Test Suite&quot;&gt;\n&lt;directory&gt;./tests&lt;/directory&gt;\n&lt;/testsuite&gt;\n&lt;/testsuites&gt;\n&lt;/phpunit&gt;\n\nEstructura d’un test\nEls tests en PHPUnit són classes PHP que hereten de PHPUnit\\Framework\\TestCase. Cada mètode dins d'aquestes classes que comence amb test serà executat com una prova.\n&lt;?php\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass CalculadoraTest extends TestCase {\npublic function testSuma() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;suma(2, 3);\n$this-&gt;assertEquals(5, $resultat);\n}\n}\n\nExecució de Proves\nPer executar les proves, podem utilitzar la següent comanda:\nvendor/bin/phpunit\nAquesta comanda cercarà els arxius de prova en el directori especificat (per defecte tests) i executarà totes les proves.\nTipus de proves\nAmb PHPUnit, podem realitzar diversos tipus de proves, entre elles:\nProves Unitàries: Verifiquen el funcionament d'una unitat de codi individual, com una funció o mètode.\nExemple de prova unitària:\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n\nProves Funcionals: Verifiquen que un conjunt de mòduls funciona correctament conjuntament. Aquestes proves poden simular interaccions de l'usuari en un sistema web, encara que això es fa millor amb frameworks especialitzats per a proves funcionals.\nProves d'Integració: Comproven que diferents mòduls o serveis funcionen correctament quan es combinen.\nAssercions\nLes assercions permeten comprovar el resultat dels mètodes que volem provar. Les assercions esperen que el predicat sempre siga vertader.\nPHPUnit ofereix les següent assercions:\n\nassertTrue / assertFalse: Comprova que la condició donada siga avaluada com true / false\nassertEquals / assertSame: Comprova que dues variables siguen iguals\nassertNotEquals / assertNotSame: Comprova que dues variables NO siguen iguals\nassertNull: Comprova que un valor és null.\nSame → comprova els tipus. Si no coincideixen els tipus i els valors, l'asserció fallarà\nEquals → sense comprovació estricta\nassertArrayHasKey / assertArrayNotHasKey: Comprova que un array posseïsca un key determinat / o NO ho posseïsca\nassertArraySubset: Comprova que un array posseïsca un altre array com subset del mateix\nassertAttributeContains / assertAttributeNotContains: Comprova que un atribut d'una classe continga una variable determinada / o NO continga una variable determinada\nassertAttributeEquals: Comprova que un atribut d'una classe siga igual a una variable determinada.\n\nProves amb dades\nLes proves en PHPUnit poden utilitzar data providers per executar el mateix test amb diferents dades:\n/**\n* @dataProvider proveidorDeDades\n*/\npublic function testMultiplica($a, $b, $esperat) {\n$calculadora = new Calculadora();\n$this-&gt;assertEquals($esperat, $calculadora-&gt;multiplica($a, $b));\n}\n\npublic function proveidorDeDades() {\nreturn [\n[2, 3, 6],\n[0, 5, 0],\n[-1, 5, -5],\n];\n}\n\nMocks\nEls mocks són objectes simulats que ens permeten aïllar la unitat de codi que estem provant. PHPUnit facilita la creació de mocks per a classes o interfícies.\n$mock = $this-&gt;createMock(ServeiExtern::class);\n$mock-&gt;method('obtenirDades')-&gt;willReturn('Dades simulades');\n\n$calculadora = new Calculadora($mock);\n$resultat = $calculadora-&gt;processaDades();\n$this-&gt;assertEquals('Resultat esperat', $resultat);\n\nProvant excepcions\nLes proves a més de comprovar que les classes funcionen com s'espera, han de cobrir tots els casos possibles. Així doncs, hem de poder fer proves que esperen que es llance una excepció (i que el missatge continga una certa informació):\nPer a això, s'utilitzen les següent expectatives:\n\nexpectException(Excepcion::class)\nexpectExceptionCode(codigoExcepcion)\nexpectExceptionMessage(missatge)\n\nDe la mateixa manera que abans, primer es posa l'expectativa, i després es provoca que es llance l'excepció:\n&lt;?php\npublic function testExcepcio() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n\nConclusió\nLes proves són crucials per a assegurar que el nostre codi PHP és fiable i manté la seua funcionalitat al llarg del temps. Utilitzar PHPUnit ens proporciona les eines necessàries per a escriure proves eficaces i mantenir el nostre projecte en un estat saludable.",
		"tags": [ "note","PHP"]
},

{
		"title": "12. Referències Bibliogràfiques",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/12-referencies-bibliografiques/",
		"content": "Programació Orientada a Objectes en PHP\n\n&quot;PHP Objects, Patterns, and Practice&quot;\nper M. Zandstra. Apress, 2017. ISBN: 978-1-4842-1361-3. Aquest llibre és un recurs essencial per entendre els fonaments de la programació orientada a objectes en PHP, així com patrons de disseny.\n\n&quot;Learning PHP, MySQL &amp; JavaScript: With jQuery, CSS &amp; HTML5&quot;\nper Robin Nixon. O'Reilly Media, 2018. ISBN: 978-1-4919-2070-2. Ofereix una introducció completa a la programació amb PHP, incloent-hi el model d'objectes de PHP.\n\nConstructors i Destructors\n\nPHP Manual: Constructors and Destructors\nDocumentació oficial de PHP sobre constructors i destructors en la programació orientada a objectes. Disponible a https://www.php.net/manual/en/language.oop5.decon.php.\n\nEncapsulació i Visibilitat\n\nPHP Manual: Visibility\nSecció del manual oficial de PHP que explica les paraules clau public, protected, i private, així com el concepte d'encapsulació. Accessible a https://www.php.net/manual/en/language.oop5.visibility.php.\n\nHerència i Polimorfisme\n\n&quot;Programming PHP&quot;\nper Kevin Tatroe, Peter MacIntyre, i Rasmus Lerdorf. O'Reilly Media, 2013. ISBN: 978-1-4493-5053-6. Aquest llibre cobreix àmpliament els conceptes d'herència i polimorfisme en PHP, proporcionant exemples pràctics.\n\nPHP Manual: Inheritance\nDocumentació oficial de PHP que tracta sobre l'herència en classes, incloent el polimorfisme. Disponible a https://www.php.net/manual/en/language.oop5.inheritance.php.\n\nClasses Abstractes i Interfícies\n\nPHP Manual: Interfaces and Abstract Classes\nExplicació oficial de les classes abstractes i les interfícies en PHP. Disponible a https://www.php.net/manual/en/language.oop5.interfaces.php.\n\nNombres màgics i Metodes màgics\n\nPHP Manual: Magic Methods\nGuia completa sobre els mètodes màgics en PHP, com __construct(), __destruct(), __get(), __set(), entre altres. Disponible a https://www.php.net/manual/en/language.oop5.magic.php.\n\nTrait en PHP\n\nPHP Manual: Traits\nDocumentació sobre traits en PHP, que permeten reutilitzar codi entre diferents classes. Disponible a https://www.php.net/manual/en/language.oop5.traits.php.\n\nExcepcions en PHP\n\n&quot;The Pragmatic Programmer: Your Journey to Mastery&quot;\nper David Thomas i Andrew Hunt. Addison-Wesley Professional, 2019. ISBN: 978-0-1359-5202-8. Inclou bones pràctiques per a la gestió d'excepcions, aplicables també a PHP.\n\nPHP Manual: Exceptions\nSecció del manual de PHP dedicada a les excepcions, explicant com llençar i capturar excepcions en PHP. Accessible a https://www.php.net/manual/en/language.exceptions.php.\n\nProves amb PHPUnit\n\n&quot;Modern PHP: New Features and Good Practices&quot;\nper Josh Lockhart. O'Reilly Media, 2015. ISBN: 978-1-4919-2904-0. Aquest llibre inclou una secció sobre proves amb PHPUnit.\n\nPHPUnit Documentation\nDocumentació oficial de PHPUnit, que cobreix com escriure i executar proves unitàries en PHP. Accessible a https://phpunit.de/documentation.html.\n\nEines de Desenvolupament i Autocàrrega\n\nComposer Documentation\nAccessible des de https://getcomposer.org/doc/. Composer és l'eina estàndard per a la gestió de dependències en PHP, i inclou suport per a l'autocàrrega de classes.\n\nPHP Manual: Autoloading Classes\nGuia sobre el mecanisme d'autocàrrega en PHP, que facilita la inclusió automàtica de classes en els teus projectes. Disponible a https://www.php.net/manual/en/language.oop5.autoload.php.\n\nPOO Avançada: Patrons de Disseny\n\n&quot;Head First Design Patterns&quot;\nper Eric Freeman i Elisabeth Robson. O'Reilly Media, 2020. ISBN: 978-1-4919-7175-9. Un recurs excel·lent per aprendre patrons de disseny aplicables a PHP.\n\n&quot;PHP Design Patterns&quot;\nper Stephan Schmidt. Publicat per Packt Publishing, 2008. ISBN: 978-1-84719-255-3. Aquest llibre explora com aplicar patrons de disseny en projectes PHP.\n\nWebs de Referència Addicionals\n\nPHP: The Right Way\nhttps://phptherightway.com/. Una guia per a desenvolupar aplicacions PHP seguint les millors pràctiques de la indústria.\n\nStack Overflow\nhttps://stackoverflow.com/questions/tagged/php. Una font d'informació valuosa per resoldre problemes específics de PHP i discutir amb altres desenvolupadors.",
		"tags": [ "note","PHP"]
},

{
		"title": "13. Exercicis",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/13-exercicis/",
		"content": "Bateria d'Exercicis Solucionats per a la Unitat de Programació Orientada a Objectes\nExercici 1: Crear una Classe Bàsica\n\nCrea una classe Cotxe que tinga les propietats marca i model. Afegeix un mètode mostraInformacio que retorne un string amb la marca i el model del cotxe.\nCrea una instància de la classe Cotxe, assigna-li una marca i un model, i mostra la informació utilitzant el mètode mostraInformacio.\n\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\n$cotxe = new Cotxe();\n$cotxe-&gt;marca = &quot;Toyota&quot;;\n$cotxe-&gt;model = &quot;Corolla&quot;;\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Toyota, Model: Corolla\n\nExercici 2. Afegir un Constructor i destructor\n\nModifica la classe Cotxe per afegir un constructor que prenga com a paràmetres la marca i el model, i que establisca aquestes propietats automàticament.\nAfegeix un destructor a la classe Cotxe que mostre un missatge quan l'objecte és destruït. Crea un objecte i permet que es destruïsca al final del programa.\n\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\npublic function __destruct() {\necho &quot;L'objecte Cotxe ha estat destruït.\\n&quot;;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nExercici 3. Encapsulació de Propietats\n\nModifica la classe Cotxe per a que les propietats marca i model siguen privades. Afegeix mètodes públics getMarca, setMarca, getModel, i setModel per accedir i modificar aquestes propietats.\n\n&lt;?php\nclass Cotxe {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function setMarca($marca) {\n$this-&gt;marca = $marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n\npublic function setModel($model) {\n$this-&gt;model = $model;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;getMarca() . &quot;, Model: &quot; . $this-&gt;getModel();\n}\n}\n\n$cotxe = new Cotxe(&quot;Ford&quot;, &quot;Fiesta&quot;);\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Ford, Model: Fiesta\n\nExercici 4. Herència i Polimorfisme\n\nCrea una classe Vehicle amb una propietat tipus. A continuació, crea una classe Motocicleta que herete de Vehicle i tinga una propietat cilindrada. Afegeix un mètode a Motocicleta que retorne el tipus i la cilindrada.\nCrea una funció mostraDetallsVehicle que accepte un objecte de tipus Vehicle i mostre les seues propietats. Prova aquesta funció amb objectes de Cotxe i Motocicleta.\n\n&lt;?php\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function mostraDetalls() {\nreturn &quot;Tipus: &quot; . $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Cilindrada: &quot; . $this-&gt;cilindrada;\n}\n}\n\nfunction mostraDetallsVehicle(Vehicle $vehicle) {\necho $vehicle-&gt;mostraDetalls() . &quot;\\n&quot;;\n}\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\nmostraDetallsVehicle($cotxe); // Output: Tipus: Cotxe, Marca: Toyota, Model: Corolla\nmostraDetallsVehicle($moto); // Output: Tipus: Motocicleta, Cilindrada: 600\n\nExercici 5. Implementació del Patró MVC amb Vehicles\nContinuant amb l'exercici anterior on has creat les classes Vehicle, Cotxe, i Motocicleta, ara refactoritzaràs el codi per seguir el patró Model-Vista-Controlador (MVC). El teu objectiu és separar la lògica de negoci (models) de la presentació (vistes) i gestionar la interacció entre aquestes capes mitjançant un controlador.\n\nCrear el Model:\n\nRefactoritza les classes Vehicle, Cotxe, i Motocicleta perquè representen el model de negoci i només contenen la lògica relacionada amb la gestió de vehicles.\nAssegura't que els models no contenen cap codi de presentació.\n\nCrear les Vistes:\n\nCrea vistes separades per mostrar els detalls dels vehicles:\n\nUna vista HTML que mostre la informació dels vehicles en format HTML.\nUna vista en text simple que mostre els detalls dels vehicles en un format de text senzill.\n\nCrear el Controlador:\n\nImplementa un controlador que gestione la interacció entre els models i les vistes.\nEl controlador ha de ser capaç de rebre una sol·licitud per mostrar un vehicle i triar la vista adequada per mostrar-ne els detalls.\n\n&lt;?php\n// Models\n\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function getTipus() {\nreturn $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function getCilindrada() {\nreturn $this-&gt;cilindrada;\n}\n}\n\n// Vistes\n\nclass VehicleView {\npublic function renderHtml(Vehicle $vehicle) {\n$output = &quot;&lt;p&gt;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;&lt;/p&gt;&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;&lt;p&gt;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;&lt;/p&gt;&quot;;\n$output .= &quot;&lt;p&gt;Model: &quot; . $vehicle-&gt;getModel() . &quot;&lt;/p&gt;&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;&lt;p&gt;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc&lt;/p&gt;&quot;;\n}\nreturn $output;\n}\n\npublic function renderText(Vehicle $vehicle) {\n$output = &quot;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;\\n&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;\\n&quot;;\n$output .= &quot;Model: &quot; . $vehicle-&gt;getModel() . &quot;\\n&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc\\n&quot;;\n}\nreturn $output;\n}\n}\n\n// Controlador\n\nclass VehicleController {\nprivate $view;\n\npublic function __construct(VehicleView $view) {\n$this-&gt;view = $view;\n}\n\npublic function mostrarVehicle(Vehicle $vehicle, $format = 'html') {\nif ($format === 'html') {\necho $this-&gt;view-&gt;renderHtml($vehicle);\n} else {\necho $this-&gt;view-&gt;renderText($vehicle);\n}\n}\n}\n\n// Exemple d'ús\n\n$view = new VehicleView();\n$controller = new VehicleController($view);\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\n// Mostrar en HTML\n$controller-&gt;mostrarVehicle($cotxe, 'html');\n$controller-&gt;mostrarVehicle($moto, 'html');\n\n// Mostrar en Text\n$controller-&gt;mostrarVehicle($cotxe, 'text');\n$controller-&gt;mostrarVehicle($moto, 'text');\n\nExercici 5. Classes Abstractes i Interfícies\n\nCrea una classe abstracta Figura amb un mètode abstracte calculaArea. Després, crea classes Cercle i Rectangle que estiguen basades en Figura i implementen el mètode calculaArea.\nDefineix una interfície OperacionsBàsiques amb els mètodes suma i resta. Implementa aquesta interfície en una classe CalculadoraSimple.\n\n&lt;?php\nabstract class Figura {\nabstract public function calculaArea();\n}\n\nclass Cercle extends Figura {\nprivate $radi;\n\npublic function __construct($radi) {\n$this-&gt;radi = $radi;\n}\n\npublic function calculaArea() {\nreturn pi() * $this-&gt;radi * $this-&gt;radi;\n}\n}\n\nclass Rectangle extends Figura {\nprivate $ample;\nprivate $llarg;\n\npublic function __construct($ample, $llarg) {\n$this-&gt;ample = $ample;\n$this-&gt;llarg = $llarg;\n}\n\npublic function calculaArea() {\nreturn $this-&gt;ample * $this-&gt;llarg;\n}\n}\n\n$cercle = new Cercle(5);\n$rectangle = new Rectangle(4, 6);\n\necho &quot;Àrea del cercle: &quot; . $cercle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del cercle: 78.5398\necho &quot;Àrea del rectangle: &quot; . $rectangle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del rectangle: 24\n\n&lt;?php\ninterface OperacionsBàsiques {\npublic function suma($a, $b);\npublic function resta($a, $b);\n}\n\nclass CalculadoraSimple implements OperacionsBàsiques {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\n$calculadora = new CalculadoraSimple();\necho &quot;Suma: &quot; . $calculadora-&gt;suma(5, 3) . &quot;\\n&quot;; // Output: Suma: 8\necho &quot;Resta: &quot; . $calculadora-&gt;resta(5, 3) . &quot;\\n&quot;; // Output: Resta: 2\n\nExercici 6. Utilitzar Traits\n\nCrea un trait Informacio amb un mètode mostraInformacio. Inclou aquest trait en les classes Cotxe i Motocicleta, i utilitza'l per mostrar informació addicional.\n\n&lt;?php\ntrait Informacio {\npublic function mostraInformacio() {\nreturn &quot;Aquest és un objecte de tipus &quot; . get_class($this);\n}\n}\n\nclass Cotxe {\nuse Informacio;\n}\n\nclass Motocicleta {\nuse Informacio;\n}\n\n$cotxe = new Cotxe();\n$moto = new Motocicleta();\n\necho $cotxe-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Cotxe\necho $moto-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Motocicleta\n\nExercici 7. Gestionar Excepcions\n\nEscriu una funció divideix que prenga dos nombres com a paràmetres i retorne el resultat de la divisió. Si el segon nombre és zero, llença una excepció amb un missatge adequat. Captura aquesta excepció quan crides a la funció i mostra un missatge d'error.\n\nSolucio\n&lt;?php\nfunction divideix($a, $b) {\nif ($b == 0) {\nthrow new Exception(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n\ntry {\necho divideix(10, 2) . &quot;\\n&quot;; // Output: 5\necho divideix(10, 0) . &quot;\\n&quot;; // Aquesta línia llançarà una excepció\n} catch (Exception $e) {\necho &quot;Error: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;; // Output: Error: No es pot dividir per zero.\n}\n\nExercici 8. Proves amb PHPUnit\n\nCrea una classe Calculadora amb els mètodes suma i resta. Escriu una prova unitària amb PHPUnit per verificar que aquests mètodes funcionen correctament.\nAfegeix un mètode divideix a la classe Calculadora que llance una excepció quan es divideix per zero. Escriu una prova unitària que assegure que aquesta excepció es llança correctament.\n\nSolucio\n&lt;?php\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testSuma() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;suma(2, 3);\n$this-&gt;assertEquals(5, $resultat);\n}\n\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n}\n\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function divideix($a, $b) {\nif ($b == 0) {\nthrow new InvalidArgumentException(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testDivideix() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n}\n\nExercici 9. Espais de Noms (Namespaces)\n\nCrea un espai de noms App\\Models i defineix una classe Usuari dins d'aquest espai de noms. Afegeix un mètode getNomComplet que retorne el nom complet de l'usuari.\nEn un fitxer separat, importa la classe Usuari de l'espai de noms App\\Models i crea una instància d'aquesta classe. Utilitza el mètode getNomComplet per mostrar el nom complet d'un usuari.\n\nSolucio\n&lt;?php\n// Arxiu: src/Models/Usuari.php\nnamespace App\\Models;\n\nclass Usuari {\nprivate $nom;\nprivate $cognom;\n\npublic function __construct($nom, $cognom) {\n$this-&gt;nom = $nom;\n$this-&gt;cognom = $cognom;\n}\n\npublic function getNomComplet() {\nreturn $this-&gt;nom . &quot; &quot; . $this-&gt;cognom;\n}\n}\n\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Usuari;\n\n$usuari = new Usuari(&quot;Joan&quot;, &quot;Garcia&quot;);\necho $usuari-&gt;getNomComplet(); // Output: Joan Garcia\n\nExercici 10. Autoloading i Composer\n\nConfigura un projecte PHP amb Composer que utilitze l'autoloading PSR-4. Crea l'estructura de directoris src/Models i col·loca una classe Producte dins de src/Models. Verifica que l'autoloading funcione correctament instanciant la classe Producte en un fitxer separat.\nAfegeix la llibreria monolog/monolog al projecte utilitzant Composer. Crea una instància de Logger i afegeix una entrada al registre de logs.\n\nSolucio\n\nCrea l'estructura de directoris src/Models i col·loca el següent codi a src/Models/Producte.php:\n\n&lt;?php\nnamespace App\\Models;\n\nclass Producte {\nprivate $nom;\n\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nConfigura l'autoloading en composer.json:\n\n{\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {\n&quot;App\\\\&quot;: &quot;src/&quot;\n}\n}\n}\n\nExecuta composer dump-autoload per generar els fitxers d'autoload.\nUtilitza la classe producte:\n\n&lt;?php\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Producte;\n\n$producte = new Producte(&quot;Ordinador&quot;);\necho $producte-&gt;getNom(); // Output: Ordinador\n\nAfegeix Monolog a composer.json:\n\ncomposer require monolog/monolog\n\nUtilitza Monolog per crear un logger:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n\n// Afegeix una entrada al log\n$log-&gt;warning('Aquesta és una entrada d'advertència');\n$log-&gt;error('Aquesta és una entrada d'error');\n\nExercici 11. Logger\n\nUtilitzant la llibreria Monolog, crea un logger que escriga missatges a un fitxer app.log. Configura el logger per registrar missatges d'informació i d'error.\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error.\n\nSolucio\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::INFO));\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::ERROR));\n\n// Registra missatges d'informació i d'error\n$log-&gt;info('Aquesta és una entrada d’informació');\n$log-&gt;error('Aquesta és una entrada d’error');\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Handler\\ErrorLogHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n$log-&gt;pushHandler(new ErrorLogHandler());\n\n// Registra missatges d’error al fitxer i a la consola\n$log-&gt;error('Aquesta és una entrada d’error');\n\nExercici 12. Documentació\n\nDocumenta la classe Producte creada en l'exercici anterior utilitzant comentaris PHPDoc. Assegura't d'incloure la descripció de la classe, les propietats, i els mètodes.\nUtilitza una eina com phpDocumentor per generar la documentació automàtica del codi PHP del projecte, incloent-hi la classe Producte.\n\nSolucio\n&lt;?php\nnamespace App\\Models;\n\n/**\n* Classe Producte\n*\n* Representa un producte amb un nom.\n*/\nclass Producte {\n/**\n* @var string El nom del producte\n*/\nprivate $nom;\n\n/**\n* Constructor de la classe Producte\n*\n* @param string $nom El nom del producte\n*/\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\n/**\n* Obté el nom del producte\n*\n* @return string El nom del producte\n*/\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nInstal·la phpDocumentor globalment o com a dependència de desenvolupament:\n\ncomposer require --dev phpdocumentor/phpdocumentor\n\nGenera la documentació:\n\nvendor/bin/phpdoc -d src -t docs\n\nAquest comandament generarà la documentació a la carpeta docs.\nExercici 13. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nSolucio\n\nInstal·la DomPDF amb Composer:\n\ncomposer require dompdf/dompdf\n\nCrea un script PHP que generi un PDF senzill:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '&lt;h1&gt;Informe de Vendes&lt;/h1&gt;&lt;p&gt;Aquest és un informe de les vendes.&lt;/p&gt;';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'landscape');\n$dompdf-&gt;render();\n$dompdf-&gt;stream('informe.pdf');\n\nCrea un PDF amb una taula i una imatge:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '\n&lt;h1&gt;Informe de Productes&lt;/h1&gt;\n&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Producte&lt;/th&gt;\n&lt;th&gt;Preu&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Ordinador&lt;/td&gt;\n&lt;td&gt;500€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Teclat&lt;/td&gt;\n&lt;td&gt;20€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;img src=&quot;https://example.com/imatge.png&quot; alt=&quot;Imatge de Producte&quot; /&gt;\n';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'portrait');\n$dompdf-&gt;render();\n$dompdf-&gt;stream(&quot;informe_productes.pdf&quot;);",
		"tags": [ "note","PHP"]
},

{
		"title": "14. Enunciat dels projectes",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/14-enunciat-dels-projectes/",
		"content": "Projecte &quot;Ofegat&quot;\n1. Refactorització amb Programació Orientada a Objectes (POO)\n\nCrear una Classe JocOfegat: Refactoritza la lògica principal del joc en una classe JocOfegat que gestione l'estat del joc, la paraula a endevinar, les lletres endevinades, i el nombre d'intents restants.\nMètodes Principals:\n\niniciarJoc($paraula): void – Inicia una nova partida amb la paraula donada.\nendevinaLletra($lletra): bool – Comprova si la lletra és part de la paraula i actualitza l'estat del joc.\nestaAcabat(): bool – Retorna true si el joc ha acabat, ja siga per guanyar o per perdre.\nobteEstat(): array – Retorna l'estat actual del joc, incloent les lletres encertades, intents restants, etc.\n\n2. Separació del Model de Negoci de la Presentació\n\nModel-Vista-Controlador (MVC):\n\nModel: La classe JocOfegat actua com a model, gestionant la lògica del joc i mantenint l'estat. Aquest model ha d'estar completament separat de qualsevol codi que gestione la presentació (HTML, CSS).\nVista: Crea vistes que s'encarreguen exclusivament de mostrar la informació a l'usuari. Aquestes vistes poden utilitzar plantilles HTML i accedir al model a través de controladors.\nControlador: El controlador serà responsable de rebre les entrades de l'usuari (com l'endevinació d'una lletra), interactuar amb el model (JocOfegat) per actualitzar l'estat del joc, i seleccionar la vista adequada per a mostrar els resultats a l'usuari.\n\n3. Integració de Composer i Autoloading\n\nConfiguració de Composer: Utilitza Composer per gestionar les dependències del projecte. Defineix l'autoloading per carregar automàticament les classes de JocOfegat.\nEstructura del Projecte:\n\nOrganitza el codi en directoris com src/Models per a les classes del joc, i src/Services per a la gestió de sessions i autenticació.\nDefineix un composer.json per configurar l'autoloading PSR-4.\n\n4. Proves amb PHPUnit\n\nEscriu Proves Unitàries: Crea proves unitàries per a la classe JocOfegat utilitzant PHPUnit. Les proves poden incloure:\n\nProva per assegurar que una paraula es configura correctament.\nProva per verificar que una lletra encertada actualitza l'estat correctament.\nProva per assegurar que el joc detecta correctament quan s'ha guanyat o perdut.\n\nProva de Gestió de Sessions: Afig proves per a la gestió de sessions, comprovant que l'estat del joc es guarda i es recupera correctament.\n\n5. Logger amb Monolog\n\nConfiguració de Logger: Utilitza Monolog per registrar esdeveniments importants, com quan s'inicia un nou joc, quan un jugador endevina una lletra o quan es produeixen errors.\nDiversos Handlers:\n\nRegistra missatges a un fitxer game.log per a esdeveniments generals.\nAfig un handler per registrar errors greus, com intents invàlids o problemes de sessió, en un fitxer d'errors separat.\n\nProjecte &quot;4 en Ratlla&quot;\n1. Refactorització amb Programació Orientada a Objectes (POO)\n\nClasse Joc4enRatlla: Refactoritza la lògica del joc en una classe Joc4enRatlla que gestione la graella, el torn del jugador, i la lògica per determinar el guanyador.\nMètodes Principals:\n\niniciarPartida(): void – Inicia una nova partida.\nferMoviment($columna): bool – Permet que un jugador faça un moviment en una columna determinada.\ncomprovaGuanyador(): ?int – Comprova si hi ha un guanyador després d'un moviment.\nobteEstatGraella(): array – Retorna l'estat actual de la graella.\n\n2. Separació del Model de Negoci de la Presentació\n\nModel-Vista-Controlador (MVC):\n\nModel: La classe Joc4enRatlla representa el model, que s'encarrega de tota la lògica del joc, incloent la gestió de la graella i la determinació del guanyador.\nVista: Les vistes presenten la graella del joc, el torn actual del jugador, i els resultats finals (guanyador o empat). Aquestes vistes han d'estar separades del model i només han de mostrar la informació proporcionada pel controlador.\nControlador: El controlador gestiona les interaccions de l'usuari, com els moviments en la graella. Aquest component comunica el model amb les vistes, assegurant-se que els canvis en l'estat del joc es reflectisquen correctament en la presentació.\n\n3. Integració de Composer i Autoloading\n\nConfiguració de Composer: Defineix un composer.json per al projecte, configurant l'autoloading PSR-4 per carregar automàticament les classes de Joc4enRatlla.\nEstructura del Projecte:\n\nOrganitza el codi en directoris com src/Models per a les classes del joc i src/Controllers per a la gestió del flux del joc.\nConfigura Composer per gestionar les dependències del projecte.\n\n4. Proves amb PHPUnit\n\nEscriu Proves Unitàries: Crea proves unitàries per a la classe Joc4enRatlla utilitzant PHPUnit. Les proves poden incloure:\n\nVerificació de la configuració inicial de la graella.\nProves per assegurar que un moviment s'aplica correctament a la graella.\nProves per assegurar que el joc detecta correctament un guanyador o un empat.\n\nProves de Gestió de Sessions: Afig proves per assegurar que l'estat del joc i el torn del jugador es mantenen correctament a través de les sessions.\n\n5. Logger amb Monolog\n\nConfiguració de Logger: Utilitza Monolog per registrar esdeveniments importants del joc, com quan un jugador fa un moviment, quan s'inicia una nova partida, o quan es produeixen errors.\nDiversos Handlers:\n\nRegistra els moviments dels jugadors i els resultats del joc en un fitxer game.log.\nRegistra errors greus o problemes amb les sessions en un fitxer d'errors separat.\n\nConsideracions Addicionals per a Ambdós Projectes\n1. Documentació amb PHPDoc\n\nDocumentació Completa: Documenta totes les classes i mètodes amb comentaris PHPDoc. Això inclou les descripcions dels paràmetres i els valors de retorn per a cada mètode.\nGeneració Automàtica: Utilitza phpDocumentor o una eina similar per generar la documentació automàticament. Afig la documentació generada al projecte per facilitar el manteniment i la comprensió del codi.\n\n2. Implementació d'Interfícies\n\nInterfície JocInterface: Crea una interfície que definisca els mètodes bàsics que qualsevol joc (com Ofegat o 4 en Ratlla) ha de tindre (iniciarJoc, ferMoviment, comprovaGuanyador, etc.). Assegura't que les classes JocOfegat i Joc4enRatlla implementen aquesta interfície.\n\n3. Serialització i Persistència\n\nSerialització de l'Estat del Joc: Implementa funcionalitats per serialitzar l'estat del joc (usant JSON o serialize()) i deserialitzar-lo per mantenir la persistència entre sessions o guardar l'estat per a reprendre la partida posteriorment.\n\nRúbrica d'Avaluació per als Projectes &quot;Ofegat&quot; i &quot;4 en Ratlla&quot;\n\nCriteri\n** Insuficient (1 punt)**\n** Adequat (2 punts)**\n** Bé (3 punts)**\n** Excel·lent (4 punts)**\n\nImplementació de Programació Orientada a Objectes (POO)\nLes classes no estan ben dissenyades, falta encapsulació, ús incorrecte d'herència, o mètodes no funcional.\nLes classes estan creades però poden tindre errors o una estructura confusa. S'aplica la POO de manera bàsica, però hi ha problemes de disseny.\nClasses correctament estructurades i funcionalment completes. Ús adequat d'encapsulació, herència i polimorfisme.\nDisseny de classes ben organitzat, reutilitzable i amb una implementació clara dels principis de POO.\n\nSeparació del Model de Negoci de la Presentació (MVC)\nNo s'ha implementat la separació de model i presentació; el codi de lògica i presentació està mesclat.\nHi ha una separació parcial, però algunes parts de la lògica del negoci es barregen amb la presentació o a l'inrevés.\nLa separació entre model, vista i controlador està ben implementada, però podria millorar en alguns aspectes.\nExcel·lent separació entre el model, vista i controlador, seguint els principis del patró MVC i mantenint un codi net.\n\nIntegració de Composer i Autoloading\nNo s'ha configurat Composer o l'autoloading, o està mal configurat i no funciona correctament.\nComposer s'ha utilitzat, però amb una estructura de projectes i autoloading bàsics o incorrectes.\nComposer i l'autoloading estan configurats correctament amb una estructura de projectes ben definida.\nÚs excel·lent de Composer amb una configuració avançada d'autoloading i una estructura de projecte organitzada i modular.\n\nImplementació de Proves amb PHPUnit\nNo s'han creat proves, o les proves creades són mínimes i no adequades per a verificar la funcionalitat.\nEs presenten proves bàsiques amb PHPUnit, però cobreixen parcialment les funcionalitats requerides.\nProves unitàries completes que cobreixen la majoria dels casos, incloent proves de gestió de sessions i lògica de joc.\nProves exhaustives que cobreixen totes les funcionalitats i consideren casos límit, amb ús de mocks quan necessari.\n\nÚs de Logger amb Monolog\nNo s'ha implementat el logger o no s'utilitza de manera efectiva per registrar esdeveniments importants.\nLogger implementat, però amb ús limitat o incorrecte en la registració d'esdeveniments i errors.\nLogger ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nÚs avançat de logger amb diferents handlers per registrar informació, errors, i seguiment detallat del flux del joc.\n\nDocumentació amb PHPDoc\nFalta documentació o és insuficient per comprendre les classes i mètodes del projecte.\nDocumentació bàsica amb PHPDoc, però amb omisions o descripcions poc clares.\nDocumentació completa amb PHPDoc per a totes les classes i mètodes, amb descripcions clares i detallades.\nDocumentació excel·lent amb PHPDoc, ben estructurada i completa, facilitant la comprensió i manteniment del projecte.\n\nQualitat del Codi i Bones Pràctiques\nCodi desorganitzat, amb molts errors de sintaxi, mala nomenclatura, o sense bones pràctiques de codi.\nCodi funcional però amb problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\nCodi ben escrit, seguint les convencions de nomenclatura i bones pràctiques de desenvolupament.\nCodi de qualitat professional, net, ben organitzat, i seguint rigorosament les millors pràctiques de programació.\n\nExplicació dels Criteris\n1 punt: Insuficient\n\nPOO: Les classes no segueixen els principis bàsics de la programació orientada a objectes. Hi ha problemes greus com la falta d'encapsulació, l'ús inadequat de l'herència o mètodes que no funcionen correctament.\nMVC: No s'ha implementat la separació del model de negoci i la presentació. El codi de la lògica del negoci està mesclat amb la presentació (HTML, CSS), cosa que dificulta el manteniment i l'escalabilitat del projecte.\nComposer i Autoloading: No s'ha configurat Composer o l'autoloading. Si estan configurats, no funcionen correctament.\nProves amb PHPUnit: Les proves estan absents o són mínimes, i no verifiquen adequadament la funcionalitat del projecte.\nLogger amb Monolog: El logger no s'ha implementat, o si està present, no s'utilitza de manera efectiva per registrar esdeveniments importants.\nDocumentació amb PHPDoc: Falta documentació essencial, o la que existeix és insuficient per a entendre el codi.\nQualitat del Codi: El codi és desorganitzat, amb molts errors de sintaxi i no segueix les bones pràctiques de programació.\n\n2 punts: Adequat\n\nPOO: Les classes estan creades, però poden contindre errors o una estructura confusa. L'aplicació de la POO és bàsica, amb alguns problemes de disseny.\nMVC: Hi ha una separació parcial entre el model de negoci i la presentació. No obstant això, encara hi ha parts del codi on la lògica del negoci està barrejada amb la presentació o a l'inrevés, cosa que indica una comprensió bàsica però incompleta del patró MVC.\nComposer i Autoloading: Composer s'ha utilitzat, però l'estructura de projectes o l'autoloading no són òptims, presentant configuracions bàsiques o incorrectes.\nProves amb PHPUnit: Es presenten proves bàsiques que cobreixen parcialment les funcionalitats requerides.\nLogger amb Monolog: El logger està implementat, però l'ús és limitat o incorrecte en la registració d'esdeveniments i errors.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és bàsica, amb algunes omisions o descripcions poc clares.\nQualitat del Codi: El codi és funcional però presenta problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\n\n3 punts: Bé\n\nPOO: Les classes estan correctament estructurades i són funcionalment completes. Es fa un ús adequat de l'encapsulació, l'herència i el polimorfisme.\nMVC: La separació entre el model, vista i controlador està ben implementada, seguint majoritàriament els principis del patró MVC. El codi és clar i estructurat, amb algunes àrees que podrien millorar-se per aconseguir una millor modularitat i mantenibilitat.\nComposer i Autoloading: Composer i l'autoloading estan configurats correctament, amb una estructura de projectes ben definida.\nProves amb PHPUnit: Les proves unitàries estan completes i cobreixen la majoria dels casos, incloent-hi la gestió de sessions i la lògica del joc.\nLogger amb Monolog: El logger està ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és completa per a totes les classes i mètodes, amb descripcions clares i detallades.\nQualitat del Codi: El codi està ben escrit, seguint les convencions de nomenclatura i les bones pràctiques de desenvolupament.\n\n4 punts: Excel·lent\n\nPOO: El disseny de classes està ben organitzat, és reutilitzable i implementa clarament els principis de la programació orientada a objectes. El codi és elegant i eficient.\nMVC: Excel·lent separació entre el model, vista i controlador, seguint rigorosament els principis del patró MVC. El codi està ben organitzat, modular i fàcil de mantenir, cosa que facilita l'escalabilitat del projecte. Hi ha una clara distinció de responsabilitats entre les diferents capes.\nComposer i Autoloading: S'utilitza Composer de manera excel·lent, amb una configuració avançada de l'autoloading i una estructura de projecte organitzada i modular.\nProves amb PHPUnit: Les proves són exhaustives, cobrint totes les funcionalitats i considerant casos límit, amb ús de mocks quan necessari.\nLogger amb Monolog: S'utilitza el logger de manera avançada, amb diferents handlers per registrar informació, errors, i fer un seguiment detallat del flux del joc.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és excel·lent, ben estructurada i completa, facilitant la comprensió i el manteniment del projecte.\nQualitat del Codi: El codi és de qualitat professional, net, ben organitzat, i segueix rigorosament les millors pràctiques de programació.",
		"tags": [ "note","PHP"]
},

{
		"title": "15. Autoavaluació Programació Orientada a Objectes en PHP",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/15-autoavaluacio-programacio-orientada-a-objectes-en-php/",
		"content": "Exercici 1: Constructors en PHP\nPregunta:\nQuina és la funció principal d'un constructor en una classe PHP?\nOpcions:\n\na) Destruir els objectes de la classe quan ja no són necessaris.\n\nb) Inicialitzar les propietats de l'objecte quan es crea.\n\nc) Executar una funció arbitrària abans de cada mètode.\n\nd) Crear mètodes màgics automàticament.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Inicialitzar les propietats de l'objecte quan es crea.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Herència en PHP\nPregunta:\nQuina és l'avantatge principal de l'herència en la programació orientada a objectes?\nOpcions:\n\na) Permet reutilitzar codi definint classes noves basades en classes existents.\n\nb) Permet ocultar totes les propietats i mètodes de la classe.\n\nc) Permet definir funcions globals sense necessitat de classes.\n\nd) Permet cridar a funcions de JavaScript des de PHP.\n\nfunction checkAnswer2() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question2');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet reutilitzar codi definint classes noves basades en classes existents.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Polimorfisme\nPregunta:\nQuè permet el polimorfisme en el context de la POO?\nOpcions:\n\na) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\n\nb) Permet la creació d'objectes a partir de funcions anònimes.\n\nc) Permet la connexió entre PHP i bases de dades relacionals.\n\nd) Permet executar múltiples scripts PHP alhora.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Espais de Noms\nPregunta:\nPer a què s'utilitzen els espais de noms (namespaces) en PHP?\nOpcions:\n\na) Per executar codi PHP de forma asincrònica.\n\nb) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\n\nc) Per definir variables globals accessibles des de qualsevol punt del codi.\n\nd) Per importar codi d'altres llenguatges de programació com JavaScript.\n\nfunction checkAnswer4() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question4');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Traits en PHP\nPregunta:\nQuin avantatge ofereixen els traits en PHP?\nOpcions:\n\na) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\n\nb) Permet la creació de funcions globals en PHP.\n\nc) Permet la comunicació entre diferents servidors web.\n\nd) Permet executar codi PHP dins de plantilles HTML.\n\nfunction checkAnswer5() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question5');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Excepcions en PHP\nPregunta:\nQuina és la finalitat d'utilitzar excepcions en PHP?\nOpcions:\n\na) Evitar l'execució de codi mal format.\n\nb) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\n\nc) Declarar funcions dins d'una classe.\n\nd) Garantir que totes les variables estiguen inicialitzades abans del seu ús.\n\nfunction checkAnswer6() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question6');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Autoloading en PHP\nPregunta:\nQuin avantatge ofereix l'autoloading en PHP?\nOpcions:\n\na) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\n\nb) Permet l'execució de múltiples scripts alhora.\n\nc) Permet la manipulació de fitxers en el servidor.\n\nd) Permet la connexió amb bases de dades.\n\nfunction checkAnswer7() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question7');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": [ "note","PHP"]
},

{
		"title": "2. Principis de la POO",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/2-principis-de-la-poo/",
		"content": "Encapsulació\nLes propietats es defineixen privades o protegides (si volem que les classes heretades puguen accedir).\nPer a cada propietat, s'afigen mètodes públics (getter/setter):\npublic setPropiedad(tipo $param)\npublic getPropiedad() : tipo\n\nLes constants es defineixen públiques perquè siguen accessibles per tots els recursos.\n&lt;?php\nclass MayorMenor {\nprivate int $mayor;\nprivate int $menor;\n\npublic function setMayor(int $may) {\n$this-&gt;mayor = $may;\n}\n\npublic function setMenor(int $men) {\n$this-&gt;menor = $men;\n}\n\npublic function getMayor() : int {\nreturn $this-&gt;mayor;\n}\n\npublic function getMenor() : int {\nreturn $this-&gt;menor;\n}\n}\n\nRebent i enviant objectes\nÉs recomanable indicar-ho en la mena de paràmetres. Si l'objecte pot retornar nuls es posa ? davant del nom de la classe.\n\n[!important] &quot;Objectes per referència&quot;\nEls objectes que s'envien i reben com a paràmetres sempre es passen per referència.\n\n&lt;?php\nfunction maymen(array $numeros) : ?MayorMenor {\n$a = max($numeros);\n$b = min($numeros);\n\n$result = new MayorMenor();\n$result-&gt;setMayor($a);\n$result-&gt;setMenor($b);\n\nreturn $result;\n}\n\n$resultado =  maymen([1,76,9,388,41,39,25,97,22]);\necho &quot;&lt;br&gt;Mayor: &quot;.$resultado-&gt;getMayor();\necho &quot;&lt;br&gt;Menor: &quot;.$resultado-&gt;getMenor();\n\nConstructor\nEl constructor dels objectes es defineix mitjançant el mètode màgic __construct.\nPot o no tindre paràmetres, però només pot haver-hi un únic constructor.\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function __construct(string $nom) {\n$this-&gt;nombre = $nom;\n}\n\npublic function imprimir(){\n  echo $this-&gt;nombre;\n  echo '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nConstructors en PHP 8\nUna de les grans novetats que ofereix PHP 8 és la simplificació dels constructors amb paràmetres, la qual cosa es coneix com a promoció de les propietats del constructor*.\nPer a això, en comptes d'haver de declarar les propietats com a privades o protegides, i després dins del constructor haver d'assignar els paràmetres a estàs propietats, el propi constructor promociona les propietats.\nVegem-ho millor amb un exemple. Imaginem una classe Punt on vulguem emmagatzemar les seues coordenades:\n&lt;?php\nclass Punto {\nprotected float $x;\nprotected float $y;\nprotected float $z;\n\npublic function __construct(\nfloat $x = 0.0,\nfloat $y = 0.0,\nfloat $z = 0.0\n) {\n$this-&gt;x = $x;\n$this-&gt;y = $y;\n$this-&gt;z = $z;\n}\n}\n\nEn PHP 8, quedaria de la següent manera (molt més curt, la qual cosa facilita la seua llegibilitat):\n&lt;?php\nclass Punto {\npublic function __construct(\nprotected float $x = 0.0,\nprotected float $y = 0.0,\nprotected float $z = 0.0,\n) {}\n}\n\n[!info] &quot;L'ordre importa&quot;\nA l'hora de codificar l'ordre dels elements ha de ser:\n\n&lt;?php\ndeclare(strict_types=1);\nclass NombreClase {\n// propiedades\n// constructor\n// getters - setters\n// resto de métodos\n}\n?&gt;\n\nClasses estàtiques\nSón aquelles que tenen propietats i/o mètodes estàtics (també es coneixen com de classe, perquè el seu valor es comparteix entre totes les instàncies de la mateixa classe).\nEs declaren amb static i es referencien amb ::.\n\nSi volem accedir a un mètode estàtic, s'anteposa el nom de la classe: Producte::nuevoProducto().\nSi des d'un mètode volem accedir a una propietat estàtica de la mateixa classe, s'utilitza la referència self: self::$numProductos\n\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0;\n\npublic static function nuevoProducto() {\nself::$numProductos++;\n}\n}\n\nProducto::nuevoProducto();\n$impuesto = Producto::IVA;\n\nTambé podem tindre classes normals que tinguen alguna propietat estàtica:\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0; \nprivate $codigo;\n\npublic function __construct(string $cod) {\nself::$numProductos++;\n$this-&gt;codigo = $cod;\n}\n\npublic function mostrarResumen() : string {\nreturn &quot;El producto &quot;.$this-&gt;codigo.&quot; es el número &quot;.self::$numProductos;\n}\n}\n\n$prod1 = new Producto(&quot;PS5&quot;);\n$prod2 = new Producto(&quot;XBOX Series X&quot;);\n$prod3 = new Producto(&quot;Nintendo Switch&quot;);\necho $prod3-&gt;mostrarResumen();\n\nIntrospecció\nEn treballar amb classes i objectes, existeixen un conjunt de funcions ja definides pel llenguatge que permeten obtindre informació sobre els objectes:\n\ninstanceof: permet comprovar si un objecte és d'una determinada classe\nget_class: retorna el nom de la classe\nget_declared_class: retorna un array amb els noms de les classes definides\nclass_àlies: crea un àlies\nclass_exists / method_exists / property_exists: true si la classe / mètode / propietat està definida\nget_class_methods / get_class_vars / get_object_vars: Retorna un array amb els noms dels mètodes / propietats d'una classe / propietats d'un objecte que són accessibles des d'on es fa la crida.\n\nUn exemple d'aquestes funcions pot ser el següent:\n&lt;?php\n$p = new Producto(&quot;PS5&quot;);\nif ($p instanceof Producto) {\necho &quot;Es un producto&quot;;\necho &quot;La clase es &quot;.get_class($p);\n\nclass_alias(&quot;Producto&quot;, &quot;Articulo&quot;);\n$c = new Articulo(&quot;Nintendo Switch&quot;);\necho &quot;Un articulo es un &quot;.get_class($c);\n\nprint_r(get_class_methods(&quot;Producto&quot;));\nprint_r(get_class_vars(&quot;Producto&quot;));\nprint_r(get_object_vars($p));\n\nif (method_exists($p, &quot;mostrarResumen&quot;)) {\n$p-&gt;mostrarResumen();\n}\n}\n\n!!! caution &quot;Clonat&quot;\nEn assignar dos objectes no es copien, es crea una nova referència. Si volem una còpia, cal clonar-ho mitjançant el mètode clone(object) : object\nSi volem modificar el clonat per defecte, cal definir el mètode màgic __clone() que es dirà després de copiar totes les propietats.\nMés informació en https://www.php.net/manual/es/language.oop5.cloning.php\nHerència\nPHP suporta herència simple, de manera que una classe només pot heretar d'una altra, no de dues classes alhora. Per a això s'utilitza la paraula clau extends. Si volem que la classe A hereta de la classe B farem:\nclass A extends B\n\nEl fill hereta els atributs i mètodes públics i protegits.\n!!! warning &quot;Cada classe en un arxiu&quot;\nCom ja hem comentat, hauríem de col·locar cada classe en un arxiu diferent per a posteriorment utilitzar-lo mitjançant include. En els següent exemple els hem col·locats junt per a facilitar la seua llegibilitat.\nPer exemple, tenim una classe Producte i una Tv que hereta de Producte:\n&lt;?php\nclass Producto {\npublic $codigo;\npublic $nombre;\npublic $nombreCorto;\npublic $PVP;\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n}\n\nPodemos utilizar las siguientes funciones para averiguar si hay relación entre dos clases:\n\nget_parent_class(object): string\nis_subclass_of(object, string): bool\n\n&lt;?php\n$t = new Tv();\n$t-&gt;codigo = 33;\nif ($t instanceof Producto) {\necho $t-&gt;mostrarResumen();\n}\n\n$padre = get_parent_class($t);\necho &quot;&lt;br&gt;La clase padre es: &quot; . $padre;\n$objetoPadre = new $padre;\necho $objetoPadre-&gt;mostrarResumen();\n\nif (is_subclass_of($t, 'Producto')) {\necho &quot;&lt;br&gt;Soy un hijo de Producto&quot;;\n}\n\nPolimorfisme\nPodem crear mètodes en els fills amb el mateix nom que el pare, canviant el seu comportament.\nPer a invocar als mètodes del pare -&gt; parent::nombreMetodo()\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nConstructor en fills\nEn els fills no es crea cap constructor de manera automàtica. Pel que si no n'hi ha, s'invoca automàticament al del pare. En canvi, si el definim en el fill, hem d'invocar al del pare de manera explícita.\n=== &quot;PHP7&quot;\n&lt;?php\nclass Producto {\npublic string $codigo;\n\npublic function __construct(string $codigo) {\n$this-&gt;codigo = $codigo;\n}\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function __construct(string $codigo, int $pulgadas, string $tecnologia) {\nparent::__construct($codigo);\n$this-&gt;pulgadas = $pulgadas;\n$this-&gt;tecnologia = $tecnologia;\n}\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n```\n\n=== &quot;PHP8&quot;\n\n``` php\n&lt;?php\nclass Producto {\npublic function __construct(private string $codigo) { }\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\n\npublic function __construct(\nstring $codigo,\nprivate int $pulgadas,\nprivate string $tecnologia)\n{\nparent::__construct($codigo);\n}\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n```\n\n### Abstracció\n\nLes classes abstractes obliguen a heretar d'una classe, ja que no es permet la seua instanciación. Es defineix mitjançant `abstract class NombreClase {`.\nUna classe abstracta pot contindre propietats i mètodes no-abstractes, i/o mètodes abstractes.\n\n``` php\n&lt;?php\n// Clase abstracta\nabstract class Producto {\nprivate $codigo;\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n// Método abstracto\nabstract public function mostrarResumen();\n}\n\nQuan una classe hereta d'una classe abstracta, obligatòriament ha d'implementar els mètodes que té el pare marcats com a abstractes.\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() { //obligado a implementarlo\necho &quot;&lt;p&gt;Código &quot;.$this-&gt;getCodigo().&quot;&lt;/p&gt;&quot;;\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\n$t = new Tv();\necho $t-&gt;getCodigo();\n\nClasses finals\nSón classes oposades a abstractes, ja que eviten que es puga heretar una classe o mètode per a sobreescriure-ho.\n&lt;?php\nclass Producto {\nprivate $codigo;\n\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n\nfinal public function mostrarResumen() : string {\nreturn &quot;Producto &quot;.$this-&gt;codigo;\n}\n}\n\n// No podremos heredar de Microondas\nfinal class Microondas extends Producto {\nprivate $potencia;\n\npublic function getPotencia() : int {\nreturn $this-&gt;potencia;\n}\n\n// No podemos implementar mostrarResumen()\n}\n\nInterfícies\nPermet definir un contracte amb les signatures dels mètodes a complir. Així doncs, només conté declaracions de funcions i totes han de ser públiques.\nEs declaren amb la paraula clau interface i després les classes que complisquen el contracte el realitzen mitjançant la paraula clau implements.\n&lt;?php\ninterface Nombreable {\n// declaración de funciones\n}\nclass NombreClase implements NombreInterfaz {\n// código de la clase\n\nEs permet l'herència d'interfícies. A més, una classe pot implementar diverses interfícies (en aquest cas, sí que suporta l'herència múltiple, però només d'interfícies).\n&lt;?php\ninterface Mostrable {\npublic function mostrarResumen() : string;\n}\n\ninterface MostrableTodo extends Mostrable {\npublic function mostrarTodo() : string;\n}\n\ninterface Facturable {\npublic function generarFactura() : string;\n}\n\nclass Producto implements MostrableTodo, Facturable {\n// Implementaciones de los métodos\n// Obligatoriamente deberá implementar public function mostrarResumen, mostrarTodo y generarFactura\n}\n\nMètodes encadenats\nSegueix el plantejament de la programació funcional, i també es coneix com method chaining. Planteja que sobre un objecte es realitzen diverses crides.\n&lt;?php\n$p1 = new Libro();\n$p1-&gt;setNombre(&quot;Harry Potter&quot;);\n$p1-&gt;setAutor(&quot;JK Rowling&quot;);\necho $p1;\n\n// Method chaining\n$p2 = new Libro();\n$p2-&gt;setNombre(&quot;Patria&quot;)-&gt;setAutor(&quot;Aramburu&quot;);\necho $p2;\n\nPer a facilitar-ho, modificarem tots els seus mètodes mutants (que modifiquen dades, setters*, ...) perquè retornen una referència a $this:\n&lt;?php\nclass Libro {\nprivate string $nombre;\nprivate string $autor;\n\npublic function getNombre() : string {\nreturn $this-&gt;nombre;\n}\npublic function setNombre(string $nombre) : Libro { \n$this-&gt;nombre = $nombre;\nreturn $this;\n}\n\npublic function getAutor() : string {\nreturn $this-&gt;autor;\n}\npublic function setAutor(string $autor) : Libro {\n$this-&gt;autor = $autor;\nreturn $this;\n}\n\npublic function __toString() : string {\nreturn $this-&gt;nombre.&quot; de &quot;.$this-&gt;autor;\n}\n}\n\nMètodes màgics\nTotes les classes PHP ofereixen un conjunt de mètodes, també coneguts com magic methods que es poden sobreescriure per a substituir el seu comportament. Alguns d'ells ja els hem utilitzats.\nDavant qualsevol dubte, és convenient consultar la documentació oficial.\nEls més destacables són:\n\n__construct()\n__destruct() → s'invoca en perdre la referència. S'utilitza per a tancar una connexió a la BD, tancar un fitxer, ...\n__toString() → representació de l'objecte com a cadena. És a dir, quan fem echo $objecte s'executa automàticament aquest mètode.\n__get(propietat), __set(propietat, valor) → Permetria accedir a les propietat privades, encara que sempre és més llegible/mantenible codificar els getter/setter.\n__isset(propietat), __unset(propietat) → Permet esbrinar o llevar el valor a una propietat.\n__sleep(), __wakeup() → S'executen en recuperar (*unserialize^) o emmagatzemar un objecte que se serialitza (*serialize), i s'utilitzen per a permet definir quines propietats se serialitzen.\n__call(), __callStatic() → S'executen en cridar a un mètode que no és públic. Permeten sobrecarreguen mètodes.",
		"tags": [ "note","PHP"]
},

{
		"title": "3. Espai de noms",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/3-espai-de-noms/",
		"content": "Des de PHP 5.3 i també coneguts com Namespaces, permeten organitzar les classes/interfícies, funcions i/o constants de manera similar als paquets a Java.\n\n[!tip] &quot;Recomanació&quot;\nUn només namespace per arxiu i crear una estructura de carpetes respectant els nivells/subnivells (igual que es fa a Java)\n\nEs declaren en la primera línia mitjançant la paraula clau namespace seguida del nom de l'espai de noms assignat (cada subnivell se separa amb la barra invertida \\):\nPer exemple, per a col·locar la classe Producte dins del namespace Dwes\\Exemples ho faríem així:\n&lt;?php\nnamespace Dwes\\Exemples;\n\nconst IVA = 0.21;\n\nclass Producte {\npublic $nombre;\n  \npublic function muestra() : void {\necho&quot;&lt;p&gt;Prod:&quot; . $this-&gt;nombre . &quot;&lt;/p&gt;&quot;;\n}\n}\n\nAccés\nPer a referenciar a un recurs que conté un namespace, primer hem de tindre'l disponible fent ús de include o require. Si el recurs està en el mateix namespace, es realitza un accés directe (es coneix com a accés sense qualificar).\nRealment hi ha tres tipus d'accés:\n\nsense qualificar: recurs\nqualificat: rutaRelativa\\recurs → no fa falta posar el namespace complet\ntotalment qualificat: \\rutaAbsoluta\\recurs\n\n&lt;?php\nnamespace Dwes\\Ejemplos;\n\ninclude_once(&quot;Producto.php&quot;);\n\necho IVA; // sin cualificar\necho Utilidades\\IVA; // acceso cualificado. Daría error, no existe \\Dwes\\Ejemplos\\Utilidades\\IVA\necho \\Dwes\\Ejemplos\\IVA; // totalmente cualificado\n\n$p1 = new Producto(); // lo busca en el mismo namespace y encuentra \\Dwes\\Ejemplos\\Producto\n$p2 = new Model\\Producto(); // daría error, no existe el namespace Model. Está buscando \\Dwes\\Ejemplos\\Model\\Producto\n$p3 = new \\Dwes\\Ejemplos\\Producto(); // \\Dwes\\Ejemplos\\Producto\n\nAccés\nPer a evitar la referència qualificada podem declarar l'ús mitjançant use (similar a fer import a Java). Es fa en la capçalera, després del namespace:\nEls tipus Posibles són:\n\nuse const nombreCualificadoConstante\nuse function nombreCualificadoFuncion\nuse nombreCualificadoClase\nuse nombreCualificadoClase as NuevoNombre // per a canviar de nom elements\n\nPer exemple, si volem utilitzar la classe \\Dwes\\Exemples\\Producte des d'un recurs que es troba en l'arrel, per exemple en inici.php, faríem:\n&lt;?php\ninclude_once(&quot;Dwes\\Exemples\\Producte.php&quot;);\n\nuse const Dwes\\Exemples\\IVA;\nuse \\Dwes\\Exemples\\Producte;\n\necho IVA;\n$p1 = new Producte();\n\n[!tip] &quot;To use or not to use&quot;\nEn resum, use permet accedir sense qualificar a recursos que estan en un altre namespace. Si estem en el mateix espai de nom, no necessitem use.\n\nOrganització\nTot projecte, conforme creix, necessita organitzar el seu codi font. Es planteja una organització en la qual els arxius que interactuan amb el navegador es col·loquen en l'arrel, i les classes que definim van dins d'un namespace (i dins de la seua pròpia carpeta src o app).\n\n[!tip] &quot;Organització, includes i usos&quot;\n* Col·locarem cada recurs en un fitxer a part.\n* En la primera línia indicarem la seua namespace (si no està en l'arrel).\n* Si utilitzem altres recursos, farem un include_once d'aqueixos recursos (classes, interfícies, etc...).\n* Cada recurs ha d'incloure tots els altres recursos que referencie: la classe de la qual hereta, interfícies que implementa, classes utilitzades/rebudes com a paràmetres, etc...\n* Si els recursos estan en un espai de noms diferent al que estem, emprarem use amb la ruta completa per a després utilitzar referències sense qualificar.\n\nAutoload\nNo és tediós haver de fer el include de les classes? El autoload ve al rescat.\nAixí doncs, permet carregar les classes (no les constants ni les funcions) que s'utilitzaran i evitar haver de fer el include_once de cadascuna d'elles. Per a això, s'utilitza la funció spl_autoload_register\n&lt;?php\nspl_autoload_register( function( $nombreClase ) {\ninclude_once $nombreClase.'.php';\n} );\n?&gt;\n\n[!question] &quot;Per què es diuen autoload?&quot;\nPerquè abans es realitzava mitjançant el mètode màgic __autoload(), el qual està deprecated des de PHP 7.2\n\nI com organitzem ara el nostre codi aprofitant el autoload?\n\nPer a facilitar la cerca dels recursos a incloure, és recomanable col·locar totes les classes dins d'una mateixa carpeta. Nosaltres la col·locarem dins de app (més endavant, quan estudiem Laravel veurem el motiu d'aquesta decisió). Altres carpetes que podem crear són test per a col·locar les proves PhpUnit que després realitzarem, o la carpeta vendor on s'emmagatzemaran les llibreries del projecte (aquesta carpeta és un estándard dins de PHP, ja que Composer la crea automàticament).\nCom hem col·locat tots els nostres recursos dins de app, ara nostre autoload.php (el qual col·loquem en la carpeta arrel) només buscarà dins d'aqueixa carpeta:\n&lt;?php\nspl_autoload_register( function( $nombreClase ) {\ninclude_once &quot;app/&quot;.$nombreClase.'.php';\n} );\n\n[!tip] &quot;autoload i rutes errònies&quot;\nEn Ubuntu en fer el include de la classe que rep com a paràmetre, les barres dels namespace (\\) són diferents a les de les rutes (/). Per això, és millor que utilitzem el fitxer autoload:\n\n&lt;?php\nspl_autoload_register( function( $nombreClase ) {\n$ruta = &quot;app\\\\&quot;.$nombreClase.'.php';\n$ruta = str_replace(&quot;\\\\&quot;, &quot;/&quot;, $ruta); // Sustituimos las barras\ninclude_once $_SERVER['DOCUMENT_ROOT'].'/'.$ruta;\n} );\n\n```",
		"tags": [ "note","PHP"]
},

{
		"title": "4. Separar la lògica de negoci dels aspectes de presentació de l'aplicació",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/4-separar-la-logica-de-negoci-dels-aspectes-de-presentacio-de-l-aplicacio/",
		"content": "Lògica de Negoci\n\nRegles i procediments que defineixen el funcionament de l'aplicació.\nInclou processament de dades, càlculs, interaccions amb la base de dades, etc.\n\nAspectes de Presentació\n\nManera en què es mostra la informació a l'usuari.\nInclou la interfície d'usuari, disseny, navegació, etc.\n\nAvantatges\n\nMantenibilitat\n\nFacilita la modificació de la lògica de negoci sense afectar la presentació.\nPermet actualitzar la interfície d'usuari sense modificar la lògica subjacent.\n\nReutilització\n\nLa lògica de negoci pot ser reutilitzada en diferents aplicacions amb interfícies variades.\nEls components de presentació poden ser reutilitzats amb diferents lògiques de negoci.\n\nEscalabilitat\n\nAjuda a escalar l'aplicació separant les preocupacions, permetent millorar una part sense impactar l'altra.\n\nProva i Depuració\n\nFacilita les proves unitàries i la depuració en permetre provar la lògica de negoci per separat de la interfície.\n\nCol·laboració\n\nPermet que desenvolupadors de backend i frontend treballen de manera independent en les seues àrees respectives.",
		"tags": [ "note","PHP"]
},

{
		"title": "5. Tecnologies i Mecanismes per a la Separació",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/5-tecnologies-i-mecanismes-per-a-la-separacio/",
		"content": "A continuació es presenten diverses tecnologies i mecanismes que faciliten la separació de la lògica de negoci i la presentació en una aplicació web:\nFrameworks PHP:\n\nLaravel: Framework que segueix el patró MVC (Model-View-Controller). Laravel facilita la creació de codi net i ben organitzat, separant clarament la lògica de negoci de la presentació.\nSymfony: Altres frameworks populars que també segueixen el patró MVC i ofereixen eines per a la separació de la lògica i la presentació.\n\nPatró MVC:\n\nModel-View-Controller: Patró de disseny que divideix una aplicació en tres components interconnectats:\n\nModel: Gestiona la lògica de negoci i les dades.\nVista: Gestiona la presentació de la informació.\nControlador: Gestiona la comunicació entre el Model i la Vista.\n\nPlantilles:\n\nBlade (Laravel): Motor de plantilles que permet separar el codi HTML de la lògica de negoci.\nTwig (Symfony): Motor de plantilles similar a Blade, utilitzat per separar la lògica de negoci del codi de presentació.\n\nAPI REST:\nPermet crear serveis web que exposen funcionalitats i dades a través de punts finals d'API, mantenint la lògica de negoci separada de la presentació.\nExemple MVC\n// Model: Product.php\nclass Product {\nprivate string $name;\nprivate float $price;\n\npublic function __construct(string $name, float $price) {\n$this-&gt;name = $name;\n$this-&gt;price = $price;\n}\n\npublic function getName(): string {\nreturn $this-&gt;name;\n}\n\npublic function getPrice(): float {\nreturn $this-&gt;price;\n}\n}\n\n// Controller: ProductController.php\nclass ProductController {\npublic function showProduct() {\n$product = new Product(&quot;Laptop&quot;, 1200.00);\ninclude 'views/productView.php';\n}\n}\n\n// View: productView.php\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Product Information&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Product: &lt;?php echo htmlspecialchars($product-&gt;getName()); ?&gt;&lt;/h1&gt;\n&lt;p&gt;Price: $&lt;?php echo htmlspecialchars($product-&gt;getPrice()); ?&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nLa separació de la lògica de negoci dels aspectes de presentació és crucial per al desenvolupament d'aplicacions web eficients, mantenibles i escalables.",
		"tags": [ "note","PHP"]
},

{
		"title": "6. Gestió d'Errors",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/6-gestio-d-errors/",
		"content": "PHP classifica els errors que ocorren en diferents nivells. Cada nivell s'identifica amb una constant. Per exemple:\n\nE_ERROR: errors fatals, no recuperables. S'interromp el script.\nE_WARNING: advertiments en temps d'execució. El script no s'interromp.\nE_NOTICE: avisos en temps d'execució.\n\nPodeu comprovar el llistat complet de constants de https://www.php.net/manual/es/errorfunc.constants.php\nPer a la configuració dels errors podem fer-ho de dues formes:\n\nA nivell de php.ini:\n\nerror_reporting: indica els nivells d'errors a notificar\n\nerror_reporting = E_ALL &amp; ~E_NOTICE -&gt; Tots els errors menys els avisos en temps d'execució.\n\ndisplay_errors: indica si mostrar o no els errors per pantalla. En entorns de producció és comuna posar-ho a off\nmitjançant codi amb les següents funcions:\n\nerror_reporting(codigo) -&gt; Controla quins errors notificar\nset_error_handler(nombreManejador) -&gt; Indica que funció s'invocarà cada vegada que es trobe un error. El manejador rep com a paràmetres el nivell de l'error i el missatge\n\nA continuació tenim un exemple mitjançant codi:\n=== &quot;Funcions per a la gestió d'errors&quot;\n&lt;?php\nerror_reporting(E_ALL &amp; ~E_NOTICE &amp; ~E_WARNING);\n$resultado = $dividendo / $divisor;\n\nerror_reporting(E_ALL &amp; ~E_NOTICE);\nset_error_handler(&quot;miManejadorErrores&quot;);\n$resultado = $dividendo / $divisor;\nrestore_error_handler(); // vuelve al anterior\n\nfunction miManejadorErrores($nivel, $mensaje) {\nswitch($nivel) {\ncase E_WARNING:\necho &quot;&lt;strong&gt;Warning&lt;/strong&gt;: $mensaje.&lt;br/&gt;&quot;;\nbreak;\ndefault:\necho &quot;Error de tipo no especificado: $mensaje.&lt;br/&gt;&quot;;\n}\n}\n```\n\n=== &quot;Consola&quot;\n\nError de tipo no especificado: Undefined variable: dividendo.\nError de tipo no especificado: Undefined variable: divisor.\nError de tipo Warning: Division by zero.\n\n### Exempcions\n\nLa gestió d'excepcions forma part des de PHP 5. El seu funcionament és similar a Java*, fent ús d'un bloc `try / catch / finally`.\nSi detectem una situació anòmala i volem llançar una excepció, haurem de realitzar `throw new Exception` (adjuntant el missatge que l'ha provocat).\n\n``` php\n&lt;?php\ntry {\nif ($divisor == 0) {\nthrow new Exception(&quot;División por cero.&quot;);\n}\n$resultado = $dividendo / $divisor;\n} catch (Exception $e) {\necho &quot;Se ha producido el siguiente error: &quot;.$e-&gt;getMessage();\n}\n\nLa classe Exception és la classe pare de totes les excepcions. El seu constructor rep missatge[,codigoError][,excepcionPrevia].\nA partir d'un objecte Exception, podem accedir als mètodes getMessage()i getCode() per a obtindre el missatge i el codi d'error de l'excepció capturada.\nEl propi llenguatge ofereix un conjunt d'excepcions ja definides, les quals podem capturar (i llançar des de PHP 7). Es recomana la seua consulta en la documentació oficial.\nCreant exempcions\nPer a crear una excepció, la forma més curta és crear una classe que únicament herete de Exception.\n&lt;?php\nclass HolaExcepcion extends Exception {}\n\nSi volem, i és recomanable depenent dels requisits, podem sobrecarregar els mètodes màgics, per exemple, sobrecarregant el constructor i cridant al constructor del pare, o reescriure el mètode __toString per a canviar el seu missatge:\n&lt;?php\nclass MiExcepcion extends Exception {\n    public function __construct($msj, $codigo = 0, Exception $previa = null) {\n        // código propio\n        parent::__construct($msj, $codigo, $previa);\n    }\n    public function __toString() {\n        return __CLASS__ . &quot;: [{$this-&gt;code}]: {$this-&gt;message}\\n&quot;;\n    }\n    public function miFuncion() {\n        echo &quot;Una función personalizada para este tipo de excepción\\n&quot;;\n    }\n}\n\nSi definim una excepció d'aplicació dins d'un namespace, quan referenciem a Exception, haurem de referenciar-la mitjançant el seu nom totalment qualificat (\\Exception), o utilitzant use:\n=== &quot;Mitjançant nom totalment qualificat&quot;\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\n\nclass AppExcepcion extends \\Exception {}\n```\n=== &quot;Mitjançant `use`&quot;\n``` php\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\n\nuse Exception;\n\nclass AppExcepcion extends Exception {}\n```\n\n##### Exempcions múltiples\n\nEs poden usar excepcions múltiples per a comprovar diferents condicions. A l'hora de capturar-les, es fa de més específica a més general.\n\n``` php\n&lt;?php\n$email = &quot;ejemplo@ejemplo.com&quot;;\ntry {\n    // Comprueba si el email es válido\n    if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE) {\n        throw new MiExcepcion($email);\n    }\n    // Comprueba la palabra ejemplo en la dirección email\n    if(strpos($email, &quot;ejemplo&quot;) !== FALSE) {\n        throw new Exception(&quot;$email es un email de ejemplo no válido&quot;);\n    }\n} catch (MiExcepcion $e) {\n    echo $e-&gt;miFuncion();\n} catch(Exception $e) {\n    echo $e-&gt;getMessage();\n}\n\n[!question] &quot;Autoevaluación&quot;\n¿Qué pasaría al ejectuar el siguiente código?\n\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\n\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException $e) {\n    echo &quot;Capturada MainException &quot; . $e-&gt;getMessage();\n} catch (SubException $e) {\n    echo &quot;Capturada SubException &quot; . $e-&gt;getMessage();\n} catch (Exception $e) {\n    echo &quot;Capturada Exception &quot; . $e-&gt;getMessage();\n}\n```\n\nSi en el mateix `catch` volem capturar diverses excepcions, hem d'utilitzar l'operador `|`:\n\n``` php\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\n\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException | SubException $e ) {\n    echo &quot;Capturada Exception &quot; . $e-&gt;getMessage();\n}\n\nDes de PHP 7, existeix el tipus Throwable, el qual és una interfície que implementen tant els errors com les excepcions, i ens permet capturar els dos tipus alhora:\n&lt;?php\ntry {\n    // tu codigo\n} catch (Throwable $e) {\n    echo 'Forma de capturar errores y excepciones a la vez';\n}\n\nSi només volem capturar els errors fatals, podem fer ús de la classe Error:\n&lt;?php\ntry {\n    // Genera una notificación que no se captura\n    echo $variableNoAsignada;\n    // Error fatal que se captura\n    funcionQueNoExiste();\n} catch (Error $e) {\n    echo &quot;Error capturado: &quot; . $e-&gt;getMessage();\n}\n\nRellançar exempcions\nEn les aplicacions reals, és molt comuna capturar una excepció de sistema i llançar una d'aplicació que hem definit nostros.\nTambé podem llançar les excepcions sense necessitat d'estar dins d'un try/catch.\n&lt;?php\nclass AppException extends Exception {}\n\ntry {\n    // Código de negocio que falla\n} catch (Exception $e) {\n    throw new AppException(&quot;AppException: &quot;.$e-&gt;getMessage(), $e-&gt;getCode(), $e);\n}",
		"tags": [ "note","PHP"]
},

{
		"title": "7. Composer",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/7-composer/",
		"content": "Eina per excel·lència en PHP per a la gestió de llibreries i dependències, de manera que instal·la i les actualitza assegurant que tot l'equip de desenvolupament té el mateix entorn i versions. A més, ofereix autoloading del nostre codi, de manera que no hàgem de fer-lo nosaltres &quot;a mà&quot;.\nEstà escrit en PHP, i podeu consultar tota la seua documentació en https://getcomposer.org/\nUtilitza Packagist com a repositori de llibreries.\nFuncionalment, és similar a Maven (Java) / npm (JS).\nInstal·lació\nSi estem usant XAMPP, hem d'instal·lar Composer en el propi sistema operatiu. Es recomana seguir les instruccions oficials segons el sistema operatiu a emprar.\nEn canvi, si usem Docker, necessitem modificar la configuració del nostre contenidor. En el nostre cas, hem decidit modificar l'arxiu Dockerfile i afegir el següent comando:\nCOPY --from=composer:2.0 /usr/bin/composer /usr/local/bin/composer\n\nÉs important que dins del contenidor comprovem que tenim la v2:\ncomposer -V\n\nPrimers passos\nQuan creem un projecte per primera vegada, hem d'inicialitzar el repositori. Per a això, executarem el comando composer init on:\n\nConfigurem el nom del paquet, descripció, autor (nom &lt;email&gt;), tipus de paquet (project), etc.\nDefinim les dependències del projecte (require) i les de desenvolupament (require-dev) de manera interactiva.\nEn les de desenvolupament s'indica aquelles que no s'instal·laran a l'entorn de producció, per exemple, les llibreries de proves.\n\nDesprés de la seua configuració, es crearà automàticament l'arxiu composer.json amb les dades introduïdes i descàrrega les llibreries en la carpeta vendor. La instal·lació de les llibreries sempre es realitza de manera local per a cada projecte.\n\t{\n&quot;name&quot;: &quot;dwes/log&quot;,\n&quot;description&quot;: &quot;Pruebas con Monolog&quot;,\n&quot;type&quot;: &quot;project&quot;,\n&quot;require&quot;: {\n&quot;monolog/monolog&quot;: &quot;^2.1&quot;\n},\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;authors&quot;: [\n{\n&quot;name&quot;: &quot;Aitor Medrano&quot;,\n&quot;email&quot;: &quot;a.medrano@edu.gva.es&quot;\n}\n]\n}\n\nA l'hora d'indicar cada llibreria introduirem:\n\nel nom de la llibreria, composta tant pel creador o &quot;vendor&quot;, com pel nom del projecte. Exemples: monolog/monolog o laravel/installer.\n\nla versió de cada llibreria. Tenim diverses opcions per a indicar-la:\n\nDirectament: 1.4.2\nAmb comodins: 1.\nA partir de: &gt;= 2.0.3\nSense trencament de canvis:\n{ #1}\n.3.2 // &gt;=1.3.2 &lt;2.0.0\n\nActualitzar llibreries\nPodem definir les dependències via l'arxiu composer.json o mitjançant comandos amb el format composer require vendor/package:version. Per exemple, si volem afegir phpUnit com a llibreria de desenvolupament, farem:\ncomposer require phpunit/phpunit –dev\n\nDesprés d'afegir noves llibreries, hem d'actualitzar el nostre projecte:\ncomposer update\n\nSi creem l'arxiu composer.json nosaltres directament sense inicialitzar el repositori, hem d'instal·lar les dependències:\ncomposer install\n\nEn fer aquest pas (tant instal·lar com actualitzar), com ja hem comentat, es descarreguen les llibreries en dins de la carpeta vendor. És molt important afegir aquesta carpeta a l'arxiu .gitignore per a no pujar-les a GitHub.\nA més es crea l'arxiu composer.lock, que emmagatzema la versió exacta que s'ha instal·lat de cada llibreria (aquest arxiu no es toca).\nautoload.php\nComposer crea de manera automàtica en vendor/autoload.php el codi per a incloure de manera automàtica totes les llibreries que tinguem configurades en composer.json.\nPer a utilitzar-ho, en la capçalera del nostre arxius posarem:\n&lt;?php\nrequire 'vendor/autoload.php';\n\nEn el nostre cas, de moment només el podrem en els arxius on provem les classes\nSi volem que Composer també s'encarregue de carregar de manera automàtica les nostres classes de domini, dins de l'arxiu composer.json, definirem la propietat autoload:\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {&quot;Dwes\\\\&quot;: &quot;app/Dwes&quot;}\n},\n\nPosteriorment, hem de tornar a generar el autoload de Composer mitjançant l'opció dump-autoload (o du):\ncomposer dump-autoload",
		"tags": ["1", "note","PHP"]
},

{
		"title": "8. Logger amb Monolog",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/8-logger-amb-monolog/",
		"content": "Provarem Composer afegint la llibreria de Monolog al nostre projecte. Es tracta d'un llibreria per a la gestió de logs de les nostres aplicacions, suportant diferents nivells (info, warning, etc...), eixides (fitxers, sockets, BBDD, Web Services, email, etc) i formats (text pla, HTML, JSON, etc...).\nPer a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require monolog/monolog\n\nMonolog 2 requereix almenys PHP 7.2, compleix amb el estandar de logging PSR-3, i és la llibreria emprada per Laravel i Symfony per a la gestió de logs.\n\n[!info] &quot;Quan utilitzar un log&quot;\n\nSeguir les acciones/moviments dels usuaris\nRegistrar les transaccions\nRastrejar els errors d'usuari\nFallades/avisos a nivell de sistema\nInterpretar i col·leccionar dades per a posterior investigació de patrons\n\nNivells\nA continuació vam mostrar els diferents nivells de menys a més restrictiu:\n\ndebug -100: Informació detallada amb propòsits de debug. No usar en entorns de producció.\ninfo - 200: Esdeveniments interessants com l'inici de sessió d'usuaris.\nnotice - 250: Esdeveniments normals però significatius.\nwarning - 300: Ocurrències excepcionals que no arriben a ser error.\nerror - 400: Errors d'execució que permeten continuar amb l'execució de l'aplicació però que han de ser monitorats.\ncritical - 500: Situacions importants on es generen excepcions no esperades o no hi ha disponible un component.\nalert - 550: S'han de prendre mesures immediatament.\nCaiguda completa de la web, base de dades no disponible, etc... A més, se solen enviar missatges per email.\nemergency - 600: És l'error més greu i indica que tot el sistema està inutilitzable.\n\nHola Monolog\nPer exemple, en l'arxiu pruebaLog.php que col·locaríem en l'arrel, primer incloem el autoload, importem els classes a utilitzar per a finalment usar els mètodes de Monolog:\n&lt;?php\ninclude __DIR__ .&quot;/vendor/autoload.php&quot;;\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger(&quot;MiLogger&quot;);\n$log-&gt;pushHandler(new StreamHandler(&quot;logs/milog.log&quot;, Logger::DEBUG));\n\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;);\n$log-&gt;error(&quot;Esto es un mensaje de ERROR&quot;);\n$log-&gt;critical(&quot;Esto es un mensaje de CRITICAL&quot;);\n$log-&gt;alert(&quot;Esto es un mensaje de ALERT&quot;);\n\nEn tots els mètodes de registre de missatges (debug, info, ...), a més del propi missatge, li podem passar informació com el contingut d'alguna variable, usuari de l'aplicació, etc.. com a segon paràmetre dins d'un array, el qual es coneix com array de contexte.\nÉs convenient fer-ho mitjançant un array associatiu per a facilitar la lectura del log.\n&lt;?php\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [$producto]);\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [&quot;datos&quot; =&gt; $producto]);\n\nFuncionament\nCada instància Logger té un nom de canal i una pila de manejadores (handler).\nCada missatge que manem al log travessa la pila de manejadores, i cadascun decideix si ha de registrar la informació, i si es dona el cas, finalitzar la propagació.\nPer exemple, un StreamHandler en el fons de la pila que ho escriga tot en disc, i en el topall afig un MailHandler que envie un mail només quan hi haja un error.\nManejadors\nCada manejador tambien té un formatejador (Formatter). Si no s'indica cap, se li assigna un per defecte. L'últim manejador inserit serà el primer a executar-se.\nDesprés es van executant conforme a la pila.\nEls manejadores més utilitzats són:\n\nStreamHandler(ruta, nivel)\nRotatingFileHandler(ruta, maxFiles, nivel)\nNativeMailerHandler(para, asunto, desde, nivel)\nFirePHPHandler(nivel)\n\nSi volem que els missatges de l'aplicació isquen pel log del servidor,\nen el nostre cas l'arxiu error.log de Apatxe* utilitzarem com a ruta l'eixida d'error:\n&lt;?php\n// error.log\n$log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Logger::DEBUG));\n\n[!tip] &quot;FirePHP&quot;\nPer exemple, mitjançant FirePHPHandler, podem utilitzar FirePHP, la qual és una eina per a fer debug en la consola de Firefox*.\nDesprés d'instal·lar l'extensió en Firefox, habilitar les opcions i configurar el Handler, podem veure els missatges acolorits amb les seues dades:\n\n&lt;?php\n$log = new Logger(&quot;MiFirePHPLogger&quot;);\n$log-&gt;pushHandler(new FirePHPHandler(Logger::INFO));\n\n$datos = [&quot;real&quot; =&gt; &quot;Bruce Wayne&quot;, &quot;personaje&quot; =&gt; &quot;Batman&quot;];\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;, $datos);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;, $datos);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;, $datos);\n// ...\n\nCanals\nSe'ls assigna en crear el Logger. En grans aplicacions, es crea un canal per cada subsistema: vendes, comptabilitat, magatzem.\nNo és una bona pràctica usar el nom de la classe com a canal, això es fa amb un processador.\nPer al seu ús, és recomane assignar el log a una propietat privada a Logger, i posteriorment, en el constructor de la classe, assignar el canal, manejadors i format.\n&lt;?php\n$this-&gt;log = new Logger(&quot;MiApp&quot;);\n$this-&gt;log-&gt;pushHandler(new StreamHandler(&quot;logs/milog.log&quot;, Logger::DEBUG));\n$this-&gt;log-&gt;pushHandler(new FirePHPHandler(Logger::DEBUG));\n\nI dins dels mètodes per a escriure en el log:\n&lt;?php\n$this-&gt;log-&gt;warning(&quot;Producto no encontrado&quot;, [$producto]);\n\nProcessadors\nEls processadors permeten afegir informació als missatges.\nPer a això, s'apilen després de cada manejador mitjançant el mètode pushProcessor($processador).\nAlguns processadors coneguts són IntrospectionProcessor (mostren la línia, fitxer, classe i metodo des del qual s'invoca el log), WebProcessor (afig la URI, mètode i IP) o GitProcessor (afig la branca i el commit).\n=== &quot;PHP&quot;\n&lt;?php\n$log = new Logger(&quot;MiLogger&quot;);\n$log-&gt;pushHandler(new RotatingFileHandler(&quot;logs/milog.log&quot;, 0, Logger::DEBUG));\n$log-&gt;pushProcessor(new IntrospectionProcessor());\n$log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Logger::WARNING));\n// no usa Introspection pq lo hemos apilado después, le asigno otro\n$log-&gt;pushProcessor(new WebProcessor());\n\n=== &quot;Consola en format text&quot;\n[2020-11-26T13:35:31.076138+01:00] MiLogger.DEBUG: Esto es un mensaje de DEBUG [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:12,&quot;class&quot;:null,&quot;function&quot;:null}\n[2020-11-26T13:35:31.078344+01:00] MiLogger.INFO: Esto es un mensaje de INFO [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:13,&quot;class&quot;:null,&quot;function&quot;:null}\n\nFormatadors\nS'associen als manejadores amb setFormatter. Els formateadores més utilitzats són LineFormatter, HtmlFormatter o JsonFormatter.\n=== &quot;PHP&quot;\n&lt;?php\n$log = new Logger(&quot;MiLogger&quot;);\n$rfh = new RotatingFileHandler(&quot;logs/milog.log&quot;, Logger::DEBUG);\n$rfh-&gt;setFormatter(new JsonFormatter());\n$log-&gt;pushHandler($rfh);\n\n=== &quot;Consola en JSON&quot;\n{&quot;message&quot;:&quot;Esto es un mensaje de DEBUG&quot;,&quot;context&quot;:{},&quot;level&quot;:100,&quot;level_name&quot;:&quot;DEBUG&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747211+01:00&quot;,&quot;extra&quot;:{}}\n{&quot;message&quot;:&quot;Esto es un mensaje de INFO&quot;,&quot;context&quot;:{},&quot;level&quot;:200,&quot;level_name&quot;:&quot;INFO&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747538+01:00&quot;,&quot;extra&quot;:{}}\n\n[!tip] &quot;Més informació&quot;\nMés informació sobre manejadores, formateadores i processadors en https://github.com/Seldaek/monolog/blob/master/doc/02-handlers-formatters-processors.md\n\nÚs de Factories\nEn comptes de instanciar un log en cada classe, és convenient crear una factoria (per exemple, seguint la idea del patró de disseny Factory Method).\nPer al següent exemple, suposarem que creguem la factoria en el namespace Dwes\\Exemples\\Util.\n&lt;?php\nnamespace Dwes\\Ejemplos\\Util\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\nclass LogFactory {\n\npublic static function getLogger(string $canal = &quot;miApp&quot;) : Logger {\n$log = new Logger($canal);\n$log-&gt;pushHandler(new StreamHandler(&quot;logs/miApp.log&quot;, Logger::DEBUG));\n\nreturn $log;\n}\n}\n\nSi en comptes de retornar un Monolog\\Logger utilitzem la interfície de PSR, si en el futur canviem la implementació del log, no haurem de modificar nostre codi. Així doncs, la factoria ara retornarà Psr\\Log\\LoggerInterface:\n&lt;?php\nnamespace Dwes\\Ejemplos\\Util\n\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Psr\\Log\\LoggerInterface;\n\nclass LogFactory {\n\npublic static function getLogger(string $canal = &quot;miApp&quot;) : LoggerInterface {\n$log = new Logger($canal);\n$log-&gt;pushHandler(new StreamHandler(&quot;log/miApp.log&quot;, Logger::DEBUG));\n\nreturn $log;\n}\n}\n\nFinalment, per a utilitzar la factoria, només canviem el codi que teníem en el constructor de les classes que usen el log, quedant alguna cosa asi:\n&lt;?php\n\nnamespace Dwes\\Ejemplos\\Model;\n\nuse Dwes\\Ejemplos\\Util\\LogFactory;\nuse Monolog\\Logger;\n\nclass Cliente {\n\nprivate $codigo;\n\nprivate Logger $log;\n\nfunction __construct($codigo){\n$this-&gt;codigo=$codigo;\n\n$this-&gt;log = LogFactory::getLogger();\n}\n\n/// ... resto del código\n}",
		"tags": [ "note","PHP"]
},

{
		"title": "9.  Generació de PDF amb DOMPDF",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/9-generacio-de-pdf-amb-dompdf/",
		"content": "Amb PHP podem manejar tot tipus d'arxius com ja hem vist però, què passa si volem generar fitxers PDF amb dades tretes d'una base de dades?\n\nGràcies a una classe escrita en PHP, podem generar arxius PDF sense necessitat d'instal·lar llibreries addicionals en el nostre servidor.\nPerò anem a utilitzar una llibreria que permet transformar codi html en pdf.\nDOMPDF\nAfegirem la llibreria de DOMPDF al nostre projecte. Per a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require dompdf/dompdf\n\nUna vegada que DOMPDF està instal·lat, el procés per generar PDFs des de HTML és bastant directe. Els passos bàsics són:\nPas 1: Incloent DOMPDF\nPrimer, necessitarem incloure DOMPDF en el script PHP. Si estem utilitzant Composer, això es fa automàticament a través de l'auto-càrrega de Composer. Només cal afegir la següent línia al principi del'script:\nrequire 'vendor/autoload.php';\n\nPas 2: Creació d'una Instància de DOMPDF\nA continuació, creem una nova instància de la classe DOMPDF:\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n\nPas 3: Carregar HTML\nDesprés, carregem l'HTML en l'objecte DOMPDF. Això es pot fer directament com una cadena o carregant un fitxer HTML:\n$html = &quot;&lt;html&gt;&lt;body&gt;Hola, això és una prova.&lt;/body&gt;&lt;/html&gt;&quot;;\n$dompdf-&gt;loadHtml($html);\n\nO bé carregar un fitxer HTML:\n$dompdf-&gt;loadHtml(file_get_contents('path/to/your/file.html'));\n\nPas 4: Configuració de la Mida del Paper i l'Orientació\nPodem configurar la mida del paper i l'orientació si és necessari:\n$dompdf-&gt;setPaper('A4', 'portrait'); // o 'landscape'\n\nPas 5: Renderització del PDF\nAra, demanem a DOMPDF que renderitze el PDF:\n$dompdf-&gt;render();\n\nPas 6: Eixida del PDF\nFinalment, podem enviar el PDF al navegador, guardar-lo en un fitxer o fer amb ell el que necessitem:\nPer mostrar-lo al navegador:\n$dompdf-&gt;stream(&quot;document.pdf&quot;, array(&quot;Attachment&quot; =&gt; false));\n\nPer desar-lo en un fitxer:\n$output = $dompdf-&gt;output();\nfile_put_contents('path/to/save/document.pdf', $output);\n\nConsells Addicionals\nCal assegurar-se que l'HTML és vàlid i ben format. DOMPDF intenta ser tolerant amb l'HTML, però l'HTML mal format pot causar problemes.\nEl CSS que s'utilitze pot afectar significativament com es veu el PDF. DOMPDF suporta una bona part de CSS 2.1, però no tot.\nSi necessitem incloure imatges, cal assegurar-se que les rutes són absolutes i accessibles des del servidor on s'executa DOMPDF.\nAquesta és una guia bàsica per començar amb DOMPDF. Per a casos d'ús més avançats i opcions de configuració, cal consultar la documentació oficial de DOMPDF.",
		"tags": [ "note","PHP"]
},

{
		"title": "Exercicis proposats",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/exercicis-proposats/",
		"content": "Exercici 1. Creació de la Classe Bàsica i Gestió de Propietats\n\nCrea una classe Persona amb les propietats privades nom, cognoms, i edat. Encapsula aquestes propietats mitjançant getters i setters. Afig els següents mètodes:\n- getNomComplet(): string – Retorna el nom complet de la persona.\n- estaJubilat(): bool – Retorna true si l'edat és major o igual a 65, false en cas contrari.\n\nModifica la classe Persona afegint un constructor que assigna nom i cognoms. Si es proporciona un tercer paràmetre, assigna l'edat; en cas contrari, assigna una edat per defecte de 25 anys.\n\nModifica la classe Persona per utilitzar una constant LIMITE_EDAT amb el valor de 66 anys i utilitza-la en el mètode estaJubilat.\n\nExercici 2. Herència i Polimorfisme\n\nCrea una classe Empleado que herete de Persona. Afig les següents propietats i mètodes:\n\nprivate float $sou\nprivate array $telefons\nanyadirTelefono(int $telefon): void – Afig un número de telèfon a l'array.\nlistarTelefonos(): string – Retorna els números de telèfon separats per comes.\nvaciarTelefonos(): void – Buida l'array de telèfons.\ndebePagarImpuestos(): bool – Retorna true si el sou és superior a 3333€, false en cas contrari.\n\nAfig un mètode estàtic toHtml(Empleado $emp): string que genere un codi HTML que mostre el nom complet de l'empleat dins d'un paràgraf i els seus telèfons dins d'una llista ordenada.\n\nAfig un mètode estàtic toHtml(Persona $p) a la classe Persona que mostre el nom complet de la persona dins d'un paràgraf. Modifica el mètode toHtml de Empleado per rebre una Persona com a paràmetre i comprovar si es tracta d'un Empleado amb instanceof.\n\nTransforma Persona en una classe abstracta. Redefineix el mètode estàtic toHtml(Persona $p) en totes les seues subclasses. Afig una classe Worker que siga també abstracta i que emmagatzeme els telefonos. Crea mètodes per calcular el sou en Empleado i Gerent, segons la descripció.\n\nExercici 3. Integració d'Espais de Noms, Autoloading, i Composer\n\nCrea una classe Empresa que incloga una propietat amb un array de Workers, ja siguen Employees o Managers. Implementa:\n\npublic function addWorker(Worker $t)\npublic function listWorkersHtml(): string – Genera la llista de treballadors en format HTML.\npublic function getCosteNominas(): float – Calcula el cost total de les nòmines.\n\nConfigura un projecte PHP amb Composer que utilitze l'autoloading PSR-4. Afig un fitxer composer.json i defineix l'estructura de directoris src/Models, src/Services, etc. Crea una classe Producte dins de src/Models i verifica que l'autoloading funcione correctament instanciant la classe en un fitxer separat.\n\nExercici 4. Logger i Documentació\n\nUtilitza la llibreria Monolog per configurar un logger que escriga missatges a un fitxer app.log. Afig funcionalitat perquè el logger registre missatges d'informació i d'error en diferents arxius segons la gravetat.\n\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error i advertència.\n\nDocumenta la classe Producte creada en exercicis anteriors utilitzant comentaris PHPDoc. Inclou la descripció de la classe, les propietats, i els mètodes. Utilitza una eina com phpDocumentor per generar documentació automàtica.\n\nEscriu proves unitàries per als mètodes de les classes Persona, Empleado, i Empresa utilitzant PHPUnit. Prova els mètodes getNomComplet, estaJubilat, addWorker, i getCosteNominas. Assegura't que les proves cobreixen diferents escenaris, incloent errors potencials.\n\nEscriu una prova unitària que comprove que el logger està registrant correctament els missatges d'error a l'arxiu corresponent. Utilitza un mock per assegurar-te que el logger funciona sense necessitat d'escriure en un fitxer real durant la prova.\n\nExercici 5. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\n\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nUtilitzant la classe Empresa i Empleado, genera un informe en PDF amb la llista de treballadors i el seu sou. Utilitza DomPDF per generar aquest informe.\n\nExercici 6. Serialització i JSON\n\nCrea una interfície JSerializable que incloga els mètodes:\n\ntoJSON(): string – Converteix l'objecte a un JSON utilitzant json_encode().\ntoSerialize(): string – Serialitza l'objecte utilitzant serialize().\n\nModifica les classes Persona, Empleado, i Empresa per implementar aquesta interfície. Assegura't que les propietats privades es puguen serialitzar correctament.\n\nEscriu mètodes per deserialitzar un objecte a partir d'una cadena JSON o d'una cadena serialitzada. Prova aquests mètodes amb PHPUnit per assegurar-te que la deserialització funciona correctament.\n\nExercici 7. Separació del Model de Negoci i la Presentació (MVC)\nFins ara, has creat diverses classes que gestionen la lògica del joc i les dades (models), com Persona, Empleado, i Empresa, i has generat sortides HTML i PDFs amb DomPDF. Ara és el moment de refactoritzar la teua aplicació per assegurar una separació clara entre la lògica del negoci i la presentació, seguint el patró Model-Vista-Controlador (MVC).\n\nCrear el Model:\n\nRefactoritza les classes Persona, Empleado, i Empresa per assegurar que només gestionen la lògica de negoci (per exemple, càlcul de nòmines, gestió d'empleats, etc.).\nAssegura't que aquestes classes no contenen codi relacionat amb la presentació (HTML o PDF).\n\nCrear les Vistes:\n\nCrea vistes separades per presentar la informació als usuaris:\n\nUna vista HTML per mostrar la informació de Empleado i Empresa com a llistats.\nUna vista PDF per generar informes amb DomPDF, basant-se en les dades proporcionades pel model.\n\nCrear el Controlador:\n\nImplementa un controlador que reba les sol·licituds dels usuaris, interactue amb el model (Persona, Empleado, Empresa), i tria la vista adequada per mostrar els resultats (HTML o PDF).\nEl controlador ha d'encapsular tota la lògica necessària per a gestionar la interacció entre la vista i el model, assegurant que el model no estiga lligat a la capa de presentació.\n\nExercici 8. Creació de Proves Unitàries per al Patró MVC\nDesprés de refactoritzar l'aplicació per separar la lògica del negoci de la presentació seguint el patró Model-Vista-Controlador (MVC), és fonamental assegurar-se que tots els components funcionen correctament i que la interacció entre ells es realitza tal com s'espera. Per això, has de crear una sèrie de proves unitàries utilitzant PHPUnit per verificar el funcionament del model, les vistes i els controladors.\n\nProves del Model:\n\nEscriu proves unitàries per verificar el funcionament dels mètodes de les classes Persona, Empleado, i Empresa.\nAssegura't que els mètodes funcionen correctament, com ara:\n\ngetNomComplet()\ndebePagarImpuestos()\naddWorker() i getCosteNominas()\n\nProva que els càlculs es realitzen correctament i que les dades es gestionen segons el que s'espera.\n\nProves del Controlador:\n\nEscriu proves unitàries per assegurar-te que els controladors interactuen correctament amb els models i que seleccionen la vista adequada per a cada situació.\nProva que les dades es passen correctament del model a la vista a través del controlador.\nImplementa proves per verificar que el controlador respon correctament a diferents sol·licituds de l'usuari, per exemple:\n\nMostrar una llista d'empleats en HTML.\nGenerar un informe en PDF utilitzant DomPDF.\n\nProves de les Vistes:\n\nEscriu proves unitàries per comprovar que les vistes reben i mostren correctament la informació proporcionada pel controlador.\nProva que la generació de contingut HTML o PDF es realitza correctament a partir de les dades proporcionades pel model.",
		"tags": [ "note","PHP"]
},

{
		"title": "phpoo",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/4-programacion-orientada-a-objetos-php/phpoo/",
		"content": "Desenvolupament d'Aplicacions Web: POO, Separació de Lògica i Presentació, Gestió d'Errors i Proves\n\n[!abstract] &quot;Duració i criteris d'avaluació&quot;\nDuració estimada: 20 hores\n\n| Resultat d'aprenentatge | Criteris d'avaluació |\n| -------- | -------- |\n| 5. Desenvolupa aplicacions Web identificant i aplicant mecanismes per a separar el codi de presentació de la lògica de negoci.| a) S'han identificat els avantatges de separar la lògica de negoci dels aspectes de presentació de l'aplicació. b) S'han analitzat tecnologies i mecanismes que permeten realitzar aquesta separació i les seues característiques principals. c) S'han utilitzat objectes i controls en el servidor per a generar l'aspecte visual de l'aplicació Web en el client. d) S’han utilitzat formularis generats de forma dinàmica per a respondre als esdeveniments de l'aplicació Web. e) S'han identificat i aplicat els paràmetres relatius a la configuració de l'aplicació Web. f) S'han escrit aplicacions Web amb manteniment d'estat i separació de la lògica de negoci. g) S'han aplicat els principis de la programació orientada a objectes. g) S'ha provat i documentat el codi. |\n\n1. Concepte de classes i Objectes\nPHP segueix un paradigma de programació orientada a objectes (POO) basada en classes.\nUn classe és un plantilla que defineix les propietats i mètodes per a poder crear objectes. D'aquest manera, un objecte és una instància d'una classe.\nTant les propietats com els mètodes es defineixen amb una visibilitat (qui pot accedir)\n\nPrivat - private: Només pot accedir la pròpia classe.\nProtegit - protected: Només pot accedir la pròpia classe o els seus descendents.\nPúblico - public: Pot accedir qualsevol altra classe.\n\nPer a declarar una classe, s'utilitza la paraula clau class seguit del nom de la classe. Per a instanciar un objecte a partir de la classe, s'utilitza new:\n&lt;?php\nclass NomClase {\n// propiedades\n// y métodos\n}\n\n$ob = new NomClase();\n\n!!! important &quot;Classes amb majúscula&quot;\nTotes les classes comencen per lletra majúscula.\nQuan un projecte creix, és normal modelar les classes mitjançant UML (recordeu Entorns de Desenvolupament?). La classes es representen mitjançant un quadrat, separant el nom, de les propietats i els mètodes:\n![UML](/img/user/01 Apuntes/DAW/PHP Teoria Batoi/imagenes/03/uml.png)\nUna vegada que hem creat un objecte, s'utilitza l'operador -&gt; per a accedir a una propietat o un mètode:\n$objeto-&gt;propiedad;\n$objeto-&gt;método(parámetros);\n\nSi des de dins de la classe, volem accedir a una propietat o mètode de la mateixa classe, utilitzarem la referència $this;\n$this-&gt;propiedad;\n$this-&gt;método(parámetros);\n\nAixí doncs, com a exemple, codificaríem una persona en el fitxer Persona.php com:\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function setNombre(string $nom) {\n$this-&gt;nombre=$nom;\n}\n\npublic function imprimir(){\necho $this-&gt;nombre;\necho '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(); // creamos un objeto\n$bruno-&gt;setNombre(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nEncara que es poden declarar diverses classes en el mateix arxiu, és una mala pràctica. Així doncs, cada fitxer contedrá una sola classe, i es nomenarà amb el nom de la classe.\n2. Principis de la POO\nEncapsulació\nLes propietats es defineixen privades o protegides (si volem que les classes heretades puguen accedir).\nPer a cada propietat, s'afigen mètodes públics (getter/setter):\npublic setPropiedad(tipo $param)\npublic getPropiedad() : tipo\n\nLes constants es defineixen públiques perquè siguen accessibles per tots els recursos.\n&lt;?php\nclass MayorMenor {\nprivate int $mayor;\nprivate int $menor;\n\npublic function setMayor(int $may) {\n$this-&gt;mayor = $may;\n}\n\npublic function setMenor(int $men) {\n$this-&gt;menor = $men;\n}\n\npublic function getMayor() : int {\nreturn $this-&gt;mayor;\n}\n\npublic function getMenor() : int {\nreturn $this-&gt;menor;\n}\n}\n\nRebent i enviant objectes\nÉs recomanable indicar-ho en la mena de paràmetres. Si l'objecte pot retornar nuls es posa ? davant del nom de la classe.\n!!! important &quot;Objectes per referència&quot;\nEls objectes que s'envien i reben com a paràmetres sempre es passen per referència.\n&lt;?php\nfunction maymen(array $numeros) : ?MayorMenor {\n$a = max($numeros);\n$b = min($numeros);\n\n$result = new MayorMenor();\n$result-&gt;setMayor($a);\n$result-&gt;setMenor($b);\n\nreturn $result;\n}\n\n$resultado =  maymen([1,76,9,388,41,39,25,97,22]);\necho &quot;&lt;br&gt;Mayor: &quot;.$resultado-&gt;getMayor();\necho &quot;&lt;br&gt;Menor: &quot;.$resultado-&gt;getMenor();\n\nConstructor\nEl constructor dels objectes es defineix mitjançant el mètode màgic __construct.\nPot o no tindre paràmetres, però només pot haver-hi un únic constructor.\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function __construct(string $nom) {\n$this-&gt;nombre = $nom;\n}\n\npublic function imprimir(){\n  echo $this-&gt;nombre;\n  echo '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nConstructors en PHP 8\nUna de les grans novetats que ofereix PHP 8 és la simplificació dels constructors amb paràmetres, la qual cosa es coneix com a promoció de les propietats del constructor*.\nPer a això, en comptes d'haver de declarar les propietats com a privades o protegides, i després dins del constructor haver d'assignar els paràmetres a estàs propietats, el propi constructor promociona les propietats.\nVegem-ho millor amb un exemple. Imaginem una classe Punt on vulguem emmagatzemar les seues coordenades:\n&lt;?php\nclass Punto {\nprotected float $x;\nprotected float $y;\nprotected float $z;\n\npublic function __construct(\nfloat $x = 0.0,\nfloat $y = 0.0,\nfloat $z = 0.0\n) {\n$this-&gt;x = $x;\n$this-&gt;y = $y;\n$this-&gt;z = $z;\n}\n}\n\nEn PHP 8, quedaria de la següent manera (molt més curt, la qual cosa facilita la seua llegibilitat):\n&lt;?php\nclass Punto {\npublic function __construct(\nprotected float $x = 0.0,\nprotected float $y = 0.0,\nprotected float $z = 0.0,\n) {}\n}\n\n!!! info &quot;L'ordre importa&quot;\nA l'hora de codificar l'ordre dels elements ha de ser:\n``` php\n&lt;?php\ndeclare(strict_types=1);\nclass NombreClase {\n// propiedades\n// constructor\n// getters - setters\n// resto de métodos\n}\n?&gt;\n```\nClasses estàtiques\nSón aquelles que tenen propietats i/o mètodes estàtics (també es coneixen com de classe, perquè el seu valor es comparteix entre totes les instàncies de la mateixa classe).\nEs declaren amb static i es referencien amb ::.\n\nSi volem accedir a un mètode estàtic, s'anteposa el nom de la classe: Producte::nuevoProducto().\nSi des d'un mètode volem accedir a una propietat estàtica de la mateixa classe, s'utilitza la referència self: self::$numProductos\n\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0;\n\npublic static function nuevoProducto() {\nself::$numProductos++;\n}\n}\n\nProducto::nuevoProducto();\n$impuesto = Producto::IVA;\n\nTambé podem tindre classes normals que tinguen alguna propietat estàtica:\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0; \nprivate $codigo;\n\npublic function __construct(string $cod) {\nself::$numProductos++;\n$this-&gt;codigo = $cod;\n}\n\npublic function mostrarResumen() : string {\nreturn &quot;El producto &quot;.$this-&gt;codigo.&quot; es el número &quot;.self::$numProductos;\n}\n}\n\n$prod1 = new Producto(&quot;PS5&quot;);\n$prod2 = new Producto(&quot;XBOX Series X&quot;);\n$prod3 = new Producto(&quot;Nintendo Switch&quot;);\necho $prod3-&gt;mostrarResumen();\n\nIntrospecció\nEn treballar amb classes i objectes, existeixen un conjunt de funcions ja definides pel llenguatge que permeten obtindre informació sobre els objectes:\n\ninstanceof: permet comprovar si un objecte és d'una determinada classe\nget_class: retorna el nom de la classe\nget_declared_class: retorna un array amb els noms de les classes definides\nclass_àlies: crea un àlies\nclass_exists / method_exists / property_exists: true si la classe / mètode / propietat està definida\nget_class_methods / get_class_vars / get_object_vars: Retorna un array amb els noms dels mètodes / propietats d'una classe / propietats d'un objecte que són accessibles des d'on es fa la crida.\n\nUn exemple d'aquestes funcions pot ser el següent:\n&lt;?php\n$p = new Producto(&quot;PS5&quot;);\nif ($p instanceof Producto) {\necho &quot;Es un producto&quot;;\necho &quot;La clase es &quot;.get_class($p);\n\nclass_alias(&quot;Producto&quot;, &quot;Articulo&quot;);\n$c = new Articulo(&quot;Nintendo Switch&quot;);\necho &quot;Un articulo es un &quot;.get_class($c);\n\nprint_r(get_class_methods(&quot;Producto&quot;));\nprint_r(get_class_vars(&quot;Producto&quot;));\nprint_r(get_object_vars($p));\n\nif (method_exists($p, &quot;mostrarResumen&quot;)) {\n$p-&gt;mostrarResumen();\n}\n}\n\n!!! caution &quot;Clonat&quot;\nEn assignar dos objectes no es copien, es crea una nova referència. Si volem una còpia, cal clonar-ho mitjançant el mètode clone(object) : object\nSi volem modificar el clonat per defecte, cal definir el mètode màgic __clone() que es dirà després de copiar totes les propietats.\nMés informació en https://www.php.net/manual/es/language.oop5.cloning.php\nHerència\nPHP suporta herència simple, de manera que una classe només pot heretar d'una altra, no de dues classes alhora. Per a això s'utilitza la paraula clau extends. Si volem que la classe A hereta de la classe B farem:\nclass A extends B\n\nEl fill hereta els atributs i mètodes públics i protegits.\n!!! warning &quot;Cada classe en un arxiu&quot;\nCom ja hem comentat, hauríem de col·locar cada classe en un arxiu diferent per a posteriorment utilitzar-lo mitjançant include. En els següent exemple els hem col·locats junt per a facilitar la seua llegibilitat.\nPer exemple, tenim una classe Producte i una Tv que hereta de Producte:\n&lt;?php\nclass Producto {\npublic $codigo;\npublic $nombre;\npublic $nombreCorto;\npublic $PVP;\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n}\n\nPodemos utilizar las siguientes funciones para averiguar si hay relación entre dos clases:\n\nget_parent_class(object): string\nis_subclass_of(object, string): bool\n\n&lt;?php\n$t = new Tv();\n$t-&gt;codigo = 33;\nif ($t instanceof Producto) {\necho $t-&gt;mostrarResumen();\n}\n\n$padre = get_parent_class($t);\necho &quot;&lt;br&gt;La clase padre es: &quot; . $padre;\n$objetoPadre = new $padre;\necho $objetoPadre-&gt;mostrarResumen();\n\nif (is_subclass_of($t, 'Producto')) {\necho &quot;&lt;br&gt;Soy un hijo de Producto&quot;;\n}\n\nPolimorfisme\nPodem crear mètodes en els fills amb el mateix nom que el pare, canviant el seu comportament.\nPer a invocar als mètodes del pare -&gt; parent::nombreMetodo()\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nConstructor en fills\nEn els fills no es crea cap constructor de manera automàtica. Pel que si no n'hi ha, s'invoca automàticament al del pare. En canvi, si el definim en el fill, hem d'invocar al del pare de manera explícita.\n=== &quot;PHP7&quot;\n``` php\n&lt;?php\nclass Producto {\npublic string $codigo;\npublic function __construct(string $codigo) {\nthis−&gt;codigo=codigo;\n}\npublic function mostrarResumen() {\necho &quot;Prod:&quot;.$this-&gt;codigo.&quot;&quot;;\n}\n}\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\npublic function __construct(string codigo,intpulgadas, string Missing open brace for subscripttecnologia) { parent::__construct(tecnologia) { parent::__construct(codigo);\nthis−&gt;pulgadas=pulgadas;\nthis−&gt;tecnologia=tecnologia;\n}\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;TV &quot;.this−&gt;tecnologia.\"de\".this-&gt;pulgadas.&quot;&quot;;\n}\n}\n```\n=== &quot;PHP8&quot;\n``` php\n&lt;?php\nclass Producto {\npublic function __construct(private string $codigo)\npublic function mostrarResumen() {\necho &quot;Prod:&quot;.$this-&gt;codigo.&quot;&quot;;\n}\n}\nclass Tv extends Producto {\npublic function __construct(\nstring codigo,privateintpulgadas,\nprivate string Missing open brace for subscripttecnologia) { parent::__construct(tecnologia) { parent::__construct(codigo);\n}\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;TV &quot;.this−&gt;tecnologia.\"de\".this-&gt;pulgadas.&quot;&quot;;\n}\n}\n```\nAbstracció\nLes classes abstractes obliguen a heretar d'una classe, ja que no es permet la seua instanciación. Es defineix mitjançant abstract class NombreClase {.\nUna classe abstracta pot contindre propietats i mètodes no-abstractes, i/o mètodes abstractes.\n&lt;?php\n// Clase abstracta\nabstract class Producto {\nprivate $codigo;\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n// Método abstracto\nabstract public function mostrarResumen();\n}\n\nQuan una classe hereta d'una classe abstracta, obligatòriament ha d'implementar els mètodes que té el pare marcats com a abstractes.\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() { //obligado a implementarlo\necho &quot;&lt;p&gt;Código &quot;.$this-&gt;getCodigo().&quot;&lt;/p&gt;&quot;;\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\n$t = new Tv();\necho $t-&gt;getCodigo();\n\nClasses finals\nSón classes oposades a abstractes, ja que eviten que es puga heretar una classe o mètode per a sobreescriure-ho.\n&lt;?php\nclass Producto {\nprivate $codigo;\n\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n\nfinal public function mostrarResumen() : string {\nreturn &quot;Producto &quot;.$this-&gt;codigo;\n}\n}\n\n// No podremos heredar de Microondas\nfinal class Microondas extends Producto {\nprivate $potencia;\n\npublic function getPotencia() : int {\nreturn $this-&gt;potencia;\n}\n\n// No podemos implementar mostrarResumen()\n}\n\nInterfícies\nPermet definir un contracte amb les signatures dels mètodes a complir. Així doncs, només conté declaracions de funcions i totes han de ser públiques.\nEs declaren amb la paraula clau interface i després les classes que complisquen el contracte el realitzen mitjançant la paraula clau implements.\n&lt;?php\ninterface Nombreable {\n// declaración de funciones\n}\nclass NombreClase implements NombreInterfaz {\n// código de la clase\n\nEs permet l'herència d'interfícies. A més, una classe pot implementar diverses interfícies (en aquest cas, sí que suporta l'herència múltiple, però només d'interfícies).\n&lt;?php\ninterface Mostrable {\npublic function mostrarResumen() : string;\n}\n\ninterface MostrableTodo extends Mostrable {\npublic function mostrarTodo() : string;\n}\n\ninterface Facturable {\npublic function generarFactura() : string;\n}\n\nclass Producto implements MostrableTodo, Facturable {\n// Implementaciones de los métodos\n// Obligatoriamente deberá implementar public function mostrarResumen, mostrarTodo y generarFactura\n}\n\nMètodes encadenats\nSegueix el plantejament de la programació funcional, i també es coneix com method chaining. Planteja que sobre un objecte es realitzen diverses crides.\n&lt;?php\n$p1 = new Libro();\n$p1-&gt;setNombre(&quot;Harry Potter&quot;);\n$p1-&gt;setAutor(&quot;JK Rowling&quot;);\necho $p1;\n\n// Method chaining\n$p2 = new Libro();\n$p2-&gt;setNombre(&quot;Patria&quot;)-&gt;setAutor(&quot;Aramburu&quot;);\necho $p2;\n\nPer a facilitar-ho, modificarem tots els seus mètodes mutants (que modifiquen dades, setters*, ...) perquè retornen una referència a $this:\n&lt;?php\nclass Libro {\nprivate string $nombre;\nprivate string $autor;\n\npublic function getNombre() : string {\nreturn $this-&gt;nombre;\n}\npublic function setNombre(string $nombre) : Libro { \n$this-&gt;nombre = $nombre;\nreturn $this;\n}\n\npublic function getAutor() : string {\nreturn $this-&gt;autor;\n}\npublic function setAutor(string $autor) : Libro {\n$this-&gt;autor = $autor;\nreturn $this;\n}\n\npublic function __toString() : string {\nreturn $this-&gt;nombre.&quot; de &quot;.$this-&gt;autor;\n}\n}\n\nMètodes màgics\nTotes les classes PHP ofereixen un conjunt de mètodes, també coneguts com magic methods que es poden sobreescriure per a substituir el seu comportament. Alguns d'ells ja els hem utilitzats.\nDavant qualsevol dubte, és convenient consultar la documentació oficial.\nEls més destacables són:\n\n__construct()\n__destruct() → s'invoca en perdre la referència. S'utilitza per a tancar una connexió a la BD, tancar un fitxer, ...\n__toString() → representació de l'objecte com a cadena. És a dir, quan fem echo $objecte s'executa automàticament aquest mètode.\n__get(propietat), __set(propietat, valor) → Permetria accedir a les propietat privades, encara que sempre és més llegible/mantenible codificar els getter/setter.\n__isset(propietat), __unset(propietat) → Permet esbrinar o llevar el valor a una propietat.\n__sleep(), __wakeup() → S'executen en recuperar (*unserialize^) o emmagatzemar un objecte que se serialitza (*serialize), i s'utilitzen per a permet definir quines propietats se serialitzen.\n__call(), __callStatic() → S'executen en cridar a un mètode que no és públic. Permeten sobrecarreguen mètodes.\n\n3. Espai de noms\nDes de PHP 5.3 i també coneguts com Namespaces, permeten organitzar les classes/interfícies, funcions i/o constants de manera similar als paquets a Java.\n!!! tip &quot;Recomanació&quot;\nUn només namespace per arxiu i crear una estructura de carpetes respectant els nivells/subnivells (igual que es fa a Java)\nEs declaren en la primera línia mitjançant la paraula clau namespace seguida del nom de l'espai de noms assignat (cada subnivell se separa amb la barra invertida \\):\nPer exemple, per a col·locar la classe Producte dins del namespace Dwes\\Exemples ho faríem així:\n&lt;?php\nnamespace Dwes\\Exemples;\n\nconst IVA = 0.21;\n\nclass Producte {\npublic $nombre;\n  \npublic function muestra() : void {\necho&quot;&lt;p&gt;Prod:&quot; . $this-&gt;nombre . &quot;&lt;/p&gt;&quot;;\n}\n}\n\nAccés\nPer a referenciar a un recurs que conté un namespace, primer hem de tindre'l disponible fent ús de include o require. Si el recurs està en el mateix namespace, es realitza un accés directe (es coneix com a accés sense qualificar).\nRealment hi ha tres tipus d'accés:\n\nsense qualificar: recurs\nqualificat: rutaRelativa\\recurs → no fa falta posar el namespace complet\ntotalment qualificat: \\rutaAbsoluta\\recurs\n\n&lt;?php\nnamespace Dwes\\Ejemplos;\n\ninclude_once(&quot;Producto.php&quot;);\n\necho IVA; // sin cualificar\necho Utilidades\\IVA; // acceso cualificado. Daría error, no existe \\Dwes\\Ejemplos\\Utilidades\\IVA\necho \\Dwes\\Ejemplos\\IVA; // totalmente cualificado\n\n$p1 = new Producto(); // lo busca en el mismo namespace y encuentra \\Dwes\\Ejemplos\\Producto\n$p2 = new Model\\Producto(); // daría error, no existe el namespace Model. Está buscando \\Dwes\\Ejemplos\\Model\\Producto\n$p3 = new \\Dwes\\Ejemplos\\Producto(); // \\Dwes\\Ejemplos\\Producto\n\nAccés\nPer a evitar la referència qualificada podem declarar l'ús mitjançant use (similar a fer import a Java). Es fa en la capçalera, després del namespace:\nEls tipus Posibles són:\n\nuse const nombreCualificadoConstante\nuse function nombreCualificadoFuncion\nuse nombreCualificadoClase\nuse nombreCualificadoClase as NuevoNombre // per a canviar de nom elements\n\nPer exemple, si volem utilitzar la classe \\Dwes\\Exemples\\Producte des d'un recurs que es troba en l'arrel, per exemple en inici.php, faríem:\n&lt;?php\ninclude_once(&quot;Dwes\\Exemples\\Producte.php&quot;);\n\nuse const Dwes\\Exemples\\IVA;\nuse \\Dwes\\Exemples\\Producte;\n\necho IVA;\n$p1 = new Producte();\n\n!!! tip &quot;To use or not to use&quot;\nEn resum, use permet accedir sense qualificar a recursos que estan en un altre namespace. Si estem en el mateix espai de nom, no necessitem use.\nOrganització\nTot projecte, conforme creix, necessita organitzar el seu codi font. Es planteja una organització en la qual els arxius que interactuan amb el navegador es col·loquen en l'arrel, i les classes que definim van dins d'un namespace (i dins de la seua pròpia carpeta src o app).\n\nOrganització del codi font\n\n!!! tip &quot;Organització, includes i usos&quot;\n* Col·locarem cada recurs en un fitxer a part.\n* En la primera línia indicarem la seua namespace (si no està en l'arrel).\n* Si utilitzem altres recursos, farem un include_once d'aqueixos recursos (classes, interfícies, etc...).\n* Cada recurs ha d'incloure tots els altres recursos que referencie: la classe de la qual hereta, interfícies que implementa, classes utilitzades/rebudes com a paràmetres, etc...\n* Si els recursos estan en un espai de noms diferent al que estem, emprarem use amb la ruta completa per a després utilitzar referències sense qualificar.\nAutoload\nNo és tediós haver de fer el include de les classes? El autoload ve al rescat.\nAixí doncs, permet carregar les classes (no les constants ni les funcions) que s'utilitzaran i evitar haver de fer el include_once de cadascuna d'elles. Per a això, es pot utilitzar el composer.\n4. Composer\n\nLogo Composer\n\nEina per excel·lència en PHP per a la gestió de llibreries i dependències, de manera que instal·la i les actualitza assegurant que tot l'equip de desenvolupament té el mateix entorn i versions. A més, ofereix autoloading del nostre codi, de manera que no hàgem de fer-lo nosaltres &quot;a mà&quot;.\nEstà escrit en PHP, i podeu consultar tota la seua documentació en https://getcomposer.org/.\nUtilitza Packagist com a repositori de llibreries.\nFuncionalment, és similar a Maven (Java) / npm (JS).\nInstal·lació\nSi estem usant XAMPP, hem d'instal·lar Composer en el propi sistema operatiu. Es recomana seguir les instruccions oficials segons el sistema operatiu a emprar.\nEn canvi, si usem Docker, necessitem modificar la configuració del nostre contenidor. En el nostre cas, hem decidit modificar l'arxiu Dockerfile i afegir el següent comando:\nCOPY --from=composer:2.0 /usr/bin/composer /usr/local/bin/composer\n\nÉs important que dins del contenidor comprovem que tenim la v2:\ncomposer -V\n\nPrimers passos\nQuan creem un projecte per primera vegada, hem d'inicialitzar el repositori. Per a això, executarem el comando composer init on:\n\nConfigurem el nom del paquet, descripció, autor (nom ), tipus de paquet (project), etc...\nDefinim les dependències del projecte (require) i les de desenvolupament (require-dev) de manera interactiva.\nEn les de desenvolupament s'indica aquelles que no s'instal·laran a l'entorn de producció, per exemple, les llibreries de proves.\n\nDesprés de la seua configuració, es crearà automàticament l'arxiu composer.json amb les dades introduïdes i descàrrega les llibreries en la carpeta vendor. La instal·lació de les llibreries sempre es realitza de manera local per a cada projecte.\n{\n&quot;name&quot;: &quot;dwes/log&quot;,\n&quot;description&quot;: &quot;Pruebas con Monolog&quot;,\n&quot;type&quot;: &quot;project&quot;,\n&quot;require&quot;: {\n&quot;monolog/monolog&quot;: &quot;^2.1&quot;\n},\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;authors&quot;: [\n{\n&quot;name&quot;: &quot;Aitor Medrano&quot;,\n&quot;email&quot;: &quot;a.medrano@edu.gva.es&quot;\n}\n]\n}\n\nA l'hora d'indicar cada llibreria introduirem:\n\nel nom de la llibreria, composta tant pel creador o &quot;vendor&quot;, com pel nom del projecte. Exemples: monolog/monolog o laravel/installer.\n\nla versió de cada llibreria. Tenim diverses opcions per a indicar-la:\n\nDirectament: 1.4.2\nAmb comodins: 1.\nA partir de: &gt;= 2.0.3\nSense trencament de canvis:\n{ #1}\n.3.2 // &gt;=1.3.2 &lt;2.0.0\n\nActualitzar llibreries\nPodem definir les dependències via l'arxiu composer.json o mitjançant comandos amb el format composer require vendor/package:version. Per exemple, si volem afegir phpUnit com a llibreria de desenvolupament, farem:\ncomposer require phpunit/phpunit –dev\n\nDesprés d'afegir noves llibreries, hem d'actualitzar el nostre projecte:\ncomposer update\n\nSi creem l'arxiu composer.json nosaltres directament sense inicialitzar el repositori, hem d'instal·lar les dependències:\ncomposer install\n\nEn fer aquest pas (tant instal·lar com actualitzar), com ja hem comentat, es descarreguen les llibreries en dins de la carpeta vendor. És molt important afegir aquesta carpeta a l'arxiu .gitignore per a no pujar-les a GitHub.\nA més es crea l'arxiu composer.lock, que emmagatzema la versió exacta que s'ha instal·lat de cada llibreria (aquest arxiu no es toca).\nautoload.php\nComposer crea de manera automàtica en vendor/autoload.php el codi per a incloure de manera automàtica totes les llibreries que tinguem configurades en composer.json.\nPer a utilitzar-ho, en la capçalera del nostre arxius posarem:\n&lt;?php\nrequire 'vendor/autoload.php';\n\nEn el nostre cas, de moment només el podrem en els arxius on provem les classes\nSi volem que Composer també s'encarregue de carregar de manera automàtica les nostres classes de domini, dins de l'arxiu composer.json, definirem la propietat autoload:\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {&quot;Dwes\\\\&quot;: &quot;app/Dwes&quot;}\n},\n\nPosteriorment, hem de tornar a generar el autoload de Composer mitjançant l'opció dump-autoload (o du):\ncomposer dump-autoload\n\n5. Logger amb Monolog\nProvarem Composer afegint la llibreria de Monolog al nostre projecte. Es tracta d'un llibreria per a la gestió de logs de les nostres aplicacions, suportant diferents nivells (info, warning, etc...), eixides (fitxers, sockets, BBDD, Web Services, email, etc) i formats (text pla, HTML, JSON, etc...).\nPer a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require monolog/monolog\n\nMonolog 2 requereix almenys PHP 7.2, compleix amb el estandar de logging PSR-3, i és la llibreria emprada per Laravel i Symfony per a la gestió de logs.\n!!! info &quot;Quan utilitzar un log&quot;\n* Seguir les acciones/moviments dels usuaris\n* Registrar les transaccions\n* Rastrejar els errors d'usuari\n* Fallades/avisos a nivell de sistema\n* Interpretar i col·leccionar dades per a posterior investigació de patrons\nNivells\nA continuació vam mostrar els diferents nivells de menys a més restrictiu:\n* debug -100: Informació detallada amb propòsits de debug. No usar en entorns de producció.\n* info - 200: Esdeveniments interessants com l'inici de sessió d'usuaris.\n* notice - 250: Esdeveniments normals però significatius.\n* warning - 300: Ocurrències excepcionals que no arriben a ser error.\n* error - 400: Errors d'execució que permeten continuar amb l'execució de l'aplicació però que han de ser monitorats.\n* critical - 500: Situacions importants on es generen excepcions no esperades o no hi ha disponible un component.\n* alert - 550: S'han de prendre mesures immediatament.\nCaiguda completa de la web, base de dades no disponible, etc... A més, se solen enviar missatges per email.\n* emergency - 600: És l'error més greu i indica que tot el sistema està inutilitzable.\nHola Monolog\nPer exemple, en l'arxiu pruebaLog.php que col·locaríem en l'arrel, primer incloem el autoload, importem els classes a utilitzar per a finalment usar els mètodes de Monolog:\n&lt;?php\ninclude __DIR__ .&quot;/vendor/autoload.php&quot;;\n\nuse Monolog\\Level;\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger(&quot;MiLogger&quot;);\n$log-&gt;pushHandler(new StreamHandler(&quot;logs/milog.log&quot;, Level::Debug));\n\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;);\n$log-&gt;error(&quot;Esto es un mensaje de ERROR&quot;);\n$log-&gt;critical(&quot;Esto es un mensaje de CRITICAL&quot;);\n$log-&gt;alert(&quot;Esto es un mensaje de ALERT&quot;);\n\nEn tots els mètodes de registre de missatges (debug, info, ...), a més del propi missatge, li podem passar informació com el contingut d'alguna variable, usuari de l'aplicació, etc.. com a segon paràmetre dins d'un array, el qual es coneix com array de contexte.\nÉs convenient fer-ho mitjançant un array associatiu per a facilitar la lectura del log.\n&lt;?php\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [$producto]);\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [&quot;datos&quot; =&gt; $producto]);\n\nFuncionament\nCada instància Logger té un nom de canal i una pila de manejadores (handler).\nCada missatge que manem al log travessa la pila de manejadores, i cadascun decideix si ha de registrar la informació, i si es dona el cas, finalitzar la propagació.\nPer exemple, un StreamHandler en el fons de la pila que ho escriga tot en disc, i en el topall afig un MailHandler que envie un mail només quan hi haja un error.\nEls manejadores més utilitzats són:\n\nStreamHandler(ruta, nivel)\nRotatingFileHandler(ruta, maxFiles, nivel)\nNativeMailerHandler(para, asunto, desde, nivel)\nFirePHPHandler(nivel)\n\nPer exemple: Si volem que els missatges de l'aplicació isquen pel log del servidor,\nen el nostre cas l'arxiu error.log de Apatxe utilitzarem com a ruta l'eixida d'error:\n&lt;?php\n// error.log\n$log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Level::Debug));\n\n!!! tip &quot;FirePHP&quot;\nPer exemple, mitjançant FirePHPHandler, podem utilitzar FirePHP, la qual és una eina per a fer debug en la consola de Firefox*.\nDesprés d'instal·lar l'extensió en Firefox, habilitar les opcions i configurar el Handler, podem veure els missatges acolorits amb les seues dades:\n``` php\n&lt;?php\n$log = new Logger(&quot;MiFirePHPLogger&quot;);\n$log-&gt;pushHandler(new FirePHPHandler(Level::INFO));\n$datos = [&quot;real&quot; =&gt; &quot;Bruce Wayne&quot;, &quot;personaje&quot; =&gt; &quot;Batman&quot;];\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;, $datos);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;, $datos);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;, $datos);\n// ...\n```\n\nEjemplo de uso de FirePHP\n\nManejadors\nSi no s'indica cap, se li assigna un per defecte. L'últim manejador inserit serà el primer a executar-se.\nDesprés es van executant conforme a la pila.\nProcessadors\nEls processadors permeten afegir informació als missatges.\nPer a això, s'apilen després de cada manejador mitjançant el mètode pushProcessor($processador).\nAlguns processadors coneguts són IntrospectionProcessor (mostren la línia, fitxer, classe i metodo des del qual s'invoca el log), WebProcessor (afig la URI, mètode i IP) o GitProcessor (afig la branca i el commit).\n=== &quot;PHP&quot;\nphp &lt;?php $log = new Logger(&quot;MiLogger&quot;); $log-&gt;pushHandler(new RotatingFileHandler(&quot;logs/milog.log&quot;, 0, Level::DEBUG)); $log-&gt;pushProcessor(new IntrospectionProcessor()); $log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Level::WARNING)); // no usa Introspection pq lo hemos apilado después, le asigno otro $log-&gt;pushProcessor(new WebProcessor());\n=== &quot;Consola en format text&quot;\nlog [2020-11-26T13:35:31.076138+01:00] MiLogger.DEBUG: Esto es un mensaje de DEBUG [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:12,&quot;class&quot;:null,&quot;function&quot;:null} [2020-11-26T13:35:31.078344+01:00] MiLogger.INFO: Esto es un mensaje de INFO [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:13,&quot;class&quot;:null,&quot;function&quot;:null}\nFormatadors\nS'associen als manejadores amb setFormatter. Els formateadores més utilitzats són LineFormatter, HtmlFormatter o JsonFormatter.\n=== &quot;PHP&quot;\nphp &lt;?php $log = new Logger(&quot;MiLogger&quot;); $rfh = new RotatingFileHandler(&quot;logs/milog.log&quot;, Level::Debug); $rfh-&gt;setFormatter(new JsonFormatter()); $log-&gt;pushHandler($rfh);\n=== &quot;Consola en JSON&quot;\njson {&quot;message&quot;:&quot;Esto es un mensaje de DEBUG&quot;,&quot;context&quot;:{},&quot;level&quot;:100,&quot;level_name&quot;:&quot;DEBUG&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747211+01:00&quot;,&quot;extra&quot;:{}} {&quot;message&quot;:&quot;Esto es un mensaje de INFO&quot;,&quot;context&quot;:{},&quot;level&quot;:200,&quot;level_name&quot;:&quot;INFO&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747538+01:00&quot;,&quot;extra&quot;:{}}\n!!! tip &quot;Més informació&quot;\nMés informació sobre manejadores, formateadores i processadors en https://github.com/Seldaek/monolog/blob/master/doc/02-handlers-formatters-processors.md\n6. Generació de PDF amb DOMPDF\nAmb PHP podem manejar tot tipus d'arxius com ja hem vist però, què passa si volem generar fitxers PDF amb dades tretes d'una base de dades?\n\nGràcies a una classe escrita en PHP, podem generar arxius PDF sense necessitat d'instal·lar llibreries addicionals en el nostre servidor.\nPerò anem a utilitzar una llibreria que permet transformar codi html en pdf.\nDOMPDF\nAfegirem la llibreria de DOMPDF al nostre projecte. Per a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require dompdf/dompdf\n\nUna vegada que DOMPDF està instal·lat, el procés per generar PDFs des de HTML és bastant directe. Els passos bàsics són:\nPas 1: Incloent DOMPDF\nPrimer, necessitarem incloure DOMPDF en el script PHP. Si estem utilitzant Composer, això es fa automàticament a través de l'auto-càrrega de Composer. Només cal afegir la següent línia al principi del'script:\nrequire 'vendor/autoload.php';\n\nPas 2: Creació d'una Instància de DOMPDF\nA continuació, creem una nova instància de la classe DOMPDF:\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n\nPas 3: Carregar HTML\nDesprés, carregem l'HTML en l'objecte DOMPDF. Això es pot fer directament com una cadena o carregant un fitxer HTML:\n$html = &quot;&lt;html&gt;&lt;body&gt;Hola, això és una prova.&lt;/body&gt;&lt;/html&gt;&quot;;\n$dompdf-&gt;loadHtml($html);\n\nO bé carregar un fitxer HTML:\n$dompdf-&gt;loadHtml(file_get_contents('path/to/your/file.html'));\n\nPas 4: Configuració de la Mida del Paper i l'Orientació\nPodem configurar la mida del paper i l'orientació si és necessari:\n$dompdf-&gt;setPaper('A4', 'portrait'); // o 'landscape'\n\nPas 5: Renderització del PDF\nAra, demanem a DOMPDF que renderitze el PDF:\n$dompdf-&gt;render();\n\nPas 6: Eixida del PDF\nFinalment, podem enviar el PDF al navegador, guardar-lo en un fitxer o fer amb ell el que necessitem:\nPer mostrar-lo al navegador:\n$dompdf-&gt;stream(&quot;document.pdf&quot;, array(&quot;Attachment&quot; =&gt; false));\n\nPer desar-lo en un fitxer:\n$output = $dompdf-&gt;output();\nfile_put_contents('path/to/save/document.pdf', $output);\n\nConsells Addicionals\nCal assegurar-se que l'HTML és vàlid i ben format. DOMPDF intenta ser tolerant amb l'HTML, però l'HTML mal format pot causar problemes.\nEl CSS que s'utilitze pot afectar significativament com es veu el PDF. DOMPDF suporta una bona part de CSS 2.1, però no tot.\nSi necessitem incloure imatges, cal assegurar-se que les rutes són absolutes i accessibles des del servidor on s'executa DOMPDF.\nAquesta és una guia bàsica per començar amb DOMPDF. Per a casos d'ús més avançats i opcions de configuració, cal consultar la documentació oficial de DOMPDF.\n7. Documentación con phpDocumentor\nphpDocumentor és l'eina per a documentar el codi PHP. És similar en propòsit i funcionament a Javadoc.\nAixí doncs, és un eina que facilita la documentació del codi PHP, creant un lloc web amb l'API de l'aplicació.\nEs basa en l'ús d'anotacions sobre els docblocks. Per a posar-ho en marxa, en el nostre cas ens decantarem per utilitzar la imatge que ja existeix de Docker.\nInstal·lació\nPas 1: Instal·lació amb Docker\nPrimer, cal assegurar-se tenir Docker instal·lat i funcionant al sistema. Després, s'ha de descarregar i executar el contenidor de phpDocumentor utilitzant la següent comanda:\ndocker pull phpdoc/phpdoc\n\nPas 2: Generació de Documentació\nUn cop tinguem la imatge, podem utilitzar-la per generar la documentació. El procés bàsic implica muntar els fitxers de codi dins del contenidor Docker i executar phpDocumentor sobre aquests fitxers.\nAcí hi ha un exemple de com fer-ho:\nEn el cas d'usar Docker, usarem el següent comando per a executar-lo (crea el contenidor, executa el comando que li demanem, i automàticament l'esborra):\ndocker run --rm -v $(pwd):/data phpdoc/phpdoc:latest run -d /data/src -t /data/src/docs\n\nAquesta comanda fa el següent:\n* -rm: Això elimina el contenidor després d'executar-lo, així no es queden contenidors inactius.\n* -v (pwd):/data:Muntaeldirectoriactualdelteusistema((pwd)) al directori /data dins del contenidor. Hauràs de reemplaçar $(pwd) amb el camí on està el teu codi font si no estàs executant aquesta comanda des del directori del teu projecte.\n* -d /data/src: Especifica el directori dins del contenidor on es troba el teu codi font. Reemplaça /data/src amb el camí corresponent dins del contenidor si és diferent.\n* -t /data/src/docs: Especifica on vols que es generi la documentació dins del contenidor. En aquest cas, es generarà dins de /data/docs.\nPas 3: Accés a la Documentació Generada\nUna vegada generada, la documentació estarà dins del directori que especificat (en aquest cas, docs dins del directori docs de projecte). Pots obrir els fitxers HTML amb qualsevol navegador per veure la documentació.\nDocBlock\nUn docblock és el bloc de codi que es col·loca damunt d'un recurs. El seu format és:\n&lt;?php\n/**\n* Sumari*, una sola línia\n\n* Descripció* que pot utilitzar diverses línies\n* i que ofereix detalls de l'element o referències\n* per a ampliar la informació\n\n* @param string $miArgumento amb una descripció* de l'argument\n* que pot usar diverses línies.\n\n* @return void\n*/\nfunction miFuncion(tipo $miArgumento)\n{\n}\n\n!!! tip &quot;Visual Studio Code&quot;\nPer tal que us ajude a documentar podeu utilitzar l'extensió PHP DocBlocker.\nDocumentant el codi\nEn tots els elements, ademas del sumari i/o descripció, posarem:\n\nEn les classes:\n\n@author nom\n@package ruta del namespace\n\nEn les propietats:\n\n@var tipus descripció\n\nEn els mètodes:\n\n@param tipus $nomene descripció\n@throws ClaseException descripció\n@return tipus descripció\n\nVegem-ho amb un exemple. Suposem que tenim una classe que representa un client:\n&lt;?php\n/**\n* Classe que representa un client\n*\n* El client s'encarrega d'emmagatzemar els suports que té llogat,\n* de manera que podem llogar i retornar productes mitjançant les operacions\n* homònimes.\n*\n* @package Dwes\\Videoclub\\Model\n* @author Aitor Medrano &lt;a.medrano@edu.gva.es&gt;\n*/\nclass Cliente {\n\npublic string $nombre;\nprivate string $numero;\n\n/**\n* Colecció de soports alquilats\n* @var array&lt;Soporte&gt;\n*/\nprivate $soportesAlquilados[];\n\n/*\n* Comprova si el suport rebut ja el té llogat el client\n* @param Suport $suporte Suport a comprovar\n* @return bool true si ho té llogat\n/\npublic function tieneAlquilado(Soporte $soporte) : bool {\n// ...\n}\n\nSi generem la documentació i obrim amb un navegador l'arxiu docs/api/index.html podrem navegar fins a la classe `Client:\n\nphpDocumentor de Cliente\n\n8. Separar la lògica de negoci dels aspectes de presentació de l'aplicació\nLògica de Negoci\n\nRegles i procediments que defineixen el funcionament de l'aplicació.\nInclou processament de dades, càlculs, interaccions amb la base de dades, etc.\n\nAspectes de Presentació\n\nManera en què es mostra la informació a l'usuari.\nInclou la interfície d'usuari, disseny, navegació, etc.\n\nAvantatges\n\nMantenibilitat\n\nFacilita la modificació de la lògica de negoci sense afectar la presentació.\nPermet actualitzar la interfície d'usuari sense modificar la lògica subjacent.\n\nReutilització\n\nLa lògica de negoci pot ser reutilitzada en diferents aplicacions amb interfícies variades.\nEls components de presentació poden ser reutilitzats amb diferents lògiques de negoci.\n\nEscalabilitat\n\nAjuda a escalar l'aplicació separant les preocupacions, permetent millorar una part sense impactar l'altra.\n\nProva i Depuració\n\nFacilita les proves unitàries i la depuració en permetre provar la lògica de negoci per separat de la interfície.\n\nCol·laboració\n\nPermet que desenvolupadors de backend i frontend treballen de manera independent en les seues àrees respectives.\n\nTecnologies i Mecanismes per a la Separació\nA continuació es presenten diverses tecnologies i mecanismes que faciliten la separació de la lògica de negoci i la presentació en una aplicació web:\nFrameworks PHP:\nLaravel: Framework que segueix el patró MVC (Model-View-Controller). Laravel facilita la creació de codi net i ben organitzat, separant clarament la lògica de negoci de la presentació.\nSymfony: Altres frameworks populars que també segueixen el patró MVC i ofereixen eines per a la separació de la lògica i la presentació.\nPatró MVC:\nModel-View-Controller: Patró de disseny que divideix una aplicació en tres components interconnectats:\nModel: Gestiona la lògica de negoci i les dades.\nVista: Gestiona la presentació de la informació.\nControlador: Gestiona la comunicació entre el Model i la Vista.\nPlantilles:\nBlade (Laravel): Motor de plantilles que permet separar el codi HTML de la lògica de negoci.\nTwig (Symfony): Motor de plantilles similar a Blade, utilitzat per separar la lògica de negoci del codi de presentació.\nAPI REST:\nPermet crear serveis web que exposen funcionalitats i dades a través de punts finals d'API, mantenint la lògica de negoci separada de la presentació.\nExemple MVC\n// Model: Product.php\nclass Product {\nprivate string $name;\nprivate float $price;\n\npublic function __construct(string $name, float $price) {\n$this-&gt;name = $name;\n$this-&gt;price = $price;\n}\n\npublic function getName(): string {\nreturn $this-&gt;name;\n}\n\npublic function getPrice(): float {\nreturn $this-&gt;price;\n}\n}\n\n// Controller: ProductController.php\nclass ProductController {\npublic function showProduct() {\n$product = new Product(&quot;Laptop&quot;, 1200.00);\ninclude 'views/productView.php';\n}\n}\n\n// View: productView.php\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Product Information&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Product: &lt;?php echo htmlspecialchars($product-&gt;getName()); ?&gt;&lt;/h1&gt;\n&lt;p&gt;Price: $&lt;?php echo htmlspecialchars($product-&gt;getPrice()); ?&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nLa separació de la lògica de negoci dels aspectes de presentació és crucial per al desenvolupament d'aplicacions web eficients, mantenibles i escalables.\n9. Gestió d'Exempcions\nLa gestió d'excepcions forma part des de PHP 5. El seu funcionament és similar a Java*, fent ús d'un bloc try / catch / finally.\nSi detectem una situació anòmala i volem llançar una excepció, haurem de realitzar throw new Exception (adjuntant el missatge que l'ha provocat).\n&lt;?php\ntry {\nif ($divisor == 0) {\nthrow new Exception(&quot;División por cero.&quot;);\n}\n$resultado = $dividendo / $divisor;\n} catch (Exception $e) {\necho &quot;Se ha producido el siguiente error: &quot;.$e-&gt;getMessage();\n}\n\nLa classe Exception és la classe pare de totes les excepcions. El seu constructor rep missatge[,codigoError][,excepcionPrevia].\nA partir d'un objecte Exception, podem accedir als mètodes getMessage()i getCode() per a obtindre el missatge i el codi d'error de l'excepció capturada.\nEl propi llenguatge ofereix un conjunt d'excepcions ja definides, les quals podem capturar (i llançar des de PHP 7). Es recomana la seua consulta en la documentació oficial.\nCreant exempcions\nPer a crear una excepció, la forma més curta és crear una classe que únicament herete de Exception.\n&lt;?php\nclass HolaExcepcion extends Exception {}\n\nSi volem, i és recomanable depenent dels requisits, podem sobrecarregar els mètodes màgics, per exemple, sobrecarregant el constructor i cridant al constructor del pare, o reescriure el mètode __toString per a canviar el seu missatge:\n&lt;?php\nclass MiExcepcion extends Exception {\n    public function __construct($msj, $codigo = 0, Exception $previa = null) {\n        // código propio\n        parent::__construct($msj, $codigo, $previa);\n    }\n    public function __toString() {\n        return __CLASS__ . &quot;: [{$this-&gt;code}]: {$this-&gt;message}\\n&quot;;\n    }\n    public function miFuncion() {\n        echo &quot;Una función personalizada para este tipo de excepción\\n&quot;;\n    }\n}\n\nSi definim una excepció d'aplicació dins d'un namespace, quan referenciem a Exception, haurem de referenciar-la mitjançant el seu nom totalment qualificat (\\Exception), o utilitzant use:\n=== &quot;Mitjançant nom totalment qualificat&quot;\n``` php\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\nclass AppExcepcion extends \\Exception {}\n=== &quot;Mitjançant `use`&quot; php\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\nuse Exception;\nclass AppExcepcion extends Exception {}\n```\nExempcions múltiples\nEs poden usar excepcions múltiples per a comprovar diferents condicions. A l'hora de capturar-les, es fa de més específica a més general.\n&lt;?php\n$email = &quot;ejemplo@ejemplo.com&quot;;\ntry {\n    // Comprueba si el email es válido\n    if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE) {\n        throw new MiExcepcion($email);\n    }\n    // Comprueba la palabra ejemplo en la dirección email\n    if(strpos($email, &quot;ejemplo&quot;) !== FALSE) {\n        throw new Exception(&quot;$email es un email de ejemplo no válido&quot;);\n    }\n} catch (MiExcepcion $e) {\n    echo $e-&gt;miFuncion();\n} catch(Exception $e) {\n    echo $e-&gt;getMessage();\n}\n\n!!! question &quot;Autoevaluación&quot;\n¿Qué pasaría al ejectuar el siguiente código?\n``` php\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException Extra open brace or missing close bracee) {     echo \"Capturada MainException \" . e) {     echo \"Capturada MainException \" . e-&gt;getMessage();\n} catch (SubException Extra open brace or missing close bracee) {     echo \"Capturada SubException \" . e) {     echo \"Capturada SubException \" . e-&gt;getMessage();\n} catch (Exception Extra open brace or missing close bracee) {     echo \"Capturada Exception \" . e) {     echo \"Capturada Exception \" . e-&gt;getMessage();\n}\n```\nSi en el mateix catch volem capturar diverses excepcions, hem d'utilitzar l'operador |:\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\n\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException | SubException $e ) {\n    echo &quot;Capturada Exception &quot; . $e-&gt;getMessage();\n}\n\nDes de PHP 7, existeix el tipus Throwable, el qual és una interfície que implementen tant els errors com les excepcions, i ens permet capturar els dos tipus alhora:\n&lt;?php\ntry {\n    // tu codigo\n} catch (Throwable $e) {\n    echo 'Forma de capturar errores y excepciones a la vez';\n}\n\nSi només volem capturar els errors fatals, podem fer ús de la classe Error:\n&lt;?php\ntry {\n    // Genera una notificación que no se captura\n    echo $variableNoAsignada;\n    // Error fatal que se captura\n    funcionQueNoExiste();\n} catch (Error $e) {\n    echo &quot;Error capturado: &quot; . $e-&gt;getMessage();\n}\n\nRellançar exempcions\nEn les aplicacions reals, és molt comuna capturar una excepció de sistema i llançar una d'aplicació que hem definit nostros.\nTambé podem llançar les excepcions sense necessitat d'estar dins d'un try/catch.\n&lt;?php\nclass AppException extends Exception {}\n\ntry {\n    // Código de negocio que falla\n} catch (Exception $e) {\n    throw new AppException(&quot;AppException: &quot;.$e-&gt;getMessage(), $e-&gt;getCode(), $e);\n}\n\n10. Proves amb PHPUNIT\nEl curs passat, dins del mòdul de Entorns de Desenvolupament, estudiarieu la importància de la realització de proves, així com les proves unitàries mitjançant JUnit.\n\nTest Driven Development\n\nHui dia és de gran importància seguir una bona metodologia de proves, sent el desenvolupament dirigit per les proves (Test Driven Development / TDD) un dels enfocaments més emprats, el qual consisteix en:\n\nEscriure el test, i com no hi ha codi implementat, la prova falle (roig).\nEscriure el codi d'aplicació perquè la prova funcione (verda).\nrefactoritzar el codi de l'aplicació amb l'ajuda de la prova per a comprovar que no trenquem res (refactor).\n\nEn el cas de PHP, l'eina que s'utilitza és PHPUnit (https://phpunit.de/), que com el seu nom indica, està basada en JUnit. La versió actual és la 11.\nIntroducció a PHPUnit\nPHPUnit és un framework de proves popular per a PHP que suporta tant proves unitàries com proves d'integració. És àmpliament utilitzat en la comunitat PHP per la seua simplicitat i eficàcia. Les proves unitàries es centren en provar components o mètodes individuals, mentre que les proves d'integració asseguren que les diferents parts del sistema funcionen conjuntament com s'espera.\nInstal·lació\nPer començar a utilitzar PHPUnit, cal instal·lar-lo. La manera recomanada és a través de Composer. Executa la següent comanda en el terminal:\ncomposer require --dev phpunit/phpunit\n\nAquesta comanda afegirà PHPUnit com a dependència de desenvolupament en el teu projecte.\n!!! tip &quot;Llibreries de desenvolupament&quot;\nLes llibreries que es col·loquen en require-dev són les de desenvolupament i testing, de manera que no s'instal·laran en un entorn de producció.\nUna vegada instal·lat, podem configurar PHPUnit creant un fitxer phpunit.xml en l'arrel del projecte per especificar la configuració de les proves:\n&lt;phpunit bootstrap=&quot;vendor/autoload.php&quot;&gt;\n&lt;testsuites&gt;\n&lt;testsuite name=&quot;Application Test Suite&quot;&gt;\n&lt;directory&gt;tests&lt;/directory&gt;\n&lt;/testsuite&gt;\n&lt;/testsuites&gt;\n&lt;/phpunit&gt;\n\nEstructura d’un test\nEls tests en PHPUnit són classes PHP que hereten de PHPUnit\\Framework\\TestCase. Cada mètode dins d'aquestes classes que comence amb test serà executat com una prova.\nuse PHPUnit\\Framework\\TestCase;\nuse App\\Models\\Empleado;\n\nclass EmpleadoTest extends TestCase {\nprivate $empleado;\n\nprotected function setUp(): void {\n$this-&gt;empleado = new Empleado('John', 'Doe', 4000, 30);\n}\n\npublic function testGetSou() {\n$this-&gt;assertEquals(4000, $this-&gt;empleado-&gt;getSou());\n}\n\npublic function testSetSou() {\n$this-&gt;empleado-&gt;setSou(4500);\n$this-&gt;assertEquals(4500, $this-&gt;empleado-&gt;getSou());\n}\n\npublic function testGetTelefonos() {\n$this-&gt;assertIsArray($this-&gt;empleado-&gt;getTelefonos());\n$this-&gt;assertEmpty($this-&gt;empleado-&gt;getTelefonos());\n}\n\npublic function testSetTelefono() {\n$this-&gt;empleado-&gt;setTelefono('123456789');\n$this-&gt;assertCount(1, $this-&gt;empleado-&gt;getTelefonos());\n$this-&gt;assertEquals('123456789', $this-&gt;empleado-&gt;getTelefonos()[0]);\n}\n\npublic function testListarTelefonos() {\n$this-&gt;empleado-&gt;setTelefono('123456789');\n$this-&gt;empleado-&gt;setTelefono('987654321');\n$this-&gt;assertEquals('123456789, 987654321', $this-&gt;empleado-&gt;listarTelefonos());\n}\n\npublic function testVaciarTelefonos() {\n$this-&gt;empleado-&gt;setTelefono('123456789');\n$this-&gt;empleado-&gt;vaciarTelefonos();\n$this-&gt;assertEmpty($this-&gt;empleado-&gt;getTelefonos());\n}\n\npublic function testDebePagarImpuestos() {\n$this-&gt;assertTrue($this-&gt;empleado-&gt;debePagarImpuestos());\n$this-&gt;empleado-&gt;setSou(3000);\n$this-&gt;assertFalse($this-&gt;empleado-&gt;debePagarImpuestos());\n}\n}\n\nExecució de Proves\nPer executar les proves, podem utilitzar la següent comanda:\nvendor/bin/phpunit\nAquesta comanda cercarà els arxius de prova en el directori especificat (per defecte tests) i executarà totes les proves.\nTipus de proves\nAmb PHPUnit, podem realitzar diversos tipus de proves, entre elles:\n\nProves Unitàries : Verifiquen el funcionament d'una unitat de codi individual, com una funció o mètode.\nProves Funcionals: Verifiquen que un conjunt de mòduls funciona correctament conjuntament. Aquestes proves poden simular interaccions de l'usuari en un sistema web, encara que això es fa millor amb frameworks especialitzats per a proves funcionals.\nProves d'Integració*: Comproven que diferents mòduls o serveis funcionen correctament quan es combinen.\n\nExemple de prova unitària:\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n\nAssercions\nLes assercions permeten comprovar el resultat dels mètodes que volem provar. Les assercions esperen que el predicat sempre siga vertader.\nPHPUnit ofereix les següent assercions:\n\nassertTrue / assertFalse: Comprova que la condició donada siga avaluada com true / false\nassertEquals / assertSame: Comprova que dues variables siguen iguals\nassertNotEquals / assertNotSame: Comprova que dues variables NO siguen iguals\nassertNull: Comprova que un valor és null.\nSame → comprova els tipus. Si no coincideixen els tipus i els valors, l'asserció fallarà\nEquals → sense comprovació estricta\nassertArrayHasKey / assertArrayNotHasKey: Comprova que un array posseïsca un key determinat / o NO ho posseïsca\nassertArraySubset: Comprova que un array posseïsca un altre array com subset del mateix\nassertAttributeContains / assertAttributeNotContains: Comprova que un atribut d'una classe continga una variable determinada / o NO continga una variable determinada\nassertAttributeEquals: Comprova que un atribut d'una classe siga igual a una variable determinada.\n\nProves amb dades\nLes proves en PHPUnit poden utilitzar data providers per executar el mateix test amb diferents dades:\n/**\n* @dataProvider proveidorDeDades\n*/\npublic function testMultiplica($a, $b, $esperat) {\n$calculadora = new Calculadora();\n$this-&gt;assertEquals($esperat, $calculadora-&gt;multiplica($a, $b));\n}\n\npublic function proveidorDeDades() {\nreturn [\n[2, 3, 6],\n[0, 5, 0],\n[-1, 5, -5],\n];\n}\n\nMocks\nEls mocks són objectes simulats que ens permeten aïllar la unitat de codi que estem provant. PHPUnit facilita la creació de mocks per a classes o interfícies.\n$mock = $this-&gt;createMock(ServeiExtern::class);\n$mock-&gt;method('obtenirDades')-&gt;willReturn('Dades simulades');\n\n$calculadora = new Calculadora($mock);\n$resultat = $calculadora-&gt;processaDades();\n$this-&gt;assertEquals('Resultat esperat', $resultat);\n\nProvant excepcions\nLes proves a més de comprovar que les classes funcionen com s'espera, han de cobrir tots els casos possibles. Així doncs, hem de poder fer proves que esperen que es llance una exempció (i que el missatge continga una certa informació):\nPer a això, s'utilitzen les següent expectatives:\n\nexpectException(Excepcion::class)\nexpectExceptionCode(codigoExcepcion)\nexpectExceptionMessage(missatge)\n\nDe la mateixa manera que abans, primer es posa l'expectativa, i després es provoca que es llance l'exempció:\n&lt;?php\npublic function testExcepcio() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n\nConclusió\nLes proves són crucials per a assegurar que el nostre codi PHP és fiable i manté la seua funcionalitat al llarg del temps. Utilitzar PHPUnit ens proporciona les eines necessàries per a escriure proves eficaces i mantenir el nostre projecte en un estat saludable.\n12. Referències Bibliogràfiques\nProgramació Orientada a Objectes en PHP\n\n&quot;PHP Objects, Patterns, and Practice&quot;\nper M. Zandstra. Apress, 2017. ISBN: 978-1-4842-1361-3. Aquest llibre és un recurs essencial per entendre els fonaments de la programació orientada a objectes en PHP, així com patrons de disseny.\n\n&quot;Learning PHP, MySQL &amp; JavaScript: With jQuery, CSS &amp; HTML5&quot;\nper Robin Nixon. O'Reilly Media, 2018. ISBN: 978-1-4919-2070-2. Ofereix una introducció completa a la programació amb PHP, incloent-hi el model d'objectes de PHP.\n\nConstructors i Destructors\n\nPHP Manual: Constructors and Destructors\nDocumentació oficial de PHP sobre constructors i destructors en la programació orientada a objectes. Disponible a https://www.php.net/manual/en/language.oop5.decon.php.\n\nEncapsulació i Visibilitat\n\nPHP Manual: Visibility\nSecció del manual oficial de PHP que explica les paraules clau public, protected, i private, així com el concepte d'encapsulació. Accessible a https://www.php.net/manual/en/language.oop5.visibility.php.\n\nHerència i Polimorfisme\n\n&quot;Programming PHP&quot;\nper Kevin Tatroe, Peter MacIntyre, i Rasmus Lerdorf. O'Reilly Media, 2013. ISBN: 978-1-4493-5053-6. Aquest llibre cobreix àmpliament els conceptes d'herència i polimorfisme en PHP, proporcionant exemples pràctics.\n\nPHP Manual: Inheritance\nDocumentació oficial de PHP que tracta sobre l'herència en classes, incloent el polimorfisme. Disponible a https://www.php.net/manual/en/language.oop5.inheritance.php.\n\nClasses Abstractes i Interfícies\n\nPHP Manual: Interfaces and Abstract Classes\nExplicació oficial de les classes abstractes i les interfícies en PHP. Disponible a https://www.php.net/manual/en/language.oop5.interfaces.php.\n\nNombres màgics i Metodes màgics\n\nPHP Manual: Magic Methods\nGuia completa sobre els mètodes màgics en PHP, com __construct(), __destruct(), __get(), __set(), entre altres. Disponible a https://www.php.net/manual/en/language.oop5.magic.php.\n\nTrait en PHP\n\nPHP Manual: Traits\nDocumentació sobre traits en PHP, que permeten reutilitzar codi entre diferents classes. Disponible a https://www.php.net/manual/en/language.oop5.traits.php.\n\nExcepcions en PHP\n\n&quot;The Pragmatic Programmer: Your Journey to Mastery&quot;\nper David Thomas i Andrew Hunt. Addison-Wesley Professional, 2019. ISBN: 978-0-1359-5202-8. Inclou bones pràctiques per a la gestió d'excepcions, aplicables també a PHP.\n\nPHP Manual: Exceptions\nSecció del manual de PHP dedicada a les excepcions, explicant com llençar i capturar excepcions en PHP. Accessible a https://www.php.net/manual/en/language.exceptions.php.\n\nProves amb PHPUnit\n\n&quot;Modern PHP: New Features and Good Practices&quot;\nper Josh Lockhart. O'Reilly Media, 2015. ISBN: 978-1-4919-2904-0. Aquest llibre inclou una secció sobre proves amb PHPUnit.\n\nPHPUnit Documentation\nDocumentació oficial de PHPUnit, que cobreix com escriure i executar proves unitàries en PHP. Accessible a https://phpunit.de/documentation.html.\n\nEines de Desenvolupament i Autocàrrega\n\nComposer Documentation\nAccessible des de https://getcomposer.org/doc/. Composer és l'eina estàndard per a la gestió de dependències en PHP, i inclou suport per a l'autocàrrega de classes.\n\nPHP Manual: Autoloading Classes\nGuia sobre el mecanisme d'autocàrrega en PHP, que facilita la inclusió automàtica de classes en els teus projectes. Disponible a https://www.php.net/manual/en/language.oop5.autoload.php.\n\nPOO Avançada: Patrons de Disseny\n\n&quot;Head First Design Patterns&quot;\nper Eric Freeman i Elisabeth Robson. O'Reilly Media, 2020. ISBN: 978-1-4919-7175-9. Un recurs excel·lent per aprendre patrons de disseny aplicables a PHP.\n\n&quot;PHP Design Patterns&quot;\nper Stephan Schmidt. Publicat per Packt Publishing, 2008. ISBN: 978-1-84719-255-3. Aquest llibre explora com aplicar patrons de disseny en projectes PHP.\n\nWebs de Referència Addicionals\n\nPHP: The Right Way\nhttps://phptherightway.com/. Una guia per a desenvolupar aplicacions PHP seguint les millors pràctiques de la indústria.\n\nStack Overflow\nhttps://stackoverflow.com/questions/tagged/php. Una font d'informació valuosa per resoldre problemes específics de PHP i discutir amb altres desenvolupadors.\n\n13. Exercicis\nBateria d'Exercicis Solucionats per a la Unitat de Programació Orientada a Objectes\nExercici 1: Crear una Classe Bàsica\n\nCrea una classe Cotxe que tinga les propietats marca i model. Afegeix un mètode mostraInformacio que retorne un string amb la marca i el model del cotxe.\nCrea una instància de la classe Cotxe, assigna-li una marca i un model, i mostra la informació utilitzant el mètode mostraInformacio.\n\nSolució\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\n$cotxe = new Cotxe();\n$cotxe-&gt;marca = &quot;Toyota&quot;;\n$cotxe-&gt;model = &quot;Corolla&quot;;\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Toyota, Model: Corolla\n\nExercici 2. Afegir un Constructor i destructor\n\nModifica la classe Cotxe per afegir un constructor que prenga com a paràmetres la marca i el model, i que establisca aquestes propietats automàticament.\nAfegeix un destructor a la classe Cotxe que mostre un missatge quan l'objecte és destruït. Crea un objecte i permet que es destruïsca al final del programa.\n\nSolució\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\npublic function __destruct() {\necho &quot;L'objecte Cotxe ha estat destruït.\\n&quot;;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nExercici 3. Encapsulació de Propietats\n\nModifica la classe Cotxe per a que les propietats marca i model siguen privades. Afegeix mètodes públics getMarca, setMarca, getModel, i setModel per accedir i modificar aquestes propietats.\n\nSolució\n&lt;?php\nclass Cotxe {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function setMarca($marca) {\n$this-&gt;marca = $marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n\npublic function setModel($model) {\n$this-&gt;model = $model;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;getMarca() . &quot;, Model: &quot; . $this-&gt;getModel();\n}\n}\n\n$cotxe = new Cotxe(&quot;Ford&quot;, &quot;Fiesta&quot;);\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Ford, Model: Fiesta\n\nExercici 4. Herència i Polimorfisme\n\nCrea una classe Vehicle amb una propietat tipus. A continuació, crea una classe Motocicleta que herete de Vehicle i tinga una propietat cilindrada. Afegeix un mètode a Motocicleta que retorne el tipus i la cilindrada.\nCrea una funció mostraDetallsVehicle que accepte un objecte de tipus Vehicle i mostre les seues propietats. Prova aquesta funció amb objectes de Cotxe i Motocicleta.\n\nSolució\n&lt;?php\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function mostraDetalls() {\nreturn &quot;Tipus: &quot; . $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Cilindrada: &quot; . $this-&gt;cilindrada;\n}\n}\n\nfunction mostraDetallsVehicle(Vehicle $vehicle) {\necho $vehicle-&gt;mostraDetalls() . &quot;\\n&quot;;\n}\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\nmostraDetallsVehicle($cotxe); // Output: Tipus: Cotxe, Marca: Toyota, Model: Corolla\nmostraDetallsVehicle($moto); // Output: Tipus: Motocicleta, Cilindrada: 600\n\nExercici 5. Implementació del Patró MVC amb Vehicles\nContinuant amb l'exercici anterior on has creat les classes Vehicle, Cotxe, i Motocicleta, ara refactoritzaràs el codi per seguir el patró Model-Vista-Controlador (MVC). El teu objectiu és separar la lògica de negoci (models) de la presentació (vistes) i gestionar la interacció entre aquestes capes mitjançant un controlador.\n\nCrear el Model:\n\nRefactoritza les classes Vehicle, Cotxe, i Motocicleta perquè representen el model de negoci i només contenen la lògica relacionada amb la gestió de vehicles.\nAssegura't que els models no contenen cap codi de presentació.\n\nCrear les Vistes:\n\nCrea vistes separades per mostrar els detalls dels vehicles:\n\nUna vista HTML que mostre la informació dels vehicles en format HTML.\nUna vista en text simple que mostre els detalls dels vehicles en un format de text senzill.\n\nCrear el Controlador:\n\nImplementa un controlador que gestione la interacció entre els models i les vistes.\nEl controlador ha de ser capaç de rebre una sol·licitud per mostrar un vehicle i triar la vista adequada per mostrar-ne els detalls.\n\nSolució\n&lt;?php\n// Models\n\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function getTipus() {\nreturn $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function getCilindrada() {\nreturn $this-&gt;cilindrada;\n}\n}\n\n// Vistes\n\nclass VehicleView {\npublic function renderHtml(Vehicle $vehicle) {\n$output = &quot;&lt;p&gt;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;&lt;/p&gt;&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;&lt;p&gt;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;&lt;/p&gt;&quot;;\n$output .= &quot;&lt;p&gt;Model: &quot; . $vehicle-&gt;getModel() . &quot;&lt;/p&gt;&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;&lt;p&gt;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc&lt;/p&gt;&quot;;\n}\nreturn $output;\n}\n\npublic function renderText(Vehicle $vehicle) {\n$output = &quot;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;\\n&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;\\n&quot;;\n$output .= &quot;Model: &quot; . $vehicle-&gt;getModel() . &quot;\\n&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc\\n&quot;;\n}\nreturn $output;\n}\n}\n\n// Controlador\n\nclass VehicleController {\nprivate $view;\n\npublic function __construct(VehicleView $view) {\n$this-&gt;view = $view;\n}\n\npublic function mostrarVehicle(Vehicle $vehicle, $format = 'html') {\nif ($format === 'html') {\necho $this-&gt;view-&gt;renderHtml($vehicle);\n} else {\necho $this-&gt;view-&gt;renderText($vehicle);\n}\n}\n}\n\n// Exemple d'ús\n\n$view = new VehicleView();\n$controller = new VehicleController($view);\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\n// Mostrar en HTML\n$controller-&gt;mostrarVehicle($cotxe, 'html');\n$controller-&gt;mostrarVehicle($moto, 'html');\n\n// Mostrar en Text\n$controller-&gt;mostrarVehicle($cotxe, 'text');\n$controller-&gt;mostrarVehicle($moto, 'text');\n\nExercici 5. Classes Abstractes i Interfícies\n\nCrea una classe abstracta Figura amb un mètode abstracte calculaArea. Després, crea classes Cercle i Rectangle que estiguen basades en Figura i implementen el mètode calculaArea.\nDefineix una interfície OperacionsBàsiques amb els mètodes suma i resta. Implementa aquesta interfície en una classe CalculadoraSimple.\n\nSolució\n&lt;?php\nabstract class Figura {\nabstract public function calculaArea();\n}\n\nclass Cercle extends Figura {\nprivate $radi;\n\npublic function __construct($radi) {\n$this-&gt;radi = $radi;\n}\n\npublic function calculaArea() {\nreturn pi() * $this-&gt;radi * $this-&gt;radi;\n}\n}\n\nclass Rectangle extends Figura {\nprivate $ample;\nprivate $llarg;\n\npublic function __construct($ample, $llarg) {\n$this-&gt;ample = $ample;\n$this-&gt;llarg = $llarg;\n}\n\npublic function calculaArea() {\nreturn $this-&gt;ample * $this-&gt;llarg;\n}\n}\n\n$cercle = new Cercle(5);\n$rectangle = new Rectangle(4, 6);\n\necho &quot;Àrea del cercle: &quot; . $cercle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del cercle: 78.5398\necho &quot;Àrea del rectangle: &quot; . $rectangle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del rectangle: 24\n\n&lt;?php\ninterface OperacionsBàsiques {\npublic function suma($a, $b);\npublic function resta($a, $b);\n}\n\nclass CalculadoraSimple implements OperacionsBàsiques {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\n$calculadora = new CalculadoraSimple();\necho &quot;Suma: &quot; . $calculadora-&gt;suma(5, 3) . &quot;\\n&quot;; // Output: Suma: 8\necho &quot;Resta: &quot; . $calculadora-&gt;resta(5, 3) . &quot;\\n&quot;; // Output: Resta: 2\n\nExercici 6. Utilitzar Traits\n\nCrea un trait Informacio amb un mètode mostraInformacio. Inclou aquest trait en les classes Cotxe i Motocicleta, i utilitza'l per mostrar informació addicional.\n\nSolució\n&lt;?php\ntrait Informacio {\npublic function mostraInformacio() {\nreturn &quot;Aquest és un objecte de tipus &quot; . get_class($this);\n}\n}\n\nclass Cotxe {\nuse Informacio;\n}\n\nclass Motocicleta {\nuse Informacio;\n}\n\n$cotxe = new Cotxe();\n$moto = new Motocicleta();\n\necho $cotxe-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Cotxe\necho $moto-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Motocicleta\n\nExercici 7. Gestionar Excepcions\n\nEscriu una funció divideix que prenga dos nombres com a paràmetres i retorne el resultat de la divisió. Si el segon nombre és zero, llença una excepció amb un missatge adequat. Captura aquesta excepció quan crides a la funció i mostra un missatge d'error.\n\nSolució\n&lt;?php\nfunction divideix($a, $b) {\nif ($b == 0) {\nthrow new Exception(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n\ntry {\necho divideix(10, 2) . &quot;\\n&quot;; // Output: 5\necho divideix(10, 0) . &quot;\\n&quot;; // Aquesta línia llançarà una excepció\n} catch (Exception $e) {\necho &quot;Error: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;; // Output: Error: No es pot dividir per zero.\n}\n\nExercici 8. Proves amb PHPUnit\n\nCrea una classe Calculadora amb els mètodes suma i resta. Escriu una prova unitària amb PHPUnit per verificar que aquests mètodes funcionen correctament.\nAfegeix un mètode divideix a la classe Calculadora que llance una excepció quan es divideix per zero. Escriu una prova unitària que assegure que aquesta excepció es llança correctament.\n\nSolució\n&lt;?php\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testSuma() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;suma(2, 3);\n$this-&gt;assertEquals(5, $resultat);\n}\n\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n}\n\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function divideix($a, $b) {\nif ($b == 0) {\nthrow new InvalidArgumentException(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testDivideix() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n}\n\nExercici 9. Espais de Noms (Namespaces)\n\nCrea un espai de noms App\\Models i defineix una classe Usuari dins d'aquest espai de noms. Afegeix un mètode getNomComplet que retorne el nom complet de l'usuari.\nEn un fitxer separat, importa la classe Usuari de l'espai de noms App\\Models i crea una instància d'aquesta classe. Utilitza el mètode getNomComplet per mostrar el nom complet d'un usuari.\n\nSolució\n&lt;?php\n// Arxiu: src/Models/Usuari.php\nnamespace App\\Models;\n\nclass Usuari {\nprivate $nom;\nprivate $cognom;\n\npublic function __construct($nom, $cognom) {\n$this-&gt;nom = $nom;\n$this-&gt;cognom = $cognom;\n}\n\npublic function getNomComplet() {\nreturn $this-&gt;nom . &quot; &quot; . $this-&gt;cognom;\n}\n}\n\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Usuari;\n\n$usuari = new Usuari(&quot;Joan&quot;, &quot;Garcia&quot;);\necho $usuari-&gt;getNomComplet(); // Output: Joan Garcia\n\nExercici 10. Autoloading i Composer\n\nConfigura un projecte PHP amb Composer que utilitze l'autoloading PSR-4. Crea l'estructura de directoris src/Models i col·loca una classe Producte dins de src/Models. Verifica que l'autoloading funcione correctament instanciant la classe Producte en un fitxer separat.\nAfegeix la llibreria monolog/monolog al projecte utilitzant Composer. Crea una instància de Logger i afegeix una entrada al registre de logs.\n\nSolució\n\nCrea l'estructura de directoris src/Models i col·loca el següent codi a src/Models/Producte.php:\n\n&lt;?php\nnamespace App\\Models;\n\nclass Producte {\nprivate $nom;\n\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nConfigura l'autoloading en composer.json:\n\n{\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {\n&quot;App\\\\&quot;: &quot;src/&quot;\n}\n}\n}\n\nExecuta composer dump-autoload per generar els fitxers d'autoload.\nUtilitza la classe producte:\n\n&lt;?php\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Producte;\n\n$producte = new Producte(&quot;Ordinador&quot;);\necho $producte-&gt;getNom(); // Output: Ordinador\n\nAfegeix Monolog a composer.json:\n\ncomposer require monolog/monolog\n\nUtilitza Monolog per crear un logger:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n\n// Afegeix una entrada al log\n$log-&gt;warning('Aquesta és una entrada d'advertència');\n$log-&gt;error('Aquesta és una entrada d'error');\n\nExercici 11. Logger\n\nUtilitzant la llibreria Monolog, crea un logger que escriga missatges a un fitxer app.log. Configura el logger per registrar missatges d'informació i d'error.\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error.\n\nSolució\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::INFO));\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::ERROR));\n\n// Registra missatges d'informació i d'error\n$log-&gt;info('Aquesta és una entrada d’informació');\n$log-&gt;error('Aquesta és una entrada d’error');\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Handler\\ErrorLogHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n$log-&gt;pushHandler(new ErrorLogHandler());\n\n// Registra missatges d’error al fitxer i a la consola\n$log-&gt;error('Aquesta és una entrada d’error');\n\nExercici 12. Documentació\n\nDocumenta la classe Producte creada en l'exercici anterior utilitzant comentaris PHPDoc. Assegura't d'incloure la descripció de la classe, les propietats, i els mètodes.\nUtilitza una eina com phpDocumentor per generar la documentació automàtica del codi PHP del projecte, incloent-hi la classe Producte.\n\nSolució\n&lt;?php\nnamespace App\\Models;\n\n/**\n* Classe Producte\n*\n* Representa un producte amb un nom.\n*/\nclass Producte {\n/**\n* @var string El nom del producte\n*/\nprivate $nom;\n\n/**\n* Constructor de la classe Producte\n*\n* @param string $nom El nom del producte\n*/\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\n/**\n* Obté el nom del producte\n*\n* @return string El nom del producte\n*/\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nInstal·la phpDocumentor globalment o com a dependència de desenvolupament:\n\ncomposer require --dev phpdocumentor/phpdocumentor\n\nGenera la documentació:\n\nvendor/bin/phpdoc -d src -t docs\n\nAquest comandament generarà la documentació a la carpeta docs.\n\nExercici 13. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nSolució\n\nInstal·la DomPDF amb Composer:\n\ncomposer require dompdf/dompdf\n\nCrea un script PHP que generi un PDF senzill:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '&lt;h1&gt;Informe de Vendes&lt;/h1&gt;&lt;p&gt;Aquest és un informe de les vendes.&lt;/p&gt;';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'landscape');\n$dompdf-&gt;render();\n$dompdf-&gt;stream('informe.pdf');\n\nCrea un PDF amb una taula i una imatge:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '\n&lt;h1&gt;Informe de Productes&lt;/h1&gt;\n&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Producte&lt;/th&gt;\n&lt;th&gt;Preu&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Ordinador&lt;/td&gt;\n&lt;td&gt;500€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Teclat&lt;/td&gt;\n&lt;td&gt;20€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;img src=&quot;https://example.com/imatge.png&quot; alt=&quot;Imatge de Producte&quot; /&gt;\n';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'portrait');\n$dompdf-&gt;render();\n$dompdf-&gt;stream(&quot;informe_productes.pdf&quot;);\n\nExercicis proposats\nExercici 1. Creació de la Classe Bàsica i Gestió de Propietats\n\nCrea una classe Persona amb les propietats privades nom, cognoms, i edat. Encapsula aquestes propietats mitjançant getters i setters. Afig els següents mètodes:\n- getNomComplet(): string – Retorna el nom complet de la persona.\n- estaJubilat(): bool – Retorna true si l'edat és major o igual a 65, false en cas contrari.\n\nModifica la classe Persona afegint un constructor que assigna nom i cognoms. Si es proporciona un tercer paràmetre, assigna l'edat; en cas contrari, assigna una edat per defecte de 25 anys.\n\nModifica la classe Persona per utilitzar una constant LIMITE_EDAT amb el valor de 66 anys i utilitza-la en el mètode estaJubilat.\n\nExercici 2. Herència i Polimorfisme\n\nCrea una classe Empleado que herete de Persona. Afig les següents propietats i mètodes:\n\nprivate float $sou\nprivate array $telefons\nanyadirTelefono(int $telefon): void – Afig un número de telèfon a l'array.\nlistarTelefonos(): string – Retorna els números de telèfon separats per comes.\nvaciarTelefonos(): void – Buida l'array de telèfons.\ndebePagarImpuestos(): bool – Retorna true si el sou és superior a 3333€, false en cas contrari.\n\nAfig un mètode estàtic toHtml(Empleado $emp): string que genere un codi HTML que mostre el nom complet de l'empleat dins d'un paràgraf i els seus telèfons dins d'una llista ordenada.\n\nAfig un mètode estàtic toHtml(Persona $p) a la classe Persona que mostre el nom complet de la persona dins d'un paràgraf. Modifica el mètode toHtml de Empleado per rebre una Persona com a paràmetre i comprovar si es tracta d'un Empleado amb instanceof.\n\nTransforma Persona en una classe abstracta. Redefineix el mètode estàtic toHtml(Persona $p) en totes les seues subclasses.\n\nExercici 3. Integració d'Espais de Noms, Autoloading, i Composer\n\nCrea una classe Empresa que incloga una propietat amb un array de Empleados . Implementa:\n\npublic function addWorker(Empleado $t)\npublic function listWorkersHtml(): string – Genera la llista de treballadors en format HTML.\npublic function getCosteNominas(): float – Calcula el cost total de les nòmines.\n\nConfigura el projecte PHP amb Composer que utilitze l'autoloading PSR-4.\n\nExercici 4. Logger i Documentació\n\nUtilitza la llibreria Monolog per configurar un logger que escriga missatges a un fitxer app.log. Afig funcionalitat perquè el logger registre missatges d'informació i d'error en diferents arxius segons la gravetat.\n\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error i advertència.\n\nDocumenta la classe Producte creada en exercicis anteriors utilitzant comentaris PHPDoc. Inclou la descripció de la classe, les propietats, i els mètodes. Utilitza una eina com phpDocumentor per generar documentació automàtica.\n\nEscriu proves unitàries per als mètodes de les classes Persona, Empleado, i Empresa utilitzant PHPUnit. Prova els mètodes getNomComplet, estaJubilat, addWorker, i getCosteNominas. Assegura't que les proves cobreixen diferents escenaris, incloent errors potencials.\n\nEscriu una prova unitària que comprove que el logger està registrant correctament els missatges d'error a l'arxiu corresponent. Utilitza un mock per assegurar-te que el logger funciona sense necessitat d'escriure en un fitxer real durant la prova.\n\nExercici 5. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\n\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nUtilitzant la classe Empresa i Empleado, genera un informe en PDF amb la llista de treballadors i el seu sou. Utilitza DomPDF per generar aquest informe.\n\nExercici 6. Serialització i JSON\n\nCrea una interfície JSerializable que incloga els mètodes:\n\ntoJSON(): string – Converteix l'objecte a un JSON utilitzant json_encode().\ntoSerialize(): string – Serialitza l'objecte utilitzant serialize().\n\nModifica les classes Persona, Empleado, i Empresa per implementar aquesta interfície. Assegura't que les propietats privades es puguen serialitzar correctament.\n\nEscriu mètodes per deserialitzar un objecte a partir d'una cadena JSON o d'una cadena serialitzada. Prova aquests mètodes amb PHPUnit per assegurar-te que la deserialització funciona correctament.\n\nExercici 7. Separació del Model de Negoci i la Presentació (MVC)\nFins ara, has creat diverses classes que gestionen la lògica del joc i les dades (models), com Persona, Empleado, i Empresa, i has generat sortides HTML i PDFs amb DomPDF. Ara és el moment de refactoritzar la teua aplicació per assegurar una separació clara entre la lògica del negoci i la presentació, seguint el patró Model-Vista-Controlador (MVC).\n\nCrear el Model:\n\nRefactoritza les classes Persona, Empleado, i Empresa per assegurar que només gestionen la lògica de negoci (per exemple, càlcul de nòmines, gestió d'empleats, etc.).\nAssegura't que aquestes classes no contenen codi relacionat amb la presentació (HTML o PDF).\n\nCrear les Vistes:\n\nCrea vistes separades per presentar la informació als usuaris:\n\nUna vista HTML per mostrar la informació de Empleado i Empresa com a llistats.\nUna vista PDF per generar informes amb DomPDF, basant-se en les dades proporcionades pel model.\n\nCrear el Controlador:\n\nImplementa un controlador que reba les sol·licituds dels usuaris, interactue amb el model (Persona, Empleado, Empresa), i tria la vista adequada per mostrar els resultats (HTML o PDF).\nEl controlador ha d'encapsular tota la lògica necessària per a gestionar la interacció entre la vista i el model, assegurant que el model no estiga lligat a la capa de presentació.\n\nEmpleadoController\n&lt;?php\nnamespace App\\Controllers;\n\nuse App\\Models\\Empleado;\n\nclass EmpleadoController {\n\npublic function listAll(){\n$persona1 = new Empleado('Ignasi','Gomis Mullor',50);\n$persona2 = new Empleado('Juan','Segura Vasco',50);\n$persona1-&gt;setSou(2500);\n$persona2-&gt;setSou(2500);\n\n$empleados = [$persona1, $persona2];\n\ninclude $_SERVER['DOCUMENT_ROOT'].'/views/empleado.view.php';\n\n}\n}\n\nempleado.view.php\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;ca&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;Empleado&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;table&gt;\n&lt;tr&gt;\n&lt;th&gt;Nom&lt;/th&gt;&lt;th&gt;Telefons&lt;/th&gt;&lt;th&gt;Sou&lt;/th&gt;\n&lt;/tr&gt;\n&lt;?php foreach ($empleados as $empleado): ?&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;?= $empleado ?&gt;&lt;/td&gt;&lt;td&gt;&lt;?= $empleado-&gt;listarTelefonos() ?&gt;&lt;/td&gt;&lt;td&gt;&lt;?= $empleado-&gt;getSou() ?&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;?php endforeach; ?&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nindex.php\n\n&lt;?php\ninclude_once __DIR__ .'/../vendor/autoload.php';\n\nuse App\\Controllers\\EmpleadoController;\n\n$controller = new EmpleadoController();\n$controller-&gt;listAll();\n\nExercici 8. Creació de Proves Unitàries per al Patró MVC\nDesprés de refactoritzar l'aplicació per separar la lògica del negoci de la presentació seguint el patró Model-Vista-Controlador (MVC), és fonamental assegurar-se que tots els components funcionen correctament i que la interacció entre ells es realitza tal com s'espera. Per això, has de crear una sèrie de proves unitàries utilitzant PHPUnit per verificar el funcionament del model, les vistes i els controladors.\n\nProves del Model:\n\nEscriu proves unitàries per verificar el funcionament dels mètodes de les classes Persona, Empleado, i Empresa.\nAssegura't que els mètodes funcionen correctament, com ara:\n\ngetNomComplet()\ndebePagarImpuestos()\naddWorker() i getCosteNominas()\n\nProva que els càlculs es realitzen correctament i que les dades es gestionen segons el que s'espera.\n\nProves del Controlador:\n\nEscriu proves unitàries per assegurar-te que els controladors interactuen correctament amb els models i que seleccionen la vista adequada per a cada situació.\nProva que les dades es passen correctament del model a la vista a través del controlador.\nImplementa proves per verificar que el controlador respon correctament a diferents sol·licituds de l'usuari, per exemple:\n\nMostrar una llista d'empleats en HTML.\nGenerar un informe en PDF utilitzant DomPDF.\n\nProves de les Vistes:\n\nEscriu proves unitàries per comprovar que les vistes reben i mostren correctament la informació proporcionada pel controlador.\nProva que la generació de contingut HTML o PDF es realitza correctament a partir de les dades proporcionades pel model.\n\n14. Enunciat dels projectes\nProjecte &quot;4 en Ratlla&quot;\n1. Crear l'entorn del 4 en ratlla\n\nDins de php crear les carpetes App,Views i Helpers.\nDins de la carpeta App crea les carpetes Models, Controllers , Services i Exceptions.\nDins de la carpeta src tindrem el index.php i el css.\n\n2. Integració de Composer i Autoloading\n\nConfiguració de Composer: Defineix un composer.json per al projecte, configurant l'autoloading PSR-4 per carregar automàticament les classes de Joc4enRatlla.\nEstructura del Projecte:\n\nOrganitza el codi en directoris com App/Models per a les classes del joc i App/Controllers per a la gestió del flux del joc.\nConfigura Composer per gestionar les dependències del projecte.\n\n3. Refactorització amb Programació Orientada a Objectes (POO) i amb MVC\nModels\n\nDins de la carpeta Models:\n\nClasse Board: Crea una classe Board per representar la graella del joc. Aquesta classe ha de gestionar la configuració inicial de la graella, els moviments dels jugadors, i la comprovació de si hi ha un guanyador.\n\nnamespace Joc4enRatlla\\Models;\n\nclass Board\n{\npublic const FILES = 6;\npublic const COLUMNS = 7;\npublic const DIRECTIONS = [\n[0, 1], // Horizontal derecha\n[1, 0], // Vertical abajo\n[1, 1], // Diagonal abajo-derecha\n[1, -1] // Diagonal abajo-izquierda\n];\n\nprivate array $slots;\n\npublic function __construct()\n\n// Getters i Setters\n\nprivate static function initializeBoard(): array //Inicialitza la graella amb valors buits\npublic function setMovementOnBoard(int $column, int $player): array //Realitza un moviment en la graella\npublic function checkWin(array $coord): bool //Comprova si hi ha un guanyador\npublic function isValidMove(int $column): bool //Comprova si el moviment és vàlid\n\n}\n\nClasse Jugador: Crea una classe Player per representar els jugadors del joc, amb propietats com el name, el color de les fitxes, forma de jugar isAutomatic.\n\nnamespace Joc4enRatlla\\Models;\n\nclass Player {\nprivate $name; // Nom del jugador\nprivate $color; // Color de les fitxes\nprivate $isAutomatic; // Forma de jugar (automàtica/manual)\n\npublic function __construct( $name, $color, $isAutomatic = false)\n\n// Getters i Setters\n\n}\n\nClasse Game: Refactoritza la lògica del joc en una classe Game que gestione la graella, el torn del jugador, i la lògica per determinar el guanyador, la puntuació.\n\nnamespace Joc4enRatlla\\Models;\n\nuse Joc4enRatlla\\Models\\Board;\nuse Joc4enRatlla\\Models\\Player;\n\nclass Game\n{\nprivate Board $board;\nprivate int $nextPlayer;\nprivate array $players;\nprivate ?Player $winner;\nprivate array $scores = [1 =&gt; 0, 2 =&gt; 0];\n\npublic function __construct( Player $jugador1, Player $jugador2)\n\n// getters i setters\n\npublic function reset(): void //Reinicia el joc\npublic function play($columna) //Realitza un moviment\npublic function playAutomatic(){\n$opponent = $this-&gt;nextPlayer === 1 ? 2 : 1;\n\nfor ($col = 1; $col &lt;= Board::COLUMNS; $col++) {\nif ($this-&gt;board-&gt;isValidMove($col)) {\n$tempBoard = clone($this-&gt;board);\n$coord = $tempBoard-&gt;setMovementOnBoard($col, $this-&gt;nextPlayer);\n\nif ($tempBoard-&gt;checkWin($coord)) {\n$this-&gt;play($col);\nreturn;\n}\n}\n}\n\nfor ($col = 1; $col &lt;= Board::COLUMNS; $col++) {\nif ($this-&gt;board-&gt;isValidMove($col)) {\n$tempBoard = clone($this-&gt;board);\n$coord = $tempBoard-&gt;setMovementOnBoard($col, $opponent);\nif ($tempBoard-&gt;checkWin($coord )) {\n$this-&gt;play($col);\nreturn;\n}\n}\n}\n\n$possibles = array();\nfor ($col = 1; $col &lt;= Board::COLUMNS; $col++) {\nif ($this-&gt;board-&gt;isValidMove($col)) {\n$possibles[] = $col;\n}\n}\nif (count($possibles)&gt;2) {\n$random = rand(-1,1);\n}\n$middle = (int) (count($possibles) / 2)+$random;\n$inthemiddle = $possibles[$middle];\n$this-&gt;play($inthemiddle);\n}\npublic function save() //Guarda l'estat del joc a les sessions\npublic static function restore() //Restaura l'estat del joc de les sessions\n\n}\n\nDocumentació:\n\nTotes les classes i mètodes han d'estar documentats amb comentaris PHPDoc.\n\nControladors\n\nDins de la carpeta Controllers:\n\nClasse JocController: Crea un controlador JocController que gestione el joc. Aquest controlador ha de permetre als jugadors realitzar moviments, comprovar l'estat del joc, i gestionar les vistes.\n\nnamespace Joc4enRatlla\\Controllers;\n\nuse Joc4enRatlla\\Models\\Player;\nuse Joc4enRatlla\\Models\\Game;\n\nclass GameController\n{\nprivate Game $game;\n\n// Request és l'array $_POST\n\npublic function __construct($request=null)\n{\n//Inicialització del joc\n$this-&gt;play($request);\n\n}\n\npublic function play(Array $request)\n{\n// Gestió del joc\n...\n\n$board = $this-&gt;game-&gt;getBoard();\n$players = $this-&gt;game-&gt;getPlayers();\n$winner = $this-&gt;game-&gt;getWinner();\n$scores = $this-&gt;game-&gt;getScores();\n\nloadView('index',compact('board','players','winner','scores'));\n}\n}\n\nServeis i funcions\n\nDins de la carpeta Services:\n\nFunció loadView: Crea una funció loadView que carregue les vistes del joc. Aquesta funció ha de rebre el nom de la vista i les dades a passar a la vista, i ha de mostrar la vista amb les dades proporcionades.\n\n&lt;?php\n\nnamespace Joc4enRatlla\\Services;\n\nclass Service\n{\npublic static function loadView($view, $data = [])\n{\n$viewPath = str_replace('.', '/', $view);\nextract($data);\n\ninclude $_SERVER['DOCUMENT_ROOT'] . &quot;/../Views/$viewPath.view.php&quot;;\n\n}\n}\n\ni la funció loadView en un fitxer de funcions\nfunction loadView($view, $data = [])\n{\nJoc4enRatlla\\Services\\Service::loadView($view, $data);\n}\n\nfunction dd(...$data )\n{\necho &quot;&lt;pre&gt;&quot;;\nforeach ($data as $d) {\nvar_dump($d);\n}\n\necho &quot;&lt;/pre&gt;&quot;;\ndie();\n}\n\nVistes\n\nDins de la carpeta Views:\n\nVista index.php: Crea una vista index.php que mostre la graella del joc, el torn actual del jugador, i els resultats finals (guanyador o empat). Aquesta vista ha de permetre als jugadors realitzar moviments en la graella.\n\n&lt;html&gt;\n&lt;head&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;4ratlla.css?v=&lt;?php echo time(); ?&gt;&quot;&gt;\n&lt;title&gt;4 en ratlla&lt;/title&gt;\n&lt;style&gt;\n.player1 {\nbackground-color: &lt;?= $players[1]-&gt;getColor() ?&gt; ; /* Color vermell per un dels jugadors */\n}\n\n.player2 {\nbackground-color: &lt;?= $players[2]-&gt;getColor() ?&gt;; /* Color groc per l'altre jugador */\n}\n\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;?php include_once $_SERVER['DOCUMENT_ROOT'].'/../Views/partials/error.view.php' ?&gt;\n&lt;form action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]); ?&gt;&quot; method=&quot;post&quot;&gt;\n&lt;?php include_once $_SERVER['DOCUMENT_ROOT'].'/../Views/partials/board.view.php' ?&gt;\n&lt;input type=&quot;submit&quot; name=&quot;reset&quot; value=&quot;Reiniciar joc&quot;&gt;\n&lt;input type=&quot;submit&quot; name=&quot;exit&quot; value=&quot;Acabar joc&quot;&gt;\n&lt;/form&gt;\n&lt;?php include_once $_SERVER['DOCUMENT_ROOT'].'/../Views/partials/panel.view.php' ?&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nSPA\nCreen la pàgina index.php que carregarà el joc 4 en ratlla.\n&lt;?php\nsession_start();\nrequire_once $_SERVER['DOCUMENT_ROOT'] . '/../vendor/autoload.php';\nrequire_once $_SERVER['DOCUMENT_ROOT'] . '/../Helpers/functions.php';\nuse Joc4enRatlla\\Controllers\\GameController;\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n$gameController = new GameController($_POST);\n} else {\nloadView('jugador');\n}\n\n4. Proves amb PHPUnit\n\nEscriu Proves Unitàries: Crea proves unitàries per a la classe Joc4enRatlla utilitzant PHPUnit. Les proves poden incloure:\n\nVerificació de la configuració inicial de la graella.\nProves per assegurar que un moviment s'aplica correctament a la graella.\nProves per assegurar que el joc detecta correctament un guanyador o un empat.\n\nProves de Gestió de Sessions: Afig proves per assegurar que l'estat del joc i el torn del jugador es mantenen correctament a través de les sessions.\n\n5. Logger amb Monolog\n\nConfiguració de Logger: Utilitza Monolog per registrar esdeveniments importants del joc, com quan un jugador fa un moviment, quan s'inicia una nova partida, o quan es produeixen errors.\nDiversos Handlers:\n\nRegistra els moviments dels jugadors i els resultats del joc en un fitxer game.log.\nRegistra errors greus o problemes amb les sessions en un fitxer d'errors separat.\n\nConsideracions Addicionals pel Projecte\n1. Documentació amb PHPDoc\n\nDocumentació Completa: Documenta totes les classes i mètodes amb comentaris PHPDoc. Això inclou les descripcions dels paràmetres i els valors de retorn per a cada mètode.\nGeneració Automàtica: Utilitza phpDocumentor o una eina similar per generar la documentació automàticament. Afig la documentació generada al projecte per facilitar el manteniment i la comprensió del codi.\n\n2. Implementació d'Interfícies\n\nInterfície JocInterface: Crea una interfície que definisca els mètodes bàsics que qualsevol joc ha de tindre (iniciarJoc, ferMoviment, comprovaGuanyador, etc.). Assegura't que la Joc4enRatlla implemente aquesta interfície.\n\n3. Serialització i Persistència\n\nSerialització de l'Estat del Joc: Implementa funcionalitats per serialitzar l'estat del joc (usant JSON o serialize()) i deserialitzar-lo per mantenir la persistència entre sessions o guardar l'estat per a reprendre la partida posteriorment.\n\n4. Exempcions\n\nGestió d'Excepcions: Utilitza excepcions per gestionar el que un jugador jugue una columna que ja estiga plena. Afig el missatge d'error al jocs.\n\n5. Fes que el jugador puga triar nom i color\n\nTriar Nom i Color: Permet als jugadors triar el seu nom i el color de les fitxes al començar una partida. Aquesta informació ha de ser guardada en les sessions i mostrada en la vista del joc.\n\nCriteri\n** Insuficient (1 punt)**\n** Adequat (2 punts)**\n** Bé (3 punts)**\n** Excel·lent (4 punts)**\n\n**Funcionalitat del programa **\nNo es funcional.\nEs funcional però falten funcionalitats.\nEs funcional però falten detalls.\nTotalment funcional.\n\nImplementació de Programació Orientada a Objectes (POO)\nLes classes no estan ben dissenyades, falta encapsulació, ús incorrecte d'herència, o mètodes no funcional.\nLes classes estan creades però poden tindre errors o una estructura confusa. S'aplica la POO de manera bàsica, però hi ha problemes de disseny.\nClasses correctament estructurades i funcionalment completes. Ús adequat d'encapsulació, herència i polimorfisme.\nDisseny de classes ben organitzat, reutilitzable i amb una implementació clara dels principis de POO.\n\nSeparació del Model de Negoci de la Presentació (MVC)\nNo s'ha implementat la separació de model i presentació; el codi de lògica i presentació està mesclat.\nHi ha una separació parcial, però algunes parts de la lògica del negoci es barregen amb la presentació o a l'inrevés.\nLa separació entre model, vista i controlador està ben implementada, però podria millorar en alguns aspectes.\nExcel·lent separació entre el model, vista i controlador, seguint els principis del patró MVC i mantenint un codi net.\n\nIntegració de Composer i Autoloading\nNo s'ha configurat Composer o l'autoloading, o està mal configurat i no funciona correctament.\nComposer s'ha utilitzat, però amb una estructura de projectes i autoloading bàsics o incorrectes.\nComposer i l'autoloading estan configurats correctament amb una estructura de projectes ben definida.\nÚs excel·lent de Composer amb una configuració avançada d'autoloading i una estructura de projecte organitzada i modular.\n\nImplementació de Proves amb PHPUnit\nNo s'han creat proves, o les proves creades són mínimes i no adequades per a verificar la funcionalitat.\nEs presenten proves bàsiques amb PHPUnit, però cobreixen parcialment les funcionalitats requerides.\nProves unitàries completes que cobreixen la majoria dels casos, incloent proves de gestió de sessions i lògica de joc.\nProves exhaustives que cobreixen totes les funcionalitats i consideren casos límit, amb ús de mocks quan necessari.\n\nÚs de Logger amb Monolog\nNo s'ha implementat el logger o no s'utilitza de manera efectiva per registrar esdeveniments importants.\nLogger implementat, però amb ús limitat o incorrecte en la registració d'esdeveniments i errors.\nLogger ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nÚs avançat de logger amb diferents handlers per registrar informació, errors, i seguiment detallat del flux del joc.\n\nDocumentació amb PHPDoc\nFalta documentació o és insuficient per comprendre les classes i mètodes del projecte.\nDocumentació bàsica amb PHPDoc, però amb omisions o descripcions poc clares.\nDocumentació completa amb PHPDoc per a totes les classes i mètodes, amb descripcions clares i detallades.\nDocumentació excel·lent amb PHPDoc, ben estructurada i completa, facilitant la comprensió i manteniment del projecte.\n\nExempcions\nNo hi ha.\nSi hi ha però no es mostra missatge d'error.\nEs tracta perfectament i hi ha missatge d'error .\n\nQualitat del Codi i Bones Pràctiques\nCodi desorganitzat, amb molts errors de sintaxi, mala nomenclatura, o sense bones pràctiques de codi.\nCodi funcional però amb problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\nCodi ben escrit, seguint les convencions de nomenclatura i bones pràctiques de desenvolupament.\nCodi de qualitat professional, net, ben organitzat, i seguint rigorosament les millors pràctiques de programació.\n\nExplicació dels Criteris\n1 punt: Insuficient\n\nPOO: Les classes no segueixen els principis bàsics de la programació orientada a objectes. Hi ha problemes greus com la falta d'encapsulació, l'ús inadequat de l'herència o mètodes que no funcionen correctament.\nMVC: No s'ha implementat la separació del model de negoci i la presentació. El codi de la lògica del negoci està mesclat amb la presentació (HTML, CSS), cosa que dificulta el manteniment i l'escalabilitat del projecte.\nComposer i Autoloading: No s'ha configurat Composer o l'autoloading. Si estan configurats, no funcionen correctament.\nProves amb PHPUnit: Les proves estan absents o són mínimes, i no verifiquen adequadament la funcionalitat del projecte.\nLogger amb Monolog: El logger no s'ha implementat, o si està present, no s'utilitza de manera efectiva per registrar esdeveniments importants.\nDocumentació amb PHPDoc: Falta documentació essencial, o la que existeix és insuficient per a entendre el codi.\nQualitat del Codi: El codi és desorganitzat, amb molts errors de sintaxi i no segueix les bones pràctiques de programació.\n\n2 punts: Adequat\n\nPOO: Les classes estan creades, però poden contindre errors o una estructura confusa. L'aplicació de la POO és bàsica, amb alguns problemes de disseny.\nMVC: Hi ha una separació parcial entre el model de negoci i la presentació. No obstant això, encara hi ha parts del codi on la lògica del negoci està barrejada amb la presentació o a l'inrevés, cosa que indica una comprensió bàsica però incompleta del patró MVC.\nComposer i Autoloading: Composer s'ha utilitzat, però l'estructura de projectes o l'autoloading no són òptims, presentant configuracions bàsiques o incorrectes.\nProves amb PHPUnit: Es presenten proves bàsiques que cobreixen parcialment les funcionalitats requerides.\nLogger amb Monolog: El logger està implementat, però l'ús és limitat o incorrecte en la registració d'esdeveniments i errors.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és bàsica, amb algunes omisions o descripcions poc clares.\nQualitat del Codi: El codi és funcional però presenta problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\n\n3 punts: Bé\n\nPOO: Les classes estan correctament estructurades i són funcionalment completes. Es fa un ús adequat de l'encapsulació, l'herència i el polimorfisme.\nMVC: La separació entre el model, vista i controlador està ben implementada, seguint majoritàriament els principis del patró MVC. El codi és clar i estructurat, amb algunes àrees que podrien millorar-se per aconseguir una millor modularitat i mantenibilitat.\nComposer i Autoloading: Composer i l'autoloading estan configurats correctament, amb una estructura de projectes ben definida.\nProves amb PHPUnit: Les proves unitàries estan completes i cobreixen la majoria dels casos, incloent-hi la gestió de sessions i la lògica del joc.\nLogger amb Monolog: El logger està ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és completa per a totes les classes i mètodes, amb descripcions clares i detallades.\nQualitat del Codi: El codi està ben escrit, seguint les convencions de nomenclatura i les bones pràctiques de desenvolupament.\n\n4 punts: Excel·lent\n\nPOO: El disseny de classes està ben organitzat, és reutilitzable i implementa clarament els principis de la programació orientada a objectes. El codi és elegant i eficient.\nMVC: Excel·lent separació entre el model, vista i controlador, seguint rigorosament els principis del patró MVC. El codi està ben organitzat, modular i fàcil de mantenir, cosa que facilita l'escalabilitat del projecte. Hi ha una clara distinció de responsabilitats entre les diferents capes.\nComposer i Autoloading: S'utilitza Composer de manera excel·lent, amb una configuració avançada de l'autoloading i una estructura de projecte organitzada i modular.\nProves amb PHPUnit: Les proves són exhaustives, cobrint totes les funcionalitats i considerant casos límit, amb ús de mocks quan necessari.\nLogger amb Monolog: S'utilitza el logger de manera avançada, amb diferents handlers per registrar informació, errors, i fer un seguiment detallat del flux del joc.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és excel·lent, ben estructurada i completa, facilitant la comprensió i el manteniment del projecte.\nQualitat del Codi: El codi és de qualitat professional, net, ben organitzat, i segueix rigorosament les millors pràctiques de programació.\n\n15. Autoavaluació: Programació Orientada a Objectes en PHP\nExercici 1: Constructors en PHP\nPregunta:\nQuina és la funció principal d'un constructor en una classe PHP?\nOpcions:\n\na) Destruir els objectes de la classe quan ja no són necessaris.\n\nb) Inicialitzar les propietats de l'objecte quan es crea.\n\nc) Executar una funció arbitrària abans de cada mètode.\n\nd) Crear mètodes màgics automàticament.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Inicialitzar les propietats de l'objecte quan es crea.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Herència en PHP\nPregunta:\nQuina és l'avantatge principal de l'herència en la programació orientada a objectes?\nOpcions:\n\na) Permet reutilitzar codi definint classes noves basades en classes existents.\n\nb) Permet ocultar totes les propietats i mètodes de la classe.\n\nc) Permet definir funcions globals sense necessitat de classes.\n\nd) Permet cridar a funcions de JavaScript des de PHP.\n\nfunction checkAnswer2() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question2');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet reutilitzar codi definint classes noves basades en classes existents.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Polimorfisme\nPregunta:\nQuè permet el polimorfisme en el context de la POO?\nOpcions:\n\na) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\n\nb) Permet la creació d'objectes a partir de funcions anònimes.\n\nc) Permet la connexió entre PHP i bases de dades relacionals.\n\nd) Permet executar múltiples scripts PHP alhora.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Espais de Noms\nPregunta:\nPer a què s'utilitzen els espais de noms (namespaces) en PHP?\nOpcions:\n\na) Per executar codi PHP de forma asincrònica.\n\nb) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\n\nc) Per definir variables globals accessibles des de qualsevol punt del codi.\n\nd) Per importar codi d'altres llenguatges de programació com JavaScript.\n\nfunction checkAnswer4() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question4');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Traits en PHP\nPregunta:\nQuin avantatge ofereixen els traits en PHP?\nOpcions:\n\na) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\n\nb) Permet la creació de funcions globals en PHP.\n\nc) Permet la comunicació entre diferents servidors web.\n\nd) Permet executar codi PHP dins de plantilles HTML.\n\nfunction checkAnswer5() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question5');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Excepcions en PHP\nPregunta:\nQuina és la finalitat d'utilitzar excepcions en PHP?\nOpcions:\n\na) Evitar l'execució de codi mal format.\n\nb) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\n\nc) Declarar funcions dins d'una classe.\n\nd) Garantir que totes les variables estiguen inicialitzades abans del seu ús.\n\nfunction checkAnswer6() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question6');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Autoloading en PHP\nPregunta:\nQuin avantatge ofereix l'autoloading en PHP?\nOpcions:\n\na) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\n\nb) Permet l'execució de múltiples scripts alhora.\n\nc) Permet la manipulació de fitxers en el servidor.\n\nd) Permet la connexió amb bases de dades.\n\nfunction checkAnswer7() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question7');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": ["1", "note","PHP"]
},

{
		"title": "0. Indice",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/0-indice/",
		"content": "[!abstract] &quot;Duració i criteris d'avaluació&quot;\nDuració estimada: 10 hores\n\nResultat d'aprenentatge\nCriteris d'avaluació\n\n6. Desenvolupa aplicacions web d'accés a magatzems de dades, aplicant mesures per a mantindre la seguretat i la integritat de la informació.\na) S'han analitzat les tecnologies que permeten l'accés mitjançant programació a la informació disponible en magatzems de dades.\n\nb) S'han creat aplicacions que establisquen connexions amb bases de dades.\n\nc) S'ha recuperat informació emmagatzemada en bases de dades.\n\nd) S'ha publicat en aplicacions web la informació recuperada.\n\ne) S'han utilitzat conjunts de dades per a emmagatzemar la informació.\n\nf) S'han creat aplicacions web que permeten l'actualització i l'eliminació d'informació disponible en una base de dades.\n\ng) S'han provat i documentat les aplicacions web.\n\nEn aquesta unitat aprendrem a accedir a dades que es troben en un servidor; recuperant, editant i creant aquestes dades a través d'una base de dades.\nA través de les diferents capes o nivells, de les quals 2 d'elles ja coneixem (Nginx, PHP) i MySQL la que estudiarem en aquest tema.",
		"tags": [ "note","PHP"]
},

{
		"title": "1. Introducció a les tecnologies per accedir a dades",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/1-introduccio-a-les-tecnologies-per-accedir-a-dades/",
		"content": "Bases de dades relacionals (SQL)\nLes bases de dades relacionals utilitzen llenguatge SQL per emmagatzemar i recuperar dades de taules relacionades. En PHP, les tecnologies més utilitzades per accedir-hi són PDO i MySQLi. PDO suporta múltiples sistemes de bases de dades (MySQL, PostgreSQL, etc.), mentre que MySQLi està dissenyat específicament per a MySQL.\nBases de dades NoSQL\nLes bases de dades NoSQL, com MongoDB o Firebase, emmagatzemen dades en formats no estructurats, com JSON. Aquestes són ideals per a aplicacions que gestionen grans volums de dades o dades no estructurades. MongoDB és un sistema orientat a documents, mentre que Firebase és conegut per les seves capacitats en temps real.\nAccés a APIs\nLes APIs REST permeten accedir a dades de serveis web externs utilitzant sol·licituds HTTP i respostes en formats com JSON o XML. GraphQL és una alternativa moderna que permet sol·licituds més específiques, només retornant les dades necessàries, en contrast amb les sol·licituds REST, que poden ser més generals.\nWeb Scraping\nEl web scraping és el procés d'extracció automàtica de dades de pàgines web. Aquesta tècnica es pot utilitzar per recuperar informació d'una pàgina web quan no hi ha una API disponible. En PHP, es poden utilitzar diverses biblioteques per descarregar i analitzar contingut HTML, com ara cURL i DOMDocument.\nConsideracions de seguretat\nÉs fonamental garantir la seguretat quan es treballa amb l'accés a dades. Això inclou protegir les aplicacions contra vulnerabilitats comunes, com les injeccions SQL, i assegurar les connexions utilitzant SSL/TLS quan es comuniqui amb bases de dades remotes o APIs externes.",
		"tags": [ "note","PHP"]
},

{
		"title": "2. Bases de dades relacionals (SQL)",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/2-bases-de-dades-relacionals-sql/",
		"content": "Instal·lació\nA través de XAMPP és molt senzill, simplement ens descarregaríem el programa i l'activaríem. Per a descarregar XAMPP prem ací.\nAmb Docker utilitzarem un altre repositori que inclou el mysql i el phpMyAdmin i llancem\ndocker-compose up -d\n\nSi tot ha eixit bé i el contenidor està en marxa, podrem visitar la pàgina de phpMyAdmin de la següent manera\nhttp://localhost:8000\n\nPer a accedir hem d'utilitzar les següents credencials que venen configurades en el arxiu docker-compose.yml\nusuario: root\ncontraseña: 1234\n\nEstructura d'una base de dades\nSabem que una base de dades té molts camps amb els seus noms i valors, però a més sabem que la base de dades ha de tindre un nom. per tant tindríem la següent estructura per a una base de dades:\nNombreBaseDeDatos\n|__Tabla-#1\n| |__DatosTabla-#1\n|\n|__Tabla-#2\n| |__DatosTabla-#2\n|\n|__Tabla-#3\n| |__DatosTabla-#3\n[...]\nVegem-ho en un exemple real\nRyanair\n|__pasajero\n| |__id[]\n| |__nombre\n| |__apellidos\n| |__edad\n| |__id_vuelo[^]\n|\n|__vuelo\n| |__id[]\n| |__n_plazas\n| |__disponible\n| |__id_pais[^]\n|\n|__pais\n|__id[*]\n|__nombre\n\n[*] Clau primària [^] Clave Forània\n\nSQL\nAquest llenguatge de consulta estructurada (Structured Query Language) és el que utilitzarem per a realitzar les consultes a les nostres bases de dades per a mostrar el contingut en les diferents interfícies web que creem al llarg de la unitat. Si vols saber més detalls visita Wiki SQL\nExemple d'una sentència SQL on seleccionem totes les files i columnes de la nostra taula anomenada 'pais'\nSELECT * FROM pais\n\nEstas sentencias pueden invocarse desde la consola de comandos mediante el intérprete mysql (previamente instalado en el sistema) o a través de la herramienta phpMyAdmin.\nLas sentencias SQL también las podemos usar dentro de nuestro código php, de tal manera que cuando se cargue nuestra interfaz web, lance una sentecia SQL para mostrar los datos que queramos.\n&lt;?php\n// Llistat de clients, adreçats per DNI de manera ASCendent\n$clientesOrdenadosPorDNI = &quot;SELECT * FROM `pasajero` ORDER BY `dni`&quot; ASC;\n?&gt;\n\nphpMyAdmin\n\nAquest programari funciona sota Ngingx i PHP i és més que res una interfície web per a gestionar les bases de dades que tinguem disponibles en el nostre servidor local. Molts *hostings ofereixen aquesta eina per defecte per a poder gestionar les BBDD que tinguem configurades sota el nostre compte.\nCreant una base de dades dins de phpMyAdmin\n\nPer a crear una nova base de dades hem d'entrar en phpMyAdmin com a usuari root i punxar en l'opció Nova del menú de l'esquerra.\n\nEn la nova finestra de creació posarem un nom a nostra bbdd.\n\nTambé establirem el cotejamiento utf8m4_unicode_ci perquè nostra bbdd suporte tot tipus de caràcters (com els asiàtics) i fins i tot emojis ;)\n\nLi donem al botó de Crear per a crear la bbdd i començar a escriure les diferents taules que anem a introduir en ella.\n\nEl sistema generarà el codi SQL per a crear tot el que li hem posat i crearà la base de dades amb les taules que li hàgem ficat.\nCREATE TABLE `persona`. ( `id` INT NOT NULL AUTO_INCREMENT , `nombre` TINYTEXT NOT NULL , `apellidos` TEXT NOT NULL , `telefono` TINYTEXT NOT NULL , PRIMARY KEY (`id`)) ENGINE = InnoDB;\n\nOpcions en phpMyAdmin\nQuan seleccionem una base de dades de la llista, el sistema ens mostra diverses pestanyes amb les quals interactuar amb la base de dades en qüestió:\n\nEstructura: Podem veure les diferents taules que consoliden la nostra base de dades\n\nSQL: Per si volem injectar codi SQL perquè el sistema l'interprete\n\nBuscar: Serveix per a buscar per termes, en la nostra base de dades, aplicant diferents filtres de cerca\n\nGenerar consulta: semblança a SQL però d'una manera més gràfica, sense haver de saber res del llenguatge\n\nExportar i importar: Com el seu nom indica, per a fer qualsevol de les 2 operacions sobre la base de dades\n\nOperacions: Diferents opcions avançades per a realitzar en la nostra base de dades, de la qual destacarem l'opció Cotejamiento on podrem canviar el cotejamiento de la nostra taula però ULL AMB ACÔ perquè podem eliminar dades sense voler, ja que en canviar el cotejamiento podem suprimir caràcters no suportats pel nou cotejamiento\n\nNo aprofundirem en la resta d'opcions però, en la pestanya Més existeix l'opció Dissenyador per a poder editar les relacions entre taules d'una manera gràfica (punxant i arrossegant) que veurem més endavant.",
		"tags": [ "note","PHP"]
},

{
		"title": "3. PHP Data Objects  PDO",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/3-php-data-objects-pdo/",
		"content": "La classe PDO de PHP s'utilitza per connectar-se a una base de dades i executar consultes SQL de manera segura. Quan construeixes una instància de PDO, pots passar-li diferents atributs en el constructor i opcions per configurar el comportament de la connexió. Aquí tens els atributs principals i el seu propòsit:\nConstructor de la classe PDO\nEl constructor de la classe PDO accepta tres paràmetres obligatoris i un opcional:\n&lt;?php\n$pdo = new PDO(string $dsn, string $username, string $password, array $options);\n\n$dsn (Data Source Name): És una cadena que especifica el tipus de base de dades i la informació necessària per connectar-s'hi.\n\nFormat per tipus de base de dades i configuració, per exemple:\n\nMysql:host=localhost;dbname=testdb (per a MySQL).\npgsql:host=localhost;port=5432;dbname=testdb (per a PostgreSQL).\nsqlite:/path/to/database.db (per a SQLite).\n\n$username: El nom d'usuari per a la connexió a la base de dades.\n$password: La contrasenya associada al nom d'usuari.\n$options (Opcional): Un array d'opcions per definir el comportament de la connexió. Aquests són alguns dels valors més comuns que es poden definir en aquest array:\n\nPDO::ATTR_ERRMODE: Controla com es gestionen els errors. Alguns valors comuns són:\n\nPDO::ERRMODE_SILENT: Els errors no generen cap missatge.\nPDO::ERRMODE_WARNING: Els errors generen un avís.\nPDO::ERRMODE_EXCEPTION: Els errors generen una excepció, que és el més recomanable per controlar errors.\n\nPDO::ATTR_DEFAULT_FETCH_MODE: Defineix el mode de recuperació de dades per defecte, com ara:\n\nPDO::FETCH_ASSOC: Retorna les dades com un array associatiu.\nPDO::FETCH_OBJ: Retorna les dades com un objecte.\nPDO::FETCH_BOTH: Retorna les dades com un array associatiu i numèric.\n\nPDO::ATTR_PERSISTENT: Habilita connexions persistents. Una connexió persistent pot millorar el rendiment mantenint la connexió activa per múltiples peticions en lloc de crear-ne una nova cada vegada.\nPDO::ATTR_TIMEOUT: Defineix un temps límit per a la connexió en segons.\n\nExemple de connexió amb PDO\n$dsn = &quot;mysql:host=localhost;dbname=testdb&quot;;\n$username = &quot;usuari&quot;;\n$password = &quot;contrasenya&quot;;\n$options = [\nPDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION,\nPDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC,\nPDO::ATTR_PERSISTENT =&gt; true,\nPDO::MYSQL_ATTR_INIT_COMMAND =&gt; &quot;SET NAMES utf8&quot;\n];\n\ntry {\n$pdo = new PDO($dsn, $username, $password, $options);\necho &quot;Connexió establerta amb èxit!&quot;;\n} catch (PDOException $e) {\necho &quot;Error de connexió: &quot; . $e-&gt;getMessage();\n}\n\nAquest codi estableix una connexió a una base de dades MySQL amb un joc de caràcters utf8, una connexió persistent, i llança excepcions en cas d'errors.\nQualsevol error que es llance a través de PDO, el sistema llançarà una PDOException .\nFitxer de configuració de la BD\nDe la mateixa manera que podem tenir el nostre arxiu de funcions funciones.php i alberguem totes les funcions que s'usen de manera global en l'aplicació, podem establir un arxiu de constants on definim els paràmetres de connexió amb la base de dades.\n&lt;?php\n\n// ▒▒▒▒▒▒▒▒ conexion.php ▒▒▒▒▒▒▒▒\n\nconstDSN = &quot;mysql:host=localhost;dbname=dwes&quot;;\nconstUSUARIO = &quot;dwes&quot;;\nconstPASSWORD = &quot;abc123&quot;;\n\n/* ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n▒▒▒▒▒▒▒▒ NO SUBAS ESTE ARCHIVO A git ▒▒▒▒▒\n\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ */\n\nAquest arxiu conté informació molt sensible així que no és recomanable que puges aquest arxiu a git.\nSentències preparades\nEs tracta de sentències que s'estableixen com si foren plantilles de la SQL que llançarem, acceptant paràmetres que són establits a posteriori de la declaració de la sentència preparada.\nLes sentències preparades eviten la injecció de SQL (SQL Injection) i milloren el rendiment de nostres aplicacions o pàgines web.\n&lt;?php\n$sql = &quot;INSERT INTO Clientes VALUES (?, ?, ?, ?)&quot;;\n\nCada interrogant és un paràmetre que establirem després, unes quantes línies més a baix.\nUna vegada tenim la plantilla de la nostra consulta, hem de seguir amb la preparació juntament amb 3 mètodes més de PHP per a la seua completa execució:\n\nprepare: prepara la sentencia abans de ser executada.\nbind: el tipus d'unió (*bind^) de dada que pot ser mitjançant ' ? ' o ' :parametre '\nexecute s'executa la consulta unint la plantilla amb les variables o paràmetres que hem establit.\n\nExemple paràmetros\n&lt;?php\n\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion = null;\n\ntry {\n$cantidad = $_GET[&quot;cantidad&quot;];\n\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;DELETE FROM stock WHERE unidades = ?&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n$isOk = $sentencia -&gt; execute([$cantidad]);\n$cantidadAfectada = $sentencia -&gt; rowCount();\n\necho $cantidadAfectada;\n} catch (PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null\n\nExemple bindParam\nMolt semblant a utilitzar paràmetres però aquesta vegada la variable està dins de la sentència SQL, en aquest cas l'hem anomenada :cant\n&lt;?php\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion=null;\n\ntry {\n$cantidad = $_GET[&quot;cantidad&quot;] ?? 0;\n\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;DELETE FROM stock WHERE unidades = :cant&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; bindParam(&quot;:cant&quot;, $cantidad);\n\n$isOk = $sentencia -&gt; execute();\n\n$cantidadAfectada = $sentencia -&gt; rowCount();\n\necho $cantidadAfectada;\n} catch (PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null;\n\nbindParam VS bindValue\nUtilitzarem bindValue() quan hàgem d'inserir dades només una vegada, en canvi, haurem d'usar bindParam() quan hàgem de passar dades múltiples, com per exemple, un array.\n&lt;?php\n// se asignan nombre a los parámetros\n$sql = &quot;DELETE FROM stock WHERE unidades = :cant&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n// bindParam enlaza por referencia\n$cantidad = 0;\n\n$sentencia -&gt; bindParam(&quot;:cant&quot;, $cantidad);\n$cantidad = 1;\n\n// se eliminan con cant = 1\n$isOk = $sentencia -&gt; execute();\n\n// bindValue enlaza por valor\n$cantidad = 0;\n\n$sentencia -&gt; bindValue(&quot;:cant&quot;, $cantidad);\n$cantidad = 1;\n\n// se eliminan con cant = 0\n$isOk = $sentencia-&gt;execute();\n\nPer a més informació i ús de les variables PDO consulta el manual de PHP.\nInserint registres\nA l'hora d'inserir registres en una base de dades, hem de tindre en compte que en la taula pot haver-hi valors autoincrementats. Per a salvaguardar açò, el que hem de fer és deixar aqueix camp autoincrementat buit, però a l'hora de fer la connexió, hem de recuperar-ho amb el mètode lastInsertId().\n&lt;?php\n$nombre = $_GET[&quot;nombre&quot;] ?? &quot;SUCURSAL X&quot;;\n$telefono = $_GET[&quot;telefono&quot;] ?? &quot;636123456&quot;;\n\n$sql=&quot;INSERT INTO tienda(nombre, tlf) VALUES (:nombre, :telefono)&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; bindParam(&quot;:nombre&quot;, $nombre);\n$sentencia -&gt; bindParam(&quot;:telefono&quot;, $telefono);\n\n$isOk = $sentencia -&gt; execute();\n$idGenerado = $conexion -&gt; lastInsertId();\n\necho $idGenerado;\n\nConsultant registres\nA l'hora de recuperar els resultats d'una consulta, bastarà amb invocar al mètode PDOStatement::fetch per a llistar les files generades per la consulta.\nPerò hem de triar el tipus de dada que volem rebre entre els 3 que hi ha disponibles:\n\nPDO::FETCH_ASSOC: array indexat que els seus keys són el nom de les columnes.\nPDO::FETCH_NUM: array indexat que els seus keys són números.\nPDO::FETCH_BOTH: valor per defecte. Retorna un array indexat que els seus keys són tant el nom de les columnes com números.\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con array asociativo.php ▒▒▒▒▒▒▒▒\n\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion = null;\n\ntry{\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;select * from tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_ASSOC);\n$sentencia -&gt; execute();\n\nwhile($fila = $sentencia -&gt; fetch()){\necho &quot;Codigo:&quot; . $fila[&quot;cod&quot;] . &quot;&lt;br /&gt;&quot;;\necho &quot;Nombre:&quot; . $fila[&quot;nombre&quot;] . &quot;&lt;br /&gt;&quot;;\necho &quot;Teléfono:&quot; . $fila[&quot;tlf&quot;] . &quot;&lt;br /&gt;&quot;;\n}\n\n}catch(PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null;\n\nRecuperant dades amb una matriu com a resultat de la nostra consulta\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con array asociativo ▒▒▒▒▒▒▒▒\n\n$sql=&quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_ASSOC);\n$sentencia -&gt; execute();\n\n$tiendas = $sentencia -&gt; fetchAll();\n\nforeach($tiendasas$tienda) {\necho&quot;Codigo:&quot; . $tienda[&quot;cod&quot;] . &quot;&lt;br /&gt;&quot;;\necho&quot;Nombre:&quot; . $tienda[&quot;nombre&quot;] . &quot;&lt;br /&gt;&quot;;\n}\n\nPerò si el que volem és llegir dades amb forma d'objecte utilitzant PDO::FETCH_OBJ, hem de crear un objecte amb propietats públiques amb el mateix nom que les columnes de la taula que anem a consultar.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con formato de objeto ▒▒▒▒▒▒▒▒\n\n$sql=&quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_OBJ);\n$sentencia -&gt; execute();\n\nwhile($t = $sentencia -&gt; fetch()) {\necho&quot;Codigo:&quot; . $t -&gt; cod . &quot;&lt;br /&gt;&quot;;\necho&quot;Nombre:&quot; . $t -&gt; nombre . &quot;&lt;br /&gt;&quot;;\necho&quot;Teléfono:&quot; . $t -&gt; tlf . &quot;&lt;br /&gt;&quot;;\n}\n\nConsultes amb models\nPortem temps creant classes en PHP i les consultes també admeten aquest tipus de dades mitjançant l'ús de PDO::FETCH_CLASS\nSi usem aquest mètode, hem de tindre en compte que els noms dels atributs privats han de coincidir amb els noms de les columnes de la taula que anem a manejar.\nAixí doncs, si pel que siga canviem l'estructura de la taula HEM DE CANVIAR la nostra classe perquè tot continue funcionant.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ clase Tienda ▒▒▒▒▒▒▒▒\n\nclassTienda {\nprivate int $cod;\nprivate string $nombre;\nprivate ? string $tlf;\n\npublic function getCodigo() : int {\nreturn $this -&gt; cod;\n}\n\npublic function getNombre() : string {\nreturn $this -&gt; nombre;\n}\n\npublic function getTelefono() : ?string {\nreturn $this -&gt; tlf;\n}\n}\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Consultando a través de la clase Tienda ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n// Aquí 'Tienda' es el nombre de nuestra clase\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS, Tienda::class);\n$sentencia -&gt; execute();\n\nwhile($t = $sentencia -&gt; fetch()) {\necho &quot;Codigo: &quot; . $t -&gt; getCodigo() . &quot;&lt;br /&gt;&quot;;\necho &quot;Nombre: &quot; . $t -&gt; getNombre() . &quot;&lt;br /&gt;&quot;;\necho &quot;Teléfono: &quot; . $t -&gt; getTelefono() . &quot;&lt;br /&gt;&quot;;\n\nvar_dump($t);\n}\n\nPerò què passa si les nostres classes tenen constructor? doncs que hem d'indicar-li, al mètode FECTH, que emplene les propietats després de cridar al constructor i per a això fem ús de PDO::FETCH_PROPS_LATE.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Consulta para una clase con constructor ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, Tienda::class);\n$sentencia -&gt; execute();\n\n$tiendas = $sentencia -&gt; fetchAll();\n\nConsultes amb LIKE\nPer a utilitzar el comodí LIKE o altres comodins, hem d'associar-lo a la dada i MAI en la pròpia consulta.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Utilizando comodines :: LIKE ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda where nombre like :nombre or tlf like :tlf&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, Tienda::class);\n\n$cadBuscar = &quot;%&quot; . $busqueda . &quot;%&quot;;\n\n$sentencia -&gt; execute([&quot;nombre&quot; =&gt; $cadBuscar,&quot;tlf&quot; =&gt; $cadBuscar]);\n\n$result = $sentencia -&gt; fetchAll();\n\nTeniu una llista d'exemples molt completa en la documentació oficial.",
		"tags": [ "note","PHP"]
},

{
		"title": "4. Login & Password",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/4-login-and-password/",
		"content": "Per a manejar un sistema complet de login i password amb contrasenyes xifrades, necessitem un mètode que xifre aqueixos strings que l'usuari introdueix com a contrasenya; tant en el formulari de registre com en el del login, ja que en codificar una contrasenya, després hem de descodificar-la per a comprovar que totes dues *contrasenyes (la que introdueix l'usuari en el login i la que tenim en la base de dades) coincidisquen.\nNecessitem doncs:\n\npassword_hash() per a emmagatzemar la contrasenya en la base de dades a l'hora de fer el INSERT\n\nPASSWORD_DEFAULT emmagatzemem la contrasenya usant el mètode d'encriptació bcrypt\n\nPASSWORD_BCRYPT emmagatzemem la contrasenya usant l'algorisme CRYPT_BLOWFISH compatible amb crypt()\n\npassword_verify() per a verificar l'usuari i la contrasenya\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Almacenando usuario y password en BD ▒▒▒▒▒▒▒▒\n\n$usu = $_POST[&quot;usuario&quot;];\n$pas = $_POST[&quot;password&quot;];\n\n$sql = &quot;INSERT INTO usuarios(usuario, password) VALUES (:usuario, :password)&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n\n$isOk = $sentencia -&gt; execute([\n&quot;usuario&quot; =&gt; $usu,\n&quot;password&quot; =&gt; password_hash($pas,PASSWORD_DEFAULT)\n]);\n\nAra que tenim l'usuari codificat i guardat en la base de dades, el recuperarem per a poder loguejar-lo correctament.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Recuperando usuario y password en BD ▒▒▒▒▒▒▒▒\n\n$usu = $_POST[&quot;login&quot;] ?? &quot;&quot;;\n\n$sql = &quot;select * from usuarios where usuario = ?&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; execute([$usu]);\n\n$usuario = $sentencia -&gt; fetch();\n\nif($usuario &amp;&amp; password_verify($_POST['pass'], $usuario['password'])) {\necho&quot;OK!&quot;;\n} else {\necho&quot;KO&quot;;\n}",
		"tags": [ "note","PHP"]
},

{
		"title": "5. QueryBuilder",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/5-query-builder/",
		"content": "Un Query Builder (Constructor de Consultes) és una eina o classe que facilita la creació, execució i manipulació de consultes SQL en un programa. L'objectiu principal és proporcionar una interfície més intuïtiva i segura per interactuar amb bases de dades, sense haver d'escriure consultes SQL en brut.\nA continuació, detallo algunes de les principals avantatges i característiques d'un Query Builder com el que has compartit anteriorment:\n\nAbstracció de la Base de Dades:\n\nEl Query Builder proporciona una capa d'abstracció que permet interactuar amb diferents tipus de bases de dades (MySQL, PostgreSQL, SQLite, etc.) sense canviar el codi de la teva aplicació. Això facilita la portabilitat i l'escalabilitat del codi.\n\nSeguretat:\n\nPrevé injeccions SQL: Gràcies a l'ús de sentències preparades i enllaçament de paràmetres, el Query Builder ajuda a prevenir atacs d'injecció SQL, una de les amenaces més comunes en desenvolupament web.\n\nSintaxi Més Neta i Més Fàcil:\n\nEls Query Builders solen proporcionar una sintaxi més neta i fàcil d'entendre que les cadenes SQL pures. Això fa que el codi sigui més llegible i fàcil de mantenir.\n\nReutilització de Codi:\n\nLes funcions del Query Builder es poden reutilitzar a tot el projecte, reduint la duplicació de codi i facilitant el manteniment.\n\nFlexibilitat:\n\nPermet realitzar consultes complexes amb una sintaxi simplificada, facilitant l'adaptació del codi a canvis en els requeriments de l'aplicació.\n\nDesenvolupament Més Ràpid:\n\nAjuda a accelerar el procés de desenvolupament, ja que els desenvolupadors no necessiten recordar la sintaxi SQL exacta per a cada tipus de base de dades.\n\nFàcil de Depurar:\n\nEl codi generat pel Query Builder és més fàcil de depurar en comparació amb les llargues cadenes SQL.\n\nSuport per a Operacions CRUD:\n\nEls Query Builders solen incloure suport integrat per a operacions CRUD (Crear, Llegir, Actualitzar, Esborrar), fent més fàcil la manipulació de dades.\n\nEn resum, un Query Builder serveix per simplificar la interacció amb bases de dades, proporcionant una interfície més segura, neta i fàcil d'utilitzar que les cadenes SQL pures. Ajuda a accelerar el desenvolupament, facilita el manteniment i millora la seguretat de l'aplicació.\nAcí en tenim un exemple de construcció casera:\n&lt;?php\n\nnamespace BatBook;\n\nuse PDO;\n\nclass QueryBuilder\n{\n// Aquesta funció serveix per a construir i executar consultes SQL de tipus SELECT.\n// Es pot filtrar per valors, limitar la quantitat de resultats i establir un offset.\npublic static function sql($class, $values=null, $limit = null, $offset = null)\n{\n// Obté el nom de la taula a partir de la propietat estàtica $nameTable de la classe passada com argument.\n$table = $class::$nameTable;\n\n// Obté una connexió a la base de dades.\n$conn = Connection::get();\n\n// Construeix la consulta SQL bàsica.\n$sql = &quot;SELECT * FROM $table&quot;;\n\n// Afegeix condicions WHERE si es proporcionen valors per a filtrar.\nif ($values) {\n$sql .= &quot; WHERE &quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= &quot; AND $id=:$id&quot;;\n} else {\n$sql .= &quot;$id=:$id&quot;;\n}\n}\n}\n\n// Afegeix les clàusules LIMIT i OFFSET si són necessàries.\nif (isset($limit) &amp;&amp; isset($offset)) {\n$sql .= &quot; LIMIT $limit OFFSET $offset&quot;;\n}\n\n// Prepara la sentència SQL.\n$sentence = $conn-&gt;prepare($sql);\n\n// Enllaça els valors a la sentència.\nforeach ($values??[] as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n\n// Estableix el mode de recuperació a objectes de la classe especificada.\n$sentence -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE , $class);\n\n// Executa la consulta.\n$sentence -&gt; execute();\n\n// Retorna tots els resultats obtinguts.\nreturn $sentence-&gt;fetchAll();\n}\n\n// Aquesta funció serveix per a trobar una fila en una taula basant-se en el seu ID.\npublic static function find($class, $id)\n{\n//TODO\n}\n\n// Aquesta funció serveix per a insertar una fila en una taula.\npublic static function insert($class, $values)\n{\n$table = $class::$nameTable;\n$conn = Connection::get();\n$sql = &quot;INSERT INTO $table (&quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= ','.$id;\n} else {\n$sql .= $id;\n}\n}\n$sql .= &quot;) VALUES (&quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= ',:'.$id;\n} else {\n$sql .= ':'.$id;\n}\n}\n$sql .= &quot;)&quot;;\n$sentence = $conn-&gt;prepare($sql);\nforeach ($values as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n$sentence -&gt; execute();\nreturn $conn-&gt;lastInsertId();\n}\n\n// Aquesta funció serveix per a actualitzar una fila en una taula.\npublic static function update($class, $values, $id)\n{\n$table = $class::$nameTable;\n$conn = Connection::get();\n$sql = &quot;UPDATE $table SET &quot;;\nforeach (array_keys($values) as $key =&gt; $value) {\nif ($key != 0) {\n$sql .= ','.$value.'=:'.$value;\n} else {\n$sql .= $value.'=:'.$value;\n}\n}\n$sql .= &quot; WHERE id=:id&quot;;\n$sentence = $conn-&gt;prepare($sql);\nforeach ($values as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n$sentence-&gt;bindValue(&quot;:id&quot;, $id);\n$sentence -&gt; execute();\nreturn $id;\n}\n\n// Aquesta funció serveix per a eliminar una fila en una taula basant-se en el seu ID.\npublic static function delete($class, $id)\n{\n//TODO\n}\n}\n\nEn resum, aquesta classe proporciona funcions estàtiques per a la construcció i execució de consultes SQL bàsiques com SELECT, INSERT, UPDATE, i DELETE. Utilitza l'extensió PDO per a la connexió a bases de dades i la preparació de sentències SQL, la qual cosa ajuda a prevenir injeccions SQL. També permet la manipulació fàcil de files en bases de dades, tot retornant objectes de la classe especificada.\nRespotes d'error\nQuan no trebem un recurs en al nostra web, podem mostrar a l'usuari una pàgina específica d'error utilitzant la funció header. Una típica seria:\n&lt;!-- not-found.php --&gt;\n&lt;?php http_response_code(404); ?&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;No trobat&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;404 - Pàgina no trobada&lt;/h1&gt;\n&lt;p&gt;Ho sentim, la pàgina que estàs buscant no s'ha pogut trobar.&lt;/p&gt;\n&lt;a href=&quot;index.php&quot;&gt;Torna a l'inici&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nI per a utilitzar-la:\n&lt;?php\nheader(&quot;Location: not-found.php&quot;);\nexit;\n?&gt;",
		"tags": [ "note","PHP"]
},

{
		"title": "6. Accès a fitxers",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/6-acces-a-fitxers/",
		"content": "Gràcies a la funció fopen() des de PHP podem obrir arxius que es troben en els nostres servidor o una URL.\nA aquesta funció cal passar-li 2 paràmetres; el nom de l'arxiu que volem obrir i la manera en què s'obrirà\n$fp = fopen(&quot;miarchivo.txt&quot;, &quot;r&quot;);\n\nMoltes vegades no podem obrir l'arxiu perquè aquest no es troba o no tenim accés a ell, per això és recomanable comprovar que podem fer-ho\nif (!$fp = fopen(&quot;miarchivo.txt&quot;, &quot;r&quot;)){\necho &quot;No se ha podido abrir el archivo&quot;;\n}\n\nManeres d'obertura de fitxers\n\nr: Manera lectura. Punter al principi de l'arxiu.\nr+: Obertura per a lectura i escriptura. Punter al principi de l'arxiu\nw: Obertura per a escriptura. Punter al principi de l'arxiu i el sobreescriu. Si no existeix s'intenta crear.\nw+: Obertura per a lectura i escriptura. Punter al principi de l'arxiu i el sobreescriu. Si no existeix s'intenta crear.\na: Obertura per a escriptura. Punter al final de l'arxiu. Si no existeix s'intenta crear.\na+: Obertura per a lectura i escriptura. Punter al final de l'arxiu. Si no existeix s'intenta crear.\nx: Creació i obertura per a només escriptura. Punter al principi de l'arxiu. Si l'arxiu ja existeix donarà error E_*WARNING. Si no existeix s'intenta crear.\nx+: Creació i obertura per a lectura i escriptura. Mateix comportament que x.\nc: Obertura per a escriptura. Si no existeix es crea. Si existeix no se sobreescriu ni dona cap error. Punter al principi de l'arxiu.\nc+: Obertura per a lectura i escriptura. Mateix comportament que C.\nb: Quan es treballa amb arxius binaris com *jpg, pdf, *png i altres. Se sol col·locar al final de la manera, és a dir *rb, r+b, x+b, *wb...\n\nOperacions amb arxius\nPer a poder llegir un arxiu necessitem usar la funció fread() de PHP\n// ▒▒▒▒▒▒▒▒ Abriendo un archivo y leyendo su contenido ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$fp = fopen($file, &quot;r&quot;);\n\n// filesize() nos devuelve el tamaño del archivo en cuestión\n$contents = fread($fp, filesize($file));\n\n// Cerramos la conexión con el archivo\nfclose();\n\nSi el que volem és escriure en un arxiu, haurem de fer ús de la funció fwrite()\n// ▒▒▒▒▒▒▒▒ Escribiendo en un archivo ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$texto = &quot;Hola que tal&quot;;\n\n$fp = fopen($file, &quot;w&quot;);\n\nfwrite($fp, $texto);\nfclose($fp);\n\nInformació d'un fitxer\nAmb PHP i el seu mètode stat() podem obtindre informació sobre els arxius que li indiquem. Aquest mètode retorna fins a un total de 12 elements amb informació sobre el nostre arxiu.\n\ndev\t número de dispositiu\nino\t número d'i-node\nmode\t manera de protecció de l'i-node\nnlink\t nombre d'enllaços\nuid\t ID d'usuari del propietari\ngid\t ID de grup del propietari\nrdev\t tipus de dispositiu, si és un dispositiu i-node\nsize\t grandària en bytes\natime\t moment de l'últim accés (temps Unix)\nmtime\t moment de l'última modificació (temps Unix)\nctime\t moment de l'última modificació de l'i-node (temps Unix)\nblksize\t grandària del bloc E/S del sistema de fitxers\nblocks\t nombre de blocs de 512 bytes assignats\n\nUns exemples...\n&lt;?php\n\n// ▒▒▒▒▒▒▒▒ Información del archivo ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$texto = &quot;Todos somos muy ignorantes, lo que ocurre es que no todos ignoramos las mismas cosas.&quot;;\n\n$fp = fopen($file, &quot;w&quot;);\nfwrite($fp, $texto);\n\n$datos = stat($file);\n\necho $datos[3] . &quot;&lt;br&gt;&quot;; // Número de enlaces, 1\necho $datos[7] . &quot;&lt;br&gt;&quot;; // Tamaño en bytes, 85\necho $datos[8] . &quot;&lt;br&gt;&quot;; // Momento de último acceso, 1444138104\necho $datos[9] . &quot;&lt;br&gt;&quot;; // Momento de última modificación, 1444138251\n\n?&gt;\n\nDona una ullada a les funcions de directoris que té PHP, és molt interessant.",
		"tags": [ "note","PHP"]
},

{
		"title": "7. Web Scraping",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/5-acceso-a-datos/7-web-scraping/",
		"content": "Consisteix a navegar a una pàgina web i extraure informació automàticament, a partir del codi HTML generat, i organitzar la informació pública disponible en Internet.\nAquesta pràctica requereix l'ús d'una llibreria que facilite la descàrrega de la informació desitjada imitant la interacció d'un navegador web. Aquest &quot;robot&quot; pot accedir a diverses pàgines simultàniament.\n\n[!question] &quot;¿És legal?&quot;\nSi el lloc web indica que té el contingut protegit per drets d'autor o en les normes d'accés via usuari/contrasenya ens avisa de la seua prohibició, estaríem incorrent en un delicte.\nÉs recomanable estudiar l'arxiu robots.txt que es troba en l'arrel de cada lloc web.\nMés informació en l'article El manual complet per al web scraping legal i ètic en 2021\n\nGoutte\nGoutte és un senzill client HTTP per a PHP creat específicament per a fer web scraping. Ho va desenvolupar el mateix autor del framework Symfony i ofereix un API senzilla per a extraure dades de les respostes HTML/XML dels llocs web.\nEls components principals que abstrau Goutte sobre Symfony són:\n\nBrowserKit: simula el comportament d'un navegador web.\nCssSelector: tradueix consultes CSS en consultes XPath.\nDomCrawler: facilita l'ús del DOM i XPath.\n\nPer a poder utilitzar Goutte en el nostre projecte, executarem el següent comando en el terminal:\ncomposer require fabpot/goutte\n\nGoutte con selectores CSS\nA continuació farem un exemple molt senzill utilitzant els selectors CSS, extraient informació de la web https://books.toscrape.com/, la qual és una pàgina per a proves que no rebutjarà les nostres peticions.\nDesprés de crear un client amb Goutte, hem de realitzar un petició a una URL. Amb la resposta obtinguda, podem utilitzar el mètode filter per a indicar-li la ruta CSS que volem recórrer i iterar sobre els resultats mitjançant una funció anònima. Una vegada estem dins d'un determinat node, el mètode text() ens retornarà el contingut del propi node.\nEn concret, ficarem en un array associatiu el títol i el preu de tots els llibres de la categoria Classics.\n&lt;?php\nrequire '../vendor/autoload.php';\n\n$httpClient = new \\Goutte\\Client();\n$response = $httpClient-&gt;request('GET', 'https://books.toscrape.com/catalogue/category/books/classics_6/index.html');\n// colocamos los precios en un array\n$precios = [];\n$response-&gt;filter('.row li article div.product_price p.price_color')-&gt;each(\n// le pasamos $precios por referencia para poder editarla dentro del closure\nfunction ($node) use (&amp;$precios) {\n$precios[] = $node-&gt;text();\n}\n);\n\n// colocamos el nombre y el precio en un array asociativo\n$contadorPrecios = 0;\n$libros = [];\n$response-&gt;filter('.row li article h3 a')-&gt;each(\nfunction ($node) use ($precios, &amp;$contadorPrecios, &amp;$libros) {\n$libros[$node-&gt;text()] = $precios[$contadorPrecios];\n$contadorPrecios++;\n}\n);\n\nCrawler\nUn cas molt comú és obtindre la informació d'una pàgina que té els resultats paginados, de manera que anem recorrent els enllaços i accedint a cadascun dels resultats.\nEn aquest cas agafarem tots els preus dels llibres de fantasia, i els sumarem:\n&lt;?php\nrequire '../vendor/autoload.php';\n\nuse Goutte\\Client;\nuse Symfony\\Component\\HttpClient\\HttpClient;\n\n$client = new Client(HttpClient::create(['timeout' =&gt; 60]));\n$crawler = $client-&gt;request('GET', 'https://books.toscrape.com/catalogue/category/books/fantasy_19/index.html');\n\n$salir = false;\n\n$precios = [];\nwhile (!$salir) {\n$crawler-&gt;filter('.row li article div.product_price p.price_color')-&gt;each(\nfunction ($node) use (&amp;$precios) {\n$texto = $node-&gt;text();\n$cantidad = substr($texto, 2); // Le quitamos las libras ¿2 posiciones?\n$precios[] = floatval($cantidad);\n}\n);\n\n$enlace = $crawler-&gt;selectLink('next');\nif ($enlace-&gt;count() != 0) {\n// el enlace next existe\n$sigPag = $crawler-&gt;selectLink('next')-&gt;link();\n$crawler = $client-&gt;click($sigPag); // hacemos click\n} else {\n// ya no hay enlace next\n$salir = true;\n}\n}\n\n$precioTotal = array_sum($precios);\necho $precioTotal;",
		"tags": [ "note","PHP"]
},

{
		"title": "1. Introducció",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/1-introduccio/",
		"content": "Laravel és un framework PHP modern que simplifica el desenvolupament d'aplicacions web, incloent-hi la gestió de bases de dades. La integració amb Eloquent, el seu ORM (Object-Relational Mapping), permet treballar amb bases de dades de forma intuïtiva i eficient.",
		"tags": [ "note"]
},

{
		"title": "2. Configuració inicial",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/2-configuracio-inicial/",
		"content": "Laravel suporta diversos motors de bases de dades com MySQL, PostgreSQL, SQLite i SQL Server. La configuració principal es fa al fitxer .env i config/database.php.\nExemple de configuració al fitxer .env:\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=nom_base_de_dades\nDB_USERNAME=usuari\nDB_PASSWORD=contrasenya\n\nComprovació de connexió:\nDesprés de configurar el .env, utilitza el comandament:\nphp artisan migrate:status\n\nAquest comandament confirma si Laravel pot connectar-se a la base de dades configurada.\nDetecció de problemes comuns\n\nComprovar que l'extensió del driver de la base de dades (com pdo_mysql o pdo_pgsql) estigui habilitada al php.ini.\nUtilitzar php artisan config:clear per esborrar la memòria cau de configuracions si els canvis al .env no es reflecteixen.",
		"tags": [ "note"]
},

{
		"title": "3. Migracions en Laravel",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/3-migracions-en-laravel/",
		"content": "Introducció\nLes migracions són un sistema de control de versions per a bases de dades que permet treballar de manera col·laborativa, mantenint un històric dels canvis realitzats en l'esquema. Amb migracions, pots:\n\nCrear, modificar i esborrar taules.\nGestionar l'esquema de manera programàtica utilitzant Artisan i el Schema Builder.\nRevertir canvis mitjançant rollback o tornar a aplicar tots els canvis amb refresh.\n\nLaravel proporciona un conjunt d'eines intuïtives per gestionar migracions, com Artisan i la classe Schema.\nEstructura de les migracions\nTotes les migracions es guarden a la carpeta database/migrations i segueixen una estructura predefinida amb dos mètodes principals:\n\nup: Defineix les operacions que s'han d'aplicar a la base de dades (crear taules, afegir columnes, etc.).\ndown: Defineix les operacions inverses per revertir els canvis aplicats per up.\n\nExemple bàsic:\npublic function up()\n{\nSchema::create('usuarios', function (Blueprint $tabla) {\n$tabla-&gt;id();\n$tabla-&gt;string('nombre');\n$tabla-&gt;string('email')-&gt;unique();\n$tabla-&gt;timestamps();\n});\n}\n\npublic function down()\n{\nSchema::dropIfExists('usuarios');\n}\n\nPer defecte, Laravel afegeix un camp autonumèric id i dues columnes timestamps (created_at i updated_at) gestionades automàticament.\nCrear una migració\nUtilitza Artisan per crear una nova migració:\nphp artisan make:migration nom_migracio\n\nAquest comando genera un fitxer amb un nom que inclou un timestamp per assegurar l'ordre cronològic.\nExemples\n\nCrear una taula:\n\nphp artisan make:migration crear_tabla_usuarios --create=usuarios\n\nModificar una taula existent:\n\nphp artisan make:migration afegir_camp_a_usuarios --table=usuarios\n\nLaravel pot inferir accions del nom de la migració gràcies a la classe TableGuesser. Per exemple, si el nom conté create o to, Artisan deduirà si és per crear o modificar taules.\nSchema Builder\nLa classe Schema és el nucli per definir i modificar l'esquema de les bases de dades. Inclou constructors per crear, modificar i eliminar taules i columnes.\nCrear una taula\nSchema::create('users', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('username', 32);\n$table-&gt;timestamps();\n});\n\nEliminar una taula\nSchema::dropIfExists('users');\n\nAfegir columnes\nSchema::table('usuarios', function (Blueprint $table) {\n$table-&gt;string('telefono')-&gt;after('email')-&gt;nullable();\n});\n\nEliminar columnes\nSchema::table('usuarios', function (Blueprint $table) {\n$table-&gt;dropColumn('telefono');\n});\n\nTipus de columnes disponibles\nLaravel ofereix una àmplia varietat de tipus de columnes per satisfer diferents necessitats\nÍndexs i claus forànies\nCrear índexs\n$table-&gt;unique('email');\n$table-&gt;index('state');\n$table-&gt;primary(['first_name', 'last_name']);\n\nDefinir claus forànies\n$table-&gt;foreignId('user_id')-&gt;constrained()-&gt;onDelete('cascade');\n\nExecutar i revertir migracions\n\nExecutar migracions pendents:\n\nphp artisan migrate\n\nRevertir l'última migració:\n\nphp artisan migrate:rollback\n\nRevertir totes les migracions:\n\nphp artisan migrate:reset\n\nRefrescar totes les migracions:\n\nphp artisan migrate:refresh\n\nComprovar l'estat de les migracions:\n\nphp artisan migrate:status\n\nAquest conjunt de comandes permet un control complet sobre l'estat de les migracions durant el desenvolupament.",
		"tags": [ "note"]
},

{
		"title": "4. Laravel Query Builder",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/4-laravel-query-builder/",
		"content": "El Query Builder de Laravel proporciona una interfície fluida per construir i executar consultes de bases de dades. Permet treballar amb diverses bases de dades de manera senzilla sense escriure SQL brut.\n\nExemples d'ús\nObtenir tots els registres:\n$users = DB::table('users')-&gt;get();\n\nFiltrar registres:\n$users = DB::table('users')\n-&gt;where('active', 1)\n-&gt;get();\n\nSeleccionar columnes específiques:\n$users = DB::table('users')\n-&gt;select('name', 'email')\n-&gt;get();\n\nOrdenar resultats:\n$users = DB::table('users')\n-&gt;orderBy('name', 'asc')\n-&gt;get();\n\nComptar registres:\n$count = DB::table('users')-&gt;count();\n\nConsultes amb agregats:\n$maxSalary = DB::table('employees')-&gt;max('salary');\n\nConsultes amb subconsultes:\n$users = DB::table('users')\n-&gt;whereExists(function ($query) {\n$query-&gt;select(DB::raw(1))\n-&gt;from('orders')\n-&gt;whereColumn('orders.user_id', 'users.id');\n})\n-&gt;get();\n\nUnions:\n$first = DB::table('users')-&gt;where('type', 'admin');\n$second = DB::table('users')-&gt;where('type', 'customer');\n\n$users = $first-&gt;union($second)-&gt;get();\n\nInserir un registre:\nDB::table('users')-&gt;insert([\n'name' =&gt; 'John Doe',\n'email' =&gt; 'john@example.com',\n]);\n\nActualitzar un registre:\nDB::table('users')\n-&gt;where('id', 1)\n-&gt;update(['name' =&gt; 'Updated Name']);\n\nEsborrar un registre:\nDB::table('users')\n-&gt;where('id', 1)\n-&gt;delete();\n\nEsborrar tots els registres:\nDB::table('users')-&gt;truncate();\n\nAvantatges\nEl Query Builder és ideal per a:\n\nConsultes personalitzades on el rendiment és una prioritat.\nConsultes complexes que no es poden expressar fàcilment amb Eloquent.",
		"tags": [ "note"]
},

{
		"title": "5. Laravel Eloquent",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/5-laravel-eloquent/",
		"content": "Eloquent és l'ORM (Object-Relational Mapping) de Laravel. Proporciona una interfície senzilla i elegant per treballar amb bases de dades relacionals mitjançant models.\nDefinició de Models\nEls models es defineixen dins de la carpeta app/Models i es poden crear mitjançant Artisan:\nphp artisan make:model Movie\n\nExemple bàsic:\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Movie extends Model\n{\n// Taula associada al model\nprotected $table = 'movies';\n}\n\nPer defecte:\n\nEl model s'associa a una taula plural (movies per al model Movie).\nUtilitza id com a clau primària.\nAssumeix l'ús de camps created_at i updated_at gestionats automàticament.\n\nÚs bàsic d'un model\nRecuperar dades:\n\nTots els registres:\n\n$movies = Movie::all();\n\nRegistres filtrats:\n\n$movies = Movie::where('rating', '&gt;', 4)-&gt;get();\n\nRegistre únic:\n\n$movie = Movie::findOrFail($id);\n\nInserir dades:\n$movie = new Movie();\n$movie-&gt;title = &quot;Inception&quot;;\n$movie-&gt;director = &quot;Christopher Nolan&quot;;\n$movie-&gt;save();\n\nActualitzar dades:\n$movie = Movie::find($id);\n$movie-&gt;title = &quot;Updated Title&quot;;\n$movie-&gt;save();\n\nEsborrar dades:\n$movie = Movie::find($id);\n$movie-&gt;delete();\n\nPropietats comuns dels Models Eloquent\nEls models d'Eloquent ofereixen diverses propietats que permeten configurar el comportament de la interacció amb la base de dades. A continuació es detallen les més importants:\n&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Example extends Model\n{\n// Especifica el nom de la taula si no segueix la convenció per defecte\nprotected $table = 'custom_table_name';\n\n// Defineix la clau primària de la taula\nprotected $primaryKey = 'custom_id';\n\n// Indica si la clau primària és autoincremental\npublic $incrementing = false;\n\n// Especifica el tipus de la clau primària (per exemple, string si no és integer)\nprotected $keyType = 'string';\n\n// Defineix quins camps poden ser assignats massivament\nprotected $fillable = ['name', 'email', 'password'];\n\n// Defineix quins camps no poden ser assignats massivament\nprotected $guarded = ['is_admin'];\n\n// Oculta camps quan es converteix a JSON o arrays\nprotected $hidden = ['password', 'remember_token'];\n\n// Defineix quins camps són visibles quan es converteix a JSON o arrays\nprotected $visible = ['name', 'email'];\n\n// Transformació automàtica de camps a un tipus específic\nprotected $casts = [\n'is_admin' =&gt; 'boolean',\n'settings' =&gt; 'array',\n];\n\n// Indica si la taula té els camps `created_at` i `updated_at`\npublic $timestamps = true;\n\n// Defineix la connexió a la base de dades\nprotected $connection = 'mysql';\n}\n\nRelacions en Eloquent\n1. Un a un (One-to-One):\nUn usuari té un perfil:\nclass User extends Model\n{\npublic function profile()\n{\nreturn $this-&gt;hasOne(Profile::class);\n}\n}\n\n$user = User::find(1);\n$profile = $user-&gt;profile;\n\n2. Un a molts (One-to-Many):\nUn autor té molts llibres:\nclass Author extends Model\n{\npublic function books()\n{\nreturn $this-&gt;hasMany(Book::class);\n}\n}\n\n$author = Author::find(1);\n$books = $author-&gt;books;\n\n3. Molts a molts (Many-to-Many):\nUn usuari té molts rols:\nclass User extends Model\n{\npublic function roles()\n{\nreturn $this-&gt;belongsToMany(Role::class);\n}\n}\n\n$user = User::find(1);\n$roles = $user-&gt;roles;\n\n4. Has Many Through (Relacions transitives):\nPermet accedir a dades relacionades a través d'un altre model.\nclass Country extends Model\n{\npublic function posts()\n{\nreturn $this-&gt;hasManyThrough(Post::class, User::class);\n}\n}\n\nEager Loading (Càrrega eficient de relacions)\nPer evitar múltiples consultes a la base de dades, pots carregar relacions amb with:\n$authors = Author::with('books')-&gt;get();\n\nCol·leccions i Agrupacions\nEloquent retorna col·leccions per defecte, que permeten treballar amb mètodes\nMutators i Accessors\nEls mutators permeten transformar dades abans de guardar-les, i els accessors les transformen en recuperar-les.\nExemple:\nclass User extends Model\n{\n// Accessor\npublic function getFullNameAttribute()\n{\nreturn &quot;{$this-&gt;first_name} {$this-&gt;last_name}&quot;;\n}\n\n// Mutator\npublic function setPasswordAttribute($value)\n{\n$this-&gt;attributes['password'] = bcrypt($value);\n}\n}\n\nÚs:\n$user = User::find(1);\n$fullName = $user-&gt;full_name;\n\n$user-&gt;password = 'new_password';\n$user-&gt;save();\n\nPaginació\nLaravel facilita la paginació:\n$movies = Movie::paginate(10);\n\nEn la vista:\n{{ $movies-&gt;links() }}",
		"tags": [ "note"]
},

{
		"title": "6. Seeders i Factories en Laravel",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/6-seeders-i-factories-en-laravel/",
		"content": "Els seeders i factories permeten generar dades de prova de manera fàcil i ràpida, útils durant el desenvolupament per simular dades inicials en una aplicació.\n\nSeeders\nEls seeders són classes especials que permeten &quot;sembrar&quot; dades a la base de dades.\nCrear un Seeder\nphp artisan make:seeder NomSeeder\n\nAixò crea un fitxer a la carpeta database/seeders. Per exemple:\nclass BooksSeeder extends Seeder\n{\npublic function run()\n{\n// Exemple: Crear un llibre\n$book = new Book();\n$book-&gt;title = &quot;Laravel for Beginners&quot;;\n$book-&gt;author = &quot;John Doe&quot;;\n$book-&gt;save();\n}\n}\n\nAfegir Seeders al Seeder General\nInclou els seeders al fitxer DatabaseSeeder:\nclass DatabaseSeeder extends Seeder\n{\npublic function run()\n{\n$this-&gt;call([\nBooksSeeder::class,\nAuthorsSeeder::class,\n]);\n}\n}\n\nExecutar Seeders\nExecutar tots els seeders:\nExecutar un seeder específic:\nReiniciar les migracions i executar els seeders:\nphp artisan db:seed\nphp artisan db:seed --class=BooksSeeder\nphp artisan migrate:fresh --seed\n\nFactories\nEls factories permeten crear grans quantitats de dades de manera ràpida i dinàmica mitjançant Faker.\nCrear un Factory\nphp artisan make:factory NomFactory -m Model\n\nPer exemple, per al model Author:\nnamespace Database\\Factories;\n\nuse App\\Models\\Author;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\n\nclass AuthorFactory extends Factory\n{\nprotected $model = Author::class;\n\npublic function definition()\n{\nreturn [\n'name' =&gt; $this-&gt;faker-&gt;name,\n'birth_year' =&gt; $this-&gt;faker-&gt;year,\n];\n}\n}\n\nUtilitzar un Factory\nPer generar dades amb un factory:\nuse App\\Models\\Author;\n\n// Crear un únic autor\nAuthor::factory()-&gt;create();\n\n// Crear diversos autors\nAuthor::factory()-&gt;count(10)-&gt;create();\n\nIntegració amb Seeders\nCombina factories amb seeders per generar dades dinàmiques:\nclass AuthorsSeeder extends Seeder\n{\npublic function run()\n{\nAuthor::factory()-&gt;count(10)-&gt;create();\n}\n}\n\nDades Relacionades\nEls factories permeten generar dades relacionades. Per exemple, llibres amb els seus autors:\nclass BooksSeeder extends Seeder\n{\npublic function run()\n{\n$authors = Author::factory()-&gt;count(5)-&gt;create();\n\n$authors-&gt;each(function ($author) {\nBook::factory()-&gt;count(2)-&gt;create(['author_id' =&gt; $author-&gt;id]);\n});\n}\n}\n\nExemples Avançats\nPodem cercar com construir factories més complexes a la documentació oficial.\nUtilitzar Factories per Relacions\nDefinir relacions dins d’un factory:\nclass BookFactory extends Factory\n{\npublic function definition()\n{\nreturn [\n'title' =&gt; $this-&gt;faker-&gt;sentence,\n'author_id' =&gt; Author::factory(),\n];\n}\n}\n\nLlançar el factory:\nBook::factory()-&gt;count(10)-&gt;create();\n\nFactories amb Estats\nEls estats permeten definir configuracions personalitzades per un model:\nclass BookFactory extends Factory\n{\npublic function withDiscount()\n{\nreturn $this-&gt;state([\n'price' =&gt; $this-&gt;faker-&gt;numberBetween(5, 10),\n]);\n}\n}\n\nÚs d'un estat:\nBook::factory()-&gt;withDiscount()-&gt;create();\n\nAvantatges dels Factories\n\nFaciliten la generació massiva de dades.\nSimplifiquen les proves i el desenvolupament amb dades fictícies realistes.\nRedueixen el temps d'inicialització de les aplicacions.",
		"tags": [ "note"]
},

{
		"title": "7. Requests, Responses i Validació en Laravel",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/7-requests-responses-i-validacio-en-laravel/",
		"content": "1. Requests\nIntroducció\nUn Request en Laravel és un objecte que encapsula la informació sobre la petició HTTP, incloent dades, capçaleres, paràmetres i fitxers.\nAccés a dades del Request\n$input = $request-&gt;all(); //Accedir a tots els inputs.\n$name = $request-&gt;input('name'); //Obtenir un input específic.\n$age = $request-&gt;input('age', 18); //Especificar valors per defecte.\n$id = $request-&gt;route('id'); //Accedir a paràmetres de ruta.\n\nValidació de presència\nif ($request-&gt;has('email')) {\n// Input 'email' present\n}\nif ($request-&gt;filled('name')) {\n// Input 'name' no està buit\n}\n$filtered = $request-&gt;only(['name', 'email']); //Filtrar inputs específics.\n$excluded = $request-&gt;except(['password']); //Excloure certs inputs.\n\nTractament de fitxers\nif ($request-&gt;hasFile('photo')) { //Comprovar si hi ha un fitxer.\n$file = $request-&gt;file('photo');\n}\n$path = $request-&gt;file('photo')-&gt;store('photos'); //Emmagatzemar un fitxer.\n\n2. Responses\nCreació de respostes\nreturn response('Hello World', 200); //Crear una resposta bàsica.\nreturn response()-&gt;json([\n'name' =&gt; 'John',\n'status' =&gt; 'success'\n]); //Crear una resposta JSON.\nreturn redirect('dashboard'); //Redirecció .\nreturn redirect('login')-&gt;with('status', 'Sessió iniciada'); //Redirecció amb dades de sessió.\n\nManipular capçaleres\n//Afegeix una o múltiples capçaleres.\nreturn response('Hello')-&gt;header('Content-Type', 'text/plain');\nreturn response('Hello')\n-&gt;header('Content-Type', 'application/json')\n-&gt;header('Cache-Control', 'no-cache');\n\nRespostes de fitxers\n\nreturn response()-&gt;download($pathToFile); //Descàrrega de fitxers.\nreturn response()-&gt;file($pathToFile); //Mostrar fitxers.\n\n3. Validació\nIntroducció\nLaravel ofereix un sistema potent i senzill per validar dades d'inputs.\nValidació bàsica\n// Validar dades amb un Request.\n$request-&gt;validate([\n'name' =&gt; 'required|string|max:255',\n'email' =&gt; 'required|email',\n'password' =&gt; 'required|min:8',\n]);\n\n// Validar manualment.\n$validator = Validator::make($request-&gt;all(), [\n'title' =&gt; 'required|max:255',\n'body' =&gt; 'required',\n]);\n\nif ($validator-&gt;fails()) {\nreturn redirect('/form')-&gt;withErrors($validator);\n}\n\nRegles comunes\n\nrequired: Camp obligatori.\nemail: Validació d'un correu electrònic.\nmin:value: Mínim de caràcters o valor numèric.\nmax:value: Màxim de caràcters o valor numèric.\nunique:table,column: Ha de ser únic en una taula/columna.\nLlista sencera de regles\n\nMissatges personalitzats\n// Es poden definir missatges personalitzats per a les regles de validació.\n\n$request-&gt;validate([\n'name' =&gt; 'required',\n], [\n'name.required' =&gt; 'El nom és obligatori.',\n]);\n\nValidació condicional\n// Validació basada en altres camps o condicions.\n$request-&gt;validate([\n'password' =&gt; 'required_if:is_admin,true',\n]);\n\nValidació personalitzada\n// Es poden afegir regles personalitzades mitjançant extensions del Validator.\n\nValidator::extend('uppercase', function ($attribute, $value, $parameters, $validator) {\nreturn strtoupper($value) === $value;\n});\n\nErrors de validació\n// Obtenir tots els errors en la vista\n@if ($errors-&gt;any())\n&lt;ul&gt;\n@foreach ($errors-&gt;all() as $error)\n&lt;li&gt;{{ $error }}&lt;/li&gt;\n@endforeach\n&lt;/ul&gt;\n@endif\n\n// Mostrar errors per camp específic\n@error('name')\n&lt;div&gt;{{ $message }}&lt;/div&gt;\n@enderror",
		"tags": [ "note"]
},

{
		"title": "8. Exercici Pràctic, Guia d'Equips de Futbol Femení amb Base de Dades",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/8-gestio-de-dades-amb-laravel/8-exercici-practic-guia-d-equips-de-futbol-femeni-amb-base-de-dades/",
		"content": "L'objectiu d'aquest exercici és estendre la Guia d'Equips de Futbol Femení per utilitzar una base de dades relacional. Aprendràs a crear taules amb migracions, models per gestionar les dades, i a integrar-los amb controladors i vistes.\n\n1. Crear la Migració per a la Taula equips\nMigració\n\nGenera una migració per a la taula equips amb la següent estructura:\n\nid: Clau primària, autoincremental.\nnom: Nom de l'equip (cadena, únic, obligatori).\nestadi: Nom de l'estadi de l'equip (cadena, obligatori).\ntitols: Nombre de títols guanyats (entero, predeterminat 0).\ncreated_at i updated_at: Camps de timestamps generats automàticament.\n\nphp artisan make:migration create_equips_table --create=equips\n\nModifica el fitxer de migració per incloure l'estructura de la taula:\n\npublic function up()\n{\nSchema::create('equips', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('nom')-&gt;unique();\n$table-&gt;string('estadi');\n$table-&gt;integer('titols')-&gt;default(0);\n$table-&gt;timestamps();\n});\n}\n\nExecuta la migració per crear la taula:\n\nphp artisan migrate\n\nModels i Seeders\n\nGenera un model anomenat Equip per gestionar la taula:\n\nphp artisan make:model Equip\n\nModifica el model Equip a app/Models/Equip.php per definir els camps que es poden emplenar mitjançant assignació massiva:\n\nprotected $fillable = ['nom', 'estadi', 'titols'];\n\nCrea un seeder per a la taula equips:\n\nphp artisan make:seeder EquipsSeeder\n\nModifica el seeder EquipsSeeder per generar dades d'exemple:\n\npublic function run()\n{\nDB::table('equips')-&gt;insert([\n['nom' =&gt; 'Barça Femení', 'estadi' =&gt; 'Camp Nou', 'titols' =&gt; 30],\n['nom' =&gt; 'Atlètic de Madrid', 'estadi' =&gt; 'Cívitas Metropolitano', 'titols' =&gt; 10],\n['nom' =&gt; 'Real Madrid Femení', 'estadi' =&gt; 'Alfredo Di Stéfano', 'titols' =&gt; 5],\n]);\n}\n\nAfegeix el seeder EquipsSeeder al fitxer DatabaseSeeder:\n\npublic function run()\n{\n$this-&gt;call([\nEquipsSeeder::class,\n]);\n}\n\nExecuta els seeders per omplir la taula equips amb dades d'exemple:\n\nphp artisan db:seed\n\nControladors i CRUD\n\nModifica el mètode index,show,create,edit i destroy del controlador per obtenir els equips des de la base de dades:\npublic function index() {\n$equips = Equip::all();\nreturn view('equips.index', compact('equips'));\n}\n\npublic function show(Equip $equip) {\nreturn view('equips.show', compact('equip'));\n}\n\npublic function create() {\nreturn view('equips.create');\n}\n\npublic function edit(Equip $equip) {\nreturn view('equips.edit', compact('equip'));\n}\n\npublic function destroy(Equip $equip) {\n$equip-&gt;delete();\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip esborrat correctament!');\n}\n\nRelacions entre Taules\n\nAnem a crear la migració, model i seeder per la taula estadis i vincular-la amb la taula equips.\n\nphp artisan make:migration create_estadis_table\nphp artisan make:migration add_estadi_id_to_equips_table\nphp artisan make:model Estadi\nphp artisan make:seeder EstadisSeeder\n\nModifica la migració create_estadis_table per incloure l'estructura de la taula estadis:\n\npublic function up()\n{\nSchema::create('estadis', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('nom')-&gt;unique();\n$table-&gt;integer('capacitat');\n$table-&gt;timestamps();\n});\n}\n\nModifica la migració add_estadi_id_to_equips_table per afegir la clau forana estadi_id a la taula equips:\n\npublic function up()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;dropColumn('estadi'); // Esborra el camp estadi\n$table-&gt;foreignId('estadi_id')-&gt;constrained(); // Afegir la clau forana\n});\n}\n\npublic function down()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;string('estadi');\n$table-&gt;dropForeign(['estadi_id']);\n$table-&gt;dropColumn('estadi_id');\n});\n}\n\nModifica el model Equip per definir la relació amb l'estadi:\n\npublic function estadi()\n{\nreturn $this-&gt;belongsTo(Estadi::class);\n}\n\nModifica el model Estadi per definir la relació amb els equips:\n\npublic function equips()\n{\nreturn $this-&gt;hasMany(Equip::class);\n}\n\nModifica el seeder EstadisSeeder per generar dades d'exemple per a la taula estadis:\n\npublic function run()\n{\nDB::table('estadis')-&gt;insert([\n['nom' =&gt; 'Camp Nou', 'capacitat' =&gt; 99000],\n['nom' =&gt; 'Wanda Metropolitano', 'capacitat' =&gt; 68000],\n['nom' =&gt; 'Santiago Bernabéu', 'capacitat' =&gt; 81000],\n]);\n}\n\nAfegeix el seeder EstadisSeeder al fitxer DatabaseSeeder:\n\npublic function run()\n{\n$this-&gt;call([\nEstadisSeeder::class,\nEquipsSeeder::class,\n\n]);\n}\n\nModifica el seeder EquipsSeeder per assignar equips a estadis existents:\n\npublic function run()\n{\n$estadi = Estadi::where('nom', 'Camp Nou')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Barça Femení',\n'titols' =&gt; 30,\n]);\n$estadi = Estadi::where('nom', 'Wanda Metropolitano')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Atlètic de Madrid',\n'titols' =&gt; 10,\n]);\n$estadi = Estadi::where('nom', 'Santiago Bernabéu')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Real Madrid Femení',\n'titols' =&gt; 5,\n]);\n}\n\nExecuta els seeders per omplir les taules equips i estadis amb dades d'exemple:\n\nphp artisan migrate:fresh --seed\n\nModifica la vista equips.index per mostrar l'estadi de cada equip:\n\n@foreach ($equips as $equip)\n&lt;tr class=&quot;hover:bg-gray-100&quot;&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;\n&lt;a href=&quot;{{ route('equips.show', $equip-&gt;id) }}&quot; class=&quot;text-blue-700 hover:underline&quot;&gt;{{ $equip-&gt;nom }}&lt;/a&gt;\n&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;{{ $equip-&gt;estadi-&gt;nom }}&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;{{ $equip-&gt;titols }}&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2 flex space-x-2&quot;&gt;\n&lt;a href=&quot;{{ route('equips.show', $equip-&gt;id) }}&quot; class=&quot;text-green-600 hover:underline&quot;&gt;Mostrar&lt;/a&gt;\n&lt;a href=&quot;{{ route('equips.edit', $equip-&gt;id) }}&quot; class=&quot;text-yellow-600 hover:underline&quot;&gt;Editar&lt;/a&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n@endforeach\n\nCrea la vista equips.create per incloure un desplegable amb els estadis disponibles:\n\n&lt;form action=&quot;{{ route('equips.store') }}&quot; method=&quot;POST&quot; class=&quot;bg-white p-6 rounded-lg shadow-md max-w-md mx-auto&quot;&gt;\n@csrf\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;nom&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Nom:&lt;/label&gt;\n&lt;input type=&quot;text&quot; name=&quot;nom&quot; id=&quot;nom&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;titols&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Títols:&lt;/label&gt;\n&lt;input type=&quot;number&quot; name=&quot;titols&quot; id=&quot;titols&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;estadi_id&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Estadi:&lt;/label&gt;\n&lt;select name=&quot;estadi_id&quot; id=&quot;estadi_id&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n@foreach ($estadis as $estadi)\n&lt;option value=&quot;{{ $estadi-&gt;id }}&quot;&gt;{{ $estadi-&gt;nom }}&lt;/option&gt;\n@endforeach\n&lt;/select&gt;\n&lt;/div&gt;\n\n&lt;button type=&quot;submit&quot;\nclass=&quot;w-full bg-blue-500 text-white font-medium py-2 px-4 rounded-lg shadow hover:bg-blue-600 focus:ring focus:ring-blue-300&quot;&gt;\nCrear Equip\n&lt;/button&gt;\n&lt;/form&gt;\n\nCal modificar el controlador EquipController per obtenir els estadis disponibles.\n\nCrea el mètode store en el controlador EquipController per emmagatzemar un nou equip:\n\npublic function store(Request $request) {\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'titols' =&gt; 'integer|min:0',\n]);\nEquip::create($validated);\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip creat correctament!');\n}\n\nCal modificat el model Equip per permetre l'assignació massiva de l'estadi.\n\nModifica la vista equips.edit per incloure un desplegable amb els estadis disponibles:\n\n&lt;form action=&quot;{{ route('equips.update', $equip-&gt;id) }}&quot; method=&quot;POST&quot; class=&quot;bg-white p-6 rounded-lg shadow-md max-w-md mx-auto&quot;&gt;\n@csrf\n@method('PUT')\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;nom&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Nom:&lt;/label&gt;\n&lt;input type=&quot;text&quot; name=&quot;nom&quot; id=&quot;nom&quot; value=&quot;{{ old('nom', $equip-&gt;nom) }}&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('nom') border-red-500 @enderror&quot;&gt;\n@error('nom')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;titols&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Títols:&lt;/label&gt;\n&lt;input type=&quot;number&quot; name=&quot;titols&quot; id=&quot;titols&quot; value=&quot;{{ old('titols', $equip-&gt;titols) }}&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('titols') border-red-500 @enderror&quot;&gt;\n@error('titols')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;estadi_id&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Estadi:&lt;/label&gt;\n&lt;select name=&quot;estadi_id&quot; id=&quot;estadi_id&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('estadi_id') border-red-500 @enderror&quot;&gt;\n@foreach ($estadis as $estadi)\n&lt;option value=&quot;{{ $estadi-&gt;id }}&quot; {{ $estadi-&gt;id == $equip-&gt;estadi_id ? 'selected' : '' }}&gt;\n{{ $estadi-&gt;nom }}\n&lt;/option&gt;\n@endforeach\n&lt;/select&gt;\n@error('estadi_id')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;button type=&quot;submit&quot;\nclass=&quot;w-full bg-blue-500 text-white font-medium py-2 px-4 rounded-lg shadow hover:bg-blue-600 focus:ring focus:ring-blue-300&quot;&gt;\nActualitzar Equip\n&lt;/button&gt;\n&lt;/form&gt;\n\nCrea el mètode update en el controlador EquipController per actualitzar un equip existent:\n\npublic function update(Request $request, $id) {\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips,nom,'.$id,\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'titols' =&gt; 'integer|min:0',\n]);\n$equip = Equip::findOrFail($id);\n$equip-&gt;update($validated);\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip actualitzat correctament!');\n}\n\nAfegir un escut a l'equip\n\nCrea una migració per afegir un camp escut a la taula equips:\n\nphp artisan make:migration add_escut_to_equips_table\n\nModifica la migració add_escut_to_equips_table per incloure el camp escut:\n\npublic function up()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;string('escut')-&gt;nullable();\n});\n}\npublic function down()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;dropColumn('escut');\n});\n}\n\nAplicar la migració\n\nphp artisan migrate\n\nModifica el model Equip per incloure el camp escut:\n\nprotected $fillable = ['nom', 'estadi_id', 'titols', 'escut'];\n\nModifica la vista equips.create per incloure un camp d'arxiu per pujar l'escut de l'equip:\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;escut&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Escut:&lt;/label&gt;\n&lt;input type=&quot;file&quot; name=&quot;escut&quot; id=&quot;escut&quot;\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\nModifica la vista equips.edit per incloure un camp d'arxiu per actualitzar l'escut de l'equip:\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;escut&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Escut:&lt;/label&gt;\n&lt;input type=&quot;file&quot; name=&quot;escut&quot; id=&quot;escut&quot;\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n@if ($equip-&gt;escut)\n&lt;p class=&quot;mt-2 text-sm text-gray-500&quot;&gt;Escut actual:&lt;/p&gt;\n&lt;img src=&quot;{{ asset('storage/' . $equip-&gt;escut) }}&quot; alt=&quot;Escut de {{ $equip-&gt;nom }}&quot; class=&quot;h-16 mt-2&quot;&gt;\n@endif\n&lt;/div&gt;\n\nAfegeix enctype=&quot;multipart/form-data&quot; al dos formularis:\n\n&lt;form action=&quot;{{ route('equips.store') }}&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;\n\nCrea un enllaç simbòlic a la carpeta storage\n\nphp artisan storage:link\n\nActualitza el mètode store del controlador\n\npublic function store(Request $request)\n{\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips',\n'titols' =&gt; 'integer|min:0',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'escut' =&gt; 'nullable|image|mimes:jpeg,png,jpg|max:2048', // Validació del fitxer\n]);\n\nif ($request-&gt;hasFile('escut')) {\n$path = $request-&gt;file('escut')-&gt;store('escuts', 'public');\n$validated['escut'] = $path;\n}\n\nEquip::create($validated);\n\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip creat correctament!');\n}\n\nActualitza el mètode update del controlador\n\npublic function update(Request $request, $id)\n{\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips,nom,' . $id,\n'titols' =&gt; 'integer|min:0',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'escut' =&gt; 'nullable|image|mimes:jpeg,png,jpg|max:2048',\n]);\n\n$equip = Equip::findOrFail($id);\n\nif ($request-&gt;hasFile('escut')) {\nif ($equip-&gt;escut) {\nStorage::disk('public')-&gt;delete($equip-&gt;escut); // Esborra l'escut antic\n}\n$path = $request-&gt;file('escut')-&gt;store('escuts', 'public');\n$validated['escut'] = $path;\n}\n\n$equip-&gt;update($validated);\n\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip actualitzat correctament!');\n}\n\nCrea el mètode delete per esborrar l'escut de l'equip:\n\npublic function delete(Equip $equip)\n{\nif ($equip-&gt;escut) {\nStorage::disk('public')-&gt;delete($equip-&gt;escut);\n}\n$equip-&gt;delete();\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip esborrat correctament!');\n}\n\nModificat el component de la vista equips.show per mostrar l'escut de l'equip:\n\n&lt;div class=&quot;equip border rounded-lg shadow-md p-4 bg-white&quot;&gt;\n@if ($escut)\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;\n&lt;img src=&quot;{{ asset('storage/' . $escut) }}&quot; alt=&quot;Escut de {{ $nom }}&quot; class=&quot;h-8 w-8 object-cover rounded-full&quot;&gt;\n&lt;/td&gt;\n@endif\n&lt;h2 class=&quot;text-xl font-bold text-blue-800&quot;&gt;{{ $nom }}&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Estadi:&lt;/strong&gt; {{ $estadi }}&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Títols:&lt;/strong&gt; {{ $titols }}&lt;/p&gt;\n&lt;/div&gt;\n\nUtilitzar Factories per a Dades d'Exemple\n\nCrea un factory per a la taula equips:\n\nphp artisan make:factory EquipFactory --model=Equip\n\nModifica el factory EquipFactory per generar dades aleatòries:\n\npublic function definition()\n{\nreturn [\n'nom' =&gt; $this-&gt;faker-&gt;unique()-&gt;company,\n'titols' =&gt; $this-&gt;faker-&gt;numberBetween(0, 50),\n'estadi_id' =&gt; \\App\\Models\\Estadi::factory(),\n'escut' =&gt; 'escuts/dummy.png', // Imatge de prova predefinida\n];\n}\n}\n\nActualitza el seeder EquipsSeeder per utilitzar el factory:\n\npublic function run()\n{\n...\nEquip::factory()-&gt;count(10)-&gt;create();\n}\n\nModifica el model Equip per permetre els factories:\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Estadi extends Model\n{\nuse HasFactory;\n...\n}\n\nCrea el factory per a la taula estadis:\n\nphp artisan make:factory EstadiFactory --model=Estadi\n\nModifica el factory EstadiFactory per generar dades aleatòries:\n\npublic function definition()\n{\nreturn [\n'nom' =&gt; $this-&gt;faker-&gt;unique()-&gt;city.' Stadium',\n'capacitat' =&gt; $this-&gt;faker-&gt;numberBetween(10000, 100000),\n];\n}\n\nExecuta els seeders per omplir la taula equips amb dades generades pel factory:\n\nphp artisan migrate:fresh --seed",
		"tags": [ "note"]
},

{
		"title": "PHP Teoria Batoi",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/php-teoria-batoi/index/",
		"content": "Desenvolupament Web en Entorn Servidor\nAcí pots trobar les anotacions del mòdul de Desenvolupament web en entorn servidor, que s'imparteix en el segon curs del cicle formatiu de grau superior de Desenvolupament d'Aplicacions Web.\nLa duració del mòdul és de 160 hores lectives, a raó de 8 hores setmanals, i es desenvolupa al llarg dels dos primers trimestres del curs. S'ha planificat basant-se en 3 sessions de 3,3 i 2 hores lectives per setmana.\nQuè aprendré?\n\nA desenvolupar aplicacions web dinàmiques, que obtenen la informació a partir d'una base de dades.\nAnalitzar l'estructura d'una aplicació client/servidor, separant el codi de presentació de la lògica de negoci\nObtindre informació a partir de les dades emmagatzemades, així com modificar-los.\n\nResultats d'aprenentatge\n\nSelecciona les arquitectures i tecnologies de programació Web en entorn servidor, analitzant les seues capacitats i característiques pròpies.\nEscriu sentències executables per un servidor Web reconeixent i aplicant procediments d'integració del codi en llenguatges de marques.\nEscriu blocs de sentències embeguts en llenguatges de marques, seleccionant i utilitzant les estructures de programació.\nDesenvolupa aplicacions Web embegudes en llenguatges de marques analitzant i incorporant funcionalitats segons especificacions.\nDesenvolupa aplicacions Web identificant i aplicant mecanismes per a separar el codi de presentació de la lògica de negoci.\nDesenvolupa aplicacions d'accés a magatzems de dades, aplicant mesures per a mantindre la seguretat i la integritat de la informació.\nDesenvolupa serveis web reutilitzables i accessibles mitjançant protocols web, verificant el seu funcionament\nGenera pàgines web dinàmiques analitzant i utilitzant tecnologies i frameworks del servidor web que afigen codi al llenguatge de marques.\nDesenvolupa aplicacions Web híbrides seleccionant i utilitzant llibreries de codi i repositoris heterogenis d'informació.\n\nUnitats didàctiques / Temporalització\nA continuació es mostren les unitats didàctiques i una estimació temporal de cadascuna d'elles.\nLa primera avaluació contindria les unitats compreses entre la 1 i 6. Així doncs, des de la meitat de la unitat 6 a la unitat 9 es veuran en la segona avaluació.\nPrimera avaluació\nDuració estimada: 75 hores\n\nArquitectures Web (3h)\n\nClient/Servidor.\nMVC.\n\nEl llenguatge PHP (16h)\n\nCondicions i bucles.\nArrays.\n\nProgramació Web (13h)\n\nFormularis.\nCookies i sessió.\n\nOrientació a objectes amb PHP (11h)\n\nClasses i objectes\nNamespaces\nExcepcions\n\nAccés a dades (16h)\n\nSQL\nPDO\nFitxers CSV i PDF.\n\nProjecte Integrador\n\nSegona avaluació\nDuració estimada: 85 hores\n\nFrameworks PHP. Laravel. (29h)\n\nRutes i vistes\nControladors\nModels i dades\nValidacio i Autenticacio\nNotificacions\nActivitats\n\nServeis Web (16h)\n\nProducció i consum.\nAJAX amb JSON.\n\nWebs Híbrides (16h)\n\nReutilització de codi i dades.\nOAuth2\n\nProjecte Integrador (24h)\n\nInstruments de qualificació\nLa nota del curs es calcula mitjançant:\n\n30% Activitats classe\n\nCada Unitat Temàtica (excepte la primera) tindrà una sèrie d'activitats avaluables que poden ser realitzades en classe i a casa.\n\nLes activitats s'avaluen mitjançant tasques de Aules avaluables per rúbriques.\nLa puntuació de cada unitat temàtica serà la del número de hores previstes per eixa unitat, descomptat les proves escrites.\n\n10% Qüestionaris per unitat temàtica (excepte la primera).\n\n20% Projecte Integrador (Final de curs)\n\n40% Exàmen d'avaluació (Fan mitja a partir de 4)\n\nUn per cada avaluació.\n\nlist from 1. Arquitecturas Web",
		"tags": [ "note","PHP"]
},

{
		"title": "01-basics",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/01-basics/",
		"content": "Conceptos básicos\n\nConceptos básicos\n\nIntroducción\nUsar Vue\nEstructura de una aplicación Vue\n\nHTML\nJavascript\n\nEstilos de API\nBinding de variables\n\nEnlace unidireccional: interpolación {{...}}\nEnlazar a un atributo: v-bind\nEnlace bidireccional: v-model\n\nVue devtools\nExtensiones para el editor de código\nOtras utilidades\nCursos de Vue\n\nIntroducción\nEl uso de un framework nos facilita enormemente el trabajo a la hora de crear una aplicación. Vue es un framework progresivo para la construcción de interfaces de usuario y aplicaciones desde el lado del cliente. Lo de framework &quot;progresivo&quot; significa que su núcleo es pequeño pero está diseñado para crecer: su núcleo está enfocado sólo en la capa de visualización pero es fácil añadirle otras bibliotecas o proyectos existentes (algunos desarrollados por el mismo equipo de Vue) que nos permitan crear complejas SPA.\nSu código es opensource y fue creado por el desarrollador independiente Evan You, lo que lo diferencia de los otros 2 frameworks más utilizados: Angular desarrollado por Google y React desarrollado por Facebook.\nVue tiene una curva de aprendizaje menor que otros frameworks y es extremadamente rápido y ligero.\nEste material está basado en la guía oficial de Vue y veremos además los servicios de vue-router, axios y pinia (sustituto de vuex en Vue3) entre otros.\n¿Qué framework es mejor?\nDepende de la aplicación a desarrollar y de los gustos del programador. Tenéis algunos enlaces al respecto:\n\nComparativa VueJs\nOpenwebminars: Vue vs React vs Angular\nCarlos Azaustre: Vue vs Angular (vídeo)\nAngular vs React vs Vue: Which Framework to Choose in 2021\n...\n\nLas razones de que veamos Vue en vez de Angular o React son, en resumen:\n\nSencillez: aunque Angular es el framework más demandado hoy en el mercado su curva de aprendizaje es muy pronunciada. Vue es mucho más sencillo de aprender pero su forma de trabajar es muy similar a Angular por lo que el paso desde Vue a Angular es relativamente sencillo\nUso del framework: React es también muy sencillo ya que es simplemente Javascript en el que podemos codificar la vista con JSX, pero la forma de trabajar de Vue es más parecida a otros frameworks, especialmente a Angular por lo que lo aprendido nos será de gran ayuda si queremos pasar a ese framework\nRendimiento: Vue hace uso del concepto de Virtual DOM igual que React por lo que también ofrece muy buen rendimiento\n\nUsar Vue\nPara utilizar Vue sólo necesitamos enlazarlo en nuestra página desde cualquier CDN como:\n&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n\nEsta no es la forma más recomendable de trabajar. Lo normal es crear un proyecto con npm que genere un completo scaffolding. Esto nos permitirá trabajar con componentes (Single File Components o SFC) lo que nos facilitará enormemente la creación de nuestras aplicaciones.\nUn SFC es un componente reutilizable que se guarda en un fichero con extensión .vue. Para que VSCode reconozca correctamente los ficheros .vue debemos instalar la extensión Volar.\nEstructura de una aplicación Vue\nVamos a crear la aplicación con Vue que mostrará un contador y un botón para actualizarlo:\nVue.createApp({\ndata() {\nreturn {\ncount: 0\n}\n},\nmethods: {\nincrement() {\nthis.count++\n}\n}\n}).mount('#app')\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot; /&gt;\n&lt;title&gt;Vue&lt;/title&gt;\n&lt;!-- Import Vue.js --&gt;\n&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=&quot;app&quot;&gt;\n&lt;button @click=&quot;increment&quot;&gt;\nCount is: { { count }}\n&lt;/button&gt;\n&lt;/div&gt;\n\n&lt;!-- Import Js --&gt;\n&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nPodéis ver su funcionamiento en la documentación oficial de Vue o en CodePen.\nEn este ejemplo podemos ver las 2 principales características de Vue:\n\nRenderizado declarativo: Vue amplía HTML con una sintaxis que nos permite declarar en HTML una salida basada en un dato Javascript\nReactividad: Vue hace un seguimiento de las variables Javascript y modifica el DOM cuando alguna cambia\n\nPara probar el funcionamiento de código tenemos el Playground de Vue al que accedemos desde su documentación en https://vuejs.org/guide/quick-start.html#try-vue-online.\nVamos a ver qué estamos haciendo en cada fichero:\nHTML\nEn el HTML debemos vincular los scripts de la librería de Vue y de nuestro código.\nVue se ejecutará dentro de un elemento de nuestra página (al que se le suele poner como id app) que en este caso es un &lt;div&gt;.\nDentro de ese elemento es donde podemos usar expresiones de Vue (fuera del mismo se ignorarán). En este ejemplo se usa\n\nel moustache {{ ... }} que muestra en la página la variable o expresión Javascript que contiene\nla directiva @click que pone al elemento un escuchador del evento click que ejecuta la función indicada en el mismo\n\nJavascript\nEn el fichero JS debemos crear la aplicación con el método createApp (al que se le pasa un objeto con una serie de opciones) y montarla en el elemento del HTML donde se ejecutará dicha aplicación. En nuestro caso la única opción que se le pasa es data pero hay muchas más:\n\ndata: aquí es donde se define el estado de la aplicación, es decir, los datos de la misma. Es una función que devuelve un objeto donde cada dato será una propiedad del mismo. Lo que definimos aquí sería el equivalente a las propiedades definidas en una clase que almacenan el estado de la misma. Estos datos son reactivos y accesibles desde el HTML\n\nVue.createApp({\ndata() {\nreturn {\ncount: 0,\nmsg: 'Hola',\n...\n}\n},\n\nmethods: es un objeto donde cada propiedad es un método de la aplicación que puede ser llamado desde el HTML. Son el equivalente a los métodos de una clase\n\nFijaos que para hacer referencia desde Javascript a una variable (o a un método) hay que anteponerle this.\nAdemás de las opciones data y methods podemos definir otras como:\n\ncomputed: es un objeto con funciones que devuelven una variable cuyo valor hay que calcularlo. Por ejemplo:\n\ndata() {\nreturn {\nnombre: 'Juan',\napellido: 'Segura',\n}\n},\ncomputed: {\nnombreCompleto() {\nreturn this.nombre + ' ' + this.apellido;\n}\n}\n\nhooks (eventos del ciclo de vida de la instancia): para ejecutar código en determinados momentos: 'created', 'mounted', 'updated', 'destroyed'. Ej.:\n\ncreated() {\nconsole.log('instancia creada');\n}\n\nEstilos de API\nLa forma en que hemos programado estos ejemplos no es la más recomendable por lo que más adelante usaremos npm para crear un completo scaffolding que nos facilitará enormemente la creación de nuestras aplicaciones. Con ella dividiremos nuestra aplicación en componentes llamados Single File Components que incluirán en un único fichero tanto la lógica del componente (Javascript) como su presentación (HTML) y su apariencia (CSS).\nVue3 proporciona 2 formas diferentes de programar:\n\nOptions API: la lógica de un componente se establece en las distintas propiedades de un objeto, a las que se accede mediante this que apunta a la instancia del componente. Es la que veremos ahora ya que es la más similar a la OOP que conocemos.\n\n&lt;script&gt;\nexport default {\n// Properties returned from data() become reactive state\n// and will be exposed on `this`.\ndata() {\nreturn {\nmsg: &quot;Hola&quot;,\ncount: 0\n}\n},\n\n// Methods are functions that mutate state and trigger updates.\n// They can be bound as event listeners in templates.\nmethods: {\nincrement() {\nthis.count++\n},\ndecrement() {\nthis.count--\n}\n},\n\n// Lifecycle hooks are called at different stages\n// of a component's lifecycle.\n// This function will be called when the component is mounted.\nmounted() {\nconsole.log(`The initial count is ${this.count}.`)\n}\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;h1&gt;{{ msg }}&lt;/h1&gt;\n&lt;button @click=&quot;increment&quot;&gt;Count is: {{ count }}&lt;/button&gt;\n&lt;/template&gt;\n\nComposition API_: es algo más compleja pero mejora la reutilización de código y su organización por funcionalidades. Indicada para aplicaciones grandes la veremos al final del bloque\n\n&lt;script setup&gt;\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref('Hola')\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\ncount.value++\n}\nfunction decrement() {\ncount.value--\n}\n\n// lifecycle hooks\nonMounted(() =&gt; {\nconsole.log(`The initial count is ${count.value}.`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;h1&gt;{{ msg }}&lt;/h1&gt;\n&lt;button @click=&quot;increment&quot;&gt;Count is: {{ count }}&lt;/button&gt;\n&lt;/template&gt;\n\nBinding de variables\nEn la Guía de la documentación oficial de Vue tenemos un tutorial guiado donde podemos probar cada una de las funcionalidades de Vue. En la parte superior izquierda nos pregunta por nuestras preferencias: de momento escogeremos Options y HTML, aunque enseguida cambiaremos a Options y SFC.\n| Haz el ejercicio del tutorial de Vue.js\nEnlace unidireccional: interpolación {{...}}\nDonde queramos mostrar en la vista el valor de una variable simplemente la ponemos entre dobles llaves:\n&lt;p&gt;Contador: { { counter }}&lt;/p&gt;\n\nY en el código Javascript sólo tenemos que declarar esa variable dentro del objeto devuelto por data():\ndata() {\nreturn {\ncounter: 0\n}\n}\n\nPodemos ver esa variable y manipularla desde la consola, y si cambiamos su valor vemos que cambia lo que muestra nuestra página. Esto es porque Vue (al igual que Angular o React) enlazan el DOM y los datos de forma que cualquier cambio en uno se refleja automáticamente en el otro.\nEnlazar a un atributo: v-bind\nPara mostrar un dato en el DOM usamos la interpolación **{ { }}** pero si queremos nostrarlo como atributo de una etiqueta debemos usar v-bind:\n&lt;p v-bind:title=&quot;message&quot;&gt;\nHover your mouse over me for a few seconds\nto see my dynamically bound title!\n&lt;/p&gt;\n\nVue incorpora estos 'atributos' que podemos usar en las etiquetas HTML y que se llaman directivas. Todas las directivas comienzan por v- (en Angular es igual pero el prefijo es ng-). Como la directiva v-bind se utiliza mucho se puede abreviar símplemente como : (el carácter 'dos puntos'). El siguiente código es equivalente al de antes:\n&lt;p :title=&quot;message&quot;&gt;\n\n| Haz el ejercicio del tutorial de Vue.js\nEnlace bidireccional: v-model\nTanto { { }} como v-bind son un enlace unidireccional: muestran en el DOM el valor de un dato y reaccionan ante cualquier cambio en dicho valor.\nPero además está la directiva v-model que es un enlace bidireccional que enlaza un dato a un campo de formulario y permite cambiar el valor del campo al cambiar el dato pero también cambia el dato si se modifica lo introducido en el input.\n&lt;input v-model=&quot;message&quot;&gt;\n\nSee the Pen\nv-model by Juan Segura (@juanseguravasco)\non CodePen.\n\nVemos que al escribir en el input automáticamente cambia lo mostrado en el primer párrafo. Esta característica nos permite ahorrar innumerables líneas de código para hacer que el DOM refleje los cambios que se producen en los datos.\nNOTA: toda la aplicación se monta en el elemento app por lo que las directivas o interpolaciones que pongamos fuera del mismo no se interpretarán.\n| Haz el ejercicio del tutorial de Vue.js\nVue devtools\nEs una extensión para Chrome y Firefox que nos permite inspeccionar nuestro objeto Vue y acceder a todos los datos de nuestra aplicación.\nAnteriormente había que instalarla pero ahora viene integrada en la herramienta de desarrollador de los navegadores.\nEn ella tenemos distintos apartados, como:\n\nComponentes: es la vista por defecto y nos permite inspeccionar todos los componentes Vue creados (ahora tenemos sólo 1, el principal, pero más adelante haremos componentes hijos)\nPinia: es la herramienta de gestión de estado para aplicaciones medias/grandes\nRouter: permite ver las rutas de nuestra aplicación\nEventos: permite ver todos los eventos emitidos\n...\n\n![DevTools](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/DevTools.png)\nExtensiones para el editor de código\nCuando empecemos a trabajar con componentes usaremos ficheros con extensión .vue que integran el HTML, el JS y el CSS de cada componente. Para que nuestro editor los detecte correctamente es conveniente instalar la extensión para Vue.\nEn el caso de Visual Studio Code esta extensión se llama Vue-Oficial.\nOtras utilidades\nVue 3 permite utilizar directamente Typescript en nuestros componentes simplemente indicándolo al definir el SFC (lo veremos al llegar allí).\nRespecto a los tests se recomienda usar Vitest para los test unitarios y Cypress para los E2E, como se indica en la documentación oficial aunque también puede usarse Jest u otras herramientas.\nCursos de Vue\nPodemos encontrar muchos cursos en internet, algunos de ellos gratuitos. Por ejemplo los creadores de Vue tienen la web Vue Mastery donde podemos encontrar desde cursos de iniciación (gratuitos) hasta los mas avanzados.",
		"tags": [ "note"]
},

{
		"title": "02-directivas",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/02-directivas/",
		"content": "Directivas en Vue\n\nDirectivas en Vue\n\nDirectivas básicas\nCondicionales: v-if\nBucles: v-for\nEventos: v-on\n\nModificadores de eventos\n\nEjemplo de aplicación\n\nSolución de la aplicación\n\nDirectivas básicas\nLas directivas son atributos especiales que se ponen en las etiquetas HTML y que les dan cierta funcionalidad. Todas comienzan por v-.\nLas más comunes son:\n\nv-text: es equivalente a hacer una interpolación ({{ ... }}). Muestra el valor en la etiqueta. Los dos ejemplos siguientes son equivalentes:\n&lt;p v-text=&quot;mensaje&quot;&gt;&lt;/p&gt;\n&lt;p&gt;{ { mensaje }}&lt;/p&gt;\n\nv-once: igual pero una vez renderizado no cambia lo mostrado en la vista aunque cambie el valor de la variable\n\nv-html: permite que el texto que se muestra contenga caracteres HTML que interpretará el navegador (al usar la interpolación las etiquetas HTML son escapadas). Internamente hace un .innerHTML del elemento mientras que v-text (y { {...}}) hacen un .textContent\n\nv-bind: para asignar el valor de una variable a un atributo de una etiqueta HTML (no entre la etiqueta y su cierre como hace la interpolación). Por ejemplo si tenemos la variable estado cuyo valor es error y queremos que un span tenga como clase ese valor haremos:\n\n&lt;span v-bind:class=&quot;estado&quot;&gt;...\n\nEl resultado será: &lt;span class=&quot;error&quot;&gt;. La directiva v-bind: se puede abreviar simplemente como : (&lt;span :class=&quot;estado&quot;&gt;)\n\nv-model: permite enlazar un input a una variable (la hemos visto en el capítulo anterior). Tiene 3 modificadores útiles.\n\n.lazy: em lugar de actualizar el valor al pulsar cada tecla (onInput) lo hace al perder el foco (onChange)\n.number: convierte el contenido a Number\n.trim: elimina los espacios al principio y al final del texto\n\nv-if: renderiza o no el elemento que la contiene en función de una condición\nv-show: similar al v-if pero siempre renderiza el elemento (está en el DOM) y lo que hace es mostrarlo u ocultarlo (display: none) en función de la condición. Es mejor si el elemento va a mostrarse y ocultarse a menudo porque no tiene que volver a renderizarlo cada vez\nv-for: repite el elemento HTML que contiene esta etiqueta para cada elemento de un array\nv-on: le pone al elemento HTML un escuchador de eventos (ej &lt;button v-on:click=&quot;pulsado&quot;&gt;Pulsa&lt;/button&gt;. La directiva v-on: se puede abreviar como @, por ejemplo &lt;button @click=&quot;pulsado&quot;&gt;Pulsa&lt;/button&gt;.\n\nLo que enlazamos en una directiva o una interpolación puede ser una variable o una expresión Javascript. Ej.:\n&lt;p&gt;{ { name }}&lt;/p&gt;\n&lt;p&gt;{ { 'Cómo estás ' + name }}&lt;/p&gt;\n&lt;p&gt;{ { name=='root'?'Hola Administrador':'Hola ' + name }}&lt;/p&gt;\n\nCondicionales: v-if\nEsta directiva permite renderizar o no un elemento HTML en función de una variable o expresión.\n\nEl checkbox está enlazado a la variable marcado (a la que al inicio le hemos dado el valor true, por eso aparece marcado por defecto) y los párrafos se muestran o no en función del valor de dicha variable.\nLa directiva v-else es opcional (puede estar sólo el v-if) pero si la ponemos el elemento con el v-else debe ser el inmediatamente siguiente al del v-if (su nextElementSibling).\nNOTA: Los ejemplos de esta página son todos de Vue2. Recordad que en Vue3 es todo igual excepto la forma de crear la instancia Vue que sería:\nconst app = Vue.createApp({\ndata() {\nreturn {\nmarcado: true,\n}\n}\n}).mount('#app');\n\nTambién se pueden enlazar varios if else con v-else-if:\n&lt;div v-if=&quot;type === 'A'&quot;&gt;\nA\n&lt;/div&gt;\n&lt;div v-else-if=&quot;type === 'B'&quot;&gt;\nB\n&lt;/div&gt;\n&lt;div v-else-if=&quot;type === 'C'&quot;&gt;\nC\n&lt;/div&gt;\n&lt;div v-else&gt;\nNot A/B/C\n&lt;/div&gt;\n\n| Haz el ejercicio del tutorial de Vue.js\nBucles: v-for\nEsta directiva repite el elemento HTML en que se encuentra una vez por cada elemento del array al que se enlaza.\n\nSee the Pen\nv-for by Juan Segura (@juanseguravasco)\non CodePen.\n\nLa directiva v-for recorre el array todos y para cada elemento del array crea una etiqueta &lt;li&gt; y carga dicho elemento en la variable elem a la que podemos acceder dentro del &lt;li&gt;.\nAdemás del elemento nos puede devolver su índice en el array: v-for=&quot;(elem, index) in todos&quot; ....\nVue es más eficiente a la hora de renderizar si cada elemento que crea v-for tiene su propia clave, lo que se consigue con el atributo key. Podemos indicar como clave algún campo único del elemento o el índice:\n&lt;... v-for=&quot;(item) in todos&quot; :key=&quot;item.id&quot; ...&gt;\no\n&lt;... v-for=&quot;(item, index) in todos&quot; :key=&quot;index&quot; ...&gt;\n\nPasar una key en cada v-for es recomendable ahora pero será obligatorio al usarlo en componentes así que conviene usarlo siempre.\nTambién podemos usar v-for para que se ejecute sobre un rango (como el típico for (i=0; i&lt;10; i++)):\n&lt;span v-for=&quot;i in 10&quot; :key=&quot;i&quot;&gt;{{ i }}&lt;/span&gt;\n\nNOTA: No se recomienda usar v-for y v-if sobre el mismo elemento. Si se hace siempre se ejecuta primero el v-if.\n| Haz el ejercicio del tutorial de Vue.js\nEventos: v-on\nEsta directiva captura un evento y ejecuta un método como respuesta al mismo.\n\nSee the Pen\nv-for by Juan Segura (@juanseguravasco)\non CodePen.\n\nEl evento que queremos capturar se pone tras el carácter : y se indica el método que se ejecutará.\nFijaos en el método delTodos() que para hacer referencia desde el objeto Vue a alguna variable o método se le antepone this.\nSe puede pasar un parámetro a la función escuchadora:\n&lt;button v-on:click=&quot;pulsado('prueba')&quot;&gt;Pulsa&lt;/button&gt;\n\npulsado(valor) {\nalert(valor);\n}\n\nEsta directiva se usa mucho así que se puede abreviar con @. El código equivalente sería:\n&lt;button @click=&quot;pulsado('prueba')&quot;&gt;Pulsa&lt;/button&gt;\n\n| Haz el ejercicio del tutorial de Vue.js\nModificadores de eventos\nA un evento gestionado por una directiva v-on podemos añadirle (separado por .) un modificador. Alguno de los más usados son:\n\n.prevent: equivale a hacer un preventDefault()\n.stop: como stopPropagation()\n.self: sólo se lanza si el evento se produce en este elemento y no en alguno de sus hijos\n.once: sólo se lanza la primera vez que se produce el evento (sería como hacer un addEventListener y tras ejecutarse la primera vez hacer un removeEventListener)\n\nEjemplo:\n&lt;form @submit.prevent=&quot;enviaForm&quot;&gt;\n\nEjemplo de aplicación\nVamos a hacer una aplicación para gestionar una lista de cosas a hacer. Cada cosa a hacer tiene un título y puede estar hecha o no.\nDebe aparecer la lista de cosas a hacer con:\n\nun checkbox para cada cosa que nos indica si está o no hecha (y que podemos marcar/desmarcar para cambiar su estado)\nel título de la cosa a hacer, que aparecerá tachado si su estado es que ya está hecha\n\nAdemás queremos que:\n\nal hacer doble click en una tarea a hacer debe borrarse de la lista\nbajo la lista aparecerá un input con un botón para añadir nuevas cosas a la lista. Sólo se añade si hemos introducido texto y su estado al añadirla será de NO hecha\ndebajo tendremos un botón que borrará toda la lista de cosas a hacer tras pedir confirmación al usuario\n\nSolución de la aplicación\nPuedes ver una solución al problema planteado en:\n\nSee the Pen\nUntitled by Juan Segura (@juanseguravasco)\non CodePen.\n\nCosas a comentar:\n\nHTML\n\nlinea 3: el &lt;ul&gt; sólo se mostrará si hay elementos en la lista (todos.length)\nlínea 4: la directiva v-for además de crear una variable con el elemento crea otra con su posición dentro del array que usaremos para borrarla\nlínea 4: al método que llamamos al producirse el evento dblclick le pasamos el índice de dicho elemento en el array de cosas a hacer\nlínea 6: enlazamos cada checkbox con la propiedad done del elemento de forma que al marcar al checkbox la propiedad valdrá true y al desmarcarlo valdrá false\nlíneas 7 a 12: para mostrar un elemento no hecho usamos un span y para mostrar uno hecho un del para que aparezca tachado\nlínea 16: si no se muestra el &lt;ul&gt; se mostrará un párrafo diciendo que no hay elementos en la lista\nlínea 17: el input lo enlazamos a una nueva variable, newTodo, donde guardaremos lo que se escriba\n\nJavascript\n\nlínea 4: creamos la nueva variable newTodo para guardar el título de la nueva cosa a añadir. Lo inicializamos a una cadena vacía y así el input estará vacío de entrada\nlínea 27: delTodo recibe como parámetro el índice del elemento a borrar así que sólo tiene que hacer un splice al array\nlínea 30: addTodo añade al array un nuevo elemento con el texto que hay en el input y después vacía dicho texto",
		"tags": [ "note"]
},

{
		"title": "03-componentes",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/03-componentes/",
		"content": "Componentes en Vue\n\nComponentes en Vue\n\nIntroducción\nDividir la aplicación en componentes\nSeparar los componentes en ficheros\nParámetros: props\nEjemplo de aplicación\n\nIntroducción\nEl sistema de componentes es un concepto importante en Vue y en cualquier framework moderno. En lugar de separar nuestra aplicación en ficheros según el tipo de información que contienen (ficheros html, css o js) es más lógico separarla según su funcionalidad. Una página web muestra una UI donde se pueden distinguir diferentes partes. En el siguiente ejemplo tenemos:\n![Ejemplo de página web](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/borsaTreball.png)\n\nun menú que es una lista que contiene\n\n(repetido) un elemento de menú, cada uno formado por un logo y un texto\n\nuna barra de título, con un icono y 2 textos\nuna tabla con la información a mostrar, formada por\n\nun elemento para filtrar la información formado por un input y un botón de buscar\nun botón para añadir nuevos elementos a la tabla\nuna cabecera con los nombres de cada campo\n(repetido) una fila para mostrar cada elemento de información, con botones para realizar diferentes acciones\nun pie de tabla con información sobre los datos mostrados\n\nun pie de página\n\nPues estos elementos podrían constituir diferentes componentes: nuestras aplicaciones estarán compuestas de pequeños componentes independientes y reusables en diferentes partes de nuestra aplicación o en otras aplicaciones (podemos usar el elemento de buscar en otras páginas de nuestra aplicación o incluso en otras aplicaciones). También es habitual que un componente contenga otros subcomponentes, estableciéndose relaciones padre-hijo (por ejemplo el componente tabla tiene como subcomponentes el buscador y cada una de las filas, y el componente fila tendrá un subcomponente por cada botón que queramos poner en ella).\nPara saber qué debe ser un componente y que no, podemos considerar un componente como un elemento que tiene entidad propia, tanto a nivel funcional como visual, es decir, que puede ponerse en el lugar que queramos de la aplicación y se verá y funcionará correctamente. Además es algo que es muy posible que pueda aparecer en más de un lugar de la aplicación. En definitiva un componente:\n\nes una parte de la UI\ndebe poder reutilizarse y combinarse con otros componentes para formar componentes mayores\nson objetos JS\n\nEl componente es un objeto con una parte de HTML donde definimos su estructura y una parte JS que le da su funcionalidad. Cuando trabajemos con Single File Components (SFC) también se incluirá una parte CSS para establecer su apariencia.\nSeparar nuestra aplicación en componentes nos va a ofrecer muchas ventajas:\n\nencapsulamos el código de la aplicación en elementos más sencillos\nfacilita la reutilización de código\nevita tener código repetido\n\nAunque también tiene sus inconvenientes: habrá que geationar la comunicación entre componentes.\nEl primer paso a la hora de hacer una aplicación debe ser analizar qué componentes tendrá. Para ello podemos hacer un mockup de la aplicación donde se vean los diferentes elementos que la componen y cómo se relacionan entre ellos. A partir de ahí podemos ir creando los componentes necesarios.\nEn definitiva nuestra aplicación será como un árbol de componentes con la instancia principal de Vue como raíz.\n\nDividir la aplicación en componentes\nUn componente se crea con app.component al que le pasamos 2 parámetros:\n\nel nombre del componente\nel objeto con sus opciones (data, methods, …). Además tendrá una opción template con el código HTML que se insertará donde pongamos el componente.\n\nPor ejemplo, vamos a crear un componente para mostrar cada elemento de la lista de tareas a hacer:\nconst app = Vue.createApp({\n...\n})\n\napp.component('TodoItem', {\ntemplate: `\n&lt;li&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;elem.done&quot;&gt;\n&lt;del v-if=&quot;elem.done&quot;&gt;\n{ { elem.title }}\n&lt;/del&gt;\n&lt;span v-else&gt;\n{ { elem.title }}\n&lt;/span&gt;\n&lt;/li&gt;`,\ndata: ()=&gt;({\nelem: { title: 'Cosa a hacer', done: true }\n})\n})\n...\napp.mount('#app')\n\nNOTA: no se puede montar la aplicación hasta después de haber definido los componentes.\nAhora ya podemos usar el componente en nuestro HTML:\n&lt;ul&gt;\n&lt;todo-item&gt;&lt;/todo-item&gt;\n&lt;/ul&gt;\n\nResultado:\n\nCosa a hacer\n\nPodemos utilizar la etiqueta tal (&lt;todo-item&gt;) o usar una etiqueta estándar y poner la nuestra como valor de su atributo is:\n&lt;ul&gt;\n&lt;li is=&quot;todo-item&quot;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\nDe esta forma evitamos errores de validación de HTML ya que algunos elementos sólo pueden tener determinados elementos hijos (por ejemplo los hijos de un deben ser o los de un deben ser ).\nATENCIÓN: El nombre de un componente puede estar en PascalCase (MyComponentName) o en kebab-case (my-component-name). Lo recomendado es que en Javascript lo pongamos en PascalCase y en el HTML en kebab-case (Vue hace la traducción automáticamente). Se recomienda que el nombre de un componente tenga al menos 2 palabras para evitar que pueda llamarse como alguna futura etiqueta HTML.\nNOTA: En versiones anteriores de Vue la propiedad template sólo podía tener un nodo raíz. En Vue3 esta limitación no existe aunque en dev-tools se depura más fácilmente si solo hay uno. Por ello, si tenemos más de 1 nodo los envolvemos en otra etiqueta (normalmente un ):\n// MAL en Vue2\ntemplate: `&lt;input id=&quot;query&quot;&gt;\n&lt;button id=&quot;search&quot;&gt;Buscar&lt;/button&gt;`,\n\n// BIEN en Vue2\ntemplate: `&lt;div&gt;\n&lt;input id=&quot;query&quot;&gt;\n&lt;button id=&quot;search&quot;&gt;Buscar&lt;/button&gt;\n&lt;/div&gt;`,\n\nSeparar los componentes en ficheros\nDeclarar los componentes con app.component() en el mismo fichero JS de la instancia genera varios problemas, especialmente:\n\nLos componentes así declarados son globales a la aplicación por lo que sus nombres deben ser únicos\nNuestro fichero crece rápidamente y nos encontramos con código spaguetti\n\nPor tanto eso puede ser adecuado para proyectos muy pequeños pero no lo es cuando estos empiezan a crecer.\nLa solución es guardar cada componente en un único fichero javascript (con extensión .js), aunque cuando usemos SFC usaremos ficheros .vue.\nEn el fichero exportaremos un objeto con las propiedades del componente (data, methods, ...), además de la propiedad template. También podemos añadir una propiedad name donde indicar el nombre del componente.\nPor ejemplo, vamos a crear un componente para el botón de eliminar todas las tareas:\n// Fichero DelAllItems.js\nexport default {\ntemplate: `\n&lt;button @click=&quot;delAll&quot;&gt;Vacía lista&lt;/button&gt;\n`,\nmethods: {\ndelAll() {\nif (confirm('Vas a borrar la lista de tareas')) {\nthis.todos.splice(0)\n}\n}\n},\n}\n\nPara poder usar un componente, en donde queramos usarlo (otro componente o la instancia raíz) debemos hacer 2 cosas:\n\nimportar el fichero\nregistrar el componente, lo que se hace en una opción llamada components\n\n// Fichero main.js\nimport DelAllItems from './DellAllItems.js'\n\nVue.createApp({\ncomponents: {\nDelAllItems,\n},\ndata() {\n...\n}\n})\n\nAhora ya podemos usar el componente en nuestro HTML:\n...\n&lt;/form&gt;\n&lt;del-all-items&gt;&lt;/del-all-items&gt;\n&lt;/div&gt;\n&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nFíjate que hay que declarar el fichero main.js como module para que nos permita importar ficheros en él.\nEl navegador sustituirá la etiqueta del componente (&lt;del-all-items&gt;) por su template.\n| Haz el ejercicio del tutorial de Vue.js\nParámetros: props\nPodemos pasar parámetros a un componente añadiendo atributos a su etiqueta:\n&lt;ul&gt;\n&lt;todo-item :todo=&quot;{ title: 'Nueva cosa', done: false }&quot;&gt;&lt;/todo-item&gt;\n&lt;/ul&gt;\n\nNOTA: recuerda que si no ponemos el v-bind estaríamos pasando texto y no el valor de una variable (en este caso un objeto).\nEl parámetro lo recibimos en el componente en una opción llamada props:\napp.component('todo-item', {\nprops: {\ntodo: Object\n},\ntemplate: `\n&lt;li&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;\n...`\n})\n\nLas props son el equivalente a los parámetros que recibe una función.\n| Haz el ejercicio del tutorial de Vue.js\nSe pueden declarar las props recibidas como un array de string (props: ['todo']), aunque es mejor declararlas como un objeto porque nos permitirá hacer ciertas comprobaciones (en el ejemplo anterior que se recibe un Object).\nIMPORTANTE: si un parámetro tiene más de 1 palabra en el HTML lo pondremos en forma kebab-case (ej.: &lt;todo-item :todo-elem=...&gt;) pero en el Javascript irá en camelCase (app.component('todo-item',{ props: ['todoElem'],...})). Vue hace la traducción automáticamente.\n\nResultado:\n\nNueva cosa a hacer\n\nEn nuestro caso queremos un componente todo-item para cada elemento del array todos:\n&lt;ul&gt;\n&lt;todo-item v-for=&quot;item in todos&quot; :key=&quot;item.id&quot; :todo=&quot;item&quot;&gt;&lt;/todo-item&gt;\n&lt;/ul&gt;\n\nResultado:\n\nLearn JavaScript\n\nLearn Vue\n\n...\n\nIMPORTANTE: al usar v-for en un componente debemos indicarle obligatoriamente en la propiedad key la clave de cada elemento. Si no tuviera ninguna podemos usar como clave su índice en el array como vimos al hablar de v-for:\n&lt;ul&gt;\n&lt;todo-item v-for=&quot;(item, index) in todos&quot; :key=&quot;index&quot; :todo=&quot;item&quot;&gt;&lt;/todo-item&gt;\n&lt;/ul&gt;\n\nEjemplo de aplicación\nPara empezar a ver el uso de componentes vamos a seguir con la aplicación de la lista de cosas que hacer pero dividiéndola en componentes.\nLa decisión de qué componentes crear es subjetiva pero en principio cuanto más descompongamos más posibilidades tendremos de reutilizar componentes. Nosotros haremos los siguientes componentes:\n\ntodo-list: muestra la lista de tareas a realizar. Dentro tendrá:\n\ntodo-item: cada una de las tareas a hacer\n\nadd-item: incluye el formulario para añadir una nueva tarea (el input y el botón)\ndel-all: el botón para borrar toda la lista\n\nA continuación tienes la solución de cómo dividirla en componentes en un único fichero pero en su lugar lo que haremos es separar cada componente en su propio fichero.\nIMPORTANTE: separar los componentes en ficheros que se importan donde vayan a usarse sólo funciona si abrimos la aplicación desde un servidor web, no desde local (sí http://..., no file://...). Si no tenéis ninguno podéis usar la extensión Live Server de Visual Studio Code para ejecutar la aplicación.\nNOTA: ahora nuestra aplicación ya no funciona porque los datos que se declaran en un componenete son locales al mismo y no son accesibles desde otros componentes. Para solucionar esto necesitamos un sistema de comunicación entre componentes que veremos en el siguiente apartado.\nSolución\n\nSee the Pen\nto-do app components by Juan Segura (@juanseguravasco)\non CodePen.\n\nPasos que he hecho:\n\nCreamos la instancia principal de Vue. No tiene data ni methods ni ningún otro elemento porque está todo en los componentes\nCreo el componente encargado de renderizar un elemento de la lista de tares, todo-item.\n\nrecibirá un objeto con la tarea a mostrar\nsu template será el que tenía en el HTML pero quitando el v-for porque él sólo se encarga de mostrar 1 item\nel método para borrarlo al hacer doble click ya no puede funcionar porque el componente no tiene acceso al array de tareas. De momento sólo ponemos un alert que nos diga que lo queremos borrar\n\nCreo el componente add-item.\n\nsu template será el &lt;input&gt; y el &lt;button&gt; que teníamos en el HTML, pero como sólo puede haber un elemento en el template los incluimos dentro de un\nno recibe ningún parámetro pero sí tiene una variable propia, newTodo, que quitamos del componente principal para añadirla a este componente\nel método addTodo ya no funciona porque no tengo acceso al array de tareas así que de momento muestro un alert con lo que querría añadir\n\nCreo el componente del-all\n\nsu template es el botón\nni recibe parámetros ni tiene variables propias\ncon el método pasa lo mismo que en los otros casos así que simplemente muestro un alert\n\nCreo el componente que mostrará la lista: todo-list.\n\nSu template es un div que incluye el título (que será una variable para poderlo reutilizar) y la lista con las tareas a mostrar. Cada una de ellas será un subcomponente llamado todo-item\ncomo parámetro recibirá el título de la lista como hemos indicado antes\nllama al subcomponente todo-item para cada tarea (v-for) y le pasa la tarea que debe mostrar\nsus datos será el array de tareas\nLos métodos los dejamos tal cual aunque ahora no funcionan porque nadie los llama. Ya lo arreglaremos",
		"tags": [ "note"]
},

{
		"title": "03_1-sfc",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/03-1-sfc/",
		"content": "Single File Components\n\nSingle File Components\n\nIntroducción\n\nRecordatorio de cómo separar componentes en ficheros\nSolución del ejemplo\n\nCrear un proyecto Vue\n\nCreación de un nuevo proyecto\nScaffolding creado\n\npackage.json\nindex.html\nmain.js\nApp.vue\ncomponents/HelloWorld.vue\n\nBuild and Deploy de nuestra aplicación\n\nLos ficheros SFC (Single File Component)\n\nSecciones de un Single File Component\n\n&lt;template&gt;\n&lt;script&gt;\n&lt;style&gt;\nCustom blocks\n\nAñadir nuevos paquetes y plugins\n\nBootstrap\n\nIconos\n\nCrear un nuevo componente\nDepurar el código en la consola\n\nAplicación de ejemplo\n\nIntroducción\nLa utilidad de separar nuestra aplicación en componentes es que cada uno de ellos puede guardarse en su propio fichero y así no tenemos un fichero con demasiado código. A estos ficheros que contienen un componente se les llama Single File Component (SFC).\nRecordatorio de cómo separar componentes en ficheros\nComo vimos en la unidad anterior, en el fichero en que definimos el componente exportamos un objeto con las opciones del componente (el segundo parámetro del app.component()):\nexport default {\nprops: ['todo'],\ntemplate:\n`&lt;li @dblclick=&quot;delTodo&quot;&gt;\n&lt;label&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;\n&lt;del v-if=&quot;todo.done&quot;&gt;\n{ { todo.title }}\n&lt;/del&gt;\n&lt;span v-else&gt;\n{ { todo.title }}\n&lt;/span&gt;\n&lt;/label&gt;\n&lt;/li&gt;`,\nmethods: {\ndelTodo() {\nalert('Quiero borrar &quot;' + this.todo.title + '&quot;');\n}\n}\n}\n\nY donde queramos usarlo (puede ser en otro componente o en la instancia raíz de Vue) debemos:\n\nimportar el fichero del componente\nregistrar el componente en una propiedad llamada components\n\nEl fichero main.js de nuestra aplicación de la Lista de tareas quedaba:\nimport TodoList from './TodoList.js'\nimport TodoAdd from './TodoAdd.js'\nimport TodoDellAll from './TodoDellAll.js'\n\nvar myApp=Vue.createApp({\ncomponents: {\nTodoList,\nTodoAdd,\nTodoDellAll,\n}\n})\n\nRecuerda que para que el navegador entienda la sentencia import debemos indicar que el script que lo contiene es de tipo module:\n&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;\n\nSolución del ejemplo\nPodéis ver aquí cómo quedará nuestra aplicación de ejemplo con los componentes separados en ficheros:\n\nCrear un proyecto Vue\nAunque puede usarse Vue como hemos visto, enlazándolo directamente en el index.html lo más habitual es crear un nuevo proyecto para la aplicación que vamos a desarrollar usando npm y Vite. Esto:\n\nCrea automáticamente el scaffolding básico de nuestro proyecto basándose en una serie de plantillas predefinidas\nFacilita el trabajo con componentes, permitiendo que cada uno de ellos esté en su propio fichero (SFC, Single File Components)\nIncluye utilidades y herramientas como Babel, Uglify, ... que permiten\n\ngestionar las dependencias de nuestro código\nempaquetar todos los ficheros .vue y librerías en un único fichero JS y CSS\ntraspilar el código ES2015/2016, SCSS, etc a ES5 y CSS3 estándar\nminimizar el código generado\n\nIncluye herramientas que facilitan el desarrollo\n\nCreación de un nuevo proyecto\nPara crear un nuevo proyecto ejecutamos:\nnpm init vue@latest\n\nAl ejecutar este comando se nos pregunta el nombre del proyecto a crear y si queremos usar o no determinadas herramientas (más adelante veremos qué es cada una, de momento decimos que No) y se creará el directorio para el mismo con el package.json del proyecto en su interior con su configuración.\n![Nuevo Proyecto](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/npm-init-vue.png)\nLo primero que haremos es entrar al directorio del proyecto e instalar las dependencias (npm install) y a continuación ejecutar:\nnpm run dev\n\nEste script de Vite funciona como ya vismo en el bloque de Javascript: compila el código, muestra si hay errores, lanza un servidor web en el puerto 5173 y carga el proyecto en el navegador (http://localhost:5173). Si cambiamos cualquier fichero del directorio src recompila y recarga la página automáticamente.\nAdemás nos permite acceder a una página desde donde explorar los componentes de nuestra aplicación y ver su código, propiedades, etc. igual que podemos hacer desde la consola si hemos instalado las Vue DevTools.\nLa página generada es por el proyecto es:\n![Proyecto de plantilla simple](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/vue-vite-sample-app.png)\nScaffolding creado\nSe ha creado la carpeta con el nombre del proyecto y dentro el scaffolding para nuestro proyecto:\n![Directorios del proyecto de plantilla simple](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/vue-vite-sample-folders.png)\nLos principales ficheros y directorios creados son:\n\npackage.json: configuración del proyecto (nombre, autor, ...) y dependencias\nvite.config.js: configuración de Vite\nindex.html: html con un div donde se cargará la app\nnode_modules: librerías de las dependencias\npublic: lugar donde dejar elementos estáticos que no pasarán por vite. Podemos poner imágenes, CSS, etc y lo referenciaremos de forma ABSOLUTA como si estuviera en /\nsrc: todo nuestro código\n\nassets/: nuestros CSS, imágenes, etc. Elementos que vite procesará y optimizará\ncomponents/: carpeta que contendrá los ficheros .vue de los diferentes componentes\n\nHelloWorld.vue: componente de ejemplo llamado por App.vue\n\nrouter/: carpeta con los ficheros del router si usamos _vue-router\nstore/: carpeta con los ficheros del store si usamos pinia o vuex\nviews: si usamos vue-router aquí pondremos los componentes que constituyen una vista de la aplicación\nApp.vue: es el componente principal y constituye nuestra página de inicio del proyecto. Aquí cargaremos la cabecera, el menú,... y los diferentes componentes\nmain.js: JS principal que crea la instancia de Vue que carga el componente principal llamado App.vue y lo renderiza en _#app_\n\npackage.json\nAquí se configura nuestra aplicación:\n\nname, version, author, license, ...: configuración general de la aplicación\nscripts: ejecutan entornos de configuración para webpack:\n\ndev: lanza el servidor web de vite y configura vue para el entorno de desarrollo\nbuild: crea los ficheros JS y CSS dentro de /dist con todo el código de la aplicación\n\ndependences: se incluyen las librerías y plugins que utiliza nuestra aplicación en producción. Todas las dependencias se instalan dentro de /node-modules. Para instalar una nueva dependencia de desarrollo ejecutaremos npm install nombre-del-paquete -S (la opción -S la añade a package.json como dependencia de producción).\ndevDependencies: igual pero son paquetes que sólo se usan en desarrollo (vite, etc). También se instalan dentro de node-modules pero no estarán cuando se genere el código para producción. Para instalar una nueva dependencia de desarrollo ejecutaremos npm install nombre-del-paquete -D (la opción -D la añade a package.json pero como dependencia de desarrollo).\n\nindex.html\nSimplemente tiene el &lt;div&gt; app que es el que contendrá la aplicación.\nmain.js\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport './assets/main.css'\n\ncreateApp(App).mount('#app')\n\nEs el fichero JS principal. Importa la utilidad createApp de la librería Vue y el componente App.vue. Crea la instancia de Vue con el componente definido en App.vue y lo renderiza en el elemento _#app_.\nApp.vue\nEs el componente raíz de la aplicación, el que contiene el layout de la página. Se trata de un SFC (Single File Component) y lo que contiene dentro de la etiqueta &lt;template&gt; es lo que se renderizará en el div app que hay en index.html. Si contiene algún otro componente se indica aquí dónde renderizarlo (en este caso &lt;HelloWorld&gt; y &lt;TheWelcome&gt;).\nEn el siguiente apartado explicaremos qué es un SFC y qué partes lo forman. De momento veamos qué contiene cada sección:\nSección template\n&lt;template&gt;\n&lt;header&gt;\n&lt;img alt=&quot;Vue logo&quot; class=&quot;logo&quot; src=&quot;./assets/logo.svg&quot; width=&quot;125&quot; height=&quot;125&quot; /&gt;\n\n&lt;div class=&quot;wrapper&quot;&gt;\n&lt;HelloWorld msg=&quot;You did it!&quot; /&gt;\n&lt;/div&gt;\n&lt;/header&gt;\n\n&lt;main&gt;\n&lt;TheWelcome /&gt;\n&lt;/main&gt;\n&lt;/template&gt;\n\nMuestra la imagen del logo (las imágenes y otros ficheros como ficheros .css se guardan dentro de /src/assets/) y los subcomponentes HelloWorld y TheWelcome.\nSección script\n&lt;script setup&gt;\nimport HelloWorld from './components/HelloWorld.vue'\nimport TheWelcome from './components/TheWelcome.vue'\n&lt;/script&gt;\n\nLo que hace es importar los componentes que se utilizan en el template. Su sintaxis es de Composition API. En sintaxis de Options API sería:\n&lt;script&gt;\nimport HelloWorld from './components/HelloWorld.vue'\nimport TheWelcome from './components/TheWelcome.vue'\n\nexport default {\ncomponents: {\nHelloWorld,\nTheWelcome\n}\n}\n&lt;/script&gt;\n\nEn esta sintaxis siempre se exporta un objeto con las opciones del componente. En este caso la opción components donde se registran los componentes que hemos importado.\nSección style\nAquí se definen los estilos de este componente. Como la etiqueta SÍ tiene el atributo scoped (&lt;style scoped&gt;) significa que los estilos aquí definidos se aplicarán SÓLO a este componente, y a sus subcomponentes.\ncomponents/HelloWorld.vue\nEs el componente que muestra el texto que aparece bajo la imagen. Recibe como parámetro el título a mostrar. Veamos qué contiene cada sección:\nSección template\n&lt;template&gt;\n&lt;div class=&quot;greetings&quot;&gt;\n&lt;h1 class=&quot;green&quot;&gt;{{ msg }}&lt;/h1&gt;\n&lt;h3&gt;\nYou’ve successfully created a project with\n&lt;a href=&quot;https://vitejs.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vite&lt;/a&gt; +\n&lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue 3&lt;/a&gt;.\n&lt;/h3&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nMuestra el msg recibido como parámetro y varios apartados con listas.\nSección script\n&lt;script setup&gt;\ndefineProps({\nmsg: {\ntype: String,\nrequired: true\n}\n})\n&lt;/script&gt;\n\nRecibe el parámetro msg que es de tipo String. En sintaxis Options API sería:\n&lt;script&gt;\nexport default {\nname: 'HelloWorld',\nprops: {\nmsg: {\ntype: String,\nrequired: true\n}\n}\n}\n&lt;/script&gt;\n\nSección style\nTambién tiene el atributo scoped (&lt;style scoped&gt;) por lo que los estilos aquí definidos se aplicarán sólo a este componente.\nBuild and Deploy de nuestra aplicación\nNormalmente trabajaremos con algún gestor de versiones como git. Para subir nuestro proyecto al repositorio lo creamos (en GitHub, GitLab o donde queramos) y ejecutamos desde la carpeta del proyecto:\ngit init\ngit add .\ngit remote add origin https://github.com/mi-usuario/mi-proyecto\ngit commit -m &quot;Primer commit&quot;\ngit push -u origin main\n\nCuando nuestra aplicación esté lista para subir a producción ejecutaremos el script:\nnpm run build\n\nEste comando genera los JS y CSS para subir a producción dentro de la carpeta dist. El contenido de esta carpeta es lo único que debemos subir a nuestro servidor de producción.\nLos ficheros SFC (Single File Component)\nGuardar los componentes en ficheros .js como hicimos en el tema anterior genera varios problemas:\n\nEl HTML del template está en ese fichero en medio del JS lo que lo hace menos legible y el editor no lo resalta adecuadamente (ya que espera encontrar código JS no HTML)\nEl HTML y el JS del componente están juntos pero no su CSS\nNo podemos usar fácilmente herramientas para convertir SCSS a CSS, ES2015 a ES5, etc\n\nPor tanto eso puede ser adecuado para proyectos muy pequeños pero no lo es cuando estos empiezan a crecer.\nLa solución es guardar cada componente en un único fichero (SFC), que tendrá extensión .vue. Estos ficheros contienen 3 secciones diferentes:\n\n&lt;template&gt;: contiene todo el HTML del componente\n&lt;script&gt;: con el JS del mismo\n&lt;style&gt;: donde pondremos el CSS del componente\n\nAunque esto va contra la norma de tener el HTML, JS y CSS en ficheros separados en realidad sí están separados en diferentes secciones y tenemos la ventaja de tener en un único fichero todo lo que necesita el componente.\nLa mayoría de editores soportan estos ficheros instalándoles algún plugin, (como Vue-Oficial para Visual Studio Code) por lo que el resaltado de las diferentes partes es correcto. Además Vite nos permite usar ES2015 o posterior y los preprocesadores más comunes (SASS, Pug/Jade, Stylus, ...) y ya se se traducirá automáticamente el código a ES5, HTML5 y CSS3.\nSecciones de un Single File Component\nVeamos en detalle cada una de las secciones del SFC.\n&lt;template&gt;\nAquí incluiremos el HTML que sustituirá a la etiqueta del componente. Recuerda que en las versiones anteriores a Vue3 dentro sólo puede haber un único elemento HTML (si queremos poner más de uno los incluiremos en otro que los englobe).\n&lt;template&gt;\n&lt;div class=&quot;greetings&quot;&gt;\n&lt;h1 class=&quot;green&quot;&gt;{{ msg }}&lt;/h1&gt;\n&lt;h3&gt;\nYou’ve successfully created a project with\n&lt;a href=&quot;https://vitejs.dev/&quot;&gt;Vite&lt;/a&gt; +\n&lt;a href=&quot;https://vuejs.org/&quot;&gt;Vue 3&lt;/a&gt;.\n&lt;/h3&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nSi el código HTML a incluir en el template es muy largo podemos ponerlo en un fichero externo y vincularlo en el template, así nuestro SFC queda más pequeño y legible:\n&lt;template src=&quot;./myComp.html&quot;&gt;\n&lt;/template&gt;\n\nRespecto al lenguaje, podemos usar HTML (la opción por defecto) o PUG que es una forma sencilla de escribir HTML. Lo indicamos como atributo de &lt;template&gt;:\n&lt;template lang=&quot;pug&quot;&gt;\ndiv.greetings\nh1.green {{ msg }}\nh3\n| You’ve successfully created a project with\na(href=&quot;https://vitejs.dev/&quot;) Vite\n| +\na(href=&quot;https://vuejs.org/&quot;) Vue 3\n\n&lt;script&gt;\nAquí definimos y exportamos el componente, que será un objeto con diferentes propiedades. Si utiliza subcomponentes hay que importarlos antes de definir el objeto y registrarlos dentro de este.\nEntre las propiedades que puede tener el objeto están:\n\nname: el nombre del componente. Es recomendable ponerlo, aunque sólo es obligatorio en caso de componentes recursivos. Es el nombre con el que se referenciará al componente en la consola del navegador usando las Dev tools.\ncomponents: aquí registramos componentes hijos que queramos usar en el template de este componente (debemos haber importado previamente los ficheros .vue que los contienen). En el template usaremos como etiqueta el nombre con que lo registramos aquí\nprops: donde registramos los parámetros que nos pasa el componente padre como atributos de la etiqueta que renderiza este componente\ndata(): función que devuelve un objeto con todas las variables locales del componente\nmethods: objeto con los métodos del componente\ncomputed: aquí pondremos las variables calculadas del componente. Lo veremos en detalle en la unidad 6\ncreated(), mounted(), ...: funciones hook que se ejecutan al crearse el componente, al montarse, ... Aquí pondremos el código que queremos que se ejecute al cargar un componente, como pedir a la BBDD los datos que necesita. Veremos los diferentes hooks en la unidad 6\nwatch: si queremos observar manualmente cambios en alguna variable y ejecutar código como respuesta a ellos (recuerda que Vue ya se encarga de actualizar la vista al cambiar las variables y viceversa). Lo veremos en detalle en la unidad 6\n...\n\n&lt;style&gt;\nAquí pondremos estilos CSS que se aplicarán al componente. Podemos usar CSS, SASS o PostCSS. Si queremos importar ficheros de estilo con @import deberíamos guardarlos dentro de la carpeta assets de nuestra aplicación.\nSi la etiqueta incluye el atributo scoped estos estilos se aplicarán únicamente a este componente (y sus descendientes) y no a todos los componentes de nuestra aplicación. Si tenemos estilos que queremos que se apliquen a toda la aplicación y otros que son sólo para el componente y sus descendientes pondremos 2 etiquetas &lt;style&gt;, una sin el atributo scoped y otra con él.\nLa forma más común de asignar estilos a elementos es usando clases. Para conseguir que su estilo cambie fácilmente podemos asignar al elemento clases dinámicas que hagan referencia a variables del componente. Ej.:\n&lt;template&gt;\n&lt;p :class=&quot;[decoration, {weight: isBold}]&quot;&gt;Hi!&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ndata() {\nreturn {\ndecoration: 'underline',\nisBold: true\n}\n}\n}\n&lt;/script&gt;\n\n&lt;style lang=&quot;css&quot;&gt;\n.underline { text-decoration: underline; }\n.weight { font-weight: bold; }\n&lt;/style&gt;\n\nEl párrafo tendrá la clase indicada en la variable decoration (en este caso underline) y además como el valor de isBold es verdadero tendrá la clase weight. Hacer que cambien las clases del elemento es tan sencillo como cambiar el valor de las variables.\nPodemos ver las diferentes maneras de asignar clases a los elementos HTML en la documentación de Vue.\nIgual que vimos en la etiqueta &lt;template&gt;, si el código de los estilos es demasiado largo podemos ponerlo en un fichero externo que vinculamos a la etiqueta con el atributo src.\nCustom blocks\nAdemás de estos 3 bloques un SFC puede tener otros bloques definidos por el programador para, por ejemplo, incluir la documentación del componente o sus test unitarios:\n&lt;custom1 src=&quot;./unit-test.js&quot;&gt;\nAquí podríamos incluir los test unitarios del proyecto\n&lt;/custom1&gt;\n\nAñadir nuevos paquetes y plugins\nSi queremos usar un nuevo paquete en nuestra aplicación lo instalaremos con npm:\nnpm install nombre-paquete\n\nEste comando además de instalar el paquete en node-modules lo añade a las dependencias del package.json. La opción --save o -S lo añadirá como dependencia de producción y --dev o -D como dependencia de desarrollo. Si no ponemos nada se añade como una dependencia de producción. Ej.:\nnpm install -S axios\n\nPara usarlo en nuestros componentes debemos importarlo y registrarlo tal y como se indique en su documentación. Lo normal es hacerlo en el main.js (o en algún fichero JS que importemos en main.js como en el caso de los plugins) si queremos poder usarlo en todos los componentes.\nSi el paquete que queremos instalar se encuentra como plugin el proceso es más sencillo ya que sólo es necesario usar app.use(myPlugin, { /* opciones opcionales */}) en el fichero main.js.\nBootstrap\nSimplemente lo instalaremos como una dependencia de producción y después lo añadimos al fichero src/main.js:\nimport &quot;bootstrap/dist/css/bootstrap.css&quot;\n\nRecuerda que siempre es conveniente importar Bootstrap antes de importar nuestro propio CSS (antes de la línea import './assets/main.css'). Si necesitamos algún componente de Bootstrap que utilice Javascript importaríamos también su javascript en el fichero main.js pero en este caso después de montar la aplicación vue:\n// src/main.js\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\nimport &quot;bootstrap/dist/css/bootstrap.css&quot;\nimport './assets/main.css'\n\ncreateApp(App).mount('#app')\n\nimport &quot;bootstrap/dist/js/bootstrap.js&quot;\n\nIconos\nPara usar los iconos de Bootstrap 5 podemos instalar el paquete bootstrap-icons o bien importarlos en el CSS desde su CDN, tal y como se explica en la documentación de Bootstrap. Una vez hecho ya podemos incluir los iconos en etiquetas &lt;i&gt;.\nPor ejemplo, si importamos el CSS incluiremos en el &lt;style&gt; del componente App.vue:\n@import url(&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css&quot;)\n\ny donde queramos incluir el icono de la papelera, por ejemplo, incluimos:\n&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;\n\nSi queremos usar otras librerías de iconos como Font Awesome o Material Icons simplemente importaremos su CSS en el fichero App.vue y usaremos las clases que nos proporcionen. Para Material Icons sería:\n@import url('https://fonts.googleapis.com/icon?family=Material+Icons');\n\ny su uso sería:\n&lt;span class=&quot;material-icons&quot;&gt;delete&lt;/span&gt;\n\nRespecto a los componentes de Bootstrap, para que funcionen sólo tenemos que usar los atributos data-bs- (recuerda que muchos de estos componenetes necesitan su Javascript por lo que deberemos importarlo como se ha explicado antes). Por ejemplo para hacer un botón colapsable haremos:\n&lt;button\nclass=&quot;btn btn-primary&quot;\ndata-bs-target=&quot;#collapseTarget&quot;\ndata-bs-toggle=&quot;collapse&quot;&gt;\nBootstrap collapse\n&lt;/button&gt;\n&lt;div class=&quot;collapse py-2&quot; id=&quot;collapseTarget&quot;&gt;\nThis is the toggle-able content!\n&lt;/div&gt;\n\nEn lugar de usar atributos data-bs- podemos envolver los componentes bootstrap en componentes Vue como se explica en muchas páginas, como Using Bootstrap 5 with Vue 3.\nCrear un nuevo componente\nCreamos un nuevo fichero en /src/components (o en alguna subcarpeta dentro) con extensión .vue. Donde queramos usar ese componente debemos importarlo y registrarlo como ya hemos visto:\nimport CompName from './CompName.vue'\n\nexport default {\n...\ncomponents: {\n'comp-name': CompName\n}\n...\n}\n\nY ya podemos incluir el componente en el HTML:\n&lt;comp-name ...&gt; ... &lt;/comp-name&gt;\n\nDepurar el código en la consola\nPodemos seguir depurando nuestro código, poniendo puntos de interrupción y usando todas las herramientas que nos proporciona la consola mientras estamos en modo de depuración (si hemos abierto la aplicación con npm run dev).\nComo estamos usando Vite no se está ejecutando nuestro código directamente sino que se ha convertido al código que ejecuta el navegador, por eso en el depurador aparecen varios ficheros y el que usaremos para depurar es el que pone (mapeado):\n![Depurar en la consola](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/console-vite.png)\nRecordad que si hemos instalado las Vue DevTools tenemos una nueva pestaña en la consola desde la que podemos ver todos nuestros componentes con sus propiedades y datos:\n![Vue DevTools](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/console-vue_devtools.png)\nAplicación de ejemplo\nRecordemos que la aplicación que estamos desarrollando tiene los componentes:\n\ntodo-list: lista de tareas a hacer. Cada item de la lista es un componente todo-item\ntodo-item: cada elemento de la lista de tareas a hacer\ntodo-add: formulario para añadir una nueva tarea\ntodo-del-all: botón para eliminar todas las tareas\n\nPara transformar esto en SFC simplemente crearemos un fichero para cada uno de estos componentes. Nuestro anterior index.html será el &lt;template&gt; del componente principal App.vue, que en un sección &lt;script&gt; deberá importar y registrar cada uno de los componentes usados en el template (todo-list, todo-add y todo-del-all).\nSolución:",
		"tags": [ "note"]
},

{
		"title": "03_2-comunicar_componentes",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/03-2-comunicar-componentes/",
		"content": "Comunicación entre componentes\n\nComunicación entre componentes\n\nIntroducción\nProps (de padre a hijo)\n\nNunca cambiar el valor de una prop\nValidación de props\nPasar otros atributos de padre a hijo\n\nEmitir eventos (de hijo a padre)\n\nDefinir y validar eventos\nCapturar el evento en el padre\n\nCompartir datos\n\n$root y $parent\nStore pattern\n\nPinia\nSlots\n\nSlots con nombre\nAcceder a datos del hijo desde el padre con slot\n\nAplicación de ejemplo\n\nIntroducción\nCada componente tiene sus propios datos que son datos de nivel de componente, pero hay ocasiones en que varios componentes necesitan acceder a los mismos datos. Es lo que nos sucede en nuestra aplicación de ejemplo donde varios componentes necesitan acceder a la lista de tareas (variable todos) para mostrarla (todo-list), añadir items (todo-add) o borrarla (todo-del-all).\nEstos datos se consideran datos de nivel de aplicación y hay varias formas de tratarlos.\nYa hemos visto que podemos pasar información a un componente hijo mediante props. Esto permite la comunicación de padres a hijos, pero queda por resolver cómo comunicarse los hijos con sus padres para informarles de cambios o eventos producidos y cómo comunicarse otros componentes entre sí.\nNos podemos encontrar las siguientes situaciones:\n\nComunicación de padres a hijos: paso de parámetros (props)\nComunicación de hijos a padres: emitir eventos ($emit)\nComunicación entre otros componentes: usar el patrón store pattern\nComunicación más compleja: Pinia\n\nProps (de padre a hijo)\nYa hemos visto que podemos pasar parámetros del padre al componente hijo. Si el valor del parámetro cambia en el padre automáticamente se reflejan esos cambios en el hijo.\nNOTA: Cualquier parámetro que pasemos sin v-bind se considera texto. Si queremos pasar un número, booleano, array u objeto hemos de pasarlo con v-bind igual que hacemos con las variables para que no se considere texto:\n&lt;ul&gt;\n&lt;todo-item todo=&quot;Aprender Vue&quot; :done=&quot;false&quot; &gt;&lt;/todo-item&gt;\n&lt;/ul&gt;\n\nSi queremos pasar varios parámetros a un componente hijo podemos pasarle un objeto en un atributo v-bind sin nombre y lo que recibirá el componente hijo son sus propiedades:\n&lt;template&gt;\n&lt;ul&gt;\n&lt;todo-item v-bind=&quot;propsObject&quot; &gt;&lt;/todo-item&gt;\n&lt;/ul&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n...\ndata() {\nreturn {\npropsObject: {\ntodo: 'Aprender Vue',\ndone: false\n}\n}\n}\n...\n&lt;/script&gt;\n\ny en el componente se reciben sus parámetros separadamente:\n// todo-item.vue\n...\nprops: ['todo', 'done'],\n...\n\nTambién es posible que el nombre de un parámetro que queramos pasar sea una variable:\n&lt;child-component :[paramName]=&quot;valorAPasar&quot; &gt;&lt;/child-component&gt;\n\n| Haz el ejercicio del tutorial de Vue.js\nNunca cambiar el valor de una prop\nAl pasar un parámetro mediante una prop su valor se mantendrá actualizado en el hijo si su valor cambiara en el padre, pero no al revés por lo que no debemos cambiar su valor en el componente hijo (de hecho Vue3 no nos lo permite).\nSi tenemos que cambiar su valor porque lo que nos pasan es sólo un valor inicial podemos crear una variable local a la que le asignamos como valor inicial el parámetro pasado:\nprops: ['initialValue'],\ndata(): {\nreturn {\nmyValue: this.initialValue\n}\n}\n\nY en el componente usaremos la nueva variable myValue.\nSi no necesitamos cambiarla sino sólo darle determinado formato a la variable pasada lo haremos creando una nueva variable (en este caso mejor una computed), que es con la que trabajaremos:\nprops: ['cadenaSinFormato'],\ncomputed(): {\ncadenaFormateada() {\nreturn this.cadenaSinFormato.trim().toLowerCase()\n}\n}\n\nOJO: Si el parámetro es un objeto o un array éste se pasa por referencia por lo que si lo cambiamos en el componente hijo sí se cambiará en el padre, cosa que debemos evitar.\nValidación de props\nAl recibir los parámetros podemos usar sintaxis de objeto en lugar de sintaxis de array y en ese caso podemos indicar algunas cosas como:\n\ntype: su tipo (String, Number, Boolean, Array, Object, Date, Function, Symbol o una clase propia). Puede ser un array con varios tipos: type: [Boolean, Number]\ndefault: su valor por defecto si no se pasa ese parámetro\nrequired: si es o no obligatorio\nvalidator: una función que recibe como parámetro el valor del parámetro y devolverá true o false en función de si el valor es o no válido\n\nEjemplos:\nprops: {\nnombre: String,\napellidos: {\ntype: String,\nrequired: true\n},\nidPropietario: {\ntype: [Boolean, Number],\ndefault: false\n},\nproducts: {\ntype: Object,\ndefault(): {\nreturn {id:0, units: 0}\n} // Si es un objeto o array _default_ debe ser una función que devuelva el valor\n},\nnifGestor: {\ntype: String,\nrequired: true,\nvalidator(value): {\nreturn /^[0-9]{8}[A-Z]$/.test(value) // Si devuelve *true* será válido\n}\n}\n\nPasar otros atributos de padre a hijo\nAdemás de los parámetros, que se reciben en props, el componente padre puede poner cualquier otro atributo en la etiqueta del hijo, quien lo recibirá y se aplicará a su elemento raíz. A esos atributos se puede acceder a través de $attr. Por ejemplo:\n&lt;!-- componente padre --&gt;\n&lt;date-picker id=&quot;now&quot; data-status=&quot;activated&quot; class=&quot;fecha&quot;&gt;&lt;/date-picker&gt;\n\n// Componente hijo date-picker.vue\n&lt;template&gt;\n&lt;div class=&quot;date-picker&quot;&gt;\n&lt;input type=&quot;datetime&quot; /&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n...\nmethods: {\nshowAttributes() {\nconsole.log('Id: ' + this.$attrs.id + ', Data: ' + this.$attrs['data-status'])\n}\n}\n...\n&lt;/script&gt;\n\nEl subcomponente se renderizará como:\n&lt;div class=&quot;fecha date-picker&quot; id=&quot;now&quot; data-status=&quot;activated&quot;&gt;\n&lt;input type=&quot;datetime&quot; /&gt;\n&lt;/div&gt;\n\ny al ejecutar el método showAttributes mostrará en la consola Id: now, Data: activated.\nA veces no queremos que esos atributos se apliquen al elemento raíz del subcomponente sino a alguno interno (habitual si le pasamos escuchadores de eventos). En ese caso podemos deshabilitar la herencia de parámetros definiendo el atributo del componente inheritAttrs a false y aplicándolos nosotros manualmente:\n&lt;!-- componente padre --&gt;\n&lt;date-picker id=&quot;now&quot; data-status=&quot;activated&quot; @input=&quot;dataChanged&quot;&gt;&lt;/date-picker&gt;\n\n// Componente hijo date-picker.vue\n&lt;template&gt;\n&lt;div class=&quot;date-picker&quot;&gt;\n&lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n...\ninheritAttrs: false,\n...\n&lt;/script&gt;\n\nEn este caso se renderizará como:\n&lt;div class=&quot;date-picker&quot;&gt;\n&lt;input type=&quot;datetime&quot; class=&quot;fecha&quot; id=&quot;now&quot; data-status=&quot;activated&quot; @input=&quot;dataChanged&quot; /&gt;\n&lt;/div&gt;\n\nEl componente padre está escuchando el evento input sobre el &lt;INPUT&gt; del componente hijo.\nEn Vue3, si el componente hijo tiene varios elementos raíz deberemos bindear los attrs a uno de ellos como acabamos de ver.\nEmitir eventos (de hijo a padre)\nSi un componente hijo debe pasarle un dato a su padre o informarle de algo puede emitir un evento que el padre capturará y tratará convenientemente. Para emitir el evento el hijo hace:\nthis.$emit('nombreEvento', parametro)\n\nEl padre debe capturar el evento como cualquier otro. En su HTML hará:\n&lt;my-component @nombre-evento=&quot;fnManejadora&quot; ... /&gt;\n\ny en su JS tendrá la función para manejar ese evento:\nmethods: {\nfnManejadora(param) {\n...\n},\n}\n...\n\nEl componente hijo puede emitir cualquiera de los eventos estándar de JS ('click', 'change', ...) o un evento personalizado ('cambiado', ...).\nIgual que un componente declara las props que recibe, también puede declarar los eventos que emite. Esto es opcional pero muy recomendable ya que proporciona mayor claridad al código:\n// TodoItem.vue\n...\nprops: {\ntodo: Object\n},\nemits: ['nombreEvento'],\n...\n\nEjemplo: continuando con la aplicación de tareas que dividimos en componentes, en el componente todo-item en lugar de hacer un alert emitiremos un evento al padre:\ndelTodo() {\nthis.$emit('delItem')\n},\n\ny en el componente todo-list lo escuchamos y llamamos al método que borre el item:\nexport default {\ntemplate: `\n&lt;div&gt;\n&lt;h2&gt;{{ title }}&lt;/h2&gt;\n&lt;ul&gt;\n&lt;todo-item\nv-for=&quot;(item, index) in todos&quot;\n:key=&quot;item.id&quot;\n:todo=&quot;item&quot;\n@del-item=&quot;delTodo(index)&quot;&gt;\n&lt;/todo-item&gt;\n&lt;/ul&gt;\n&lt;add-item&gt;&lt;/add-item&gt;\n&lt;br&gt;\n&lt;del-all&gt;&lt;/del-all&gt;\n&lt;/div&gt;`,\nmethods: {\ndelTodo(index){\nthis.todos.splice(index,1)\n},\n}\n}\n\n| Haz el ejercicio del tutorial de Vue.js\nDefinir y validar eventos\nComo hemos dicho, los eventos que emite un componente pueden (y se recomienda) definirse en la opción emits:\n// component todo-item.vue\n...\nemits: ['toogle-done', 'dblclick'],\nprops: ['todo'],\n...\n\nEs recomendable definir los argumentos que emite usando sintaxis de objeto en vez de array, similar a como hacemos con las props. Para ello el evento se asigna a una función que recibe como parámetro los parámetros del evento y devuelve true si es válido o false si no lo es:\ncustom-form.vue\n&lt;script&gt;\nemits: {\n// No validation\nclick: null,\n// Validate submit event\nsubmit: ({ email, password }) =&gt; {\nif (email &amp;&amp; password) {\nreturn true\n} else {\nconsole.warn('Invalid submit event payload!')\nreturn false\n}\n}\n},\n&lt;/script&gt;\n\nEn este ejemplo el componente emite click que no se valida y submit donde se valida que reciba 2 parámetros.\nCapturar el evento en el padre\nEn ocasiones (como en este caso) el componente hijo no hace nada más que informar al padre de que se ha producido un evento sobre él. En estos casos podemos hacer que el evento se capture directamente en el padre en lugar de en el hijo:\nComponente todo-list.vue\n&lt;template&gt;\n&lt;div&gt;\n&lt;h2&gt;{{ title }}&lt;/h2&gt;\n&lt;ul&gt;\n&lt;todo-item\nv-for=&quot;(item, index) in todos&quot;\n:key=&quot;item.id&quot;\n:todo=&quot;item&quot;\n@dblclick=&quot;delTodo(index)&quot;&gt;\n&lt;/todo-item&gt;\n...\n&lt;/template&gt;\n\nLe estamos indicando a Vue que el evento dblclick se capture en todo-list directamente por lo que el componente todo-item no tiene que capturarlo ni hacer nada:\nComponente todo-item.vue\n&lt;template&gt;\n&lt;li&gt;\n&lt;label&gt;\n...\n&lt;/template&gt;\n\nCompartir datos\nUna forma más sencilla de modificar datos de un componente desde otros es compartiendo los datos entre ellos. Definimos en un fichero .js aparte un objeto que contendrá todos los datos a compartir entre componentes, lo importamos y lo registramos en el data de cada componente que tenga que acceder a él. Ejemplo:\nFichero /src/store/index.js\nimport { reactive } from 'vue'\n\nexport const store = reactive({\nmessage: '',\nmyData: [],\n...\n})\n\nNOTA: En Vue3 para que la variable store sea reactiva (que la vista reaccione a los cambios que se produzcan en ella) hay que declararla con reactive si es un objeto o con ref si es un tipo primitivo (string, number, ...).\nFijaos que se declara el objeto store como una constante porque NO puedo cambiar su valor para que pueda ser usado por todos los componentes, pero sí el de sus propiedades.\nEn cada componente que necesite acceder a datos del store lo importamos y definimos dentro de computed las variables a las que queramos acceder. No lo hacemos en data porque allí declaro las variables locales del componente y estas está en el store.:\n\nComponente `compA.vue`\n```javascript\nimport { store } from '../store/'\n\nexport default {\ntemplate: `&lt;p&gt;Mensaje: { { message}} &lt;/p&gt;`,\ncomputed: {\nmessage() {\nreturn store.message\n}\n},\n...\n}\n\nY ya puedo acceder a la variable message del store desde el componente con this.message.\nEsta forma de trabajar tiene un grave inconveniente: como el valor de cualquier dato puede ser modificado desde cualquier parte de la aplicación es difícilmente mantenible y se convierte en una pesadilla depurar el código y encontrar errores.\nPara evitarlo usaremos un patrón de programación llamado Store pattern que veremos en el siguiente apartado.\n$root y $parent\nTodos los componentes tienen acceso a:\n\nlos parámetros que le han pasado como props (que no deberían cambiarse)\nsus variables locales, declaradas en data()\nsus variables calculadas, declaradas en computed\npero además tienen acceso a los datos y métodos definidos en la instancia de Vue (donde hacemos el Vue.createApp(), es decir, en el main.js) a los que accede desde el objeto $root\n\nPor ejemplo:\nVue.createApp({\ndata: {\nmessage: 'Hola',\n},\nmethods: {\ngetInfo() {\n...\n}).mount('#app')\n\nDesde cualquier componente podemos hacer cosas como:\nconsole.log(this.$root.message)\nthis.$root.message='Adios'\nthis.$root.getInfo()\n\nTambién es posible acceder a los datos y métodos del componente padre del actual usando $parent en lugar de $root.\nDe esta manera podríamos acceder directamente a datos del padre o usar la instancia de Vue como almacén (evitando crear el objeto store para compartir datos). Sin embargo, aunque esto puede ser útil en aplicaciones pequeñas, es difícil de mantener cuando nuestra aplicación crece por lo que se recomienda usar un Store pattern como veremos a continuación o Pinia si nuestra aplicación va a ser grande.\nStore pattern\nEs una mejora sobre lo que hemos visto de compartir datos. Para evitar que todos los componentes puedan modificar los datos compartidos en el almacén, las acciones que modifican dichos datos están incluidas dentro del propio almacén, lo que facilita su seguimiento:\nFichero /src/store/index.js\nimport { reactive } from 'vue'\n\nexport const store = {\ndebug: true,\nstate: reactive({\nmessage: '',\n...\n}),\nsetMessageAction (newValue) {\nif (this.debug) console.log('setMessageAction triggered with ', newValue)\nthis.state.message = newValue\n},\nclearMessageAction () {\nif (this.debug) console.log('clearMessageAction triggered')\nthis.state.message = ''\n}\n}\n\nComponente compA.vue\nimport { store } from '../store/'\n\nexport default {\ntemplate: `&lt;p&gt;Mensaje: { { message}} &lt;/p&gt;`,\ncomputed: {\nmessage() {\nreturn store.state.message,\n}\n},\n...\n}\n\nFijaos que lo declaramos como computed porque es una varable calculada: una variable que está en otro sitio.\nComponente compB.vue\nimport { store } from '/src/datos.js'\n...\nmethods: {\ndelMessage() {\nstore.clearMessageAction()\n}\n},\n...\n\nNOTA: no debemos guardar todos los datos en el store sólo los datos de aplicación (aquellos que utiliza más de un componente). Los datos privados de cada componente seguiremos declarándolos en su data.\nPinia\nHemos visto que con un store pattern se simplifica mucho la gestión de los datos de aplicación y al centralizar los métodos que modifican los datos tengo control sobre los cambios producidos. Sin embargo en un componente puedo seguir escribiendo código que manipule los datos del almacén directamente, sin usar los métodos del almacén. Pinia básicamente es un store pattern donde parte del trabajo de definirlo ya está hecho y que me obliga a usarlo para mainular los datos de aplicación (con él no puedo cambiarlos directamente desde un componente). Además se integra perfectamente con las DevTools por lo que es muy sencillo seguir los cambios producidos.\nSe trata de una librería para gestionar los estados en una aplicación Vue. Ofrece un almacenamiento centralizado para todos los componentes con unas reglas para asegurar que un estado sólo cambia de determinada manera. Es el método a utilizar en aplicaciones medias y grandes y le dedicaremos todo un tema más adelante. En Vue2 y anteriores la librería que se usaba es Vuex.\nLo veremos en detalle en la unidad dedicada a esta librería.\nSlots\nOtra forma en que un componente hijo puede mostrar información del padre es usando slots. Un slot es un hueco en un componente que, al renderizarse, se rellena con lo que le pasa el padre en el innerHTML de la etiqueta del componente. El slot tiene acceso al contexto del componente padre, no al del componente donde se renderiza. Los slots son una herramienta muy potente. Podemos obtener toda la información en la documentación de Vue.\nEjemplo:\nTenemos un componente llamado my-component con un slot:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h3&gt;Componente con un slot&lt;/h3&gt;\n&lt;slot&gt;&lt;p&gt;Esto se verá si no se pasa nada al slot&lt;/p&gt;&lt;/slot&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nSi llamamos al componente con:\n&lt;my-component&gt;\n&lt;p&gt;Texto del slot&lt;/p&gt;\n&lt;/my-component&gt;\n\nse renderizará como:\n&lt;div&gt;\n&lt;h3&gt;Componente con un slot&lt;/h3&gt;\n&lt;p&gt;Texto del slot&lt;/p&gt;\n&lt;/div&gt;\n\nPero si lo llamamos con:\n&lt;my-component&gt;\n&lt;/my-component&gt;\n\nse renderizará como:\n&lt;div&gt;\n&lt;h3&gt;Componente con un slot&lt;/h3&gt;\n&lt;p&gt;Esto se verá si no se pasa nada al slot&lt;/p&gt;\n&lt;/div&gt;\n\n| Haz el ejercicio del tutorial de Vue.js\nUn ejemplo más util de slot es el siguiente: queremos hacer un componente que renderice una fila de una tabla donde mostrar los datos de un usuario. Tendremos una última columna donde poner unos botones para realizar acciones sobre ese usuario pero esos botones variarán en función de la página donde se muestre la tabla. Para ello usaremos slots:\n&lt;template&gt;\n&lt;tr&gt;\n&lt;td&gt;{{ user.name }}&lt;/td&gt;\n&lt;td&gt;{{ user.email }}&lt;/td&gt;\n&lt;td&gt;{{ user.age }}&lt;/td&gt;\n&lt;td&gt;\n&lt;slot&gt;&lt;/slot&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/template&gt;\n\nDonde queremos mostrar un usuario con botones para editar y borrar haremos:\n&lt;user-row :user=&quot;user&quot;&gt;\n&lt;button @click=&quot;editUser&quot;&gt;Editar&lt;/button&gt;\n&lt;button @click=&quot;deleteUser&quot;&gt;Borrar&lt;/button&gt;\n&lt;/user-row&gt;\n\ny donde queremos mostrarlo sólo con un botón para ver más detalles haremos:\n&lt;user-row :user=&quot;user&quot;&gt;\n&lt;button @click=&quot;showDetails&quot;&gt;Detalles&lt;/button&gt;\n&lt;/user-row&gt;\n\nSlots con nombre\nA veces nos interesa tener más de un slot en un componente. Para saber qué contenido debe ir a cada slot se les da un nombre.\nVamos a ver un ejemplo de un componente llamado base-layout con 3 slots, uno para la cabecera, otro para el pie y otro principal:\n&lt;div class=&quot;container&quot;&gt;\n&lt;header&gt;\n&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n&lt;/header&gt;\n&lt;main&gt;\n&lt;slot&gt;&lt;/slot&gt;\n&lt;/main&gt;\n&lt;footer&gt;\n&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\n&lt;/footer&gt;\n&lt;/div&gt;\n\nA la hora de llamar al componente hacemos:\n&lt;base-layout&gt;\n&lt;template v-slot:header&gt;\n&lt;h1&gt;Here might be a page title&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;template v-slot:default&gt;\n&lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n&lt;p&gt;And another one.&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;template v-slot:footer&gt;\n&lt;p&gt;Here's some contact info&lt;/p&gt;\n&lt;/template&gt;\n&lt;/base-layout&gt;\n\nLa directiva v-slot tiene una abreviatura que es # de forma que podríamos haber puesto &lt;template #header&gt;.\nPodría no ponerse el template #default y funcionaría igual: lo que está dentro de un template con v-slot irá al slot del componente con ese nombre. El resto del innerHTML irá al slot por defecto (el que no tiene nombre).\nLa directiva v-slot podemos ponérsela a cualquier etiqueta (no tiene que ser &lt;template&gt;):\n&lt;base-layout&gt;\n&lt;h1 v-slot=&quot;header&quot;&gt;Here might be a page title&lt;/h1&gt;\n\n&lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n&lt;p&gt;And another one.&lt;/p&gt;\n\n&lt;p slot=&quot;footer&quot;&gt;Here's some contact info&lt;/p&gt;\n&lt;/base-layout&gt;\n\nAcceder a datos del hijo desde el padre con slot\nEl componente hijo puede hacer accesibles sus variables al padre declarándolas en su etiqueta &lt;slot&gt;:\n&lt;!-- ChildComponent --&gt;\n&lt;div&gt;\n&lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;\n&lt;/div&gt;\n\n&lt;!-- ParentComponent --&gt;\n&lt;child-component v-slot={ text, count }&gt;\n{{ text }}: {{ count }}\n&lt;/child-component&gt;\n\nEsto es particularmente útil en componentes hijos que muestran un array de datos (con un v-for) si queremos acceder con el padre a cada dato.\nPodéis profundizar en el uso de slots en la documentación oficial de Vue.\nAplicación de ejemplo\nVamos a hacer que funcione la aplicación que tenemos hecha con SFC y Store pattern. Para ello vamos a crear un store que contendrá el array de tareas y los métodos para añadir, borrar y cambiar el estado de las tareas, así como para borrarlas todas.\nEn el componente todo_list debemos incluir el array todos lo que haremos en su computed. El resto de componentes no necesitan acceder al array, pero sí llamarán a los métodos para cambiarlo.\nRespecto al todo-item debe cambiar los datos tanto al hacer doble click (se borra la tarea) como al marcar/desmarcar el checkbox (se cambia el estado de la tarea).",
		"tags": ["header", "default", "note"]
},

{
		"title": "04-axios",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/04-axios/",
		"content": "Tabla de contenidos\n\nAxios\n\nInstalación\nUsar axios\nAplicación de ejemplo\n\nPedir los datos al cargarse\nBorrar un todo\nAñadir un todo\nActualizar el campo done\nBorrar todas las tareas\n\nOrganizar las peticiones\n\nApi con varias tablas\nApi como clase\nEl fichero .env\n\nAxios interceptors\n\nAxios\nEl framework Vue sólo se ocupa de la capa de vista de la aplcación pero su &quot;ecosistema&quot; como sus creadores le llaman, incluye multitud de herramientas para todo lo que podamos necesitar a la hora de realizar grandes proyectos.\nUna de las librerías más utilizadas es la que permite realizar de forma sencilla peticiones Ajax a un servidor. Existen múltiples librerías para ello y la más utilizada es axios.\nPodríamos hacer peticiones Ajax como vimos en Javascript (con fetch y async/await) pero es más sencillo con axios. Axios ya devuelve los datos transformados a JSON en una propiedad llamada data.\nInstalación\nComo esta librería vamos a usarla en producción la instalaremos como dependencia del proyecto:\nnpm install axios -S\n\nUsar axios\nEn el componente en que vayamos a usarla la importaremos:\nimport axios from 'axios'\n\nComo es una dependencia incluida en el package.json no se indica su ruta (se buscará en node-modules).\nYa podemos hacer peticiones Ajax en el componente. Para ello axios incluye los métodos:\n\n.get(url): realiza una petición GET a la url pasada como parámetro que supondrá una consulta SELECT a la base de datos\n.post(url, objeto): realiza una petición POST a la url pasada como parámetro que posiblemente realizará un INSERT del objeto pasado como segundo parámetro\n.put(url, objeto): realiza una petición PUT a la url pasada como parámetro que posiblemente realizará un UPDATE sobre el registro indicado en la url que será actualizado con los datos del objeto pasado como segundo parámetro\n.delete(url): realiza una petición DELETE a la url pasada como parámetro que supondrá una consulta DELETE a la base de datos para borrar el registro indicado en la url\n\nEstos métodos devuelven una promesa por lo que al hacer la petición deberemos anteponerle el await o bien indicaremos con el método .then la función que se ejecutará cuando responda el servidor si la petición se resuelve correctamente y con el método .catch la función que se ejecutará cuando responda el servidor si ocurre algún error.\nLo que devuelve es un objeto que tiene, entre otras, las propiedades:\n\ndata: aquí tendremos los datos devueltos por el servidor\nstatus: obtendremos el código de la respuesta del servidor (200, 404, ...)\nstatusText: el texto de la respuesta del servidor ('Ok', 'Not found', ...)\nmessage: mensaje del servidor en caso de producirse un error\nheaders: las cabeceras HTTP de la respuesta\n...\n\nLa sintaxis de una petición GET a axios usando async/await sería algo como:\ntry {\nconst response = await axios.get(url)\nconsole.log(response.data)\n} catch (response) {\nconsole.error(response.message)\n}\n\ny usando promesas sería algo como:\naxios.get(url)\n.then(response =&gt; console.log(response.data))\n.catch(response =&gt; console.error(response.message))\n\nAplicación de ejemplo\nVamos a seguir con la aplicación de la lista de tareas pero ahora los datos no serán un array estático sino que estarán en un servidor. Usaremos como servidor para probar la aplicación json-server por lo que las peticiones serán a la URL 'localhost:3000' que es el servidor web de json-server.\nLos cambios que debemos hacer en nuestra aplicación son:\n\nEl componente principal (TodoList) pide todos los datos al cargarse\nAl borrar un elemento haremos una petición al servidor para que lo borre de allí y cuando sepamos que se ha borrado lo borramos del array (o recargamos los datos)\nLo mismo al insertar un nuevo elemento\nAl marcar/desmarcar un elemento lo modificaremos en la base de datos\nPara borrarlos todos haremos peticiones DELETE al servidor\n\nVamos a modificar los diferentes componentes para implementar os cambios requeridos:\nPedir los datos al cargarse\nModificamos el fichero TodoList.vue para añadir en su sección script:\n\nAntes del objeto vue:\n\nimport axios from 'axios'\n\nconst SERVER = 'http://localhost:3000'\n// o mejor, si usamos el fichero .env como vimos en Javascript\n// const SERVER = import.meta.env.VITE_URL_API\n\nDentro del objeto añadimos el hook mounted() para hacer la petición Ajax al montar el componente (recordad que esa función se ejecuta automáticamente cuando se acaba de renderizar el componente):\n\n...\nasync mounted() {\ntry {\nconst response = await axios.get(SERVER + '/todos')\nthis.todos = response.data\n} catch (response) {\nalert('Error: ' + response.message)\nthis.todos=[]\n}\n},\n...\n\nBorrar un todo\nModificamos el método delTodo del fichero Todo-List.vue:\nasync delTodo(index){\nconst id = this.todos[index].id\ntry {\nawait axios.delete(SERVER + '/todos/' + id)\nthis.todos.splice(index, 1)\n} catch (response) {\nalert('Error: no se ha borrado el registro. ' + response.message)\n}\n},\n\nAñadir un todo\nModificamos el método addTodo del fichero Todo-List.vue:\nasync addTodo(title) {\ntry {\nconst response = await axios.post(SERVER + '/todos', {\ntitle: title,\ndone: false\n})\nthis.todos.push(response.data)\n} catch (response) {\nalert('Error: no se ha añadido el registro. ' + response.message)\n}\n},\n\nAl servidor hay que pasarle como parámetro el objeto a añadir. En el caso de json-server devolverá en el response.data el nuevo objeto añadido al completo. Otras APIs devuelven sólo la id del nuevo registro o pueden no devolver nada.\nActualizar el campo done\nAhora ya no nos es útil el índice de la tarea a actualizar sino que necesitamos su id, su título y su estado así que modificamos el template del fichero TodoList.vue para pasar el elemento entero a la función:\n&lt;todo-item\nv-for = &quot;(item,index) in todos&quot;\n:key = &quot;item.id&quot;\n:todo = &quot;item&quot;\n@delItem = &quot;delTodo(index)&quot;\n@doneChanged = &quot;toogleDone(item)&quot;&gt;\n&lt;/todo-item&gt;\n\nA continuación modificamos el método changeTodo del fichero TodoList.vue:\nasync toogleDone(todo) {\ntry {\nconst response = await axios.patch(SERVER + '/todos/' + todo.id, {\ndone: !todo.done\n})\ntodo.done = response.data.done\n} catch (response) {\nalert('Error: no se ha modificado el registro. ' + response.message)\n}\n},\n\nBorrar todas las tareas\nModificamos el método delTodos del fichero TodoList.vue. Como el servidor no tiene una llamada para borrar todos los datos podemos recorrer el array todos y borrar cada tarea usando el método delTodo que ya tenemos hecho:\ndelTodos() {\nthis.todos.forEach((todo, index) =&gt; this.delTodo(index))\n}\n\nEsto no tiene mucho sentido y si necesito borrar todos los datos de la base de datos lo mejor es que la API me proporcione un método para borrarlos todos.\nSi lo probáis este código con muchos registros es posible que no se borren todos correctamente (en realidad sí se borran de la base de datos pero no del array). ¿Sabes por qué?. ¿Cómo lo podemos arreglar? (PISTA: el índice cambia según los elementos que haya y las peticiones asíncronas pueden no ejecutarse en el orden que esperamos).\nOrganizar las peticiones\nQue cada componente haga llamadas a axios tiene el inconveniente de que cada uno crea su propia instancia, además de que tenemos las peticiones a la API desperdigadas por el código. Para mejorar la legibilidad del código vamos a crear un fichero que será donde estén las peticiones a axios de forma que nuestros componentes queden más limpios. Otra ventaja de centralizar las peticiones es que cosas como la URL a la que hacer la petición la definimos en un único sitio.\nPodríamos llamar al fichero repositories/todosRepository.js y allí creamos las funciones que laman a la API:\nimport axios from 'axios'\n\nconst apiClient = axios.create({\n// Esta parte es opcional. Estamos creando un 'axios' personailizado con las opciones\n// que necesitemos para no tener que indicarlas cada vez. En concreto:\n// - baseURL: lo que antecederá a la ruta de cada petición\n// - headers.Accept: el tipo de datos que esperamos obtener (no es necesario\n// porque JSON es la opción por defecto)\n// - headers.Content-type: el tipo de datos que estamos pasando al servidor (no es\n// necesario porque JSON es la opción por defecto)\n// - headers.Authorization: el token que enviaremos junto a cada petición\nbaseURL: 'http://localhost:3000',\nheaders: {\nAccept: 'application/json',\n'Content-Type': 'application/json'\nAuthorization = 'Bearer ' + localStorage.token\n}\n})\n\nexport default {\ngetTodos() {\nreturn apiClient.get('/todos')\n},\n\ndelTodo(id){\nreturn apiClient.delete('/todos/' + id)\n},\n\naddTodo(newTodo) {\nreturn apiClient.post('/todos', newTodo)\n},\n\ntoogleDone(todo) {\nreturn apiClient.put('/todos/' + todo.id, {\nid: todo.id,\ntitle: todo.title,\ndone: !todo.done\n})\n},\n}\n\nEn primer lugar importamos axios y a continuación creamos una única instancia con las opciones que necesitemos. En este ejemplo estamos enviando al servidor el token del usuario con cada petición.\nEn cada componente que tenga que hacer una llamada a la API se importa este fichero y se llama a sus funciones:\nimport todosRepository from '../repositories/todosRepository'\n\nexport default {\n...\nmethods: {\nasync getData() {\ntry {\nconst response = await todosRepository.getTodos()\nthis.todos = response.data\n} catch (response) {\nconsole.error('Error: ' + response.message)\n}\n},\n...\n},\ncreated() {\nthis.getData()\n},\n}\n\nApi con varias tablas\nSi trabajamos con varias tablas podemos hacer un fichero de repositorio para cada una de ellas o bien podemos escribir lo mismo de antes pero de forma más concisa:\nimport axios from 'axios'\n\nconst apiClient = axios.create({\nbaseURL: 'http://localhost:3000',\nwithCredentials: false,\nheaders: {\nAccept: 'application/json',\n'Content-Type': 'application/json'\n}\n})\n\nconst todos = {\ngetAll: () =&gt; apiClient.get(`/todos`),\ngetOne: (id) =&gt; apiClient.get(`/todos/${id}`),\ncreate: (item) =&gt; apiClient.post(`/todos`, item),\nmodify: (item) =&gt; apiClient.put(`/todos/${item.id}`, item),\ndelete: (id) =&gt; apiClient.delete(`/todos/${id}`),\ntoogleDone: (item) =&gt; apiClient.put(`/categories/${item.id}`, {\nid: item.id,\ntitle: item.title,\ndone: !item.done\n}),\n}\n\nconst categories = {\ngetAll: () =&gt; apiClient.get(`/categories`),\ngetOne: (id) =&gt; apiClient.get(`/categories/${id}`),\ncreate: (item) =&gt; apiClient.post(`/categories`, item),\nmodify: (item) =&gt; apiClient.put(`/categories/${item.id}`, item),\ndelete: (id) =&gt; apiClient.delete(`/categories/${id}`),\n}\n\nexport default {\ntodos,\ncategories,\n}\n\nY en los componentes donde queramos usarlo importamos el fichero y llamamos a las funciones que necesitemos:\nimport apiService from '../apiService'\n\nexport default {\nmethods: {\nasync getData() {\ntry {\nconst response = await apiService.todos.getAll()\nthis.todos = response.data\n} catch (response) {\nconsole.error('Error: ' + response.message)\n}\n},\n},\n}\n\nApi como clase\nTambién podemos usar programación orientada a objetos para hacer nuestra ApiService y construir una clase que se ocupe de las peticiones a la API:\nimport axios from 'axios'\n\nconst apiClient = axios.create({\nbaseURL: 'http://localhost:3000',\nwithCredentials: false,\nheaders: {\nAccept: 'application/json',\n'Content-Type': 'application/json'\n}\n})\n\nexport default class APIService{\nconstructor(){\n}\ngetTodos() {\nreturn apiClient.get('/todos')\n}\ndelTodo(id){\nreturn apiClient.delete('/todos/'+id)\n},\naddTodo(newTodo) {\nreturn apiClient.post('/todos', newTodo)\n},\ntoogleDone(todo) {\nreturn apiClient.put('/todos/'+todo.id, {\nid: todo.id,\ntitle: todo.title,\ndone: !todo.done\n})\n},\n}\n\nY en los componentes donde queramos usarlo importamos la clase y creamos una instancia de la misma:\nimport APIService from '../APIService'\n\nconst apiService = new APIService()\n\nexport default {\nmethods: {\nasync getData() {\ntry {\nconst response = await apiService.getAll()\nthis.todos = response.data\n} catch (response) {\nconsole.error('Error: ' + response.message)\n}\n},\n},\n}\n\nEl fichero .env\nSe trata de un fichero donde guardar las configuraciones de la aplicación y la ruta del servidor es una constante que estaría mejor en este fichero que en el código como hemos hecho nosotros.\nVue por medio de Vite puede acceder a todas las variables de .env que comiencen por VITE_ por medio del objeto import.meta.env por lo que en nuestro código en vez de darle el valor a baseURL podríamos haber puesto:\nconst apiClient = axios.create({\nbaseURL: import.meta.env.VITE_RUTA_API,\n...\n})\n\nY en el fichero .env ponemos\nVITE_RUTA_API=http://localhost:3000\n\nSi usamos Vue con webpack las variables de .env deben comenzar por VUE_APP_ y accedemos a ellas por medio del objeto process.env por lo que en el fichero .env definiríamos la variable VUE_APP_RUTA_API=http://localhost:3000 y en nuestro código pondría:\nconst apiClient = axios.create({\nbaseURL: process.env.VUE_APP_RUTA_API,\n...\n})\n\nEl fichero .env por defecto se sube al repositorio por lo que no debemos poner información sensible (como usuarios o contraseñas). Para ello tenemos un fichero .env.local que no se sube, o bien debemos añadir al .gitignore dicho fichero. En cualquier caso, si el fichero con la configuración no lo subimos al repositorio es conveniente tener un fichero .env.exemple, que sí se sube, con valores predeterminados para las distintas variables que deberán cambiarse por los valores adecuados en producción. Además del .env y el .env.local también hay distintos ficheros que son usados en desarrollo (.env.development) y en producción (.env.production) y que pueden tener distintos datos según el entorno en que nos encontramos. Por ejemplo en el de desarrollo el valor de VUE_APP_RUTA_API podría ser &quot;http://localhost:3000&quot; si usamos json-server mientras que en el de producción tendríamos la ruta del servidor de producción de la API.\nAxios interceptors\nPodemos hacer que se ejecute código antes de cualquier petición a axios o tras recibir la respuesta del servidor usando los interceptores de axios. Es otra forma de enviar un token que nos autentifique ante una API sin tener que ponerlo en el código de cada petición, pero también nos permite hacer cualquier cosa que necesitemos.\nY podemos interceptar las respuestas para, por ejemplo, redireccionar a la página de login si el servidor nos devuelve un error 401 (no autorizado).\nPara interceptar las peticiones que hacemos usaremos axios.interceptors.request.use( (config) =&gt; fnAEjecutar, (error) =&gt; fnAEjecutar) y para interceptar las respuestas del servidor axios.interceptors.response.use( (response) =&gt; fnAEjecutar, (error) =&gt; fnAEjecutar). Se les pasa como parámetro la función a ejecutar si todo es correcto y la que se ejecutará si ha habido algún error. El interceptor de peticiones recibe como parámetro un objeto con toda la configuración de la petición (incluyendo sus cabeceras) y el interceptor de respuestas recibe la respuesta del servidor.\nVeamos un ejemplo en que queremos enviar en las cabeceras de cada petición el token que tenemos almacenado en el LocalStorage y queremos mostrar un alert siempre que el servidor devuelva en su respuesta un error que no sea de tipo 400. Además mostraremos por consola las peticiones y las respuestas si activamos el modo DEBUG:\nimport axios from 'axios'\nconst baseURL = 'http://localhost:3000'\nconst DEBUG = true\n\naxios.interceptors.request.use((config) =&gt; {\nif (DEBUG) {\nconsole.info('Request: ', config)\n}\n\nconst token = localStorage.token\nif (token) {\nconfig.headers['Authorization'] = 'Bearer ' + localStorage.token\n}\nreturn config\n}, (error) =&gt; {\nif (DEBUG) {\nconsole.error('Request error: ', error)\n}\nreturn Promise.reject(error)\n})\n\naxios.interceptors.response.use((response) =&gt; {\nif (DEBUG) {\nconsole.info('Response: ', response)\n}\nreturn response\n}, (error) =&gt; {\nif (error.response &amp;&amp; error.response.status !== 400) {\nalert('Response error ' + error.response.status + '(' + error.response.statusText + ')')\n}\nif (DEBUG) {\nconsole.info('Response error: ', error)\n}\nreturn Promise.reject(error)\n})\n\nconst categories = {\ngetAll: () =&gt; axios.get(`${baseURL}/categories`),\ngetOne: (id) =&gt; axios.get(`${baseURL}/categories/${id}`),\ncreate: (item) =&gt; axios.post(`${baseURL}/categories`, item),\nmodify: (item) =&gt; axios.put(`${baseURL}/categories/${item.id}`, item),\ndelete: (id) =&gt; axios.delete(`${baseURL}/categories/${id}`),\n}\n\nexport default {\ncategories,\n}",
		"tags": [ "note"]
},

{
		"title": "05-vue-router",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/05-vue-router/",
		"content": "Vue-router\n\nVue-router\n\nIntroducción\nInstalación\n\nAñadir vue-router a un proyecto ya creado\n\nCrear las rutas\n\nRutas dinámicas\nOpciones de cada ruta\n\nCrear un menú\nSaltar a una ruta\nPaso de parámetros\nEl objeto $route\nRuta no encontrada: 404 Not found\nRedireccionamiento\nCambio de parámetros en una ruta\nVistas con nombre y Subvistas\n\nIntroducción\nComo comentamos al principio Vue nos va a permitir crear SPA (Single Page Applications) lo que significa que sólo se cargará una pagina: index.html. Sin embargo nuestra aplicación estará dividida en diferentes vistas que el usuario percibirá como si fueran páginas diferentes y el encargado de gestionar la navegación entre estas vistas/páginas es vue-router que es otra de las librerías del &quot;ecosistema&quot; de Vue (en este caso realizada por los desarrolladores de Vue).\nEn resumen, en nuestra aplicación (normalmente en el App.vue) tendremos una etiqueta &lt;router-view&gt; y lo que hará vue-router es cargar en esa etiqueta el componente que corresponda en función de la ruta que haya en la barra de direcciones del navegador. Por ejemplo si la URL es /products cargará un componente llamado ProductsTable (que mostrará una tabla con todos los productos de la aplicación) y si la URL es /newprod cargará un componente llamado ProductForm con un formulario para añadir un nuevo producto.\nLo que hacemos para configurar vue-router es definir rutas que mapean componentes de nuestra aplicación a rutas URL de forma que cuando se pone determinada ruta en el navegador se carga en nuestra página el componente indicado. También permite tener subrutas que mapeen subcomponentes dentro de otros.\nInstalación\nLa forma más sencilla es escoger la opción de Vue-router al crear nuestro proyecto Vue. En ese caso no es necesario hacer nada porque se instala y configura todo automáticamente.\nAñadir vue-router a un proyecto ya creado\nSi queremos añadirlo a un proyecto ya creado previamente tendremos que instalarlo y configurarlo manualmente nosotros.\nLos pasos son:\n\nse instala el paquete vue-router como dependencia de producción:\n\nnpm install -S vue-router\n\nse crea el fichero de rutas, por ejemplo en /src/router/index.js. Aquí se define para cada ruta de nuestra aplicación el componente que debe cargarse. Su contenido es\n\nimport { createRouter, createWebHistory } from &quot;vue-router&quot;;\nimport HomeView from &quot;../views/HomeView.vue&quot;;\n\nconst router = createRouter({\nhistory: createWebHistory(import.meta.env.BASE_URL),\nroutes: [\n{\npath: &quot;/&quot;,\nname: &quot;home&quot;,\ncomponent: HomeView,\n},\n{\npath: &quot;/about&quot;,\nname: &quot;about&quot;,\n// route level code-splitting\n// this generates a separate chunk (About.[hash].js) for this route\n// which is lazy-loaded when the route is visited.\ncomponent: () =&gt; import(&quot;../views/AboutView.vue&quot;),\n},\n],\n});\n\nexport default router;\n\nse importa dicho fichero en el main.js para que el almacén esté disponible para todos los componentes en la variable this.$router:\n\nimport { createApp } from &quot;vue&quot;;\nimport App from &quot;./App.vue&quot;;\nimport router from &quot;./router&quot;; // &lt;---\n\nconst app = createApp(App);\napp.use(router);\napp.mount(&quot;#app&quot;);\n\nen el scaffolding del proyecto es recomendable crear una nueva carpeta views donde guardar las distintas vistas de nuestra aplicación, que son componentes que renderizan una &quot;página&quot; de la aplicación (es decir, nuestros componentes ahora se dividen en 2 tipos: los que renderizan una &quot;página&quot;, que irán a Views y los que son parte de una página, que irán a Components).\n\nCrear las rutas\nLas rutas de nuestra aplicación las definiremos en un fichero Javascript (por defecto /src/router/index.js). Allí creamos la instancia para nuestras rutas (el objeto que exportamos) y la configuramos. También debemos importar todos los componentes que definamos en el router:\nimport { createWebHistory, createRouter } from 'vue-router'\n\n// Importamos los componentes que se carguen en alguna ruta\nimport AppHome from './components/AppHome.vue'\nimport AppAbout from './components/AppAbout.vue'\nimport UsersTable from './components/UsersTable.vue'\nimport UserNew from './components/UserNew.vue'\nimport UserEdit from './components/UserEdit.vue'\n\nconst routes = [\n{\npath: '/',\nname: 'home',\ncomponent: AppHome\n},{\npath: '/about',\nname: about,\ncomponent: AppAbout\n},{\npath: '/users',\ncomponent: UsersTable\n},{\npath: '/new',\ncomponent: UserNew\n},{\npath: '/edit/:id',\ncomponent: UserEdit\nprops: true\n}\n];\n\nconst router = createRouter({\nhistory: createWebHistory(import.meta.env.BASE_URL),\nroutes\n})\n\nexport default router\n\nCada vez que cambie la URL en el navegador no cambiará todo el layout sino que sólo se cargará en la etiqueta\n&lt;router-view&gt;&lt;/router-view&gt;\n\nel componente indicado para esa ruta. Dicha etiqueta estará normalmente en el fichero App.vue.\nEl modo 'history' de nuestro router indica que use rutas &quot;amigables&quot; y que no incluyan la # (piensa que en realidad no se están cargando diferentes páginas sino partes de una única página ya que es una SPA). Esta es la opción que escogeremos siempre en las aplicaciones SPA, aunque si nuestro servidor web usa ASP.NET o JSP habrá que decirle que ignore las URLs porque ya se ocupa de ellas Vue. La alternativa sería usar createWebHashHistory() pero en ese caso las rutas en vez de ser algo como http://localhost:8080/products serían http://localhost:8080/#products.\nRutas dinámicas\nVueRouter permite rutas dinámicas como la indicada para el componente UserEdit:\n{\npath: '/edit/:id',\ncomponent: UserEdit\n}\n\nEsa ruta coincidirá con cualquier URL que comience por /edit/ y tenga algo más. Lo que haya tras la última / lo asignará el router a una variable llamada id (el nombre que pongamos tras el carácter :) y dicha variable la recibirá el componente UserEdit en un parámetro accesible desde this.$route.params.id. Si añadimos a la ruta la opción props: true hacemos que el componente además reciba el parámetro en sus props (en este caso recibirá una variable llamada id que será accesible desde this.id directamente).\nOpciones de cada ruta\nPara cada ruta que queramos mapear hay que definir:\n\npath: la url que hará que se cargue el componente\ncomponent: el componente que se cargará donde se encuentre la etiqueta &lt;router-view&gt; en el HTML\n\nAdemás de esas propiedades podemos indicar:\n\nname: le damos a la ruta un nombre que luego podemos usar para referirnos a ella\nprops: se usa en rutas dinámicas e indica que el componente recibirá el parámetro de la ruta en sus props. Si no se incluye esta opción el componente tendrá que acceder al parámetro id desde this.$route.params.id\n\nCrear un menú\nSeguramente querremos un menú en nuestra SPA que nos permita ir a las diferentes rutas (que provocarán que se carguen los componentes). Para ello usaremos la etiqueta &lt;router-link&gt;. Ejemplo:\n&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;\n&lt;router-link to=&quot;/about&quot;&gt;Acerca de...&lt;/router-link&gt;\n\nCuando accedemos a una ruta su elemento &lt;router-link&gt; adquiere la clase .router-link-active.\nSi le hemos puesto la propiedad name a una ruta podemos hacer un enlace a ella con\n&lt;router-link :to=&quot;{name: 'nombre_de_la_ruta'}&quot;&gt;Home&lt;/router-link&gt;\n\nFijaos que hemos de bindear el atributo to porque ya no le pasamos texto sino una variable.\nSe podría hacer (aunque no es normal) una opción de menú a una ruta dinámica y pasarle el parámetro deseado. Por ejemplo para editar el usuario 5 haríamos:\n&lt;router-link :to=&quot;{name: 'edit', params: {id: 5}}&quot;\n&gt;Editar usuario 5&lt;/router-link\n&gt;\n\nEn este caso es necesario que la ruta dinámica tenga un name.\nSaltar a una ruta\nAl hacer .use(router) en el fichero main.js estamos declarando esa variable (router) en la instancia principal de la aplicación por lo que estará disponible para todos los componentes desde this.$router. Esto nos permite acceder al router desde un componente para, por ejemplo, cambiar a una ruta.\nEl código para cambiar la ruta desde Javascript es\nthis.$router.push(ruta);\n\nTenemos varios métodos para navegar por código:\n\n.push(newUrl): salta a la ruta newUrl y la añade al historial\n.replace(newURL): salta a la nueva ruta pero reemplaza en el historial la ruta actual por esta\n.go(num): permite saltar el num. de páginas indicadas adelante (ej. this.$router.go(1)) o atrás (.go(-1)) por el historial\n\nEstos métodos son equivalentes a los métodos history.push(), history.replace() y history.go() de Javascript.\nAdemás podemos pasar a push() y replace() funciones callback que se ejecutarán al cambiar la ruta si todo va bien o si hay algún error.\nthis.$router.push(location, onComplete?, onAbort?)\n\nTambién podemos obtener toda la ruta con this.$route.fullPath.\nPaso de parámetros\nLa forma de pasar parámetros a la ruta es:\nthis.$router.push({ name: &quot;users&quot;, params: { id: 123 } });\n\nesto hace que se salte a la ruta con name &quot;users&quot; y le pasa como parámetro una id de valor 123. En el componente que se cargue en dicha ruta obtendremos el parámetro pasado con this.$route.params.nombreparam (en el ejemplo en this.$route.params.id obtenemos el valor 123).\nSe puede pasar más de un parámetro pero para que los pueda recibir el componente hay que ponerlos todos en el router. Por ejemplo para hacer un this.$router.push({ name: 'books', params: { autor: 12, tema: 4 }})\nla ruta en el router debería contener ambas variables:\npath: &quot;/books/author/:autor/topic/:tema&quot;;\n\nPodemos pasar también un objeto como parámetro pero antes debemos convertirlo a texto con JSON.stringify(). Sin embargo no es muy conveniente porque la URL quedaría demasiado larga y &quot;sucia&quot;.\nTambién se puede pasar una query a la ruta:\nthis.$router.push({ path: &quot;/register&quot;, query: { plan: &quot;private&quot; } });\n\nsalta a la URL /register?plan=private. En el componente que se carga obtenemos la query pasada con this.$route.query (obtenemos un objeto, en el ejemplo { plan: 'private' }).\nIMPORTANTE: Tened en cuenta que lo que se pasa como parámetro o consulta aparecerá en la URL por lo que no debemos enviar información sensible y no se recomienda enviar algo muy largo (como un objeto o array) para evitar que la URL quede &quot;sucia&quot;.\nEl objeto $route\nEs un objeto que contiene información de la ruta actual (no confundir con $router). Algunas de sus propiedades son:\n\nparams: el objeto con los parámetros pasados a la ruta (puede haber más de uno)\nquery: si hubiera alguna consulta en la ruta (tras '?') se obtiene aquí un objeto con ellas\npath: la ruta pasada (sin servidor ni querys, por ejemplo de http://localhost:3000/users?company=5 devolvería '/users')\nfullPath: la ruta pasada (con las querys, por ejemplo de http://localhost:3000/users?company=5 devolvería '/users?company=5')\n\nRuta no encontrada: 404 Not found\nSi en nuestra aplicación cargamos una ruta que no coincide con ninguna de las definidas en el router no se cargará ningún componente en el RouterView.\nUna mejora de esto es crear una vista con lo que queramos mostrar ('404 - La página no existe' o algo similar) y hacer una ruta que cargue dicho componente.\nSi llamamos a esa vista PathNotFound.vue la ruta a crear sería:\n{\npath: '/:pathMatch(.*)*',\ncomponent: PathNotFound\n},\n\nEsta ruta hay que ponerla la última ya que coincidirá con cualquier URL (usa una expresión regular y la dice que la ruta coincida con '*').\nRedireccionamiento\nEn el router puedo también poner una ruta que haga una redirección a otra en lugar de cargar un componente.\n{\npath: '/a',\nredirect: '/b'\n},\n\nLo que hace es que si se pone una URL /a la cambia automáticamente a /b y se buscará una ruta que coincida con esa.\nTambién podemos poner alias a una ruta de forma que se cargue un componente tanto si la URL es una como otra (en este caso no se cambiaría la URL):\n{\npath: '/a',\ncomponent: A,\nalias: '/b'\n},\n\nPodés obtener más información en la documentación de Vue-router.\nCambio de parámetros en una ruta\nSi cambiamos a la misma ruta pero con distintos parámetros Vue reutiliza la instancia del componente y no vuelve a lanzar sus hooks (created, mounted, ...). Esto hará que no se ejecute el código que tengamos allí. Por ejemplo supongamos que en una ruta '/edit/5' al cargar el componente se pide el registro 5 y se muestra en la página. Si a continuación cargamos la ruta '/edit/8' seguiremos viendo los datos del registro 5).\nPodemos solucionar esto desde el router o desde el componente.\nDesde el router podemos usar el elemento beforeRouteUpdate y realizar allí la carga de los datos:\nbeforeRouteUpdate (to, from, next) {\n// Código que responde al cambio. En 'to' tenemos la ruta anterior y en 'from' la nueva\n// antes de acabar hay que llamar a next()\n// Aquí cargamos los nuevos datos\nnext();\n}\n\nDesde el componente podemos usar un watcher para detectar el cambio en la ruta:\nwatch: {\n'$route' (to, from) {\n// Aquí cargamos los nuevos datos\n}\n}\n\nCada vez que cambie el valor de $route se ejecutará ese código y recibirá en el parámetro to la nueva ruta y en from el valor anterior de la variable. Veremos los watchers más adelante o podéi consultar la documentación de Vue.\nVistas con nombre y Subvistas\nPodemos cargar más de un componente usando varias etiquetas &lt;router-view&gt;. Por ejemplo si nestra página constará de 3 componentes (uno en la cabecera, otro el principal y otro en un aside pondremos en el HTML:\n&lt;router-view class=&quot;cabecera&quot; name=&quot;top&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;main&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;aside&quot; name=&quot;aside&quot;&gt;&lt;/router-view&gt;```\n\nPara que se carguen los 3 componentes lo debemos indicar al definir las rutas:\n{\npath: '/',\ncomponents: {\ndefault: CompMain,\t\t// CompMain se cargará en el &lt;router-view&gt; sin nombre\ntop: CompCabecera,\naside: CompAside\n}\n}\n\nTambién un componente puede incluir su propia etiqueta &lt;router-view&gt; que cargue dentro de él un subcomponente en función de una subruta. Por ejemplo tenemos una ruta /user/:id que carga un componente User con el nombre y la imagen del usuario y debajo cargará, en función de la ruta:\n\n/user/:id: debajo cargará el componente con el home del usuario\n/user/:id/profile: debajo cargará el componente con el perfil del usuario\n/user/:id/posts: debajo cargará el componente con los posts del usuario\nDefiniremos la ruta del siguiente modo:\n\n{\npath: '/',\ncomponents: {\n{\npath: '/user/:id',\ncomponent: User,\nchildren: [\n{ path: '', component: UserHome },\n{ path: 'profile', component: UserProfile },\n{ path: 'posts', component: UserPosts }\n]\n}\n}\n}\n\nPodemos consultar toda la información referente al router de Vue en https://router.vuejs.org/.",
		"tags": [ "note"]
},

{
		"title": "06-profundizando",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/06-profundizando/",
		"content": "Profundizando en Vue\nTabla de contenidos\n\nProfundizando en Vue\n\nComputed\nWatchers\nAcceder al DOM: 'ref'\n\nnextTick\n\nClases HTML\n\nSintaxis de objeto\nSintaxis de array\nAsignar clases a un componente\nAsignar estilos directamente\n\nCiclo de vida del componente\n\nEl ciclo de vida de un componente\n\nComponentes asíncronos\nCustom Directives\nImágenes\nTransiciones\nEntornos\nGuards del router\n\nComputed\nCuando se crea un componente de Vue (o el componente raíz) se le pasa como parámetro un objeto con las opciones con que se creará. Entre ellas tenemos props, _ data_, methods, y también otras como computed y watch.\nHemos visto que en una interpolación o directiva podemos poner una expresión javascript. Pero si la expresión es demasiado compleja hace que nuestro HTML sea más difícil de leer. La solución es crear una expresión calculada que nos permite tener &quot;limpio&quot; el HTML. Por ejemplo un código con expresiones complejas como:\n&lt;template&gt;\n&lt;p&gt;Autor: { { author.name + ' ' + author.surname }}&lt;/p&gt;\n&lt;p&gt;Ha publicado libros: { { author.books.length &gt; 0 ? 'Sí' : 'No' }}&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'author-item',\ndata() {\nreturn {\nauthor: {\nname: 'John',\nsurname: 'Doe',\nbooks: [\n'Vue 2 - Advanced Guide',\n'Vue 3 - Basic Guide',\n'Vue 4 - The Mystery'\n]\n}\n}\n}\n}\n&lt;/script&gt;\n\nse puede simplificar creando propiedades calculadas:\n&lt;template&gt;\n&lt;p&gt;Autor: { { fullName }}&lt;/p&gt;\n&lt;p&gt;Ha publicado libros: { { hasPublished }}&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'author-item',\ndata() {\nreturn {\nauthor: {\nname: 'John',\nsurname: 'Doe',\nbooks: [\n'Vue 2 - Advanced Guide',\n'Vue 3 - Basic Guide',\n'Vue 4 - The Mystery'\n]\n}\n}\n},\ncomputed: {\nfullName() {\nreturn this.name + ' ' + this.surname;\n},\nhasPublished() {\nreturn this.author.books.length &gt; 0 ? 'Sí' : 'No'\n}\n}\n})\n&lt;/script&gt;\n\nEn lugar de definir computed podríamos haber obtenido el mismo resultado usando métodos, pero la ventaja de las propiedades calculadas es que se cachean por lo que si se vuelven a tener que renderizar en el DOM no vuelven a evaluarse, a menos que cambie el valor de alguna de las variables reactivas que use.\n| Haz el ejercicio del tutorial de Vue.js\nPor defecto las propiedades computed sólo hacen un getter, por lo que no se puede cambiar su valor. Pero podemos si queremos hacerlo definir métodos getter y setter:\ncomputed: {\nfullName:\n// getter\nget() {\nreturn this.name + ' ' + this.surname;\n},\n// setter\nset(newValue) {\nconst names = newValue.split(' ');\nthis.name = names[0];\nthis.surname = names[names.length - 1];\n}\n},\n},\n})\n\nSi hacemos this.fullName = 'John Doe' estaremos asignando los valores adecuados a las variables name y surname.\nWatchers\nVue proporciona una forma genérica de controlar cuándo cambia el valor de una variable reactiva para poder ejecutar código en ese momento poniéndole un watch:\ndata() {\nreturn {\nname: 'John',\nsurname: 'Doe',\nfullName: 'John Doe',\n}\n},\nwatch: {\nname(newValue, oldValue) {\nthis.fullName = newValue + ' ' + this.surname;\n},\nsurname(newValue, oldValue) {\nthis.fullName = this.name + ' ' + newValue;\n},\n},\n})\n\nEn este caso no tiene mucho sentido y es más fácil (y más eficiente) usar una propiedad computed como hemos visto antes, pero hay ocasiones en que necesitamos ejecutar código al cambiar una variable y es así donde se usan. Veremos su utilidad cuando trabajemos con vue-router.\nNOTA: los watcher son costosos por lo que no debemos abusar de ellos\n| Haz el ejercicio del tutorial de Vue.js\nAcceder al DOM: 'ref'\nAunque Vue se encarga de la vista por nosotros en alguna ocasión podemos tener que acceder a un elemento del DOM. En ese caso no haremos un document.getElement... sino que le ponemos una referencia al elemento con el atributo ref para poder acceder al mismo desde nuestro script:\n&lt;template&gt;\n&lt;form ref=&quot;myForm&quot;&gt;\n...\n&lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nmounted() {\nthis.$refs.myForm.setAttribute('novalidate', true)\n}\n}\n&lt;/script&gt;\n\nDesde el código tenemos acceso a todas las referencias desde this.$refs. Hay que tener en cuenta que sólo se puede acceder a un elemento después de montarse el componente (en el hook mounted() o después).\n| Haz el ejercicio del tutorial de Vue.js\nnextTick\nSi modificamos una variable reactiva el cambio se refleja automáticamente en el DOM, pero no inmediatamente sino que se espera hasta el evento nextTick en el ciclo de modificación para asegurarse de no cambiar algo que quizá va a volverse a cambiar en este ciclo.\nSi accedemos al DOM antes de que se produzca este evento el valor aún será el antiguo. Para obtener el nuevo valor hemos de esperar al nextTick:\n&lt;template&gt;\n&lt;p&gt;Contador: &lt;span ref=&quot;contador&quot;&gt;{ { count }}&lt;/span&gt;&lt;/p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementa&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ndata() {\nreturn {\ncount: 0\n}\n},\nmethods: {\nincrement() {\ncount.value++\nconsole.log('Contador en el DOM: ' + this.$refs.contador.textContent)\n// Devolverá el valor sin actualizar aún\nnextTick(() =&gt; {\nconsole.log('Contador en el DOM tras nextTick: ' + this.$refs.contador.textContent)\n// Devolverá el valor actualizado\n})\n}\n}\n}\n&lt;/script&gt;\n\nRealmente es algo que seguramente nunca necesitemos pero así conocemos un poco más cómo funciona Vue internamente.\nClases HTML\nYa hemos visto que en Javascript usamos las clases con mucha frecuencia, normalmente para asignar a elementos estilos definidos en el CSS, pero también para identificar elementos sin usar una id (como hacíamos poniendo a los botones de acciones de los productos las clases subir, bajar, editar o borrar).\nEn Vue tenemos diferentes formas de asignar clases. La más simple sería bindear el atributo class y gestionarlas directamente en el código, pero no es lo más cómodo:\n&lt;div :class=&quot;clasesDelDiv&quot;&gt;&lt;/div&gt;\n\nEn este caso tendríamos que asignar a la variables clasesDelDiv las diferentes clases separadas por espacio, lo que es engorroso de mantener.\nSintaxis de objeto\nUna forma más sencilla es bindear un objeto donde cada propiedad es el nombre de una posible clase y su valor es un booleano que indica si tendrá o no dicha clase, por ejemplo:\n&lt;div\nclass=&quot;static&quot;\n:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;\n&gt;&lt;/div&gt;\n\nEn este caso el &lt;DIV&gt; tendrá las clases:\n\nstatic: siemrpe tendrá esta clase. Como véis puede coexistir la directiva :class con el atributo class y se suman ambos\nactive: tendrá esta clase si el valor de la variable isActive es true\ntext-danger: ídem para la variable hasError. Si el nombre de una clase tiene más de una palabra hay que entrecomillarla\n\nPara mejorar la legibilidad del HTML podemos poner el objeto de las clases en el Javascript\n&lt;div\nclass=&quot;static&quot;\n:class=&quot;classObject&quot;\n&gt;&lt;/div&gt;\n\ndata() {\nreturn {\nclassObject: {\nactive: true,\n'text-danger': false\n}\n}\n}\n\nSintaxis de array\nPodemos indicar las clases en forma de array de variables que contienen la clase a asignar:\n&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n\ndata() {\nreturn {\nactiveClass: 'active',\nerrorClass: 'text-danger'\n}\n}\n\nEn este caso el &lt;DIV&gt; tendrá las clases active y text-danger.\nY es posible incluir sintaxis de objeto dentro de la sintaxis de array:\n&lt;div :class=&quot;[{ active: isActive}, errorClass]&quot;&gt;&lt;/div&gt;\n\nAsignar clases a un componente\nEn la etiqueta de un componente podemos ponerle un atributo class que le asignará las clases incluidas y que se sumaran a las que se le asignen dentro del propio componente. Por ejemplo, si el &lt;DIV&gt; del ejemplo anterior es el template de un componente llamado MyComponent puedo poner:\n&lt;my-component class=&quot;main highligth&quot;&gt;&lt;/my-component&gt;\n\nEn este caso el &lt;DIV&gt; tendrá las clases main, highligth, active si la variable isActive vale true y text-danger.\nEn Vue3 el template de un componente puede tener varios elementos raíz. En ese caso para indicar a cuál se aplicarán las clases definidas en el padre se usa la propiedad $attr.class:\n&lt;template&gt;\n&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;\n&lt;span&gt;This is a child component&lt;/span&gt;\n&lt;/template&gt;\n\nAsignar estilos directamente\nAunque no es lo recomendable, podemos asignar directamente estilos CSS igual que asignamos clases y también podemos usar la sintaxis de objeto o la de array.\n&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;\n\ndata() {\nreturn {\nactiveColor: 'red',\nfontSize: 30'\n}\n}\n\nCiclo de vida del componente\nEl ciclo de vida de un componente\nAl crearse la instancia de Vue o un componente la aplicación debe realizar unas tareas como configurar la observación de variables, compilar su plantilla (template), montarla en el DOM o reaccionar ante cambios en las variables volviendo a renderizar las partes del DOM que han cambiado. Además ejecuta funciones definidas por el usuario cuando sucede alguno de estos eventos, llamadas hooks del ciclo de vida.\nEn la siguiente imagen podéis ver el ciclo de vida de la instancia Vue (y de cualquier componente) y los eventos que se generan y que podemos interceptar:\n\nNOTA: En Vue2: los métodos beforeDestroyed y destroyed se usan en lugar de beforeUnmounted y unmounted.\nIMPORTANTE: no debemos definir estas funciones como arrow functions porque en estas funciones se enlaza en la variable this el componente donde se definen y si hacemos una arrow function no tendríamos this:\n// MAL, NO HACER ASÍ\ncreated: () =&gt; {\nconsole.log('instancia creada');\n}\n\n// BIEN, HACER ASÍ\ncreated() {\nconsole.log('instancia creada');\n}\n\nLos principales hooks son:\n\nbeforeCreate: aún no se ha creado el componente (sí la instancia de Vue) por lo que no tenemos acceso a sus variables, etc\ncreated: se usa por ejemplo para realizar peticiones a servicios externos lo antes posible\nbeforeMount: ya se ha generado el componente y compilado su template\nmounted: ahora ya tenemos acceso a todas las propiedades del componete. Es el sitio donde hacer una patición externa si el valor devuelto queremos asignarlo a una variable del componente\nbeforeUpdate: se ha modificado el componente pero aún no se han renderizado los cambios\nupdated: los cambios ya se han renderizado en la página\nbeforeUnmount: antes de que se destruya el componente (en versiones anteriores a Vue3 beforeDestroy)\nunmounted: ya se ha destruido el componente (en versiones anteriores a Vue3 destroyed)\n\n| Haz el ejercicio del tutorial de Vue.js\nComponentes asíncronos\nEn proyectos grandes con centenares de componentes podemos hacer que en cada momento se carguen sólo los componentes necesarios de manera que se ahorra mucho tiempo de carga de la página.\nPara que un componente se cargue asíncronamente al registrarlo se hace como un objeto que será una función que importe el componente. Un componente normal (síncrono) se registraría así:\n&lt;script&gt;\nimport ProductItem from './ProductItem.vue'\n\nexport default {\nname: 'products-table',\ncomponents: {\nProductItem,\n},\n...\n}\n&lt;/script&gt;\n\nSi queremos que se cargue asíncronamente no lo importamos hasta se registra:\n&lt;script&gt;\nexport default {\nname: 'products-table',\ncomponents: {\nProductItem: () =&gt; import('./ProductItem.vue'),\n},\n...\n}\n&lt;/script&gt;\n\nTambién podemos decirle que espere un tiempo a cargar el componente (delay) e incluso qué componente queremos cargar mientras está cargando el componente o cuál cargar si hay un error al cargarlo:\n&lt;script&gt;\nexport default {\nname: 'products-table',\ncomponents: {\nProductItem: () =&gt; ({\ncomponent: import('./ProductItem.vue'),\ndelay: 500, // en milisegundos\ntimeout: 6000,\nloading: compLoading, // componente que cargará mientras se está cargando\nerror: compError, // componente que cargará si hay un error,\n})\n},\n...\n}\n&lt;/script&gt;\n\nCustom Directives\nPodemos crear nuestras propias directivas para usar en los elementos que queramos. Se definen en un fichero .js con Vue.directive y le pasamos su nombre y un objeto con los estados en que queremos que reaccione. Por ejemplo vamos a hacer una directiva para que se le asigne el foco al elemento al que se la pongamos, que será de tipo input:\nimport Vue from 'vue'\n\nVue.directive('focus', {\nmounted(el) {\nel.focus();\n}\n})\n\nPara usarla en un componente la importamos y ya podemos usarla en el template:\n&lt;template&gt;\n...\n&lt;input v-focus type=&quot;text&quot; name=&quot;nombre&quot;&gt;\n...\n&lt;/template&gt;\n\n&lt;script&gt;\nimport focus from './focus.js'\n...\n}\n&lt;/script&gt;\n\nSi queremos utilizarla en muchos componentes podemos importarla en el main.js y así estará disponible para todos los componentes.\nLos estados de la directiva en los que podemos actuar son:\n\nmounted (en Vue2 inserted): cuando se inserte la directiva\nupdated (en Vue2 componentUpdated): cuando se actualice el componente que contiene la directiva\nbeforeMount (en Vue2 bind): cuando se enlaza la directiva al componente por primera vez, antes de montar el componente\n...\n\nImágenes\nSi se trata de imágenes estáticas lo más sencillo es ponerlas dentro de la carpeta public y hacer referencia a ellas usando ruta absoluta. Todo lo que está en public se referencia como si estuviera en la raíz de nuestra aplicación:\n&lt;img src=&quot;/img/elPatitoFeo.jpeg&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n\nTambién podemos poner las imágenes en la carpeta assets, pero antes de usarlas deberemos imnportarlas. Ejemplo:\n&lt;script&gt;\nimport imgUrl from './assets/img/elPatitoFeo.jpeg'\n...\n&lt;/script&gt;\n\n&lt;template&gt;\n...\n&lt;img :src=&quot;imgUrl&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n...\n&lt;/template&gt;\n\nNOTA: Si usamos webpack en lugar de Vite, en lugar de importarlas usaremos en su atributo src la función require con la URL de la imagen:\n&lt;img :src=&quot;require('../assets/img/elPatitoFeo.jpeg')&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n\nCon Vite también podemos importarlas usando import.meta.url (más información en la documentación de Vite):\n&lt;script&gt;\nexport default {\ndata() {\nreturn {\nimgUrl = new URL('./assets/elPatitoFeo.png', import.meta.url).href\n}\n},\n...\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n...\n&lt;img :src=&quot;imgUrl&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n...\n&lt;/template&gt;\n\nEsto nos permite también importar las imágenes dinámicamente:\n&lt;script&gt;\nexport default {\nmethods: {\nfunction getImageUrl(name) {\nreturn new URL(`./dir/${name}`, import.meta.url).href\n}\n}\n...\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n...\n&lt;img :src=&quot;getImageUrl(imgName)&quot; height=&quot;100px&quot;&gt;\n...\n&lt;/template&gt;\n\nEsto permitiría mostrar también imágenes obtenidas de una API.\nTransiciones\nVue permite controlar transiciones en nuestra aplicación poniendo el código CSS correspondiente y añadiéndole al elemento el atributo transition. Podemos encontrar más información en la documentación oficial de Vue.\nEntornos\nEn Vue tenemos normalmente 3 entornos o modos, el de development, el de test y el de production. Las variables de entorno las guardaremos en uno de los siguientes ficheros:\n\n.env: se cargan en todos los modos\n.env.local: se cargan en todos los modos pero son ignoradas por git\n.env.[modo]: se cargan sólo en el modo indicado\n.env.[modo].local: ídem pero son ignordas por git\n\nEn contenido de estos ficheros son variables en forma clave=valor:\n// fichero .env\nTITULO=Mi proyecto\nVITE_API=https://localhost/api\n\nSi el nombre de la variable comienza por VITE_ será accesible desde el código a través de import.meta.env.nombreVariable:\n// &lt;script&gt; de componente\nconsole.log(process.env.VITE_API);\n\nPodemos saber en qué entorno se está ejecutando la aplicación consultando el valor de la variable import.meta.env.MODE.\nSi no estamos usando Vite sino webpack el nombre de las variables debe comenzar por VUE_APP_ y será accesible desde el código con process.env.nombreVariable:\n// &lt;script&gt; de componente\nconsole.log(process.env.VUE_APP_API);\n\nGuards del router\nSon hooks que podemos controlar en distintos momentos, algunos desde el componente y otros desde el router. Podemos ponerlos para todas las rutas, para una ruta en concreto o en el componente.\nLa mayoría reciben 3 parámetros:\n\nto: ruta a la que se va a saltar\nfrom: ruta de la que se viene\nnext: función para que continue la carga del router. Siempre tras ejecutar el código que deseemos pondremos netx().\n\nEn el router tenemos estos guards:\n\nrouter.beforeEach(to, from, next): se ejecuta antes de que vaya a cambiarse la ruta\nrouter.afterEach(to, from): se ejecuta una vez cambiada la ruta (por eso no tiene next, porque ya ha acabado)\nruta.beforeEnter(to, from, next): se pone como propiedad de una ruta y se ejecuta antes de entrar a ella\n\nPara aplicarlos en nuestro router lo asignamos a una variable que exportamos:\nlet router = new Router({\nroutes: [\n{\npath: '/',\ncomponent: 'MyComponent',\nbeforeEnter(to, from, next) {\nconsole.log('Vengo de ' + from + ' y voy a ' + to);\nnext();\n},\n...\n})\n\nrouter.beforeEach(to, from, next) {\nconsole.log('Vengo de ' + from + ' y voy a ' + to);\nnext();\n}\n\nexport default router\n\nEn un componente también puedo definir los hooks:\n\nbeforeRouteEnter(to, from, next)\nbeforeRouteUpdate(to, from, next)\nbeforeRouteLeave(to, from, next)",
		"tags": [ "note"]
},

{
		"title": "07-pinia",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/07-pinia/",
		"content": "Pinia\nTabla de contenidos\n\nPinia\n\nIntroducción\nInstalar y configurar Pinia\nCrear un store\nUsar Pinia\n\nGetters\nActions\n\nstate en formularios\n\nIntroducción\nEs un 'State Management Pattern' basado en el patrón Flux que sirve para controlar el flujo de datos en una aplicación. Sustituye a la anterior librería usada en Vue 2 llamada Vuex.\nSegún la filosofía de Vue cada componente es una unidad funcional que contiene 3 partes:\n\nestado: los datos o source of truth que maneja en componente\nvista: la representación del estado que se ve en la aplicación\nacciones: la forma en que el estado puede cambiar para reaccionar a entradas del usuario en la vista\n\nPor ejemplo, el componente contador sería:\n&lt;script&gt;\nexport default {\n// state\ndata() {\nreturn {\ncount: 0\n}\n},\n// actions\nmethods: {\nincrement() {\nthis.count++\n}\n}\n}\n&lt;/script&gt;\n\n&lt;!-- view --&gt;\n&lt;template&gt;\n{{ count }}\n&lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;\n&lt;/template&gt;\n\nEsto es lo que se llama one-way data flow:\n\nEl problema lo tenemos cuando un componente necesita acceder a datos (state) de otro componente.\nEn Vue la comunicación entre componentes padre-hijo se hace hacia abajo mediante props y hacia arriba emitiendo eventos. Y vimos que si distintos componentes que no son padre-hijo tenían que compartir un mismo estado (acceder a los mismos datos) surgían problemas e intentamos solucionarlos con el patrón store pattern. Esto puede servir para pequeñas aplicaciones pero cuando crecen se hace difícil seguir los cambios. Para esos casos debemos usar Pinia, que proporciona un almacén de datos centralizado para todos los componentes de la aplicación y asegura que los datos sólo puedan cambiarse de forma controlada.\nEl uso de Pinia es imprescindible en aplicaciones de tamaño medio o grande pero incluso para aplicaciones pequeñas nos ofrece ventajas frente a un store pattern hecho por nosotros como soporte para las DevTools y para Server Side Rendering o uso de Typescript.\nComo ya dijimos, no debemos almacenar todos los datos en el store centralizado sino sólo los que necesitan varios componentes (los datos privados de un componente deben permanecer en él).\nInstalar y configurar Pinia\nLa forma más sencilla de utilizar Pinia es incluirla a la hora de crear nuestro proyecto cuando nos pregunta si queremos usarla. Esto hace que la instalación y configuración de la herramienta se haga automáticamente.\nAl entrar en nuestro nuevo proyecto vemos que dentro de /src se ha creado una carpeta llamada stores/ donde crearemos los distintos almacenes de datos (podemos tener sólo uno o varios).\nPara poder usar Pinia en los distintos componentes vemos que en el fichero main.js se importa la función createPinia() y se indica que se use en la instancia de Vue:\nimport { createApp } from 'vue'\nimport { createPinia } from 'pinia' // &lt;---\nimport App from './App.vue'\nimport router from './router'\n\ncreateApp(App).use(createPinia()).use(router).mount('#app')\n\nSi queremos usar Pinia en un proyecto existente donde no la seleccionamos al crear el proyecto deberemos instalar la librería como dependencia de producción y modificar el fichero main.js para que pueda usarse, como hemos visto arriba. Luego crearemos la carpeta /src/stores/ y en ella los almacenes que queramos usar.\nCrear un store\nAhora hay que crear el fichero del store. Podemos tener todos los datos en un único fichero o, si son muchos, hacer ficheros diferentes. Por ejemplo para la aplicación de 'ToDo' podemos crear su store en /src/stores/toDo.js.\nAl crear un almacén pondremos en él todas las variables que vaya a usar más de un componente (dentro de state) y los métodos para acceder a ellas y modificarlas (dentro de actions), por ejemplo, para compartir un contador haríamos:\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\nstate() {\nreturn {\ncount: 0\n}\n},\n// o usando arrow functions\n// state: () =&gt; ({\n// count: 0\n// }),\n\nactions: {\nincrement () {\nthis.count++\n},\ndecrement () {\nthis.count--\n},\n}\n})\n\nEn este ejemplo hemos creado un almacén que tiene un dato (count) y dos métodos para cambiar su valor (increment y decrement). El primer parámetro de defineStore es el nombre con el que veremos el almacén desde las DevTools (por si tenemos varios).\nDesde la consola del navegador podemos usar las DevTools para ver nuestro almacén. Para ello vamos a la pestaña de Vue y desde el Inspector buscamos Pinia:\n![DevTools - Pinia](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/DevTools-Pinia.png)\nSi al crear el proyecto hemos incorporado Pinia nos ha creado un almacén de ejemplo como el anterior, pero escrito con la sintaxis de Compositon API que sería:\nimport { ref } from 'vue'\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', () =&gt; {\nconst count = ref(0)\nfunction increment() {\ncount.value++\n}\nfunction increment() {\ncount.value--\n}\n\nreturn { count, increment, decrement }\n})\n\nUsar Pinia\nEn cada componente que lo necesitemos podemos usar el almacén de datos. Para ello lo importamos y luego definimos en computed las variables del state a que queramos acceder y en methods las actions que deseemos. Para ello debemos usar los helpers mapState y mapActions en los que indicaremos las variables y métodos del store que queremos usar en este componente:\n//MyComponent.vue\nimport { useCounterStore } from '../stores/conterStore';\nimport { mapState, mapActions } from 'pinia';\n\nexport default {\n...\ncomputed: {\n...mapState(useCounterStore, {\ncount: 'count',\n})\n},\nmethods: {\n...mapActions(useCounterStore, ['increment', 'decrement'])\n}\n}\n\nCon esto se mapean las variables, getters y actions a variables y métodos locales a los que podemos acceder desde this. (por ejemplo this.count o this.increment()).\nGetters\nEn ocasiones no necesitamos una variable del state sino cierta información sobre ella (por ejemplo no todas las tareas del array todos sino sólo las tareas pendientes). En ese caso podemos filtrarlas en cada componente que las necesite o podemos hacer un método en el almacén (dentro de getters) que nos devuelva directamente las tareas filtradas. Estos getters funcionan como las variables computed (sólo se ejecutan de nuevo si cambian los datos de que dependen):\nimport { defineStore } from 'pinia'\n\nexport const useToDoStore = defineStore('todo', {\nstate: () =&gt; ({\n/** @type { { title: string, id: number, done: boolean }[]} */\ntodos: [\n{ id: 1, title: '...', done: true },\n{ id: 2, title: '...', done: false }\n],\nnextId: 3,\n}),\ngetters: {\n// reciben como primer parámetro el 'state'\nfinishedTodos: (state) =&gt; state.todos.filter((todo) =&gt; todo.done),\nunfinishedTodos: (state) =&gt; state.todos.filter((todo) =&gt; !todo.done),\n/**\n* @returns { { title: string, id: number, done: boolean }[]}\n*/\n},\nactions: {\n// any amount of arguments, return a promise or not\naddTodo(title) {\nthis.todos.push({\ntitle,\nid: this.nextId,\ndone: false\n})\nthis.nextId++\n},\n},\n})\n\nCada getter recibe como primer parámetro el state del almacén.\nDentro de los componentes se usan como cualquier variable del state:\nexport default {\n...\ncomputed: {\n...mapState(useToDoStore, {\ntodos: 'todos',\nfinishedTodos: 'finishedTodos',\n})\n},\n\nLos getters pueden recibir parámetros, por ejemplo, para hacer búsquedas:\ngetters: {\ngetTodoById: (state) =&gt; (id) =&gt; state.todos.find((todo) =&gt; todo.id === id)\n}\n\nDesde el componente lo llamaremos con this.getTodoById(2).\nActions\nLa manera de cambiar los datos del almacén es llamando a las acciones que hayamos definido, y que hemos mapeado al componente como métodos locales. Estas acciones pueden recibir tantos parámetros como se desee.\nCada vez que se llama a una acción se registra en las DevTools y podemos ver la acción llamada y los datos que se le han pasado:\n![DevTools - Actions](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/DevTools-Pinia-actions.png)\nLas acciones pueden hacer llamadas asíncronas. Lo normal es llamar a la BBDD y cuando el servidor responda modificaremos los datos del store.\nimport { defineStore } from 'pinia'\nimport TodoService from '../services/TodoService.js'\n\nexport const useToDoStore = defineStore('todo', {\nstate: () =&gt; {\nreturn {\ntodos: [],\nnextId: 0,\n}\n},\nactions: {\nasync addTodo(title) {\ntry {\nconst newToDo = await TodoService.addTodo({\ntitle,\nid: this.nextId + 1,\nisFinished: false\n});\nthis.nextId++\nthis.todos.push(newToDo)\n} catch(error) {\nthrow error;\n}\n},\n},\n})\n\nSi la acción realiza una llamada asíncrona y el componente que la llama tiene que enterarse de cuándo finaliza debe devolver una promesa (debe declararse con async o envolverse en un return new Promise(...)). En el componente podemos usar await o then / catch para saber cuándo ha acabado la acción:\ntry {\nawait this.addTodo(this.newTodo)\nalert('Añadida la tarea ' + this.newTodo.title)\nthis.$router.push('/todos')\n} catch(error) {\nalert(error)\n}\n\nNOTA: si quien llama a una acción no necesita saber cuándo termina la acción ni su resultado no es necesario llamarla con await.\nstate en formularios\nAunque no es lo habitual, si queremos usar un formulario para modificar un state del store no podemos asociarlo al input con la directiva v-model porque cuando el usuario cambie el valor del input estaría escribiendo directamente sobre un state, lo que debe hacerse por medio de una acción.\nTenemos 2 soluciones al problema:\n\npodemos no usar el v-model sino descomponerlo en un :value y un @input como vimos al hablar de poner un input en un subcomponente\npodemos ponerle al computed de ese state un setter y un getter como vimos en el capítulo de Profundizando en Vue\n\nMás información en la documentación oficial de Pinia.",
		"tags": [ "note"]
},

{
		"title": "07-vuex",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/07-vuex/",
		"content": "Vuex\nTabla de contenidos\n\nVuex\n\nIntroducción\nInstalar y configurar Vuex\nUsar Vuex\n\nAcceder al State desde un componente\nGetters\nMutations\nActions\n\nstate en formularios\nSaber más\n\nIntroducción\nEs un 'State Management Pattern' basado en el patrón Flux que sirve para controlar el flujo de datos en una aplicación.\nEn Vue la comunicación entre componentes se hace hacia abajo mediante props y hacia arriba emitiendo eventos. Ya vimos que cuando distintos componentes que no son padre-hijo tenían que compartir un mismo estado (acceder a los mismos datos) surgían problemas e intentamos solucionarlos con event Bus o store pattern. Estas soluciones pueden servir para pequeñas aplicaciones pero cuando crecen se hace difícil seguir los cambios con estos patrones. Para esos casos debemos usar Vuex, que proporciona un almacén de datos centralizado para todos los componentes de la aplicación y asegura que los datos sólo puedan cambiarse de forma controlada.\nEl uso de Vuex implica mayor complejidad en nuestra aplicación por lo que es recomendable su uso en aplicaciones de tamaño medio o grande (para aplicaciones pequeñas basta con un eventBus o un store pattern hecho por nosotros). Como dijo Dan Abramov, el creador de Redux\n\nLas librerías Flux son como las gafas: lo sabrás cuando las necesites\n\nVuex se integra con las DevTools por lo que es muy sencillo depurar los datos del almacén y los cambios que se producen en ellos. Sin embargo no debemos almacenar todos los datos en Vuex, sólo los que necesitan varios componentes (los datos privados de un componente deben permanecer en él).\nEl flujo de datos de una aplicación podemos verlo (de manera muy simplificada) en el siguiente esquema:\n\nEl estado es el conjunto de datos de nuestra aplicación\nLa vista representa el estado al usuario\nLas acciones son las formas en que podemos cambiar el estado, normalmente en respuesta a entradas del usuario desde la vista\n\nEl estado de los datos se representa en la vista, donde el usuario tiene herramientas que provocan acciones que modifican el estado. Este esquema funciona perfectamente cuando cada componente tiene su propio estado, pero empieza a dar problemas cuando el estado debe compartirse entre varios componentes. Para ese caso ya vimos soluciones como el Event Bus o el state management pattern pero son soluciones difícilmente mantenibles cuando nuestra aplicación crece. En aplicaciones medias o grandes es conveniente usar Vuex.\nVuex centraliza la forma en que nuestros componentes se comunican entre ellos. Con Vuex el flujo de datos podemos verlo de la siguiente manera:\n\nLos componentes de Vue pueden renderizar datos de Vuex y es reactivo frente a ellos (si se modifican se volverá a renderizar el componente). Si el componente quiere modificar estos datos debe enviar (dispatch) acciones que ejecutan un proceso (que puede ser asíncrono, por ejemplo una petición a una API). Cuando se resuelve la acción realiza una confirmación (commit) que muta el estado de la aplicación (aquí podemos depurar con las DevTools) por lo que se renderiza de nuevo el componente para mostrar el nuevo estado. En Vuex almacenaremos tanto datos (accesibles desde cualquier componente) como métodos que se utilicen en más de un componente.\nInstalar y configurar Vuex\nSi al crear nuestro proyecto Vue marcamos en las opciones que incluya Vuex la instalación y configuración de la herramienta se hará automáticamente:\n\nse instala el paquete vuex. Si no marcamos vuex al crear el proyecto debemos instalarlo nosotros\n\nnpm install -S vuex\n\nse crea el fichero de vuex en /src/store/index.js. Es nuestro almacén donde se guardan todas las variables que vaya a usar más de un componente y los métodos para acceder a ellas y modificarlas. Su contenido en Vue2 es\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\nstate: {\n},\nmutations: {\n},\nactions: {\n},\nmodules: {\n},\n})\n\ny en Vue3\nimport { createStore } from 'vuex'\n\nexport default createStore({\nstate: {\n},\nmutations: {\n},\nactions: {\n},\nmodules: {\n},\n})\n\nse importa dicho fichero en el main.js para que el almacén esté disponible para todos los componentes en la variable this.$store. Es igual que pasaba con vue-router:\n\n...\nimport router from './router'\nimport store from './store'\n\nnew Vue({\nrouter,\t\nstore,\nrender: h =&gt; h(App)\n}).$mount('#app')\n\nSi no hemos seleccionado vuex al crear el proyecto deberemos hacer estos 3 pasos nosotros manualmente. También tenemos la opción de no importar el store en el fichero main.js sino importarlo únicamente en cada componente que vaya a utilizarlo.\nUsar Vuex\nEl corazón de Vuex es el store que es un objeto donde almacenar states (datos globales) de la aplicación pero se diferencia de un objeto normal en que:\n\nes reactivo\nsólo se puede modificar haciendo commits de mutaciones\n\nDesde la consola del navegador podemos usar las DevTools para ver nuestro almacén. Para ello vamos a Vue y elegimos la segunda opción (Vuex):\n![DevTools - Vuex](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/DevTools-Vuex.png)\nAl crear el almacén (normalmente en el fichero src/store/index.js) pondremos en state nuestras variables globales y en mutations los métodos que se pueden usar para cambiarlas, ej.:\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\nstate: {\ncount: 0\n},\nmutations: {\nincrement (state) {\nstate.count++\n},\ndecrement (state) {\nstate.count--\n},\n}\n})\n\nCada mutación recibe como primer parámetro el state del almacén para que pueda modificarlo y el componente lo llama mediante el método commit:\nthis.$store.commit('increment')\n\nEn este ejemplo hemos creado un almacén que tiene un dato (count) y dos mutaciones para cambiar su valor (increment y decrement). Lo usa un componente que muestra el valor del contador e incluye un botón para incrementar su valor y otro para decrementarlo:\n&lt;template&gt;\n&lt;div&gt;\n&lt;p&gt;Valor del contador: { { contador }}&lt;/p&gt;\n&lt;button @click=&quot;incrementa&quot;&gt;Incrementar&lt;/button&gt;\n&lt;button @click=&quot;decrementa&quot;&gt;Decrementar&lt;/button&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nexport default {\ncomputed: {\ncontador() {\nreturn this.$store.state.count\n}\n},\nmethods: {\nincrementa() {\nthis.$store.commit('increment')\n},\ndecrementa() {\nthis.$store.commit('decrement')\n},\n}\n}\n\nSi no hemos importado el almacén en el main.js lo tendremos que importar en cada componente que lo necesite (no es lo habitua):\nimport store from '@/store'\n\nexport default {\ncomputed: {\ncontador() {\nreturn store.state.count\n}\n},\nmethods: {\nincrementa() {\nstore.commit('increment')\n...\n\nAcceder al State desde un componente\nLa mejor forma de acceder a propiedades del almacén es creando métodos computed que cambiarán al cambiar el estado del mismo:\ncomputed: {\ncount () {\nreturn this.$store.state.count\n},\n},\n\nSi queremos usar varias propiedades del store en un componente en vez de hacer un método computed para cada una podemos usar el helper mapState:\nimport { mapState } from 'vuex'\n\ncomputed: mapState([\n'count'\t // map this.count to store.state.count\n])\n\nGetters\nEn ocasiones no necesitamos una variable del state sino cierta información sobre ella (por ejemplo no todas las tareas del array todos sino sólo las tareas pendientes). En ese caso podemos filtrarlas en cada componente que las necesite o podemos hacer un getter en el almacén que nos devuelva directamente las tareas filtradas. Estos getters funcionan como las variables computed (sólo se ejecutan de nuevo si cambian los datos de que dependen):\nexport default new Vuex.Store({\nstate: {\ntodos: [\n{ id: 1, text: '...', done: true },\n{ id: 2, text: '...', done: false }\n]\n},\ngetters: {\npendingTodos: state =&gt; {\nreturn state.todos.filter(todo =&gt; !todo.done)\n},\ndoneTodos: state =&gt; {\nreturn state.todos.filter(todo =&gt; todo.done)\n},\npendingTodosCount: (state, getters) =&gt; {\nreturn getters.pendingTodos.length\n}\n}\n})\n\nCada getter recibe como primer parámetro el state del almacén.\nDentro de los componentes se usan como cualquier variable:\ncomputed: {\npendingTodos () {\nreturn this.$store.getters.pendingTodos\n}\n}\n\nY también podemos usar varios con el helper mapGetters:\nimport { mapGetters } from 'vuex'\n\nexport default {\n// ...\ncomputed: {\n// mix the getters into computed with object spread operator\n...mapGetters([\n'pendingTodos',\n'pendingTodosCount',\n// ...\n])\n}\n}\n\nSi queremos podemos hacer getters también para los states y así no necesitamos mapState sino que accedemos a todo con mapGetters.\nLos getters pueden recibir parámetros, por ejemplo, para hacer búsquedas:\ngetters: {\n// ...\ngetTodoById: (state) =&gt; (id) =&gt; {\nreturn state.todos.find((todo) =&gt; todo.id === id)\n}\n}\n\nY lo llamaremos con this.$store.getters.getTodoById(2).\nMutations\nNOTA: Una mutación no puede hacer una llamada asíncrona (por ejemplo llamar a axios)\nLa única manera de cambiar los datos del almacén es llamando a las mutaciones que hayamos definido, pero no se llaman como si fueran métodos sino que se lanzan (como si fueran eventos) con commit: this.$store.commit('increment').\nLas mutaciones reciben como primer parámetro el store pero pueden recibir otro parámetro adicional, llamado payload, donde incluyamos los datos a pasarle a la mutación:\nmutations: {\naddTodo (state, toDo) {\nstate.todos.push(toDo)\n}\n}\n\nAl llamar a la mutación le pasamos el valor esperado: this.$store.commit('addTodo', this.newTodo).\nCada vez que se llama a una mutación se registra en las DevTools y podemos ver la mutación llamada y los datos que se le han pasado:\n![DevTools - Mutations](/img/user/01 Apuntes/DAW/Vue Teoria Batoi/img/DevTools-Vuex-mutations.png)\nSi queremos pasar varios parámetros el payload deberá ser un objeto. En ese caso podemos pasar el nombre de la mutación como propiedad type del objeto:\nthis.$store.commit({\ntype: 'incrementBy',\namount: 10\n})\n\nPodemos llamar a las mutaciones desde un componente, aunque lo habitual es llamar a acciones que ejecuten esas mutaciones. Recuerda que el código de las mutaciones NO puede ser asíncrono, por lo que no pueden, por ejemplo, hacer una llamada a axios.\nPara llamar a la mutación desde un componente haríamos:\nthis.$store.commit('increment'):\n\nAl igual con con el estado o los getters podemos mapear las mutaciones a métodos locales para poder hacer this.increment() en lugar de this.$store.commit('increment') con el helper mapMutatios:\nimport { mapMutations } from 'vuex'\n\nexport default {\n// ...\nmethods: {\n...mapMutations([\n'increment', // map `this.increment()` to `this.$store.commit('increment')`\n'incrementBy' // map `this.incrementBy(amount)`\n// to `this.$store.commit('incrementBy', amount)`\n]),\n// Y podemos hacer 'alias' de las mutaciones\n...mapMutations({\nadd: 'increment' // map `this.add()` to `this.$store.commit('increment')`\n})\n}\n}\n\nActions\nSon métodos del almacén como las mutaciones pero que SÍ pueden hacer llamadas asíncronas. Por tanto es aquí donde haremos las llamadas a la BBDD y cuando el servidor responda modificaremos los datos del store. Lo mejor es no cambiarlos directamente en la action (aunque podría hacerse) sino que la action debería llamar a una mutation que la cambie y así se registra en las DevTools. Las acciones reciben como parámetro un objeto context con las mismas propiedades y métodos que el almacén, lo que permite:\n\nlanzar una mutación con context.commit(\nacceder a los datos con context.state.\nacceder a los getters con context.getters.\nllamar a otras acciones con context.dispatch(\n\n...\nimport axios from 'axios'\n\nexport default new Vuex.Store({\nstate: {\ntodos: []\n},\nmutations: {\naddTodo(state, todo) {\nstate.todos.push(todo);\n},\n},\nactions: {\naddTodo(context, item) {\naxios.post(`${baseURL}/todos`, item)\n.then((response) =&gt; context.commit('addTodo', response.data))\n.catch((error) =&gt; alert(error))\n},\n},\n\nPara llamarla desde un componente hacemos:\nthis.$store.dispatch('addTodo', this.newTodo)\n\nTambién podemos usar la desestructuración de objetos de ES2015 para obtener sólo la parte del contexto que nos interesa:\nactions: {\naddTodo({ commit }, item) {\naxios.post(`${baseURL}/todos`, item)\n.then((response) =&gt; commit('addTodo', response.data))\n.catch((error) =&gt; alert(error))\n},\n\nIgual que antes podemos usar el helper mapActions para mapear acciones y no tener que llamarlas en el componente con this.$store.dispatch('...').\nSi la acción realiza una llamada asíncrona y el componente que la llama tiene que enterarse de cuándo finaliza debe devolver una promesa:\nactions: {\naddTodo(context, item) {\nreturn new Promise((resolve, reject) =&gt; {\naddTodo(context, item) {\naxios.post(`${baseURL}/todos`, item)\n.then((response) =&gt; {\ncontext.commit('addTodo', response.data)\nresolve(response.data)\n})\n.catch((error) =&gt; reject(error))\n}\n},\n},\n\nEn este caso en el componente tenemos los métodos then y catch para saber cuándo ha acabado la acción:\nthis.$store.dispatch('addTodo', this.newTodo)\n.then((todo) =&gt; { \t // se ejecutará si la acción ha hecho un resolve()\nalert('Añadida la tarea ' + todo.id)\nthis.$router.push('/todos')\n})\n.catch((error) =&gt; alert(error))\t// se ejecutará si la acción ha hecho un reject()\n\nNOTA: si quien llama a una acción no necesita saber cuándo termina la acción ni su resultado la acción no es necesario que devuelva una promesa\nstate en formularios\nSi queremos usar un formulario para modificar un state del store no podemos asociarlo al input con la directiva v-model porque cuando el usuario cambie el valor del input estaría escribiendo directamente sobre un state, lo que no puede hacerse más que por medio de una mutación.\nTenemos 2 soluciones al problema:\n\npodemos no usar el v-model sino descomponerlo en un :value y un @input como vimos al hablar de poner un input en un subcomponente\npodemos ponerle al computed de ese state un setter y un getter como vimos en el capítulo de Profundizando en Vue\n\nMás información en la documentación oficial de Vuex.\nSaber más\n\nVuex\nCómo Construir Aplicaciones Complejas y a Gran Escala Vue.js con Vuex\nVuex for Everyone\nVueJS: Introducción a vuex\nManaging State in Vue.js",
		"tags": [ "note"]
},

{
		"title": "08-forms",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/08-forms/",
		"content": "Formularios en Vue\n\nFormularios en Vue\nIntroducción\n\nUtilizar diferentes tipos de inputs\n\ninput normal\nradio button\ncheckbox\ncheckbox múltiple\n\nGenerar los checkbox automáticamente\n\nselect\nEjemplo\n\nValidar formularios\n\nValidar con VeeValidate\n\nValidar otros inputs\nUsar un schema\nValidar con vee-validate y yup\nPersonalizar los mensajes de yup\nValidación personalizada con yup\n\nInputs en subcomponentes\n\nv-model en subcomponente input\n\nEjemplo\nValidación con Vee Validate\n\nSlots\n\nEjemplo\n\nIntroducción\nPara poder tener sincronizado el formulario con nuestros datos utilizamos la directiva v-model en cada campo. Algunos modificadores útiles de v-model son:\n\n.lazy: hace que v-model sincronice al producirse el evento change en vez del input, es decir, que no sincroniza con cada tecla que pulsemos sino cuando acabamos de escribir y salimos del input.\n.number: convierte automáticamente el valor introducido (que se considera siempre String) a Number\n.trim: realiza un trim() sobre el texto introducido\n\nVamos a ver cómo usar los diferentes tipos de campos con Vue.\nUtilizar diferentes tipos de inputs\nPodemos probar el resultado en la documentación de Vue.\ninput normal\nEn este caso simplemente añadimos la directiva v-model al input:\n&lt;label&gt;Nombre:&lt;/label&gt;\n&lt;input type=&quot;text&quot; v-model=&quot;user.nombre&quot;&gt;\n\nradio button\nPonemos en todos los radiobuttons el v-model y a cada uno el value que se guardará al escoger dicha opción:\n&lt;label&gt;Sexo:&lt;/label&gt;\n&lt;input type=&quot;radio&quot; value=&quot;H&quot; name=&quot;sexo&quot; v-model=&quot;user.sexo&quot;&gt;Hombre\n&lt;input type=&quot;radio&quot; value=&quot;M&quot; name=&quot;sexo&quot; v-model=&quot;user.sexo&quot;&gt;Mujer\n\ncheckbox\nIgual que cualquier input, le ponemos el v-model. Si no ponemos un value los valores que se guardarán serán true si está marcado y false si no lo está:\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.acepto&quot;&gt;Acepto las condiciones\n\ncheckbox múltiple\nSe trata de varios checkbox pero cuyos valores se guardan en el mismo campo, que debe ser un array. Le ponemos el v-model y el value que queramos que se guarde. La variable (en este ejemplo user.ciclos será un array y guardará el value de cada checkbox marcado:\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;smx&quot;&gt;Sistemas Microinformáticos y Redes&lt;br&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;asix&quot;&gt;Administración de Sistemas Informáticos y Redes&lt;br&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;dam&quot;&gt;Desarrollo de Aplicaciones Multiplataforma&lt;br&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;daw&quot;&gt;Desarrollo de Aplicaciones Web&lt;br&gt;\n\nSi tenemos marcadas las casillas 1 y 3 el valor de user.ciclos será ['smx', 'dam'].\nGenerar los checkbox automáticamente\nMuchas veces las opciones a mostrar las tendremos en algún objeto (una tabla de la BBDD, ...). En ese caso podemos generar automáticamente un checkbox para cada elemento:\nciclos: [\n{cod: 'smx', desc: 'Sist. Microinformáticos y Redes'},\n{cod: 'asix', desc: 'Adm. de Sistemas Informáticos y Redes'},\n{cod: 'dam', desc: 'Desar. de Aplicaciones Multiplataforma'},\n{cod: 'daw', desc: 'Desar. de Aplicaciones Web'},\n]\n\n&lt;div v-for=&quot;ciclo in ciclos&quot; :key=&quot;ciclo.cod&quot;&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; :value=&quot;ciclo.cod&quot;&gt;{ { ciclo.desc }}&lt;br&gt;\n&lt;/div&gt;\n\nselect\nLo único que hay que hacer es poner al select la directiva v-model:\n&lt;select v-model=&quot;user.tutor&quot;&gt;\n&lt;option value=''&gt;No es tutor&lt;/option&gt;\n&lt;option value=&quot;smx&quot;&gt;Sistemas Microinformáticos y Redes&lt;/option&gt;\n&lt;option value=&quot;asix&quot;&gt;Administración de Sistemas Informáticos y Redes&lt;/option&gt;\n&lt;option value=&quot;dam&quot;&gt;Desarrollo de Aplicaciones Multiplataforma&lt;/option&gt;\n&lt;option value=&quot;daw&quot;&gt;Desarrollo de Aplicaciones Web&lt;/option&gt;\n&lt;/select&gt;\n\nTambién podemos generar las opciones automáticamente:\n&lt;select v-model=&quot;user.tutor&quot;&gt;\n&lt;option value=''&gt;No es tutor&lt;/option&gt;\n&lt;option v-for=&quot;ciclo in ciclos&quot; :key=&quot;ciclo.cod&quot; :value=&quot;ciclo.cod&quot;&gt;\n{ { ciclo.desc }}\n&lt;/option&gt;\n&lt;/select&gt;\n\nSi queremos que sea un select múltiple sólo tenemos que ponerle el atributo multiple a la etiqueta &lt;select&gt; y hacer que la variable user.tutor sea un array, que se comportará como en los checkbox múltiples.\nEjemplo\n\nValidar formularios\nPodemos validar el formulario &quot;a mano&quot; como hemos visto en JS:\n\nAdemás deberíamos poner clase de error a los inputs con errores para destacarlos, poner el cursor en el primer input erróneo, etc.\nTodo esto es incómodo y poco productivo. Para mejorarlo podemos usar una de las muchísimas librerías para validación de formularios como:\n\nVeeValidate\nvuelidate\nVueFormGenerator\n...\n\nValidar con VeeValidate\nTenéis toda la información así como un tutorial de cómo usar este librería en la documentación de VeeValidate).\nLa forma de instalarla es\nnpm install vee-validate -S\n\nY para usarla simplemente cambiaremos la etiqueta &lt;input&gt; por el componente &lt;Field&gt; y la etiqueta &lt;form&gt; por el componente &lt;Form&gt; pero quitándole el modificador .prevent del escuchador @submit y haciendo que la función manejadora reciba un parámetro llamado values que es un objeto con los valores de los inputs del formulario.\nCada componente Field necesitará un atributo name que es el nombre del campo con el valor de ese input dentro del objeto values. Si el formulario es sólo para recoger datos, no para modificar datos existentes no necesitamos la directiva v-model porque sus valores se guardarán en el objeto values que recibe la función manejadora del @submit. Sin embargo si debe mostrar datos que pueden cambiar tras la carga del componente mantendremos el atributo v-model (como en la práctica que estamos haciendo, que si nos pasan una id cargamos el libro con dicha id y lo mostramos en el formlario para editarlo).\nPara validar un campo se le añade al componente un atributo :rules con la función a ejecutar, que devolverá el mensaje a mostrar en caso de error o true si es correcto. El mensaje se mostrará en un componente llamado ErrorMessage (que deberemos importar y registrar) cuyo atributo name debe ser igual al del campo a validar. Si alguna de las funciones de validación no devuelve true no se ejecuta la función manejadora del submit.\nHabrá que importar los componentes de'vee-validate' que se usen (Form, Field, ErrorMessage) y registrarlos.\nSi no usamos v-model podemos darle un valor por defecto a los inputs (por ejemplo, si estamos editando un objeto que ya tiene valores) pasándole el objeto con los valores al componente &lt;Form&gt; en un atributo llamado initial-values. Pero si cambien esos valores tras cargar el componente no se reflejarán los cambios (para ello debemos usar v-model).\nPor ejemplo si estamos editando el objeto\nproduct = {\nname: 'Ratón óptico',\nprice: '8.95'\n}\n\nel formulario sería:\n&lt;Form :initial-values=&quot;product&quot; @submit=&quot;onSubmit&quot;&gt;\n&lt;Field name=&quot;name&quot; type=&quot;text&quot; /&gt;\n&lt;ErrorMessage name=&quot;name&quot; /&gt;\n\n&lt;Field name=&quot;price&quot; type=&quot;text&quot; /&gt;\n&lt;ErrorMessage name=&quot;price&quot; /&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Guardar&lt;/button&gt;\n&lt;/Form&gt;\n\nSi el objeto product está vacío el formulario aparecerá en blanco pero si contiene datos se mostrarán en el formulario. Sin embargo si modificamos los datos de product esos cambios no se reflejan en el formlario a menos que usemos v-model.\nA continuación tenéis un ejemplo completo de un formulario para validar un email y una contraseña (Fuente https://codesandbox.io/s/vee-validate-basic-example-nc7eh?from-embed=&amp;file=/src/App.vue):\n&lt;template&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;Form @submit=&quot;onSubmit&quot;&gt;\n&lt;Field name=&quot;email&quot; type=&quot;email&quot; :rules=&quot;validateEmail&quot; /&gt;\n&lt;ErrorMessage name=&quot;email&quot; /&gt;\n\n&lt;Field name=&quot;password&quot; type=&quot;password&quot; :rules=&quot;validatePassword&quot; /&gt;\n&lt;ErrorMessage name=&quot;password&quot; /&gt;\n\n&lt;button&gt;Sign up&lt;/button&gt;\n&lt;/Form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Form, Field, ErrorMessage } from &quot;vee-validate&quot;;\n\nexport default {\ncomponents: {\nForm,\nField,\nErrorMessage,\n},\nmethods: {\nonSubmit(values) {\nconsole.log(values);\n},\nvalidateEmail(value) {\n// if the field is empty\nif (!value) {\nreturn &quot;This field is required&quot;;\n}\n\n// if the field is not a valid email\nconst regex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i;\nif (!regex.test(value)) {\nreturn &quot;This field must be a valid email&quot;;\n}\n\n// All is good\nreturn true;\n},\nvalidatePassword(value) {\n// if the field is empty\nif (!value) {\nreturn &quot;This field is required&quot;;\n}\n\n// if the length is less than 8 characters\nif (value.length &lt; 8) {\nreturn &quot;The length of this field must be at least 8 characters&quot;;\n}\n\n// All is good\nreturn true;\n}\n},\n};\n&lt;/script&gt;\n\nPodemos encontrar más información sobre vee-validate en su documentación oficial.\nValidar otros inputs\nPara validar un &lt;select&gt; simplemente lo cambiamos por un &lt;Field as=&quot;select&quot;&gt;. Ejemplo:\n&lt;Field as=&quot;select&quot; name=&quot;autor&quot; class=&quot;form-control&quot; required&gt;\n&lt;option value=&quot;&quot;&gt;--- Selecciona autor ---&lt;/option&gt;\n&lt;option v-for=&quot;autor in autores&quot; :key=&quot;autor.id&quot;\n:value=&quot;autor.id&quot;&gt;\n{{ autor.nombre + ' ' + autor.apellidos }}\n&lt;/option&gt;\n&lt;/Field&gt;\n&lt;ErrorMessage name=&quot;autor&quot; /&gt;\n\nPara un textarea pondremos un &lt;Field as=&quot;textarea&quot;&gt;.\nEn el caso de un checkbox o un radiobutton simplemente añadimos al Field un atributo type indicando su tipo:\n&lt;Field name=&quot;drink&quot; type=&quot;radio&quot; value=&quot;Water&quot; /&gt; Water\n&lt;Field name=&quot;drink&quot; type=&quot;radio&quot; value=&quot;Tea&quot; /&gt; Tea\n&lt;Field name=&quot;drink&quot; type=&quot;radio&quot; value=&quot;Coffee&quot; /&gt; Coffee\n\nSi se trata de varios checkbox con el mismo atributo name en values se recibirá un array con los values de los elementos marcados.\nUsar un schema\nEl problema de validar los datos así es que tenemos varias funciones independientes que validan los distintos inputs lo que dispersa el código de la vaidación.\nPodemos ponerlas todas como propiedades de un objeto que le pasamos como atributo al Form, evitando además tener que poner los atributos rules en cada Field a validar.\nEl ejemplo anterior quedaría:\n&lt;template&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;Form :validation-schema=&quot;mySchema&quot; @submit=&quot;onSubmit&quot;&gt;\n&lt;Field name=&quot;email&quot; type=&quot;email&quot; /&gt;\n&lt;ErrorMessage name=&quot;email&quot; /&gt;\n\n&lt;Field name=&quot;password&quot; type=&quot;password&quot; /&gt;\n&lt;ErrorMessage name=&quot;password&quot; /&gt;\n\n&lt;button&gt;Sign up&lt;/button&gt;\n&lt;/Form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Form, Field, ErrorMessage } from &quot;vee-validate&quot;;\n\nexport default {\ncomponents: {\nForm,\nField,\nErrorMessage,\n},\ndata() {\nreturn {\nmySchema = {\nemail: (value) =&gt; {\nif (!value) return &quot;This field is required&quot;;\nconst regex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i;\nif (!regex.test(value)) return &quot;This field must be a valid email&quot;;\nreturn true;\n},\npassword: (value) =&gt; {\nif (!value) return &quot;This field is required&quot;;\nif (value.length &lt; 8) return &quot;The length of this field must be at least 8 characters&quot;;\nreturn true;\n}\n}\n}\n},\nmethods: {\nonSubmit(values) {\nconsole.log(values);\n},\n},\n};\n&lt;/script&gt;\n\nValidar con vee-validate y yup\nVee-validate 4 también permite usar librerías como yup. En este caso la validación es casi automática como se muestra en la documentación de vee-validate. El ejemplo anterior quedaría:\n&lt;template&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;Form @submit=&quot;onSubmit&quot; :validation-schema=&quot;mySchema&quot;&gt;\n&lt;Field name=&quot;email&quot; type=&quot;email&quot; /&gt;\n&lt;ErrorMessage name=&quot;email&quot; /&gt;\n\n&lt;Field name=&quot;password&quot; type=&quot;password&quot; /&gt;\n&lt;ErrorMessage name=&quot;password&quot; /&gt;\n\n&lt;button&gt;Sign up&lt;/button&gt;\n&lt;/Form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Form, Field, ErrorMessage } from &quot;vee-validate&quot;;\nimport * as yup from 'yup';\n\nexport default {\ncomponents: {\nForm,\nField,\nErrorMessage,\n},\ndata() {\nconst mySchema = yup.object({\nemail: yup.string().required().email(),\npassword: yup.string().required().min(8),\n})\nreturn {\nmySchema\n}\n},\nmethods: {\nonSubmit(values) {\nconsole.log(values);\n},\n},\n};\n&lt;/script&gt;\n\nPersonalizar los mensajes de yup\nPara personalizar un mensaje de error de un campo sólo tenemos que indicar el mensaje al definir la regla del campo:\nconst mySchema = yup.object({\nemail: yup.string().required('El email es obligatorio').email(),\npassword: yup.string().required().min(8, 'La contraseña debe tener al menos 8 caracteres'),\n})\n\nEn este caso hemos personalizado el mensaje del email si no contiene nada y del password si no cumple el min.\nSi queremos personalizar todos los mensajes de error debemos definir un objeto con los nuevos mensajes. Las validaciones no incluidas mantendrán el mensaje original. Ejemplo:\nimport * as yup from 'yup';\nimport { setLocale } from 'yup';\nsetLocale({\nmixed: {\ndefault: 'Campo no válido',\nrequired: 'El campo ${path} no puede estar vacío'\n},\nstring: { // sólo las reglas 'min' de campos 'string'\nmin: 'El campo ${path} debe tener al menos ${max} caracteres'\n},\nnumber: { // sólo las reglas 'min' de campos 'number'\nmin: 'El valor del campo debe ser mayor que ${min}',\n},\n});\n\nValidación personalizada con yup\nSi lo que queremos validar no lo hace ningún validador de yup podemos crear nuestra propia regla usando el validador test() que como 1º parámetro recibe el nombre de la regla, como 2º el mensaje de error a mostrar y como 3º una función que recibe el valor del campo y devolverá true/false indicando si es válido o no. Por ejemplo el campo seed debe ser múltiplo de 7:\nconst mySchema = yup.object({\nseed: yup.number().required().test('seven-multiplo', 'El valor debe ser múltiplo de 7', (value) =&gt; {\nreturn !(value % 7)\n},\n...\n})\n\nInputs en subcomponentes\nLa forma enlazar cada input con su variable correspondiente es mediante la directiva v-model que hace un enlace bidireccional: al cambiar la variable Vue cambia el valor del input y si el usuario cambia el input Vue actualiza la variable automáticamente.\nEl problema lo tenemos si hacemos que los inputs estén en subcomponentes. Si ponemos allí el v-model al escribir en el input se modifica el valor de la variable en el subcomponente (que es donde está el v-model) pero no en el padre.\nPara solucionar este problema tenemos 2 opciones: imitar nosotros en el subcomponente lo que hace v-model o utilizar slots.\nv-model en subcomponente input\nComo los cambios en el subcomponente no se transmiten al componente padre hay que emitir un evento desde el subcomponente que escuche el padre y que proceda a hacer el cambio en la variable.\nLa solución es imitar lo que hace un v-model que en realidad está formado por:\n\nun v-bind para mostrar el valor inicial en el input\nun _v-on:input que se encarga de avisar para que se modifique la variable al cambiar el valor del input\n\nAsí que lo que haremos es:\n\nen el componente del formulario ponemos un v-model que se encargue de actualizar la variable\n\n&lt;form-input v-model=&quot;campo&quot;&gt;&lt;/form-input&gt;\n\nen el subcomponente del inpit ponemos\n\nun v-bind que muestre el valor inicial\nun v-on:input que emita un evento input al padre pasándole el valor actual\n\n&lt;template&gt;\n&lt;div class=&quot;control-group&quot;&gt;\n&lt;!-- id --&gt;\n&lt;label class=&quot;control-label&quot; :for=&quot;nombre&quot;&gt;{ { titulo }}&lt;/label&gt;\n&lt;div class=&quot;controls&quot;&gt;\n&lt;input :value=&quot;value&quot; @input=&quot;$emit('input', $event.target.value)&quot; type=&quot;text&quot; :id=&quot;nombre&quot; :name=&quot;nombre&quot; placeholder=&quot;Escribe el nombre&quot; class=&quot;form-control&quot;&gt;\n&lt;/div&gt;\n&lt;/div&gt;\t\n&lt;/template&gt;\n\nprops: ['value'],\n\nEjemplo\nComponente padre: formulario\n&lt;form class=&quot;form-horizontal&quot;&gt;\n\t&lt;form-input v-model=&quot;user.id&quot; titulo=&quot;Id&quot; nombre=&quot;id&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.name&quot; titulo=&quot;Nombre&quot; nombre=&quot;name&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.username&quot; titulo=&quot;Username&quot; nombre=&quot;username&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.email&quot; titulo=&quot;E-mail&quot; nombre=&quot;email&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.phone&quot; titulo=&quot;Teléfono&quot; nombre=&quot;phone&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.website&quot; titulo=&quot;URL&quot; nombre=&quot;website&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.companyName&quot; titulo=&quot;Nombre de la empresa&quot; nombre=&quot;nomEmpresa&quot;&gt;&lt;/form-input&gt;\n&lt;/form&gt;\n\nSubcomponente: form-input\n&lt;template&gt;\n&lt;div class=&quot;control-group&quot;&gt;\n&lt;label class=&quot;control-label&quot; :for=&quot;nombre&quot;&gt;{ { titulo }}&lt;/label&gt;\n&lt;div class=&quot;controls&quot;&gt;\n&lt;input :value=&quot;value&quot; @input=&quot;updateValue($event.target.value)&quot; type=&quot;text&quot; :id=&quot;nombre&quot; :name=&quot;nombre&quot; placeholder=&quot;&quot; class=&quot;form-control&quot;&gt;\n&lt;/div&gt;\n&lt;/div&gt;\t\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'user-form-input',\nprops: ['value', 'titulo', 'nombre'],\nmethods: {\nupdateValue(value) {\n\tthis.$emit('input', value)\n}\n}\n}\n&lt;/script&gt;\n\nValidación con Vee Validate\nEsto mismo podemos hacer si estamos usando VeeValidate para validar nuestro formulario. Tenemos toda la información en la documentación oficial.\nSlots\nYa vimos al hablar de la comunicación entre componentes que un slot es una ranura en un subcomponente que, al renderizarse, se rellena con lo que le pasa el padre.\nEsto podemos usarlo en los formularios de forma que el &lt;input&gt; con el v-model lo pongamos en un slot de forma que está enlazado correctamente en el padre.\nEjemplo\nComponente padre: formulario\n&lt;form class=&quot;form-horizontal&quot;&gt;\n\t&lt;form-input titulo=&quot;Id&quot;&gt;\n&lt;input v-model=&quot;user.id&quot; type=&quot;text&quot; id=&quot;id&quot; name=&quot;id&quot; class=&quot;form-control&quot; disabled&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Nombre&quot;&gt;\n\t &lt;input v-model=&quot;user.name&quot; type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Username&quot;&gt;\n\t &lt;input v-model=&quot;user.username&quot; type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;E-mail&quot;&gt;\n&lt;input v-model=&quot;user.email&quot; type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Teléfono&quot;&gt;\n&lt;input v-model=&quot;user.phone&quot; type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;URL&quot;&gt;\n\t &lt;input v-model=&quot;user.website&quot; type=&quot;text&quot; id=&quot;website&quot; name=&quot;website&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Nombre de la empresa&quot;&gt;\n\t &lt;input v-model=&quot;user.companyName&quot; type=&quot;text&quot; id=&quot;nomEmpresa&quot; name=&quot;nomEmpresa&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n&lt;/form&gt;\n\nSubcomponente: form-input\n&lt;template&gt;\n&lt;div class=&quot;control-group&quot;&gt;\n&lt;label class=&quot;control-label&quot;&gt;{ { titulo }}&lt;/label&gt;\n&lt;div class=&quot;controls&quot;&gt;\n\t &lt;slot&gt;Aquí va un INPUT&lt;/slot&gt;\n&lt;/div&gt;\n&lt;/div&gt;\t\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'user-form-input',\nprops: ['value', 'titulo', 'nombre'],\nmethods: {\nupdateValue(value) {\nthis.$emit('input', value)\n}\n}\n}\n&lt;/script&gt;",
		"tags": [ "note"]
},

{
		"title": "09-cosas",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/09-cosas/",
		"content": "Siguientes cosas a aprender en Vue\nAlgunas cosas interesantes que nos pueden ser útiles en nuestros proyectos son:\n\nSiguientes cosas a aprender en Vue\n\nAutenticación\n\nStore\nAPI\nLogin.vue\nRouter\n\nPaso a producción\nVuetify\n\nInstalación\nCrear el layout\nSaber más\n\nTypescript\nSSR (Server Side Rendering)\nCrear aplicaciones móviles con Vue\n\nQuasar\nVue Native\nIonic Vue\n\nNuxt\nConclusión\nAngular\nVue con Laravel\n\nCreación del proyecto\nConfiguramos el proyecto en Vue\nConfiguramos Laravel\nCompilamos Vue\nCreamos la API\nSaber más\n\nAutenticación\nUna parte importante de cualquier aplicación es la autenticación de usuarios. Una de las formas más usadas y sencillas de autenticarnos frente a una API es el uso de tokens: cuando nos logueamos la API nos pasa un token y en cada petición que le hagamos debemos adjuntar dicho token en las cabeceras de la petición, tal y como vimos al final del tema de axios.\nAparte de eso, que es lo básico, hay muchas más cosas que podemos incluir en nuestras aplicaciones. Por ejemplo vamos a hacer una aplicación que:\n\nal loguearnos la API nos pasa un token que guardaremos en el store y también en el localStorage para poder continuar logueados si se recarga la página (recuerda que al recargar se borran todas las variables de nuestro código)\ninterceptaremos todas las peticiones a la API para incluir en las cabeceras el token, si tenemos\ninterceptaremos todas las respuestas a la API y si en alguna el servidor responde con un error 401 (Unauthenticated) reenviaremos al usuario a la página de login para que se loguee pero pasándole como parámetro la página a la que quería ir para que una vez logueado vaya automáticamente a dicha página\nel login hará varias cosas\n\nsi hay token en el localStorage es que ya está logueado (posiblemente se haya recargado la página y al interceptar la respuesta era un 401 porque iba sin token y se ha redireccionado aquí). En este caso simplemente se guarda el token en el store y se vuelve a la página de donde venía la petición. OJO: si el token caduca (que es lo más normal) deberemos mirar si ya ha expirado y en ese caso no se guarda en el store sino que se elimina del localStorage y se hace un login normal\nsi no hay token es que debemos loguearnos así que se muestra el formulario para que el usuario introduzca sus credenciales y se le envían al servidor. Este contestará con un token que deberemos guardar en el store y en el localStorage antes de redireccionar a la página de la que venía la petición o a la página de inicio\n\nen el router indicaremos para qué rutas hay que estar autentificado y antes de cargar cualquiera de ellas (usaremos el hook beforeEach) comprobamos si estamos autenticados y en caso de no estarlo redireccionamos al login, pero pasándole como parámetro la ruta a la que queríamos ir para que se cargue tras loguearse\n\nVeamos el código para hacer todo esto:\nStore\n// Fichero '@/store/index.js'\n...\nmutations: {\nloginUser(state, token) {\nstate.token = token\nlocalStorage.token = token\n},\nlogoutUser(state) {\nstate.token = null\nlocalStorage.removeItem('token')\n},\n},\nactions: {\nlogin(context, user) {\nreturn new Promise ((resolve, reject) =&gt; {\nAPI.users.login(user)\n.then((response) =&gt; {\ncontext.commit('login', response.data)\nresolve(response.data)\n})\n.catch((err) =&gt; reject(err))\n})\n},\n...\n},\n\nLa acción que envía las credenciales del usuario al servidor es una promesa porque el componente Login.vue tiene que saber cuándo se obtiene el token para redireccionar a la página correspondiente.\nLas mutaciones almacenan el token en el store y también en el localStorage.\nAPI\n// Fichero '@/services/API.js'\nimport axios from 'axios'\nimport store from '@/store'\nimport router from '@/router'\n\nconst API_URL = process.env.VUE_APP_API\n\nconst users = {\nlogin: (item) =&gt; axios.post(`${API_URL}/auth/login`, item),\nregister: (user) =&gt; axios.post(`${API_URL}/auth/signup`, user),\n}\n...\n\naxios.interceptors.request.use((config) =&gt; {\nconst token = store.state.user.access_token\nif (token) {\nconfig.headers['Authorization'] = 'Bearer ' + token\n}\nreturn config;\n}, (error) =&gt; {\nreturn Promise.reject(error)\n})\n\naxios.interceptors.response.use((response) =&gt; {\nreturn response\n}, (error) =&gt; {\nif (error.response) {\nswitch (error.response.status) {\ncase 401:\nstore.commit('logout')\nif (router.currentRoute.path !== 'login') {\nrouter.replace({\npath: 'login',\nquery: { redirect: router.currentRoute.path },\n})\n}\n}\n}\nreturn Promise.reject(error)\n})\n\nexport default {\nusers,\n...\n};\n\nInterceptamos las peticiones para incluir el token si lo tenemos.Y también las respuestas porque si es un error 401 hay que loguearse por lo que se cambia el router al login pero se le pasa la dirección de la página en la que se estaba para que tras loguearse se cargue esa página y no la de inicio.\nLogin.vue\n// script de la vista 'Login.vue'\n...\nmounted() {\nif (localStorage.token) {\n// Si el token caduca debemos comprobar que no haya expirado\nthis.$store.commit(&quot;login&quot;, localStorage.token)\nthis.loadPage()\n}\n},\nmethods: {\nsubmit() {\nthis.$store.dispatch(&quot;login&quot;, this.user)\n.then(() =&gt; this.loadPage())\n.catch((err) =&gt; alert(err))\n},\nloadPage() {\nconst redirect = decodeURIComponent(this.$route.query.redirect || '/')\nthis.$router.push({ path: redirect })\n}\n},\n...\n\nRouter\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport store from '../store'\n\nimport Datos from '../views/Datos.vue'\n...\n\nVue.use(VueRouter)\n\nrouter.beforeEach((to, from, next) =&gt; {\nif (to.meta.requireAuth) {\nif (store.token) {\nnext();\n}\nelse {\nnext({\npath: '/login',\nquery: { redirect: to.fullPath }\n})\n}\n}\nelse {\nnext();\n}\n})\n\nconst routes = [\n{\npath: '/datos',\nname: 'Datos',\ncomponent: Datos,\nmeta: {\nrequireAuth: true,\n},\n},\n...\n]\n\nexport default router = new VueRouter({\nmode: 'history',\nbase: process.env.BASE_URL,\nroutes\n})\n\nPara ver algunos ejemplos de cómo gestionar la autenticación en nuestros proyectos Vue podemos consultar cualquiera de estos enlaces:\n\nAuthentication Best Practices for Vue\nVue Authentication And Route Handling Using Vue-router\n\nPaso a producción\nUna vez acabada nuestra aplicación debemos general el build que pasaremos a producción. El build es el conjunto de ficheros compilados, minificados, etc que subiremos al servidor de producción. Para ello tenemos un script en el package.json que se encarga de todo:\nnpm run build\n\nCrea un directorio dist con lo qie hay que subir a producción:\n\nindex.html: HTML\nficheros que hay en /public: imágenes, CSS y cualquier otro fichero estático que hubiera en la carpeta /public, como favicon.ico\nassets: todo lo que ha compilado Vite optimizado y minimizado:\n\nindex-xxxx.js: fichero con todo nuestro código Javascript más el de las librerías usadas\nindex-xxxx-css: fichero con todo nuestro CSS\nimágenes y otros archivos que hubiera en assets\n\nVuetify\nSon varias las librerías para Vue que nos facilitan enormemente la creación de nuestros componentes ya que nos dan un código para los mismos (tanto el template como el Javascript) de manera que simplemente personalizando ese código con nuestros datos ya tenemos un componente totalmente funcional. Entre ellas están Material Design, ElementUI, Vuetify y muchas otras.\nPodemos ver la utilidad de estas librerías consultando, por ejemplo, como crear una Datatable con Vuetify. Vuetify sigue el diseño de Material Design.\nPodemos obtener toda la información sobre esta librería en su página web.\nInstalación\nVue se instala como cualquier otro plugin:\nvue add vuetify\n\nCrear el layout\nEn App.vue borramos todo su contenido y lo sustituimos por el código de layout que deseemos de Vuetify. Para ver el código pinchamos en la imagen del layout deseada y lo copiamos.\nA continuación ponemos el &lt;router-view&gt; donde corresponda.\nCada elemento del menú es una etiqueta &lt;v-list-tile&gt; dentro del &lt;v-navigation-drawer&gt;. Para modificar el menú vamos a Vuetify -&gt; UI components -&gt; Navigation drawers.\nPara cada elemento que queramos añadir:\n\nSu icono está dentro de &lt;v-icon&gt; y para elegirlo vamos a Material Design y elegimos el que queramos. Para modificar su aspecto vamos a Vuetify -&gt; UI components -&gt; Icons y copiamos el código que queramos\nPara que enlace a la ruta que queramos añadimos a la etiqueta &lt;v-list-tile-title&gt; una etiqueta &lt;router-link :to=&quot;{ name: nombre_de_la_ruta }&gt;, ejemplo:\n\n&lt;v-list-tile-title&gt;\n&lt;routerlink :to=&quot;{ name: 'perfil' }&quot;&gt;Perfil&lt;/router-link&gt;\n&lt;/v-list-tile-title&gt;\n\nSi no nos gusta Material Dessign tenemos alternativas como Buefy (que proporciona componentes Vue basados en Bulma) y muchas otras.\nSaber más\n\nVuetifyJS.com\nVuetify Material Framework in 60 minutes\nIntro and Overview of Vuetify.js (Build a CRUD client with Vue.js)\n\nTypescript\nEs Javascript al que se le ha incorporado tipado de datos y otras utilidades. En los apuntes puedes ver una introducción a cómo usarlo en Vue y en Internet tienes infinidad de recursos para aprender más.\nSSR (Server Side Rendering)\nEsta tecnología permite que al obtener la página un robot (haciendo curl miURL) no devuelva sólo la &lt;app&gt; sino el HTML para que los robots la puedan indexar correctamente.\nEl problema que tiene una SPA es que las rutas no existen realmente sino sólo en el front y se generan asíncronamente, lo que dificulta a los robots obtener las páginas de las distintas rutas.\nSSR hace que la primera vez que un usuario accede a la web se sirve entera desde el servidor y el resto de veces ya se sirve desde el front. Eso permite que a un robot se le sirva toda desde el servidor y la puede indexar. Esto no es algo que nos interese en todos los proyectos, sólo en aquellos en que sea importante que estén bien posicionados en los buscadores.\nMás info: Server-Side Rendering.\nExplicación de qué es y cómo funciona en Angular: Angular &amp; SEO\nCrear aplicaciones móviles con Vue\nDiferentes librerías nos permiten que nuestras aplicaciones puedan ejecutarse en móviles tanto Android como iOS. La mayoría utilizan la librería Cordova de Apache2 para tener acceso a los elementos del móvil como notificaciones, cámara, geolocalización, ...\nExisten muchos pero las más utilizadas hoy en día son Quasar, Vue native e Ionic.\nQuasar\nQuasar es un framework basado en VueJS que te permite generar la aplicación de escritorio y la aplicación móvil tanto para Android como para iOS.\nTiene licencia MIT y su UI sigue las guías de Material. Su ventaja sobre los otros es que está creado en Vue y pensado para este framework.\nVue Native\nVue native es otro framework que permite generar aplicaciones móviles nativas usando Vue. En realidad es una capa sobre React Native que permite a Vue usar su API.\nCon ella podemos acceder a los diferentes dispositivos del móvil como la cámara, la geolocalización, el acelerómetro, ... Podemos encontrar en Internet muchos ejemplos de cómo hacer nuestra App con este framework, como este de scotch.io.\nIonic Vue\nIonic es posiblemente el Framework más utilizado para crear aplicaciones móviles nativas a partir de nuestra aplicación web. Está basado en Angular pero desde diciembre de 2020 puede usarse directamente en Vue, y es compatible con Vue3 y su Composition API.\nNuxt\nNuxt es un framework basado en Vue que crea un scaffolding de Vue con todo lo necesario para una aplicación media-grande (incluye rutas, Vuex,...) lo que nos facilita el desarrollo de nuestros proyectos.\nTambién hay otras librerías que nos pueden ser de utilidad como:\n\nFramework7 para crear una aplicación web que use\nWeex para crear aplicaciones nativas para iOS y Android\n\nConclusión\nComo vés existen infinidad de librerías alrededor de Vue para ofrecernos nuevas funcionalidades. Son tantas que el equipo de Vue ha creado AwesomeVue donde se registran parte de estas librerías y a donde podemos acceder en busca de cualquier cosa que necesitemos.\nAngular\nAunque el crecimiento de Vue es muy importante, Angular sigue siendo aún el framework Javascript más demandado por las empresas. Si quieres aprender aquí tienes algunos enlaces de utilidad:\n\nDocumentación oficial de Angular\nEjemplo de CRUD con Angular\n...\n\nVue con Laravel\nEs sencillo crear una SPA completa usando Vue en el Front-end y Laravel para crear el Back-end que sirva la API. Podemos hacerlo como dos proyectos independientes o integrando Vue en Laravel.\nComo proyectos independientes es la forma más sencilla. Simplemente nuestro proyecto Vue hará peticiones a la API desarrollada en Laravel.\nSi queremos integrar Vue dentro del proyecto Laravel el funcionamiento es el siguiente:\n\nLa primera petición le llega al router de Laravel que renderiza el diseño de la SPA\nLas demás peticiones usan la API history.pushState para navegar sin recargar la página y las gestiona el enrutador Vue\n\nVamos a ver en detalle cómo gestionarlo.\nCreación del proyecto\nCreamos el proyecto Laravel. Dentro del mismo instalamos los paquetes que necesitemos para Vue:\nlaravel new laravue\ncd laravue\nnpm install\nnpm i -S vue-router\n\nConfiguramos el proyecto en Vue\nConfiguramos el router de Vue en un nuevo fichero JS (por ejemplo /resources/js/router.js) y lo importamos en el fichero principal, /resources/js/app.js (el equivalente al main.js de un proyecto con vue-cli):\n// Fichero app.js\n...\nimport App from './views/App'\nimport router from './router'\n\nconst app = new Vue({\nel: '#app',\ncomponents: {\nApp\n},\nrouter,\n});\n\nCreamos el fichero /resources/js/App.vue que será el equivalente al App.vue de los proyectos vue-cli:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;Vue Router Demo App&lt;/h1&gt;\n\n&lt;p&gt;\n&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;\n...\n&lt;router-link to=&quot;/about&quot;&gt;Sobre nosotros...&lt;/router-link&gt;\n&lt;/p&gt;\n\n&lt;div class=&quot;container&quot;&gt;\n&lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nConfiguramos Laravel\nCreamos la vista principal en /resources/views/spa.blade.php:\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;{{ str_replace('_','-', app()-&gt;getLocale()) }}&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;meta name=&quot;csrf-token&quot; content=&quot;{{ csrf_token() }}&quot;&gt;\n&lt;title&gt;Vue SPA Demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;app&gt;&lt;/app&gt;\n&lt;/div&gt;\n\n&lt;script src=&quot;{{ mix('js/app.js') }}&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nNOTA: la línea del &lt;meta CSRF-TOKEN&gt; es para evitar los errores de la consola por no pasar el token csrf.\nConfiguramos /routes/web.php para que sirva siempre esa página:\nRoute::get('/{any}', 'SpaController@index')-&gt;where('any', '.*');\n\npara lo que creamos el controlador:\nphp artisan make:controller SpaController\nhttps://vuex.vuejs.org/guide/forms.html```\ny lo editamos:\n```php\n&lt;?php\nnamespace App\\Http\\Controllers;\nuse Illuminate\\Http\\Request;\n\nclass SpaController extends Controller\n{\npublic function index()\n{\nreturn view('spa');\n}\n}\n\nCompilamos Vue\nAhora simplemente ejecutamos en la terminal\nnpm run dev\n\ny ya tenemos la aplicación en marcha. Si aparece un error de &quot;The Mix manifest does not exist&quot; ejecutaremos npm run prod que crea el fichero mix-manifest.json.\nPara que se compilen automáticamente los cambios que vayamos haciendo en Vue mientras desarrollamos el proyecto ejecutamos npm run watch-poll en una terminal.\nCreamos la API\nPara obtener datos de una API debemos en primer lugar crear la ruta en /routes/api.php:\nRoute::namespace('Api')-&gt;group(function () {\nRoute::get('/alumnos', 'AlumnosController@index');\n});\n\nEsto nos crea sólo la ruta para el verbo GET. Una opción mejor es crear todas las rutas del recurso con:\nRoute::resource('alumnos',’AlumnosController’,['only'=&gt;['index','store','show','update','destroy' ]]);\n\nLa opción only es opcional y permite restringir las rutas que se crearán para que no se muestren las que no utilizaremos (podemos comprobarlo con un php artisan route:list).\nOtra opción es usar apiResources que crea sólo funciones para los métodos API:\nRoute::apiResource('alumnos',’AlumnosController’);\n\nTambién podemos crear las rutas para varios controladores a la vez con resources en vez de resource:\nRoute::resources(\n[\n'alumnos' =&gt; 'Api\\AlumnosController',\n'profes' =&gt; 'Api\\ProfesoresController',\n],\n['only'=&gt;['index','store','show','update','destroy' ]]\n);\n\nLuego creamos el controlador y el recurso:\nphp artisan make:controller Api/AlumnosController --api\n\nLa opción --resource (o -r) crea automáticamente los puntos de entrada para los métodos indicados. La opción --api es igual pero no crea funciones para los métodos create ni edit.\ny el recurso:\nphp artisan make:resource AlumnoResource\n\nUn recurso es un modelo que se debe transformar a un objeto JSON (lo que necesitamos en una API).\ny editamos el controlador:\n&lt;?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Alumno;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse App\\Http\\Resources\\AlumnoResource;\n\nclass AlumnosController extends Controller {\npublic function index() {\nreturn AlumnoResource::collection(Alumno::paginate(10));\n// Esto devuelve, además del data información para paginar la salida\n\n// lo anterior equivaldría, sin usar el recurso, a\n$alumnos=Alumno::all()-&gt;toArray();\nreturn response()-&gt;json($alumnos);\n}\n\npublic function show($id) {\nreturn new AlumnoResource(Alumno::find($id));\n}\n\npublic function store(Request $request) {\n\n$alumno = Alumno::create([\n'alumno_id' =&gt; $request-&gt;alumno()-&gt;id,\n'nombre' =&gt; $request-&gt;nombre,\n'apellidos' =&gt; $request-&gt;apellidos,\n...\n]);\n\nreturn new AlumnoResource($alumno);\n}\n}\n\nSaber más\n\nBuilding a Vue SPA with Laravel\nLaravel 5.7 + Vue + Vue Router = SPA. Igual pero usando la librería Vuetify",
		"tags": [ "note"]
},

{
		"title": "0x-quasar",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/0x-quasar/",
		"content": "Quasar\nEs un framwork basado en Vue que permite crear aplicaciones multiplataforma (web/desktop/mobile) con un sólo código fuente. Para usarlo podemos integrarlo desde n CDN, añadirlo como un plugin a Vue-cli o utilizar su propio entorno, Quasar CLI, lo que nos permitirá obtener las máximas prestaciones de este framework. Tenéis una comparativa sobre los 3 métodos en la documentación de Quasar.\nInstalar Quasar cli\nNecesitamos tener NodeJs instalado y haremos:\nnpm install -S @quasar/cli\n\nLa opción -g es para que se instale globalmente y así poder tenerlo disponible para cualquier proyecto.\nCrear un proyecto\nSe crea mendiante\nquasar createnombre-proyecto\n\nDetección de plataforma\nQuasar nos permite saber en qué plataforma se está mostrando mediante $q.plataform:\n&lt;div v-if=&quot;$q.plataform.is.desktop&quot;&gt;\nEsto se muestra en un escritorio\n&lt;/div&gt;\n&lt;div v-if=&quot;$q.plataform.is.mobile&quot;&gt;\nEsto se muestra en un móvil\n&lt;/div&gt;\n\nOtros posibles valores de plataforma son electron, cordova, ... Para usarlo debemos importar esta característica:\nimport { Plataform } from 'quasar'",
		"tags": [ "note"]
},

{
		"title": "0x-testing",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/0x-testing/",
		"content": "Testear nuestros componentes\nLa librería que incluye Vue para testear las aplicaciones el vue-test_utils que proporciona herramientas para montar e interactuar con componentes. Para los tests unitarios usaremos Jest.\nTras instalar la librería con npm (será una dependencia de desarrollo) indicaremos al linter que vamos a usar jest para que no genere advertencias al usar sus comandos para lo que modificaremos el fichero .eslintrc.js y añadiremos al apartado env una línea indicando que vamos a usar jest. Dicho apartado quedará:\nenv: {\nnode: true,\njest: true,\n},\n\nSi usamos librerías como Vue-Material o Vuetify y debemos importar ficheros .css de las mismas en nuestros componentes es posible que falle Jest a la hora de pasar los test y nos dará un error de que no puede procesar el fichero porque no es Javascript. Podemos solucionarlo instalando para desarrollo el paquete identuty-obj-proxy y añadiendo una entrada para moduleNameMapper al fichero de configuración de Jest jest.config.js que quedará:\nmodule.exports = {\npreset: '@vue/cli-plugin-unit-jest',\nmoduleNameMapper: {\n&quot;\\\\.(css|less|scss|sass)$&quot;: &quot;identity-obj-proxy&quot;\n},\n}\n\n(fuente: https://stackoverflow.com/questions/46177148/how-to-exclude-css-module-files-from-jest-test-suites)\nTests unitarios\nA la hora de crear el proyecto no escogeremos preset sino que seleccionaremos manualmente las características a instalar y marcaremos la de tests unitarios con Jest que es la librería que usamos en el bloque de Javascript.\nPara ejecutar los tests ejecutaremos en la terminal\nnpm run test:unit\n\nEl projecto está configurado para ejecutar los ficheros de pruebas cuyo nombre acabe por .spec.js. Por defecto se guardan en la carpeta /tests.\nPrimer test: HelloWorld.vue\nEn primer lugar vamos a analizar el test que hay hecho en @/tests/exemple.spec.js para testear el componente HelloWorld.vue:\nimport { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\nit('renders props.msg when passed', () =&gt; {\nconst msg = 'new message'\nconst wrapper = shallowMount(HelloWorld, {\npropsData: { msg }\n})\nexpect(wrapper.text()).toMatch(msg)\n})\n})\n\nLo primero que hay que hacer es importar el plugin de tests de vue y el componente a testear. Dentro de la prueba se monta el componente (shallowMount) y se le pasan las props que necesite (msg). A esta función se le pasa un componente y devuelve la instancia de Vue creada para él y su nodo del DOM.\nComo segundo parámetro se le puede pasar un objeto con opciones a montar en el componente (por ejemplo un data que sustituirá al del componente) o, como en el ejemplo anterior, los parámetros que se le pasan al componente (en propsData).\nAdemás de shallowMount podemos usar (si lo importamos) el método mount que hace lo mismo pero también renderiza los subcomponentes que tenga el componente.\nPor último se comprueba que el texto renderizado por el template del componente incluye el mensaje pasado. La variable wrapper es el nodo DOM raíz del componente y podemos obtener su textContent (.text()), su innerHTML (.html()), sus atributos (.attributes(), y para acceder a uno, por ejemplo la id haríamos .attributes().id ), sus clases (.classes()), etc.Podemos ver todos sus métodos en la documentación oficial de Vue test utils.\nTambién podríamos haber hecho la siguiente comprobación:\nexpect(wrapper.html()).toMatch('&lt;h1&gt;'+msg+'&lt;/h1&gt;')\n\no bien comprobar directamente el valor de prop:\nexpect(wrapper.props().msg).toBe(msg)\n\nComprobar atributos, clases y estilos en línea\nEl componente que vamos a probar es:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;Testing dom attributes&lt;/h1&gt;\n&lt;a href=&quot;https://google.com&quot; class=&quot;link&quot; style=&quot;color:green&quot;&gt;Google&lt;/a&gt; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {};\n&lt;/script&gt;\n\nY el test es:\nimport App from '../src/App.vue'\nimport { shallowMount } from '@vue/test-utils';\n\ndescribe('Testing dom attributes', () =&gt; {\nit('checks href to google ', () =&gt; {\nconst wrapper = shallowMount(App);\nconst a = wrapper.find('a'); //finds an `a` element\nexpect(a.attributes().href).toBe('https://google.com')\n})\n})\n\nSi lo que queremos comprobar son las clases, estas tienen su propio método:\ndescribe('Testing class', () =&gt; {\nit('checks the class to be link', () =&gt; {\nconst wrapper = shallowMount(App);\nconst a = wrapper.find('a'); //finds an `a` element\nexpect(a.classes()).toContain('link')\n})\n})\n\nY lo mismo ocurre para comprobar un estilo:\ndescribe('Testing style', () =&gt; {\nit('checks the inline style color to be green', () =&gt; {\nconst wrapper = shallowMount(App);\nconst a = wrapper.find('a'); //finds an `a` element\nexpect(a.style.color).toBe('green')\n})\n})\n\nComprobar un método de un componente\nEl componente que vamos a probar es:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{{title}}&lt;/h1&gt; &lt;button @click=&quot;changeTitle&quot;&gt;Change title&lt;/button&gt; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ndata: function() {\nreturn {\ntitle: &quot;Hello&quot; };\n},\nmethods: {\nchangeTitle() {\nthis.title = &quot;Hi&quot;; }\n}\n};\n&lt;/script&gt;\n\nY el test es:\nimport { shallowMount } from '@vue/test-utils';\nimport Post from '../src/components/Welcome.vue'\ndescribe('Testing Component Methods', () =&gt; {\nconst wrapper = shallowMount(Post);\n\nit('correctly updates the title when changeTitle is called', () =&gt; {\nexpect(wrapper.vm.title).toBe('Hello'); //initial title Hello\nwrapper.vm.changeTitle(); // calling component method\nexpect(wrapper.vm.title).toBe('Hi'); // title updates to Hi\n})\n})\n\nComprobar que un método es llamado al producirse un evento\nEl componente que vamos a probar es:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{{count}}&lt;/h1&gt;\n&lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ndata: function() {\nreturn {\ncount:0\n};\n},\nmethods: {\nincrement() {\nthis.count++;\n}\n}\n};\n&lt;/script&gt;\n\nY el test es:\nimport { shallowMount } from '@vue/test-utils';\nimport Post from '../src/components/Counter.vue'\n\ndescribe('Testing native dom events', () =&gt; {\nconst wrapper = shallowMount(Post);\n\nit('calls increment method when button is clicked', () =&gt; {\nconst increment = jest.fn(); // mock function\n// updating method with mock function\nwrapper.setMethods({ increment });\n//find the button and trigger click event\nwrapper.find('button').trigger('click');\nexpect(increment).toBeCalled();\n})\n\n})\n\nFuente: Testing Dom events in Vue.js using Jest and vue-test-utils. Sai gowtham\nComprobar que el DOM reacciona a cambios en una variable reactiva\nDado que Vue realiza las actualizaciones de DOM de forma asíncrona, las comprobaciones sobre las actualizaciones de DOM resultantes del cambio de estado, deberán realizarse en un callback Vue.nextTick.\nit('button click should increment the count text', async () =&gt; {\nexpect(wrapper.text()).toContain('0')\nconst button = wrapper.find('button')\nbutton.trigger('click')\nawait Vue.nextTick()\nexpect(wrapper.text()).toContain('1')\n})\n\nComprobar peticiones asíncronas a servicios ajenos a Vue\nEn muchos casos hacemos peticiones asíncronas, como peticiones a una API. Podéis obtener información en:\n\nDoc Vue test utils\nJest: Mock Functions\n...\n\nNuestro primer test: TodoItem.vue\nEn primer lugar vamos a testear que la propiedad 'done' tiene el valor que se le pasa y que cambia al llamar a la función 'toogleDone':\nimport { shallowMount } from '@vue/test-utils'\nimport Usuario from '@/components/Usuario.vue'\n\ndescribe('componente Usuario.vue', () =&gt; {\nit('debe cambiar el valor a true', () =&gt; {\n/// Crea una instancia del componente\nconst wrapper = shallowMount(Usuario);\n\n/// Evalúa que el valor por defecto sea &quot;false&quot;\nexpect(wrapper.vm.usuarioActivo).toBe(false);\n\n/// Ejecuta el metodo que cambia el valor de la variable a &quot;true&quot;\nwrapper.vm.activarUsuario();\n\n/// Evalúa que el nuevo valor usuarioActivo sea &quot;true&quot;\nexpect(wrapper.vm.usuarioActivo).toBe(true);\n})\n})\n\nTestear Vuex\nNormalmente nuestros componentes usaran Vuex para:\n\nhacer un commit a una mutation\nhacer un dispatch a una action\nacceder a los datos mediante state o getters\n\nTestear mutations\nEs sencillo porque sólo son llamadas Javascript. Ejemplo:\n// store.js\n...\nmutations: {\naddPost(state, post) {\nstate.posts.push(post);\n},\n}\n...\n\n// store.spec.js\nimport { mutations } from &quot;@/store/index.js&quot;\n\ndescribe(&quot;addPost&quot;, () =&gt; {\nit(&quot;adds a post to the state&quot;, () =&gt; {\nconst post = { id: 1, title: &quot;Primer post&quot; }\nconst state = {\nposts: [],\n}\n\nmutations.addPost(state, post)\n\nexpect(state).toEqual({\nposts: [ { id: 1, title: 'Primer post' } ]\n})\n})\n})\n\nTestear actions\n\nEjemplo\nPodéis encontrar un completo ejemplo de cómo testear una aplicación ToDo en Adictos al trabajo - Testing en componentes de Vue.js.\nPodéis encontrar ejemplos más completos en muchas páginas, como:\n\n[Testing Vue]\nVue Testing Handbook: completo tutorial de cómo testear todo en nuestros componentes Vue (props, computed, Vuex, router, ...)\nTesting Vuex\nTesting Vue.js Applications\n[]\n\nFuentes:\n\nVue test utils\nDocumentación oficial de Vue\nReactGo: Vue tutorials\nPruebas unitarias en Vue.js: Setup y primeros pasos. Carlos Solis\n\nTest e2e\nNo comprueban un componente sino un workflow completo, por ejemplo, que el usuario introduce algo como nombre de nueva tarea, pulsa enviar y se añade la tarea a la lista.\nAl pasar los tests arranca un servidor de tests (selenium) y un navegador donde hace las pruebas y luego los cierra.",
		"tags": [ "note"]
},

{
		"title": "10-vue3_composition_api",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/10-vue3-composition-api/",
		"content": "La Composition API de Vue3\n\nLa Composition API de Vue3\n\nIntroducción\nEjemplo básico\nsetup\n\n&lt;script setup&gt;\n\nReactividad en Vue3\nConfiguraciones básicas\n\nProps\nComponents\nComputed\nhooks\nrouter\nwatchEffect y watch\nPinia\n\nReusabilidad: composables\n\nValores devueltos\nPaso de parámetros\nOrganizar el código con composables\n\nIntroducción\nVue3 incluye una importante novedad, la Composition API, aunque podemos seguir usando la Options API clásica de Vue2 donde cada elemento (data, computed, methods, ...) es una opción del componente.\nLa forma de trabajar hasta Vue 2 es mediante la Options API donde definíamos un componente mediante una serie de opciones:\nexport default {\nname: &quot;ComponentName&quot;,\nprops: { ... },\ndata() { return {...} },\ncomputed: { ... },\nmethods: { ... },\nmounted() { ... },\n...\n}\n\nEsto es ideal para pequeñas aplicaciones porque mantiene el código ordenado según su funcionalidad: variables en data, funciones en methods, .... Pero en grandes aplicaciones donde un componente necesita hacer varias cosas (como mostrar datos en una tabla pero que esté paginada y con posibilidad de filtrar, ...) el código crece y esta forma de organizarlo se vuelve algo confusa.\nVue3 permite seguir trabajando así pero incorpora una nueva forma de trabajar con nuestros componentes, la Composition API. En ella se define un hook llamado setup() donde escribimos el código que inicializa el componente y devuelve un objeto con las variables y métodos que podrá usar el resto del componente (por ejemplo el template).\n&lt;script&gt;\nimport { defineProps } from &quot;vue&quot;;\n\nexport default {\nname: &quot;ComponentName&quot;,\nprops: defineProps({ ... }), // Props\nsetup(props, context) {\n// Init logic, lifecycle hooks, etc...\n\nreturn {\n// Data, methods, computed, etc...\n}\n}\n}\n&lt;/script&gt;\n\nLa composition API es especialmente útil en aplicaciones grandes ya que va a permitir que nuestros componentes sean mucho más reutilizables. Además nos va a permitir organizar el código por funcionalidades y no por opciones. Por ejemplo si un componente muestra una serie de datos y tiene filtrado de datos y paginación de los mismos en el data() definiré variables para los datos, variables para el filtrado y variables para la paginación. En computed puede que también tenga métodos para las 3 cosas y el methods tendré varios métodos para cada una de las 3 funcionalidades. La composition API me va a permitir que todo el código (data, computed, methods, ...) referente a la funcionalidad de mostrar los datos esté junto y lo mismo para las funcionalidades de filtrar y de paginar:\n\nCuándo es recomendable usarla:\n\nsi queremos soporte total de Typescript\nsi nuestro componente es demasiado largo y queremos organizarlo por características (features)\npara mejorar la reutilización de código entre componentes\n\nEjemplo básico\nPor ejemplo, un componente que muestra un contador y un botón para incrementarlo, con la Options API sería:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n// Properties returned from data() becomes reactive state\n// and will be exposed on `this`.\nprops: ['title'],\ndata() {\nreturn {\ncount: 0\n}\n},\nmethods: {\nincrement() {\nthis.count++\n}\n},\nmounted() {\nconsole.log(`The initial count is ${this.count}.`)\n}\n}\n&lt;/script&gt;\n\nEste ejemplo con la Composition API quedaría:\n&lt;script&gt;\nimport { ref, onMounted } from &quot;vue&quot;;\n\nexport default {\nname: &quot;ComponentName&quot;,\nprops: ['title'],\n\nsetup(props, context) {\nconst count = ref(0)\n\nfunction increment() {\ncount.value++\n}\n\nonMounted(() =&gt; {\nconsole.log(`${props.title}: the initial count is ${count.value}.`)\n})\n\nreturn {\ncount,\nincrement,\n}\n}\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\nFijaos que para hacer reactiva una variable hemos de declararla con ref y su valor lo obtenemos dentro de la propiedad .value, aunque en el &lt;template&gt; no es necesario poner el .value. En el caso de objetos (incluidos arrays) se hacen reactivos con reactive como veremos al hablar de la reactividad.\nLas funciones podemos ponerlas como arrow functions:\nconst increment = () =&gt; {\ncount.value++\n}\n\nsetup\nLo primero que hace un componente que usa esta API es ejecutar su método setup, antes de evaluar ninguna otra característica (data, computed, hooks, ...). Por tanto este método no tiene acceso a this como el resto. Para que pueda acceder a datos que pueda necesitar recibe 2 parámetros:\n\nprops: aquí recibe los parámetros pasados al componente. Todos ellos son reactivos y se pueden observar con un watch\ncontext: es un objeto con las propiedades attrs, slots, parent y emit. Nos permite acceder a lo que antes accedíamos desde this.\n\nEl hook setup() se encarga de:\n\ntareas de inicialización del componente: todo lo que antes se hacía en created() o mounted()\ntareas de definición: aquí se definen las variables (que antes estaban en data), variables calculadas (antes computed), funciones (antes methods) o los watchers.\ndevolver los elementos que se puedan usar en el &lt;template&gt; (variables y funciones)\n\n&lt;script setup&gt;\nAdemás de la sintaxis que hemos visto arriba existe una forma 'reducida' de escribir la parte de &lt;script&gt; que es:\n&lt;script setup&gt;\nimport { ref, defineProps, onMounted } from &quot;vue&quot;;\n\nconst props = defineProps(['title'])\nconst count = ref(0)\n\nconst increment = () =&gt; {\ncount.value++\n}\n\nonMounted(() =&gt; {\nconsole.log(`${props.title}: the initial count is ${count.value}.`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\nEn este caso no es necesario exportar nada (por defecto se exportan las variables y funciones definidas).\nEsta es la sintaxis recomendada cuando usamos SFC por simplicidad y rendimiento tal y como se indica en la documentación de Vue3.\nReactividad en Vue3\nEn la composition API de Vue3 sólo las variables recogidas en props son reactivas. Cualquier otra declarada en el setup que queramos que lo sea debemos declararla con ref si es un tipo primitivo o reactive si es un objeto.\nLa función ref envuelve la variable en un Proxy reactivo. El valor de la variable estará en su propiedad .value, aunque desde el template podemos usarla directamente como hemos visto en el código anterior.\nEn el caso de variables de tipos no primitivos (objetos, arrays, ...) se declaran con reactive pero en este caso no es necesario usar la propiedad .value (es lo mismo que hace el método data() en la options API):\n&lt;script setup&gt;\nimport { reactive, defineProps, onMounted } from &quot;vue&quot;;\n\nconst props = defineProps(['title'])\nconst counter = reactive({ count: 0})\n\nconst increment = () =&gt; {\ncounter.count++\n}\n\nonMounted(() =&gt; {\nconsole.log(`${props.title}: the initial count is ${counter.count}.`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { counter.count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\nSin embargo si cambiamos la referencia del objeto (por ejemplo si lo desestructuramos) pierde su reactividad.\nimport { reactive } from &quot;vue&quot;;\n\nconst counter = reactive({ count: 0})\nlet { count } = counter // count no es reactivo\ncount++ // no afecta a counter.count\n\nPara hacerlo reactivo deberíamos usar el método toRef() o toRefs():\nimport { reactive } from &quot;vue&quot;;\n\nconst counter = reactive({ count: 0})\nlet { count } = toRefs(counter) // count SÍ es reactivo\n\nO bien, si queremos trabajar con las propiedades de un objeto podemos declararlas con ref:\nimport { ref } from &quot;vue&quot;;\n\nconst counter = { count: ref(0) }\nlet { count } = counter // count SÍ es reactivo\n\nTambién hay métodos para ver si una variable es reactiva:\n\nisRef(variable)\nisReactive(variable)\n\nPodéis ver esto con más detalle en:\n\nEscuela VUE.\nDocumentación de Vue\n\nConfiguraciones básicas\nProps\nPara tener acceso a las props hay que hacerlas accesibles con defineProps:\n&lt;script setup&gt;\nimport { defineProps } from &quot;vue&quot;;\n\ndefineProps(['title'])\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nSi necesitamos acceder a ellas desde el código las asignamos a una variable:\n&lt;script setup&gt;\nimport { onMounted, defineProps } from &quot;vue&quot;;\n\nconst props = defineProps(['title'])\n\nonMounted(() =&gt; {\nconsole.log(`El parámetro pasado en 'title' es ${props.title}`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nComponents\nNo necesitamos registrarlos, basta con importarlos y ya se pueden usar:\n&lt;script setup&gt;\nimport ErrorMessages from &quot;./components/ErrorMessages.vue&quot;;\nimport AppNav from &quot;./components/AppNav.vue&quot;;\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;app-nav&gt;&lt;/app-nav&gt;\n&lt;div class=&quot;container&quot;&gt;\n&lt;error-messages&gt;&lt;/error-messages&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nComputed\nEl uso de computed cambia ya que ahora es una función en lugar de un objeto.\n# Options API\ndata(): {\nreturn {\nproductPrice: 100\n}\n},\ncomputed: {\nofferPrice() {\nreturn this.productPrice * 50%\n},\noriginalPrice() {\nreturn this.productPrice\n},\n}\n\n// Composition API\nimport { ref, computed } from &quot;vue&quot;;\n\nconst productPrice = ref(100)\n\nconst offerPrice = computed(() =&gt; productPrice.value * 50%)\nconst originalPrice = computed(() =&gt; productPrice.value)\n...\n\nNOTA: Todas las variables definidas como computed son automáticamente reactivas.\nhooks\nSe les antepone on (ej, onMounted). Ya no son necesarios ni beforeCreated ni created que son sustituidas por el setup.\nPodéis ver esto con más detalle en la documentación de Vue.\nrouter\nPara acceder al router y a la variable route en composition API tenemos que importarlas de vue-router e instanciarlas, ya que no tenemos acceso a this:\nimport { useRouter, useRoute } from 'vue-router'\n\nconst router = useRouter()\nconst route = useRoute()\n\nwatchEffect y watch\nwatch funciona como en Vue2:\n# Vue 3\nimport { ref, watch } from &quot;vue&quot;;\nsetup(props) {\nconst productPrice = ref(props.price);\nwatch(productPrice, (current, prev) =&gt; {\nconsole.log('productPrice current: ' + current + ', prev: ' + prev)\n})\n...\n\nwatchEffect es una función que se ejecuta inmediatamente y cada vez que cambie alguna de sus dependencias reactivas:\nimport { ref, watchEffect } from &quot;vue&quot;;\nsetup(props) {\nconst productPrice = ref(props.price);\nwatchEffect(() =&gt; {\nconsole.log('productPrice current: ' + productPrice.value)\n})\n...\n\nPodemos obtener más información sobre cuándo usar un u otro método en Escuela VUE.\nPinia\nLos ficheros de store no cambian pero sí la forma de usarlos en el componente. Allí se importa el store y cada variable, getter o action que queramos usar en el componente:\n&lt;script setup&gt;\nimport { useCounterStore } from '../stores/counterStore';\nimport { computed } from 'vue';\n\n// store\nconst counterStore = useCounterStore();\n\n//state &amp; getters\nconst count = computed(() =&gt; counterStore.count); // state\nconst lastOperation = computed(() =&gt; counterStore.lastOperation); // getter\n\n//actions\nconst increment = () =&gt; counterStore.increment();\nconst decrement = () =&gt; counterStore.decrement();\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;p&gt;Counter: { { count }}&lt;/p&gt;\n&lt;p&gt;Last: { { lastOperation }}&lt;/p&gt;\n&lt;button @click=&quot;increment()&quot;&gt;Add&lt;/button&gt;\n&lt;button @click=&quot;decrement()&quot;&gt;Subtract&lt;/button&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nReusabilidad: composables\nLa principal razón de ser de la composition API es que permite usar funciones composables, que son funciones donde podemos poner código con estado (es decir, que usa variables reactivas). El nombre de las funciones composables por convenio comienza por use y se usan para encapsular código que podrá usar cualquier componente.\nPor ejemplo podemos hacer una composable que nos proporcione la posición actual del ratón:\n// mouse.js\n\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\nconst x = ref(0)\nconst y = ref(0)\n\nfunction update(event) {\nx.value = event.pageX\ny.value = event.pageY\n}\n\nonMounted(() =&gt; window.addEventListener('mousemove', update))\nonUnmounted(() =&gt; window.removeEventListener('mousemove', update))\n\nreturn { x, y }\n}\n\nLa función useMouse proporciona a quien la importe 2 variables reactivas (x e y) donde se encuentra la posición actual del ratón, actualizada por la función update.\nEn cualquier componente donde necesitemos conocer la posición del ratón sólo necesitamos importar esta función:\n&lt;script setup&gt;\nimport { useMouse } from './useMouse';\nconst { x, y } = useMouse();\n&lt;/script&gt;\n\n&lt;template&gt;\nX: { { x }} Y: { { y }}\n&lt;/template&gt;\n\nSiempre que pongamos un escuchador en una composable (como hemos hecho en el onMounted) debemos quitarlo cuando ya no se utilice (en el unMounted).\nValores devueltos\nComo se ve la composable devuelve un objeto formado por variables reactivas (refs) en lugar de un objeto reactivo. Se hace así por convención, lo que permite desestructurar las variables en el componente que las vaya a usar sin perder su reactividad (al desestructurar un reactive deja de serlo).\nSi lo hubiéramos hecho con un reactive NO funcionaría:\n// mouse.js MAL\n\nimport { reactive, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\nconst x = 0\nconst y = 0\n\n...\nreturn reactive({ x, y })\n}\n\nporque entonces al hacer en el componente\nconst { x, y } = useMouse();\n\nlas variables x e y dejarían de ser reactivas.\nPodría hacerse no desestructurando el objeto, pero se prefiere así por claridad, para tener claras qué variables nos proporciona la función:\n&lt;script setup&gt;\nimport { useMouse } from './useMouse';\nconst position = useMouse();\n&lt;/script&gt;\n\n&lt;template&gt;\nX: { { position.x }} Y: { { position.y }}\n&lt;/template&gt;\n\nEsto sí funcionaría pero se recomienda la otra forma: una composable devuelve un array de variables reactivas que se importan (desestructurando el objeto) en el componente que las vaya a usar.\nPaso de parámetros\nPodemos pasar parámetros a las funciones composables en el momento de usarlas y dichos parámetros los recibirá directamente la composable como cualquier otra función.\nPor ejemplo podemos crear useFetch a la que le pasamos una url y hace un fetch para hacer la llamada a esa url y devolver los datos o el error devueltos por el servidor.\nEl componente que quiera usarla haría:\n&lt;script setup&gt;\nimport { useFetch } from './useFetch';\nconst { data, error } = useFetch('https://jsonplaceholder.typicode.com/users/3')\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div v-if=&quot;error&quot;&gt;{{ error }}&lt;/div&gt;\n&lt;div v-else&gt;\n// Aquí mostramos los datos recibidos en la variable 'data'\n&lt;/div&gt;\n&lt;/template&gt;\n\nY nuestra función haría:\n// useFetch.js\nimport { ref } from 'vue'\n\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\n\nfetch(url)\n.then((res) =&gt; res.json())\n.then((json) =&gt; (data.value = json))\n.catch((err) =&gt; (error.value = err))\n\nreturn { data, error }\n}\n\nSi el parámetro recibido es reactivo podemos hacer que la función se ejecute cada vez que cambie observándolo con watch o watchEffect:\n// fetch.js\nimport { ref, watch } from 'vue'\n\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\n\nfunction doFetch() {\nfetch(url.value)\n.then((res) =&gt; res.json())\n.then((json) =&gt; (data.value = json))\n.catch((err) =&gt; (error.value = err))\n}\n\nwatch(url, () =&gt; doFetch())\n\nreturn { data, error }\n}\n\nSi nuestras composables pueden recibir parámetros reactivos siempre es una buena práctica que puedan recibir también parámetros primitivos (en el caso anterior daría un error al hacer fetch(url.value) porque url es un string). La forma más correcta de hacerlo sería:\n// fetch.js\nimport { ref, isRef, unref, watchEffect } from 'vue'\n\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\n\nfunction doFetch() {\n// reset state before fetching..\ndata.value = null\nerror.value = null\n// unref() unwraps potential refs\nfetch(unref(url))\n.then((res) =&gt; res.json())\n.then((json) =&gt; (data.value = json))\n.catch((err) =&gt; (error.value = err))\n}\n\nif (isRef(url)) {\n// setup reactive re-fetch if input URL is a ref\nwatchEffect(doFetch)\n} else {\n// otherwise, just fetch once\n// and avoid the overhead of a watcher\ndoFetch()\n}\n\nreturn { data, error }\n}\n\nEn este caso se ha hecho una función que va a funcionar tanto si se le pasa un url estática como si se le pasa una reactiva. Lo que ha cambiado es:\n\nisRef: nos dice si el parámetro pasado es o no reactivo. Si no lo es llama directamente a la función. Si lo es hace\nwatchEffect: cada vez que cambie el valor de url llamará a la función\nunref: devuelve el .value de una variable si es reactiva o la variable si no lo es. Si url es reactiva devuelve url.value y si no devuelve url.\n\nOrganizar el código con composables\nAdemás de para que el código sea fácilmente reutilizable, las composables se usan para sacar código de un componente cuando este es demasiado grande o se encarga de varias funcionalidades. Una vez creadas las funciones se usan en el componente:\n&lt;script setup&gt;\nimport { useFeatureA } from './featureA.js'\nimport { useFeatureB } from './featureB.js'\nimport { useFeatureC } from './featureC.js'\n\nconst { foo, bar } = useFeatureA()\nconst { baz } = useFeatureB(foo)\nconst { qux } = useFeatureC(baz)\n&lt;/script&gt;\n\nSi tenemos que usar una función composable en un componente escrito en modo Options API simplemente añadimos el hook setup y allí la llamamos:\nimport { useMouse } from './mouse.js'\nimport { useFetch } from './fetch.js'\n\nexport default {\nsetup() {\nconst { x, y } = useMouse()\nconst { data, error } = useFetch('...')\nreturn { x, y, data, error }\n},\nmounted() {\n// setup() exposed properties can be accessed on `this`\nconsole.log(this.x)\n}\n// ...other options\n}\n\nAlgunos enlaces útiles:\n\nHow to Create Reusable Components with the Vue 3 Composition API\nWhy I Love Vue 3's Composition API\n\nPodemos encontrar infinidad de composables que podemos usar en nuestro código en la página VueUse.",
		"tags": [ "note"]
},

{
		"title": "21-typescript",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/21-typescript/",
		"content": "Typescript\n\nTypescript\n\nIntroducción\nTypescript en Vue\nTipos de datos\nDefinir variables\n\nCrear custom types\ninterfaces\nCreación automática de interfaces\n\nTipos genéricos\nClases\nDecoradores\n\nIntroducción\nEs un lenguaje basado el Javascript al que le ha añadido definiciones de tipos estáticas y alguna característica más.\nEl hecho de que Javascript permite cambiar dinámicamente el tipo de datos de una variable da lugar a veces a resultados inesperados y dificulta la localización de errores derivados de un uso no adecuado de esto.\nTypescript obliga a definir el tipo de datos de una variable e impide cambiarlo (como sucede en la mayoría de lenguajes de programación) lo que nos obliga a escribir un código más consistente. Esto es especialmente importante en proyectos grandes o en los que colaboran muchos programadores.\nTypescript en Vue\nEl soporte de Typescript en Vue 3 es total ya que este framework ha sido totalmente reescrito en este lenguaje. Cuando creamos un nuevo proyecto una de las opciones que podemos marcar es Typescript con lo que ya tendremos todo preparado para utilizar este lenguaje en nuestro proyecto. Veremos que al crearse el proyecto el fichero main.js ahora se llama main.ts. Además se crea un nuevo fichero llamado tsconfig.json con configuraciones por defecto para Typescript.\nSi queremos añadir Typescript a un proyecto ya existente lo añadiremos como plugin:\nvue add typescript\n\nAl hacerlo nos pregunta, entre otras cosas, si queremos convertir todos nuestros ficheros .js a .ts.\nPara usar TS en un componente tenemos que indicarlo en la etiqueta &lt;script&gt; e importar defineComponent para transformar el objeto que exportamos. Con Javascript definimos un SFC con:\n&lt;script&gt;\nexport default {\nname: ...,\n...\n}\n&lt;/script&gt;\n\nEsto con Typescript se haría:\n&lt;script lang=&quot;ts&quot;&gt;\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\nname: ...,\n...\n})\n&lt;/script&gt;\n\nNo es necesario que todos los componentes estén en Typescript(o Javascript) sino que cada uno puede ser diferente.\nTipos de datos\nLos tipos de datos que podemos encontrar en Javascript son:\n\nString\nNumber\nBoolean\nArray\nTuple (como un array con un número fijo de elementos)\nEnum (permite asignar nombres amigables a conjuntos de números)\nFunction\nObject\nAny (puede ser de cualquier tipo)\nVoid (se aplica a funciones que no devuelven nada)\n\nDefinir variables\nEl tipo de datos de una variable lo indicamos al definirla con el caràcter : (dos puntos):\nlet title: string = 'Aprende Typescript'\nlet numPages: number = 100\nlet isFree: boolean = true\n\nEn los arrays debemos indicar el tipo de datos de los elementos del array:\nlet lenguajes: string[] = ['Typescript', 'Javascript', 'PHP']\nlet notes: number[] = [3, 4.5, 7, 4, 9]\n\nRespecto a los objetos hay que definir el tipo de cada propiedad y a continuación asignarles su valor\nlet Student: {\nname: string;\nage: number;\nmodules: string[];\n} = {\nname: 'Peter Parker',\nage: 20,\nmodules: ['DWEC', 'DWES', 'DAW']\n}\n\nY en las funciones debemos indicar el tipo de datos de sus parámetros y de la propia función:\nlet getFullName = (firstName: string, lastName: string): string =&gt; {\nreturn firstName + ' ' + lastName\n}\n\nCrear custom types\nPodemos definir nuestros propios tipos de datos. Por ejemplo crearemos un tipo para los valores permitidos para la clase de un botón:\ntype buttonType = 'primary' | 'secondary' | 'success' | 'danger'\n\nlet myBtnStyle: buttonType = 'danger'\n\nSi le asigno un valor que no es uno de los definidos en su tipo se producirá un error.\ninterfaces\nUna interface es la definición de los tipos de datos de un objeto, para evitar definirlo como hemos visto antes que es demasiado verbose. Por tanto es como definir nu nuevo tipo de datos.\ntype Modules = 'DWEC' | 'DWES' |'DIW' |'DAW' | 'EIE' | 'Inglés'\n\ninterface Student {\nname: string;\nage: number;\nmodules: Modules[]; // o también modules: Array&lt;Modules&gt;\n}\n\nPodemos centralizar todas las interfaces que se usan en más de un componente en un fichero al que podemos llamar src/types.ts:\ntype Modules = 'DWEC' | 'DWES' |'DIW' |'DAW' | 'EIE' | 'Inglés'\n\nexport interface Student {\nname: string;\nage: number;\nmodules: Modules[];\n}\n\nA veces definimos un objeto vacío pero que cuando tenga datos será de cierto tipo. Para que Typescript no piense que se trata de un objeto sin propiedades lo definiremos con as:\nlet futureStudent = {} as Student\n\nEsto nos permitirá hacer cosas como futureStudent.name = 'Peter Parker' sin que se produzcan errores de tipo. A esto se llama type assertions.\nSi se quiere aplicar un tipo propio a una variable pasada por props debemos importar el helper PropType:\nimport { defineComponent, PropType } from 'vue'\n\nexport default defineComponent({\nprops: {\nStudent: {\ntype: Object as PropType&lt;Student&gt;,\nrequired: true\n}\n},\n})\n\nPara centralizar la definición de tipos se suelen incluir todos los tipos e interfaces en un fichero que llamaremos src/types.ts. Deberemos exportar los tipos y/o interfaces.\nVisual Studio Code incluye la extensión VueDX que nos informa al escribir código si un objeto tiene o no la propiedad que estamos escribiendo. Es muy recomendable instalarla cuando trabajamos con Typescript.\nCreación automática de interfaces\nTenemos utilidades que nos permiten generar automáticamente las interfaces de nuestra aplicación a partir de la documentación de la API o incluso a partir del fichero JSON de los datos.\nUn ejemplo es Quicktype donde pegamos nuestros datos en formato JSON y genera automáticamente las interfaces y types necesarios en typescript.\nTipos genéricos\nA veces nos gustaría que una función pudiera trabajar con distintos tipos de datos. Por ejemplo, una función para añadir un item a una lista podría ser:\nfunction addItemToNumberList(item: number, list: number[]): number[] {\nlist.push(item)\n\nreturn list\n}\n\nconst numberList = addItemToNumberList(123, [])\n\nSi queremos algo similar para listas de cadenas habría que crear otra función pero de tipo string. En lugar de eso podemos decir que el tipo de los parámetros y de la función sea genérico:\nfunction addItemToList&lt;T&gt;(item: T, list: T[]): T[] {\nlist.push(item)\n\nreturn list\n}\n\nconst numberList = addItemList&lt;number&gt;(123, [])\nconst stringList = addItemList&lt;string&gt;('manzanas', [])\n\nClases\nSon muy similares a las de otros lenguajes. Ejemplo:\nclass Student {\npublic name : string; // atributo accesible desde fuera de la clase\nprotected age: number; // accesible desde clases que hereden de Student\nprivate nia : string; // accesible sólo desde la clase Student\n\nconstructor(name:string ,age:number, nia:string){\nthis.name = name;\nthis.age = age;\nthis.nia = nia;\n}\ngetName(){\nreturn this.name;\n}\n\nsetName(name:string){\nthis.name = name;\n}\ngetAge(){\nreturn this.age;\n}\n\nsetAge(age:number){\nthis.age = age;\n}\n\ngetNia(nia:string){\nthis.nia = nia;\n}\n}\n\nLos getters y setters también pueden definirse como:\n...\nget name(){\nreturn this.name;\n}\n\nset name(name:string){\nthis.name = name;\n}\n...}\n\nSería conveniente definir una interfaz para el objeto Student:\ninterface IStudent {\nname: string;\nage: number;\nnia: string\n\ngreeting: () =&gt; void\n}\n\nclass Student implements IStudent {\nconstructor(name:string ,age:number, nia:string){\nthis.name = name;\nthis.age = age;\nthis.nia = nia;\n}\n...\nfunction greetings () {\nconsole.log('Hi ' + this.name)\n}\n}\n\nLa interfaz obliga a las clases que la implementen a definir, al menos, todas las propiedades y todos los métodos de la interfaz.\nDecoradores\nOtra utilidad importante de Typescript son los decoradores que permiten &quot;decorar&quot; un constructor o método, es decir, personalizarlo para que haga algo ligeramente diferente a lo que hace el genérico.",
		"tags": [ "note"]
},

{
		"title": "90-tdd",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/daw/vue-teoria-batoi/90-tdd/",
		"content": "Desarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y después refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el est (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).\nUsar TDD en Javascript\nLo más sencillo es usar alguna librería como Mocha. Se trata de un gramework que se ejecuta sobre Node.js y permite crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado. Luego creamos una carpeta para nuestro proyecto y dentro ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
},

{
		"title": "Indice",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "Asignaturas:\nAcceso a datos\nDesarrollo de interfaces\nDigitalizacion aplicada el sistema productivo GS\nItinerario personal para la empleabilidad II\nMódulo optativo\nProgramación de servicios y procesos\nProgramación multimedia y dispositivos móviles\nProyecto intermodular 2 de Desarrollo de aplicaciones multiplataforma\nSistemas de gestión empresarial\nSostenibilidad aplicada al sistema productivo\nTutoria\nHorario:\n\nHora\nLunes\nMartes\nMiercoles\nJueves\nViernes\n\n14:55 - 15:50\nDesarrollo de interfaces\nProgramación multimedia y dispositivos móviles\nProgramación de servicios y procesos\nProyecto intermodular 2 de Desarrollo de aplicaciones multiplataforma\nItinerario personal para la empleabilidad II\n\n15:50 - 16:45\nDesarrollo de interfaces\nProgramación multimedia y dispositivos móviles\nProgramación de servicios y procesos\nProyecto intermodular 2 de Desarrollo de aplicaciones multiplataforma\nItinerario personal para la empleabilidad II\n\n16:45 - 17:40\nDesarrollo de interfaces\nTutoria\nDesarrollo de interfaces\nMódulo optativo\nSostenibilidad aplicada al sistema productivo\n\n17:40 - 18:00\nDescanso\nDescanso\nDescanso\nDescanso\nDescanso\n\n18:00 - 18:55\nItinerario personal para la empleabilidad II\nProyecto intermodular 2 de Desarrollo de aplicaciones multiplataforma\nDesarrollo de interfaces\nAcceso a datos\nProgramación multimedia y dispositivos móviles\n\n18:55 - 19:50\nMódulo optativo\nSistemas de gestión empresarial\nAcceso a datos\nAcceso a datos\nProgramación multimedia y dispositivos móviles\n\n19:50 - 20:45\nMódulo optativo\nSistemas de gestión empresarial\nAcceso a datos\nSistemas de gestión empresarial\nSistemas de gestión empresarial\n\n20:45 - 21:40\n\nDigitalizacion aplicada el sistema productivo GS",
		"tags": [ "note","gardenEntry"]
},

{
		"title": "04-axios",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/04-axios/",
		"content": "Tabla de contenidos\n\nAxios\n\nInstalación\nUsar axios\nAplicación de ejemplo\n\nPedir los datos al cargarse\nBorrar un todo\nAñadir un todo\nActualizar el campo done\nBorrar todas las tareas\n\nOrganizar las peticiones\n\nApi con varias tablas\nApi como clase\nEl fichero .env\n\nAxios interceptors\n\nAxios\nEl framework Vue sólo se ocupa de la capa de vista de la aplcación pero su &quot;ecosistema&quot; como sus creadores le llaman, incluye multitud de herramientas para todo lo que podamos necesitar a la hora de realizar grandes proyectos.\nUna de las librerías más utilizadas es la que permite realizar de forma sencilla peticiones Ajax a un servidor. Existen múltiples librerías para ello y la más utilizada es axios.\nPodríamos hacer peticiones Ajax como vimos en Javascript (con fetch y async/await) pero es más sencillo con axios. Axios ya devuelve los datos transformados a JSON en una propiedad llamada data.\nInstalación\nComo esta librería vamos a usarla en producción la instalaremos como dependencia del proyecto:\nnpm install axios -S\n\nUsar axios\nEn el componente en que vayamos a usarla la importaremos:\nimport axios from 'axios'\n\nComo es una dependencia incluida en el package.json no se indica su ruta (se buscará en node-modules).\nYa podemos hacer peticiones Ajax en el componente. Para ello axios incluye los métodos:\n\n.get(url): realiza una petición GET a la url pasada como parámetro que supondrá una consulta SELECT a la base de datos\n.post(url, objeto): realiza una petición POST a la url pasada como parámetro que posiblemente realizará un INSERT del objeto pasado como segundo parámetro\n.put(url, objeto): realiza una petición PUT a la url pasada como parámetro que posiblemente realizará un UPDATE sobre el registro indicado en la url que será actualizado con los datos del objeto pasado como segundo parámetro\n.delete(url): realiza una petición DELETE a la url pasada como parámetro que supondrá una consulta DELETE a la base de datos para borrar el registro indicado en la url\n\nEstos métodos devuelven una promesa por lo que al hacer la petición deberemos anteponerle el await o bien indicaremos con el método .then la función que se ejecutará cuando responda el servidor si la petición se resuelve correctamente y con el método .catch la función que se ejecutará cuando responda el servidor si ocurre algún error.\nLo que devuelve es un objeto que tiene, entre otras, las propiedades:\n\ndata: aquí tendremos los datos devueltos por el servidor\nstatus: obtendremos el código de la respuesta del servidor (200, 404, ...)\nstatusText: el texto de la respuesta del servidor ('Ok', 'Not found', ...)\nmessage: mensaje del servidor en caso de producirse un error\nheaders: las cabeceras HTTP de la respuesta\n...\n\nLa sintaxis de una petición GET a axios usando async/await sería algo como:\ntry {\nconst response = await axios.get(url)\nconsole.log(response.data)\n} catch (response) {\nconsole.error(response.message)\n}\n\ny usando promesas sería algo como:\naxios.get(url)\n.then(response =&gt; console.log(response.data))\n.catch(response =&gt; console.error(response.message))\n\nAplicación de ejemplo\nVamos a seguir con la aplicación de la lista de tareas pero ahora los datos no serán un array estático sino que estarán en un servidor. Usaremos como servidor para probar la aplicación json-server por lo que las peticiones serán a la URL 'localhost:3000' que es el servidor web de json-server.\nLos cambios que debemos hacer en nuestra aplicación son:\n\nEl componente principal (TodoList) pide todos los datos al cargarse\nAl borrar un elemento haremos una petición al servidor para que lo borre de allí y cuando sepamos que se ha borrado lo borramos del array (o recargamos los datos)\nLo mismo al insertar un nuevo elemento\nAl marcar/desmarcar un elemento lo modificaremos en la base de datos\nPara borrarlos todos haremos peticiones DELETE al servidor\n\nVamos a modificar los diferentes componentes para implementar os cambios requeridos:\nPedir los datos al cargarse\nModificamos el fichero TodoList.vue para añadir en su sección script:\n\nAntes del objeto vue:\n\nimport axios from 'axios'\n\nconst SERVER = 'http://localhost:3000'\n// o mejor, si usamos el fichero .env como vimos en Javascript\n// const SERVER = import.meta.env.VITE_URL_API\n\nDentro del objeto añadimos el hook mounted() para hacer la petición Ajax al montar el componente (recordad que esa función se ejecuta automáticamente cuando se acaba de renderizar el componente):\n\n...\nasync mounted() {\ntry {\nconst response = await axios.get(SERVER + '/todos')\nthis.todos = response.data\n} catch (response) {\nalert('Error: ' + response.message)\nthis.todos=[]\n}\n},\n...\n\nBorrar un todo\nModificamos el método delTodo del fichero Todo-List.vue:\nasync delTodo(index){\nconst id = this.todos[index].id\ntry {\nawait axios.delete(SERVER + '/todos/' + id)\nthis.todos.splice(index, 1)\n} catch (response) {\nalert('Error: no se ha borrado el registro. ' + response.message)\n}\n},\n\nAñadir un todo\nModificamos el método addTodo del fichero Todo-List.vue:\nasync addTodo(title) {\ntry {\nconst response = await axios.post(SERVER + '/todos', {\ntitle: title,\ndone: false\n})\nthis.todos.push(response.data)\n} catch (response) {\nalert('Error: no se ha añadido el registro. ' + response.message)\n}\n},\n\nAl servidor hay que pasarle como parámetro el objeto a añadir. En el caso de json-server devolverá en el response.data el nuevo objeto añadido al completo. Otras APIs devuelven sólo la id del nuevo registro o pueden no devolver nada.\nActualizar el campo done\nAhora ya no nos es útil el índice de la tarea a actualizar sino que necesitamos su id, su título y su estado así que modificamos el template del fichero TodoList.vue para pasar el elemento entero a la función:\n&lt;todo-item\nv-for = &quot;(item,index) in todos&quot;\n:key = &quot;item.id&quot;\n:todo = &quot;item&quot;\n@delItem = &quot;delTodo(index)&quot;\n@doneChanged = &quot;toogleDone(item)&quot;&gt;\n&lt;/todo-item&gt;\n\nA continuación modificamos el método changeTodo del fichero TodoList.vue:\nasync toogleDone(todo) {\ntry {\nconst response = await axios.patch(SERVER + '/todos/' + todo.id, {\ndone: !todo.done\n})\ntodo.done = response.data.done\n} catch (response) {\nalert('Error: no se ha modificado el registro. ' + response.message)\n}\n},\n\nBorrar todas las tareas\nModificamos el método delTodos del fichero TodoList.vue. Como el servidor no tiene una llamada para borrar todos los datos podemos recorrer el array todos y borrar cada tarea usando el método delTodo que ya tenemos hecho:\ndelTodos() {\nthis.todos.forEach((todo, index) =&gt; this.delTodo(index))\n}\n\nEsto no tiene mucho sentido y si necesito borrar todos los datos de la base de datos lo mejor es que la API me proporcione un método para borrarlos todos.\nSi lo probáis este código con muchos registros es posible que no se borren todos correctamente (en realidad sí se borran de la base de datos pero no del array). ¿Sabes por qué?. ¿Cómo lo podemos arreglar? (PISTA: el índice cambia según los elementos que haya y las peticiones asíncronas pueden no ejecutarse en el orden que esperamos).\nOrganizar las peticiones\nQue cada componente haga llamadas a axios tiene el inconveniente de que cada uno crea su propia instancia, además de que tenemos las peticiones a la API desperdigadas por el código. Para mejorar la legibilidad del código vamos a crear un fichero que será donde estén las peticiones a axios de forma que nuestros componentes queden más limpios. Otra ventaja de centralizar las peticiones es que cosas como la URL a la que hacer la petición la definimos en un único sitio.\nPodríamos llamar al fichero repositories/todosRepository.js y allí creamos las funciones que laman a la API:\nimport axios from 'axios'\n\nconst apiClient = axios.create({\n// Esta parte es opcional. Estamos creando un 'axios' personailizado con las opciones\n// que necesitemos para no tener que indicarlas cada vez. En concreto:\n// - baseURL: lo que antecederá a la ruta de cada petición\n// - headers.Accept: el tipo de datos que esperamos obtener (no es necesario\n// porque JSON es la opción por defecto)\n// - headers.Content-type: el tipo de datos que estamos pasando al servidor (no es\n// necesario porque JSON es la opción por defecto)\n// - headers.Authorization: el token que enviaremos junto a cada petición\nbaseURL: 'http://localhost:3000',\nheaders: {\nAccept: 'application/json',\n'Content-Type': 'application/json'\nAuthorization = 'Bearer ' + localStorage.token\n}\n})\n\nexport default {\ngetTodos() {\nreturn apiClient.get('/todos')\n},\n\ndelTodo(id){\nreturn apiClient.delete('/todos/' + id)\n},\n\naddTodo(newTodo) {\nreturn apiClient.post('/todos', newTodo)\n},\n\ntoogleDone(todo) {\nreturn apiClient.put('/todos/' + todo.id, {\nid: todo.id,\ntitle: todo.title,\ndone: !todo.done\n})\n},\n}\n\nEn primer lugar importamos axios y a continuación creamos una única instancia con las opciones que necesitemos. En este ejemplo estamos enviando al servidor el token del usuario con cada petición.\nEn cada componente que tenga que hacer una llamada a la API se importa este fichero y se llama a sus funciones:\nimport todosRepository from '../repositories/todosRepository'\n\nexport default {\n...\nmethods: {\nasync getData() {\ntry {\nconst response = await todosRepository.getTodos()\nthis.todos = response.data\n} catch (response) {\nconsole.error('Error: ' + response.message)\n}\n},\n...\n},\ncreated() {\nthis.getData()\n},\n}\n\nApi con varias tablas\nSi trabajamos con varias tablas podemos hacer un fichero de repositorio para cada una de ellas o bien podemos escribir lo mismo de antes pero de forma más concisa:\nimport axios from 'axios'\n\nconst apiClient = axios.create({\nbaseURL: 'http://localhost:3000',\nwithCredentials: false,\nheaders: {\nAccept: 'application/json',\n'Content-Type': 'application/json'\n}\n})\n\nconst todos = {\ngetAll: () =&gt; apiClient.get(`/todos`),\ngetOne: (id) =&gt; apiClient.get(`/todos/${id}`),\ncreate: (item) =&gt; apiClient.post(`/todos`, item),\nmodify: (item) =&gt; apiClient.put(`/todos/${item.id}`, item),\ndelete: (id) =&gt; apiClient.delete(`/todos/${id}`),\ntoogleDone: (item) =&gt; apiClient.put(`/categories/${item.id}`, {\nid: item.id,\ntitle: item.title,\ndone: !item.done\n}),\n}\n\nconst categories = {\ngetAll: () =&gt; apiClient.get(`/categories`),\ngetOne: (id) =&gt; apiClient.get(`/categories/${id}`),\ncreate: (item) =&gt; apiClient.post(`/categories`, item),\nmodify: (item) =&gt; apiClient.put(`/categories/${item.id}`, item),\ndelete: (id) =&gt; apiClient.delete(`/categories/${id}`),\n}\n\nexport default {\ntodos,\ncategories,\n}\n\nY en los componentes donde queramos usarlo importamos el fichero y llamamos a las funciones que necesitemos:\nimport apiService from '../apiService'\n\nexport default {\nmethods: {\nasync getData() {\ntry {\nconst response = await apiService.todos.getAll()\nthis.todos = response.data\n} catch (response) {\nconsole.error('Error: ' + response.message)\n}\n},\n},\n}\n\nApi como clase\nTambién podemos usar programación orientada a objetos para hacer nuestra ApiService y construir una clase que se ocupe de las peticiones a la API:\nimport axios from 'axios'\n\nconst apiClient = axios.create({\nbaseURL: 'http://localhost:3000',\nwithCredentials: false,\nheaders: {\nAccept: 'application/json',\n'Content-Type': 'application/json'\n}\n})\n\nexport default class APIService{\nconstructor(){\n}\ngetTodos() {\nreturn apiClient.get('/todos')\n}\ndelTodo(id){\nreturn apiClient.delete('/todos/'+id)\n},\naddTodo(newTodo) {\nreturn apiClient.post('/todos', newTodo)\n},\ntoogleDone(todo) {\nreturn apiClient.put('/todos/'+todo.id, {\nid: todo.id,\ntitle: todo.title,\ndone: !todo.done\n})\n},\n}\n\nY en los componentes donde queramos usarlo importamos la clase y creamos una instancia de la misma:\nimport APIService from '../APIService'\n\nconst apiService = new APIService()\n\nexport default {\nmethods: {\nasync getData() {\ntry {\nconst response = await apiService.getAll()\nthis.todos = response.data\n} catch (response) {\nconsole.error('Error: ' + response.message)\n}\n},\n},\n}\n\nEl fichero .env\nSe trata de un fichero donde guardar las configuraciones de la aplicación y la ruta del servidor es una constante que estaría mejor en este fichero que en el código como hemos hecho nosotros.\nVue por medio de Vite puede acceder a todas las variables de .env que comiencen por VITE_ por medio del objeto import.meta.env por lo que en nuestro código en vez de darle el valor a baseURL podríamos haber puesto:\nconst apiClient = axios.create({\nbaseURL: import.meta.env.VITE_RUTA_API,\n...\n})\n\nY en el fichero .env ponemos\nVITE_RUTA_API=http://localhost:3000\n\nSi usamos Vue con webpack las variables de .env deben comenzar por VUE_APP_ y accedemos a ellas por medio del objeto process.env por lo que en el fichero .env definiríamos la variable VUE_APP_RUTA_API=http://localhost:3000 y en nuestro código pondría:\nconst apiClient = axios.create({\nbaseURL: process.env.VUE_APP_RUTA_API,\n...\n})\n\nEl fichero .env por defecto se sube al repositorio por lo que no debemos poner información sensible (como usuarios o contraseñas). Para ello tenemos un fichero .env.local que no se sube, o bien debemos añadir al .gitignore dicho fichero. En cualquier caso, si el fichero con la configuración no lo subimos al repositorio es conveniente tener un fichero .env.exemple, que sí se sube, con valores predeterminados para las distintas variables que deberán cambiarse por los valores adecuados en producción. Además del .env y el .env.local también hay distintos ficheros que son usados en desarrollo (.env.development) y en producción (.env.production) y que pueden tener distintos datos según el entorno en que nos encontramos. Por ejemplo en el de desarrollo el valor de VUE_APP_RUTA_API podría ser &quot;http://localhost:3000&quot; si usamos json-server mientras que en el de producción tendríamos la ruta del servidor de producción de la API.\nAxios interceptors\nPodemos hacer que se ejecute código antes de cualquier petición a axios o tras recibir la respuesta del servidor usando los interceptores de axios. Es otra forma de enviar un token que nos autentifique ante una API sin tener que ponerlo en el código de cada petición, pero también nos permite hacer cualquier cosa que necesitemos.\nY podemos interceptar las respuestas para, por ejemplo, redireccionar a la página de login si el servidor nos devuelve un error 401 (no autorizado).\nPara interceptar las peticiones que hacemos usaremos axios.interceptors.request.use( (config) =&gt; fnAEjecutar, (error) =&gt; fnAEjecutar) y para interceptar las respuestas del servidor axios.interceptors.response.use( (response) =&gt; fnAEjecutar, (error) =&gt; fnAEjecutar). Se les pasa como parámetro la función a ejecutar si todo es correcto y la que se ejecutará si ha habido algún error. El interceptor de peticiones recibe como parámetro un objeto con toda la configuración de la petición (incluyendo sus cabeceras) y el interceptor de respuestas recibe la respuesta del servidor.\nVeamos un ejemplo en que queremos enviar en las cabeceras de cada petición el token que tenemos almacenado en el LocalStorage y queremos mostrar un alert siempre que el servidor devuelva en su respuesta un error que no sea de tipo 400. Además mostraremos por consola las peticiones y las respuestas si activamos el modo DEBUG:\nimport axios from 'axios'\nconst baseURL = 'http://localhost:3000'\nconst DEBUG = true\n\naxios.interceptors.request.use((config) =&gt; {\nif (DEBUG) {\nconsole.info('Request: ', config)\n}\n\nconst token = localStorage.token\nif (token) {\nconfig.headers['Authorization'] = 'Bearer ' + localStorage.token\n}\nreturn config\n}, (error) =&gt; {\nif (DEBUG) {\nconsole.error('Request error: ', error)\n}\nreturn Promise.reject(error)\n})\n\naxios.interceptors.response.use((response) =&gt; {\nif (DEBUG) {\nconsole.info('Response: ', response)\n}\nreturn response\n}, (error) =&gt; {\nif (error.response &amp;&amp; error.response.status !== 400) {\nalert('Response error ' + error.response.status + '(' + error.response.statusText + ')')\n}\nif (DEBUG) {\nconsole.info('Response error: ', error)\n}\nreturn Promise.reject(error)\n})\n\nconst categories = {\ngetAll: () =&gt; axios.get(`${baseURL}/categories`),\ngetOne: (id) =&gt; axios.get(`${baseURL}/categories/${id}`),\ncreate: (item) =&gt; axios.post(`${baseURL}/categories`, item),\nmodify: (item) =&gt; axios.put(`${baseURL}/categories/${item.id}`, item),\ndelete: (id) =&gt; axios.delete(`${baseURL}/categories/${id}`),\n}\n\nexport default {\ncategories,\n}",
		"tags": [ "note"]
},

{
		"title": "05-vue-router",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/05-vue-router/",
		"content": "Vue-router\n\nVue-router\n\nIntroducción\nInstalación\n\nAñadir vue-router a un proyecto ya creado\n\nCrear las rutas\n\nRutas dinámicas\nOpciones de cada ruta\n\nCrear un menú\nSaltar a una ruta\nPaso de parámetros\nEl objeto $route\nRuta no encontrada: 404 Not found\nRedireccionamiento\nCambio de parámetros en una ruta\nVistas con nombre y Subvistas\n\nIntroducción\nComo comentamos al principio Vue nos va a permitir crear SPA (Single Page Applications) lo que significa que sólo se cargará una pagina: index.html. Sin embargo nuestra aplicación estará dividida en diferentes vistas que el usuario percibirá como si fueran páginas diferentes y el encargado de gestionar la navegación entre estas vistas/páginas es vue-router que es otra de las librerías del &quot;ecosistema&quot; de Vue (en este caso realizada por los desarrolladores de Vue).\nEn resumen, en nuestra aplicación (normalmente en el App.vue) tendremos una etiqueta &lt;router-view&gt; y lo que hará vue-router es cargar en esa etiqueta el componente que corresponda en función de la ruta que haya en la barra de direcciones del navegador. Por ejemplo si la URL es /products cargará un componente llamado ProductsTable (que mostrará una tabla con todos los productos de la aplicación) y si la URL es /newprod cargará un componente llamado ProductForm con un formulario para añadir un nuevo producto.\nLo que hacemos para configurar vue-router es definir rutas que mapean componentes de nuestra aplicación a rutas URL de forma que cuando se pone determinada ruta en el navegador se carga en nuestra página el componente indicado. También permite tener subrutas que mapeen subcomponentes dentro de otros.\nInstalación\nLa forma más sencilla es escoger la opción de Vue-router al crear nuestro proyecto Vue. En ese caso no es necesario hacer nada porque se instala y configura todo automáticamente.\nAñadir vue-router a un proyecto ya creado\nSi queremos añadirlo a un proyecto ya creado previamente tendremos que instalarlo y configurarlo manualmente nosotros.\nLos pasos son:\n\nse instala el paquete vue-router como dependencia de producción:\n\nnpm install -S vue-router\n\nse crea el fichero de rutas, por ejemplo en /src/router/index.js. Aquí se define para cada ruta de nuestra aplicación el componente que debe cargarse. Su contenido es\n\nimport { createRouter, createWebHistory } from &quot;vue-router&quot;;\nimport HomeView from &quot;../views/HomeView.vue&quot;;\n\nconst router = createRouter({\nhistory: createWebHistory(import.meta.env.BASE_URL),\nroutes: [\n{\npath: &quot;/&quot;,\nname: &quot;home&quot;,\ncomponent: HomeView,\n},\n{\npath: &quot;/about&quot;,\nname: &quot;about&quot;,\n// route level code-splitting\n// this generates a separate chunk (About.[hash].js) for this route\n// which is lazy-loaded when the route is visited.\ncomponent: () =&gt; import(&quot;../views/AboutView.vue&quot;),\n},\n],\n});\n\nexport default router;\n\nse importa dicho fichero en el main.js para que el almacén esté disponible para todos los componentes en la variable this.$router:\n\nimport { createApp } from &quot;vue&quot;;\nimport App from &quot;./App.vue&quot;;\nimport router from &quot;./router&quot;; // &lt;---\n\nconst app = createApp(App);\napp.use(router);\napp.mount(&quot;#app&quot;);\n\nen el scaffolding del proyecto es recomendable crear una nueva carpeta views donde guardar las distintas vistas de nuestra aplicación, que son componentes que renderizan una &quot;página&quot; de la aplicación (es decir, nuestros componentes ahora se dividen en 2 tipos: los que renderizan una &quot;página&quot;, que irán a Views y los que son parte de una página, que irán a Components).\n\nCrear las rutas\nLas rutas de nuestra aplicación las definiremos en un fichero Javascript (por defecto /src/router/index.js). Allí creamos la instancia para nuestras rutas (el objeto que exportamos) y la configuramos. También debemos importar todos los componentes que definamos en el router:\nimport { createWebHistory, createRouter } from 'vue-router'\n\n// Importamos los componentes que se carguen en alguna ruta\nimport AppHome from './components/AppHome.vue'\nimport AppAbout from './components/AppAbout.vue'\nimport UsersTable from './components/UsersTable.vue'\nimport UserNew from './components/UserNew.vue'\nimport UserEdit from './components/UserEdit.vue'\n\nconst routes = [\n{\npath: '/',\nname: 'home',\ncomponent: AppHome\n},{\npath: '/about',\nname: about,\ncomponent: AppAbout\n},{\npath: '/users',\ncomponent: UsersTable\n},{\npath: '/new',\ncomponent: UserNew\n},{\npath: '/edit/:id',\ncomponent: UserEdit\nprops: true\n}\n];\n\nconst router = createRouter({\nhistory: createWebHistory(import.meta.env.BASE_URL),\nroutes\n})\n\nexport default router\n\nCada vez que cambie la URL en el navegador no cambiará todo el layout sino que sólo se cargará en la etiqueta\n&lt;router-view&gt;&lt;/router-view&gt;\n\nel componente indicado para esa ruta. Dicha etiqueta estará normalmente en el fichero App.vue.\nEl modo 'history' de nuestro router indica que use rutas &quot;amigables&quot; y que no incluyan la # (piensa que en realidad no se están cargando diferentes páginas sino partes de una única página ya que es una SPA). Esta es la opción que escogeremos siempre en las aplicaciones SPA, aunque si nuestro servidor web usa ASP.NET o JSP habrá que decirle que ignore las URLs porque ya se ocupa de ellas Vue. La alternativa sería usar createWebHashHistory() pero en ese caso las rutas en vez de ser algo como http://localhost:8080/products serían http://localhost:8080/#products.\nRutas dinámicas\nVueRouter permite rutas dinámicas como la indicada para el componente UserEdit:\n{\npath: '/edit/:id',\ncomponent: UserEdit\n}\n\nEsa ruta coincidirá con cualquier URL que comience por /edit/ y tenga algo más. Lo que haya tras la última / lo asignará el router a una variable llamada id (el nombre que pongamos tras el carácter :) y dicha variable la recibirá el componente UserEdit en un parámetro accesible desde this.$route.params.id. Si añadimos a la ruta la opción props: true hacemos que el componente además reciba el parámetro en sus props (en este caso recibirá una variable llamada id que será accesible desde this.id directamente).\nOpciones de cada ruta\nPara cada ruta que queramos mapear hay que definir:\n\npath: la url que hará que se cargue el componente\ncomponent: el componente que se cargará donde se encuentre la etiqueta &lt;router-view&gt; en el HTML\n\nAdemás de esas propiedades podemos indicar:\n\nname: le damos a la ruta un nombre que luego podemos usar para referirnos a ella\nprops: se usa en rutas dinámicas e indica que el componente recibirá el parámetro de la ruta en sus props. Si no se incluye esta opción el componente tendrá que acceder al parámetro id desde this.$route.params.id\n\nCrear un menú\nSeguramente querremos un menú en nuestra SPA que nos permita ir a las diferentes rutas (que provocarán que se carguen los componentes). Para ello usaremos la etiqueta &lt;router-link&gt;. Ejemplo:\n&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;\n&lt;router-link to=&quot;/about&quot;&gt;Acerca de...&lt;/router-link&gt;\n\nCuando accedemos a una ruta su elemento &lt;router-link&gt; adquiere la clase .router-link-active.\nSi le hemos puesto la propiedad name a una ruta podemos hacer un enlace a ella con\n&lt;router-link :to=&quot;{name: 'nombre_de_la_ruta'}&quot;&gt;Home&lt;/router-link&gt;\n\nFijaos que hemos de bindear el atributo to porque ya no le pasamos texto sino una variable.\nSe podría hacer (aunque no es normal) una opción de menú a una ruta dinámica y pasarle el parámetro deseado. Por ejemplo para editar el usuario 5 haríamos:\n&lt;router-link :to=&quot;{name: 'edit', params: {id: 5}}&quot;\n&gt;Editar usuario 5&lt;/router-link\n&gt;\n\nEn este caso es necesario que la ruta dinámica tenga un name.\nSaltar a una ruta\nAl hacer .use(router) en el fichero main.js estamos declarando esa variable (router) en la instancia principal de la aplicación por lo que estará disponible para todos los componentes desde this.$router. Esto nos permite acceder al router desde un componente para, por ejemplo, cambiar a una ruta.\nEl código para cambiar la ruta desde Javascript es\nthis.$router.push(ruta);\n\nTenemos varios métodos para navegar por código:\n\n.push(newUrl): salta a la ruta newUrl y la añade al historial\n.replace(newURL): salta a la nueva ruta pero reemplaza en el historial la ruta actual por esta\n.go(num): permite saltar el num. de páginas indicadas adelante (ej. this.$router.go(1)) o atrás (.go(-1)) por el historial\n\nEstos métodos son equivalentes a los métodos history.push(), history.replace() y history.go() de Javascript.\nAdemás podemos pasar a push() y replace() funciones callback que se ejecutarán al cambiar la ruta si todo va bien o si hay algún error.\nthis.$router.push(location, onComplete?, onAbort?)\n\nTambién podemos obtener toda la ruta con this.$route.fullPath.\nPaso de parámetros\nLa forma de pasar parámetros a la ruta es:\nthis.$router.push({ name: &quot;users&quot;, params: { id: 123 } });\n\nesto hace que se salte a la ruta con name &quot;users&quot; y le pasa como parámetro una id de valor 123. En el componente que se cargue en dicha ruta obtendremos el parámetro pasado con this.$route.params.nombreparam (en el ejemplo en this.$route.params.id obtenemos el valor 123).\nSe puede pasar más de un parámetro pero para que los pueda recibir el componente hay que ponerlos todos en el router. Por ejemplo para hacer un this.$router.push({ name: 'books', params: { autor: 12, tema: 4 }})\nla ruta en el router debería contener ambas variables:\npath: &quot;/books/author/:autor/topic/:tema&quot;;\n\nPodemos pasar también un objeto como parámetro pero antes debemos convertirlo a texto con JSON.stringify(). Sin embargo no es muy conveniente porque la URL quedaría demasiado larga y &quot;sucia&quot;.\nTambién se puede pasar una query a la ruta:\nthis.$router.push({ path: &quot;/register&quot;, query: { plan: &quot;private&quot; } });\n\nsalta a la URL /register?plan=private. En el componente que se carga obtenemos la query pasada con this.$route.query (obtenemos un objeto, en el ejemplo { plan: 'private' }).\nIMPORTANTE: Tened en cuenta que lo que se pasa como parámetro o consulta aparecerá en la URL por lo que no debemos enviar información sensible y no se recomienda enviar algo muy largo (como un objeto o array) para evitar que la URL quede &quot;sucia&quot;.\nEl objeto $route\nEs un objeto que contiene información de la ruta actual (no confundir con $router). Algunas de sus propiedades son:\n\nparams: el objeto con los parámetros pasados a la ruta (puede haber más de uno)\nquery: si hubiera alguna consulta en la ruta (tras '?') se obtiene aquí un objeto con ellas\npath: la ruta pasada (sin servidor ni querys, por ejemplo de http://localhost:3000/users?company=5 devolvería '/users')\nfullPath: la ruta pasada (con las querys, por ejemplo de http://localhost:3000/users?company=5 devolvería '/users?company=5')\n\nRuta no encontrada: 404 Not found\nSi en nuestra aplicación cargamos una ruta que no coincide con ninguna de las definidas en el router no se cargará ningún componente en el RouterView.\nUna mejora de esto es crear una vista con lo que queramos mostrar ('404 - La página no existe' o algo similar) y hacer una ruta que cargue dicho componente.\nSi llamamos a esa vista PathNotFound.vue la ruta a crear sería:\n{\npath: '/:pathMatch(.*)*',\ncomponent: PathNotFound\n},\n\nEsta ruta hay que ponerla la última ya que coincidirá con cualquier URL (usa una expresión regular y la dice que la ruta coincida con '*').\nRedireccionamiento\nEn el router puedo también poner una ruta que haga una redirección a otra en lugar de cargar un componente.\n{\npath: '/a',\nredirect: '/b'\n},\n\nLo que hace es que si se pone una URL /a la cambia automáticamente a /b y se buscará una ruta que coincida con esa.\nTambién podemos poner alias a una ruta de forma que se cargue un componente tanto si la URL es una como otra (en este caso no se cambiaría la URL):\n{\npath: '/a',\ncomponent: A,\nalias: '/b'\n},\n\nPodés obtener más información en la documentación de Vue-router.\nCambio de parámetros en una ruta\nSi cambiamos a la misma ruta pero con distintos parámetros Vue reutiliza la instancia del componente y no vuelve a lanzar sus hooks (created, mounted, ...). Esto hará que no se ejecute el código que tengamos allí. Por ejemplo supongamos que en una ruta '/edit/5' al cargar el componente se pide el registro 5 y se muestra en la página. Si a continuación cargamos la ruta '/edit/8' seguiremos viendo los datos del registro 5).\nPodemos solucionar esto desde el router o desde el componente.\nDesde el router podemos usar el elemento beforeRouteUpdate y realizar allí la carga de los datos:\nbeforeRouteUpdate (to, from, next) {\n// Código que responde al cambio. En 'to' tenemos la ruta anterior y en 'from' la nueva\n// antes de acabar hay que llamar a next()\n// Aquí cargamos los nuevos datos\nnext();\n}\n\nDesde el componente podemos usar un watcher para detectar el cambio en la ruta:\nwatch: {\n'$route' (to, from) {\n// Aquí cargamos los nuevos datos\n}\n}\n\nCada vez que cambie el valor de $route se ejecutará ese código y recibirá en el parámetro to la nueva ruta y en from el valor anterior de la variable. Veremos los watchers más adelante o podéi consultar la documentación de Vue.\nVistas con nombre y Subvistas\nPodemos cargar más de un componente usando varias etiquetas &lt;router-view&gt;. Por ejemplo si nestra página constará de 3 componentes (uno en la cabecera, otro el principal y otro en un aside pondremos en el HTML:\n&lt;router-view class=&quot;cabecera&quot; name=&quot;top&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;main&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;aside&quot; name=&quot;aside&quot;&gt;&lt;/router-view&gt;```\n\nPara que se carguen los 3 componentes lo debemos indicar al definir las rutas:\n{\npath: '/',\ncomponents: {\ndefault: CompMain,\t\t// CompMain se cargará en el &lt;router-view&gt; sin nombre\ntop: CompCabecera,\naside: CompAside\n}\n}\n\nTambién un componente puede incluir su propia etiqueta &lt;router-view&gt; que cargue dentro de él un subcomponente en función de una subruta. Por ejemplo tenemos una ruta /user/:id que carga un componente User con el nombre y la imagen del usuario y debajo cargará, en función de la ruta:\n\n/user/:id: debajo cargará el componente con el home del usuario\n/user/:id/profile: debajo cargará el componente con el perfil del usuario\n/user/:id/posts: debajo cargará el componente con los posts del usuario\nDefiniremos la ruta del siguiente modo:\n\n{\npath: '/',\ncomponents: {\n{\npath: '/user/:id',\ncomponent: User,\nchildren: [\n{ path: '', component: UserHome },\n{ path: 'profile', component: UserProfile },\n{ path: 'posts', component: UserPosts }\n]\n}\n}\n}\n\nPodemos consultar toda la información referente al router de Vue en https://router.vuejs.org/.",
		"tags": [ "note"]
},

{
		"title": "06-profundizando",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/06-profundizando/",
		"content": "Profundizando en Vue\nTabla de contenidos\n\nProfundizando en Vue\n\nComputed\nWatchers\nAcceder al DOM: 'ref'\n\nnextTick\n\nClases HTML\n\nSintaxis de objeto\nSintaxis de array\nAsignar clases a un componente\nAsignar estilos directamente\n\nCiclo de vida del componente\n\nEl ciclo de vida de un componente\n\nComponentes asíncronos\nCustom Directives\nImágenes\nTransiciones\nEntornos\nGuards del router\n\nComputed\nCuando se crea un componente de Vue (o el componente raíz) se le pasa como parámetro un objeto con las opciones con que se creará. Entre ellas tenemos props, _ data_, methods, y también otras como computed y watch.\nHemos visto que en una interpolación o directiva podemos poner una expresión javascript. Pero si la expresión es demasiado compleja hace que nuestro HTML sea más difícil de leer. La solución es crear una expresión calculada que nos permite tener &quot;limpio&quot; el HTML. Por ejemplo un código con expresiones complejas como:\n&lt;template&gt;\n&lt;p&gt;Autor: { { author.name + ' ' + author.surname }}&lt;/p&gt;\n&lt;p&gt;Ha publicado libros: { { author.books.length &gt; 0 ? 'Sí' : 'No' }}&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'author-item',\ndata() {\nreturn {\nauthor: {\nname: 'John',\nsurname: 'Doe',\nbooks: [\n'Vue 2 - Advanced Guide',\n'Vue 3 - Basic Guide',\n'Vue 4 - The Mystery'\n]\n}\n}\n}\n}\n&lt;/script&gt;\n\nse puede simplificar creando propiedades calculadas:\n&lt;template&gt;\n&lt;p&gt;Autor: { { fullName }}&lt;/p&gt;\n&lt;p&gt;Ha publicado libros: { { hasPublished }}&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'author-item',\ndata() {\nreturn {\nauthor: {\nname: 'John',\nsurname: 'Doe',\nbooks: [\n'Vue 2 - Advanced Guide',\n'Vue 3 - Basic Guide',\n'Vue 4 - The Mystery'\n]\n}\n}\n},\ncomputed: {\nfullName() {\nreturn this.name + ' ' + this.surname;\n},\nhasPublished() {\nreturn this.author.books.length &gt; 0 ? 'Sí' : 'No'\n}\n}\n})\n&lt;/script&gt;\n\nEn lugar de definir computed podríamos haber obtenido el mismo resultado usando métodos, pero la ventaja de las propiedades calculadas es que se cachean por lo que si se vuelven a tener que renderizar en el DOM no vuelven a evaluarse, a menos que cambie el valor de alguna de las variables reactivas que use.\n| Haz el ejercicio del tutorial de Vue.js\nPor defecto las propiedades computed sólo hacen un getter, por lo que no se puede cambiar su valor. Pero podemos si queremos hacerlo definir métodos getter y setter:\ncomputed: {\nfullName:\n// getter\nget() {\nreturn this.name + ' ' + this.surname;\n},\n// setter\nset(newValue) {\nconst names = newValue.split(' ');\nthis.name = names[0];\nthis.surname = names[names.length - 1];\n}\n},\n},\n})\n\nSi hacemos this.fullName = 'John Doe' estaremos asignando los valores adecuados a las variables name y surname.\nWatchers\nVue proporciona una forma genérica de controlar cuándo cambia el valor de una variable reactiva para poder ejecutar código en ese momento poniéndole un watch:\ndata() {\nreturn {\nname: 'John',\nsurname: 'Doe',\nfullName: 'John Doe',\n}\n},\nwatch: {\nname(newValue, oldValue) {\nthis.fullName = newValue + ' ' + this.surname;\n},\nsurname(newValue, oldValue) {\nthis.fullName = this.name + ' ' + newValue;\n},\n},\n})\n\nEn este caso no tiene mucho sentido y es más fácil (y más eficiente) usar una propiedad computed como hemos visto antes, pero hay ocasiones en que necesitamos ejecutar código al cambiar una variable y es así donde se usan. Veremos su utilidad cuando trabajemos con vue-router.\nNOTA: los watcher son costosos por lo que no debemos abusar de ellos\n| Haz el ejercicio del tutorial de Vue.js\nAcceder al DOM: 'ref'\nAunque Vue se encarga de la vista por nosotros en alguna ocasión podemos tener que acceder a un elemento del DOM. En ese caso no haremos un document.getElement... sino que le ponemos una referencia al elemento con el atributo ref para poder acceder al mismo desde nuestro script:\n&lt;template&gt;\n&lt;form ref=&quot;myForm&quot;&gt;\n...\n&lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nmounted() {\nthis.$refs.myForm.setAttribute('novalidate', true)\n}\n}\n&lt;/script&gt;\n\nDesde el código tenemos acceso a todas las referencias desde this.$refs. Hay que tener en cuenta que sólo se puede acceder a un elemento después de montarse el componente (en el hook mounted() o después).\n| Haz el ejercicio del tutorial de Vue.js\nnextTick\nSi modificamos una variable reactiva el cambio se refleja automáticamente en el DOM, pero no inmediatamente sino que se espera hasta el evento nextTick en el ciclo de modificación para asegurarse de no cambiar algo que quizá va a volverse a cambiar en este ciclo.\nSi accedemos al DOM antes de que se produzca este evento el valor aún será el antiguo. Para obtener el nuevo valor hemos de esperar al nextTick:\n&lt;template&gt;\n&lt;p&gt;Contador: &lt;span ref=&quot;contador&quot;&gt;{ { count }}&lt;/span&gt;&lt;/p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementa&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ndata() {\nreturn {\ncount: 0\n}\n},\nmethods: {\nincrement() {\ncount.value++\nconsole.log('Contador en el DOM: ' + this.$refs.contador.textContent)\n// Devolverá el valor sin actualizar aún\nnextTick(() =&gt; {\nconsole.log('Contador en el DOM tras nextTick: ' + this.$refs.contador.textContent)\n// Devolverá el valor actualizado\n})\n}\n}\n}\n&lt;/script&gt;\n\nRealmente es algo que seguramente nunca necesitemos pero así conocemos un poco más cómo funciona Vue internamente.\nClases HTML\nYa hemos visto que en Javascript usamos las clases con mucha frecuencia, normalmente para asignar a elementos estilos definidos en el CSS, pero también para identificar elementos sin usar una id (como hacíamos poniendo a los botones de acciones de los productos las clases subir, bajar, editar o borrar).\nEn Vue tenemos diferentes formas de asignar clases. La más simple sería bindear el atributo class y gestionarlas directamente en el código, pero no es lo más cómodo:\n&lt;div :class=&quot;clasesDelDiv&quot;&gt;&lt;/div&gt;\n\nEn este caso tendríamos que asignar a la variables clasesDelDiv las diferentes clases separadas por espacio, lo que es engorroso de mantener.\nSintaxis de objeto\nUna forma más sencilla es bindear un objeto donde cada propiedad es el nombre de una posible clase y su valor es un booleano que indica si tendrá o no dicha clase, por ejemplo:\n&lt;div\nclass=&quot;static&quot;\n:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;\n&gt;&lt;/div&gt;\n\nEn este caso el &lt;DIV&gt; tendrá las clases:\n\nstatic: siemrpe tendrá esta clase. Como véis puede coexistir la directiva :class con el atributo class y se suman ambos\nactive: tendrá esta clase si el valor de la variable isActive es true\ntext-danger: ídem para la variable hasError. Si el nombre de una clase tiene más de una palabra hay que entrecomillarla\n\nPara mejorar la legibilidad del HTML podemos poner el objeto de las clases en el Javascript\n&lt;div\nclass=&quot;static&quot;\n:class=&quot;classObject&quot;\n&gt;&lt;/div&gt;\n\ndata() {\nreturn {\nclassObject: {\nactive: true,\n'text-danger': false\n}\n}\n}\n\nSintaxis de array\nPodemos indicar las clases en forma de array de variables que contienen la clase a asignar:\n&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n\ndata() {\nreturn {\nactiveClass: 'active',\nerrorClass: 'text-danger'\n}\n}\n\nEn este caso el &lt;DIV&gt; tendrá las clases active y text-danger.\nY es posible incluir sintaxis de objeto dentro de la sintaxis de array:\n&lt;div :class=&quot;[{ active: isActive}, errorClass]&quot;&gt;&lt;/div&gt;\n\nAsignar clases a un componente\nEn la etiqueta de un componente podemos ponerle un atributo class que le asignará las clases incluidas y que se sumaran a las que se le asignen dentro del propio componente. Por ejemplo, si el &lt;DIV&gt; del ejemplo anterior es el template de un componente llamado MyComponent puedo poner:\n&lt;my-component class=&quot;main highligth&quot;&gt;&lt;/my-component&gt;\n\nEn este caso el &lt;DIV&gt; tendrá las clases main, highligth, active si la variable isActive vale true y text-danger.\nEn Vue3 el template de un componente puede tener varios elementos raíz. En ese caso para indicar a cuál se aplicarán las clases definidas en el padre se usa la propiedad $attr.class:\n&lt;template&gt;\n&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;\n&lt;span&gt;This is a child component&lt;/span&gt;\n&lt;/template&gt;\n\nAsignar estilos directamente\nAunque no es lo recomendable, podemos asignar directamente estilos CSS igual que asignamos clases y también podemos usar la sintaxis de objeto o la de array.\n&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;\n\ndata() {\nreturn {\nactiveColor: 'red',\nfontSize: 30'\n}\n}\n\nCiclo de vida del componente\nEl ciclo de vida de un componente\nAl crearse la instancia de Vue o un componente la aplicación debe realizar unas tareas como configurar la observación de variables, compilar su plantilla (template), montarla en el DOM o reaccionar ante cambios en las variables volviendo a renderizar las partes del DOM que han cambiado. Además ejecuta funciones definidas por el usuario cuando sucede alguno de estos eventos, llamadas hooks del ciclo de vida.\nEn la siguiente imagen podéis ver el ciclo de vida de la instancia Vue (y de cualquier componente) y los eventos que se generan y que podemos interceptar:\n\nNOTA: En Vue2: los métodos beforeDestroyed y destroyed se usan en lugar de beforeUnmounted y unmounted.\nIMPORTANTE: no debemos definir estas funciones como arrow functions porque en estas funciones se enlaza en la variable this el componente donde se definen y si hacemos una arrow function no tendríamos this:\n// MAL, NO HACER ASÍ\ncreated: () =&gt; {\nconsole.log('instancia creada');\n}\n\n// BIEN, HACER ASÍ\ncreated() {\nconsole.log('instancia creada');\n}\n\nLos principales hooks son:\n\nbeforeCreate: aún no se ha creado el componente (sí la instancia de Vue) por lo que no tenemos acceso a sus variables, etc\ncreated: se usa por ejemplo para realizar peticiones a servicios externos lo antes posible\nbeforeMount: ya se ha generado el componente y compilado su template\nmounted: ahora ya tenemos acceso a todas las propiedades del componete. Es el sitio donde hacer una patición externa si el valor devuelto queremos asignarlo a una variable del componente\nbeforeUpdate: se ha modificado el componente pero aún no se han renderizado los cambios\nupdated: los cambios ya se han renderizado en la página\nbeforeUnmount: antes de que se destruya el componente (en versiones anteriores a Vue3 beforeDestroy)\nunmounted: ya se ha destruido el componente (en versiones anteriores a Vue3 destroyed)\n\n| Haz el ejercicio del tutorial de Vue.js\nComponentes asíncronos\nEn proyectos grandes con centenares de componentes podemos hacer que en cada momento se carguen sólo los componentes necesarios de manera que se ahorra mucho tiempo de carga de la página.\nPara que un componente se cargue asíncronamente al registrarlo se hace como un objeto que será una función que importe el componente. Un componente normal (síncrono) se registraría así:\n&lt;script&gt;\nimport ProductItem from './ProductItem.vue'\n\nexport default {\nname: 'products-table',\ncomponents: {\nProductItem,\n},\n...\n}\n&lt;/script&gt;\n\nSi queremos que se cargue asíncronamente no lo importamos hasta se registra:\n&lt;script&gt;\nexport default {\nname: 'products-table',\ncomponents: {\nProductItem: () =&gt; import('./ProductItem.vue'),\n},\n...\n}\n&lt;/script&gt;\n\nTambién podemos decirle que espere un tiempo a cargar el componente (delay) e incluso qué componente queremos cargar mientras está cargando el componente o cuál cargar si hay un error al cargarlo:\n&lt;script&gt;\nexport default {\nname: 'products-table',\ncomponents: {\nProductItem: () =&gt; ({\ncomponent: import('./ProductItem.vue'),\ndelay: 500, // en milisegundos\ntimeout: 6000,\nloading: compLoading, // componente que cargará mientras se está cargando\nerror: compError, // componente que cargará si hay un error,\n})\n},\n...\n}\n&lt;/script&gt;\n\nCustom Directives\nPodemos crear nuestras propias directivas para usar en los elementos que queramos. Se definen en un fichero .js con Vue.directive y le pasamos su nombre y un objeto con los estados en que queremos que reaccione. Por ejemplo vamos a hacer una directiva para que se le asigne el foco al elemento al que se la pongamos, que será de tipo input:\nimport Vue from 'vue'\n\nVue.directive('focus', {\nmounted(el) {\nel.focus();\n}\n})\n\nPara usarla en un componente la importamos y ya podemos usarla en el template:\n&lt;template&gt;\n...\n&lt;input v-focus type=&quot;text&quot; name=&quot;nombre&quot;&gt;\n...\n&lt;/template&gt;\n\n&lt;script&gt;\nimport focus from './focus.js'\n...\n}\n&lt;/script&gt;\n\nSi queremos utilizarla en muchos componentes podemos importarla en el main.js y así estará disponible para todos los componentes.\nLos estados de la directiva en los que podemos actuar son:\n\nmounted (en Vue2 inserted): cuando se inserte la directiva\nupdated (en Vue2 componentUpdated): cuando se actualice el componente que contiene la directiva\nbeforeMount (en Vue2 bind): cuando se enlaza la directiva al componente por primera vez, antes de montar el componente\n...\n\nImágenes\nSi se trata de imágenes estáticas lo más sencillo es ponerlas dentro de la carpeta public y hacer referencia a ellas usando ruta absoluta. Todo lo que está en public se referencia como si estuviera en la raíz de nuestra aplicación:\n&lt;img src=&quot;/img/elPatitoFeo.jpeg&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n\nTambién podemos poner las imágenes en la carpeta assets, pero antes de usarlas deberemos imnportarlas. Ejemplo:\n&lt;script&gt;\nimport imgUrl from './assets/img/elPatitoFeo.jpeg'\n...\n&lt;/script&gt;\n\n&lt;template&gt;\n...\n&lt;img :src=&quot;imgUrl&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n...\n&lt;/template&gt;\n\nNOTA: Si usamos webpack en lugar de Vite, en lugar de importarlas usaremos en su atributo src la función require con la URL de la imagen:\n&lt;img :src=&quot;require('../assets/img/elPatitoFeo.jpeg')&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n\nCon Vite también podemos importarlas usando import.meta.url (más información en la documentación de Vite):\n&lt;script&gt;\nexport default {\ndata() {\nreturn {\nimgUrl = new URL('./assets/elPatitoFeo.png', import.meta.url).href\n}\n},\n...\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n...\n&lt;img :src=&quot;imgUrl&quot; height=&quot;100px&quot; alt=&quot;El Patito Feo&quot;&gt;\n...\n&lt;/template&gt;\n\nEsto nos permite también importar las imágenes dinámicamente:\n&lt;script&gt;\nexport default {\nmethods: {\nfunction getImageUrl(name) {\nreturn new URL(`./dir/${name}`, import.meta.url).href\n}\n}\n...\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n...\n&lt;img :src=&quot;getImageUrl(imgName)&quot; height=&quot;100px&quot;&gt;\n...\n&lt;/template&gt;\n\nEsto permitiría mostrar también imágenes obtenidas de una API.\nTransiciones\nVue permite controlar transiciones en nuestra aplicación poniendo el código CSS correspondiente y añadiéndole al elemento el atributo transition. Podemos encontrar más información en la documentación oficial de Vue.\nEntornos\nEn Vue tenemos normalmente 3 entornos o modos, el de development, el de test y el de production. Las variables de entorno las guardaremos en uno de los siguientes ficheros:\n\n.env: se cargan en todos los modos\n.env.local: se cargan en todos los modos pero son ignoradas por git\n.env.[modo]: se cargan sólo en el modo indicado\n.env.[modo].local: ídem pero son ignordas por git\n\nEn contenido de estos ficheros son variables en forma clave=valor:\n// fichero .env\nTITULO=Mi proyecto\nVITE_API=https://localhost/api\n\nSi el nombre de la variable comienza por VITE_ será accesible desde el código a través de import.meta.env.nombreVariable:\n// &lt;script&gt; de componente\nconsole.log(process.env.VITE_API);\n\nPodemos saber en qué entorno se está ejecutando la aplicación consultando el valor de la variable import.meta.env.MODE.\nSi no estamos usando Vite sino webpack el nombre de las variables debe comenzar por VUE_APP_ y será accesible desde el código con process.env.nombreVariable:\n// &lt;script&gt; de componente\nconsole.log(process.env.VUE_APP_API);\n\nGuards del router\nSon hooks que podemos controlar en distintos momentos, algunos desde el componente y otros desde el router. Podemos ponerlos para todas las rutas, para una ruta en concreto o en el componente.\nLa mayoría reciben 3 parámetros:\n\nto: ruta a la que se va a saltar\nfrom: ruta de la que se viene\nnext: función para que continue la carga del router. Siempre tras ejecutar el código que deseemos pondremos netx().\n\nEn el router tenemos estos guards:\n\nrouter.beforeEach(to, from, next): se ejecuta antes de que vaya a cambiarse la ruta\nrouter.afterEach(to, from): se ejecuta una vez cambiada la ruta (por eso no tiene next, porque ya ha acabado)\nruta.beforeEnter(to, from, next): se pone como propiedad de una ruta y se ejecuta antes de entrar a ella\n\nPara aplicarlos en nuestro router lo asignamos a una variable que exportamos:\nlet router = new Router({\nroutes: [\n{\npath: '/',\ncomponent: 'MyComponent',\nbeforeEnter(to, from, next) {\nconsole.log('Vengo de ' + from + ' y voy a ' + to);\nnext();\n},\n...\n})\n\nrouter.beforeEach(to, from, next) {\nconsole.log('Vengo de ' + from + ' y voy a ' + to);\nnext();\n}\n\nexport default router\n\nEn un componente también puedo definir los hooks:\n\nbeforeRouteEnter(to, from, next)\nbeforeRouteUpdate(to, from, next)\nbeforeRouteLeave(to, from, next)",
		"tags": [ "note"]
},

{
		"title": "07-pinia",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/07-pinia/",
		"content": "Pinia\nTabla de contenidos\n\nPinia\n\nIntroducción\nInstalar y configurar Pinia\nCrear un store\nUsar Pinia\n\nGetters\nActions\n\nstate en formularios\n\nIntroducción\nEs un 'State Management Pattern' basado en el patrón Flux que sirve para controlar el flujo de datos en una aplicación. Sustituye a la anterior librería usada en Vue 2 llamada Vuex.\nSegún la filosofía de Vue cada componente es una unidad funcional que contiene 3 partes:\n\nestado: los datos o source of truth que maneja en componente\nvista: la representación del estado que se ve en la aplicación\nacciones: la forma en que el estado puede cambiar para reaccionar a entradas del usuario en la vista\n\nPor ejemplo, el componente contador sería:\n&lt;script&gt;\nexport default {\n// state\ndata() {\nreturn {\ncount: 0\n}\n},\n// actions\nmethods: {\nincrement() {\nthis.count++\n}\n}\n}\n&lt;/script&gt;\n\n&lt;!-- view --&gt;\n&lt;template&gt;\n{{ count }}\n&lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;\n&lt;/template&gt;\n\nEsto es lo que se llama one-way data flow:\n\nEl problema lo tenemos cuando un componente necesita acceder a datos (state) de otro componente.\nEn Vue la comunicación entre componentes padre-hijo se hace hacia abajo mediante props y hacia arriba emitiendo eventos. Y vimos que si distintos componentes que no son padre-hijo tenían que compartir un mismo estado (acceder a los mismos datos) surgían problemas e intentamos solucionarlos con el patrón store pattern. Esto puede servir para pequeñas aplicaciones pero cuando crecen se hace difícil seguir los cambios. Para esos casos debemos usar Pinia, que proporciona un almacén de datos centralizado para todos los componentes de la aplicación y asegura que los datos sólo puedan cambiarse de forma controlada.\nEl uso de Pinia es imprescindible en aplicaciones de tamaño medio o grande pero incluso para aplicaciones pequeñas nos ofrece ventajas frente a un store pattern hecho por nosotros como soporte para las DevTools y para Server Side Rendering o uso de Typescript.\nComo ya dijimos, no debemos almacenar todos los datos en el store centralizado sino sólo los que necesitan varios componentes (los datos privados de un componente deben permanecer en él).\nInstalar y configurar Pinia\nLa forma más sencilla de utilizar Pinia es incluirla a la hora de crear nuestro proyecto cuando nos pregunta si queremos usarla. Esto hace que la instalación y configuración de la herramienta se haga automáticamente.\nAl entrar en nuestro nuevo proyecto vemos que dentro de /src se ha creado una carpeta llamada stores/ donde crearemos los distintos almacenes de datos (podemos tener sólo uno o varios).\nPara poder usar Pinia en los distintos componentes vemos que en el fichero main.js se importa la función createPinia() y se indica que se use en la instancia de Vue:\nimport { createApp } from 'vue'\nimport { createPinia } from 'pinia' // &lt;---\nimport App from './App.vue'\nimport router from './router'\n\ncreateApp(App).use(createPinia()).use(router).mount('#app')\n\nSi queremos usar Pinia en un proyecto existente donde no la seleccionamos al crear el proyecto deberemos instalar la librería como dependencia de producción y modificar el fichero main.js para que pueda usarse, como hemos visto arriba. Luego crearemos la carpeta /src/stores/ y en ella los almacenes que queramos usar.\nCrear un store\nAhora hay que crear el fichero del store. Podemos tener todos los datos en un único fichero o, si son muchos, hacer ficheros diferentes. Por ejemplo para la aplicación de 'ToDo' podemos crear su store en /src/stores/toDo.js.\nAl crear un almacén pondremos en él todas las variables que vaya a usar más de un componente (dentro de state) y los métodos para acceder a ellas y modificarlas (dentro de actions), por ejemplo, para compartir un contador haríamos:\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\nstate() {\nreturn {\ncount: 0\n}\n},\n// o usando arrow functions\n// state: () =&gt; ({\n// count: 0\n// }),\n\nactions: {\nincrement () {\nthis.count++\n},\ndecrement () {\nthis.count--\n},\n}\n})\n\nEn este ejemplo hemos creado un almacén que tiene un dato (count) y dos métodos para cambiar su valor (increment y decrement). El primer parámetro de defineStore es el nombre con el que veremos el almacén desde las DevTools (por si tenemos varios).\nDesde la consola del navegador podemos usar las DevTools para ver nuestro almacén. Para ello vamos a la pestaña de Vue y desde el Inspector buscamos Pinia:\n![DevTools - Pinia](/img/user/01 Apuntes/Vue Teoria Batoi/img/DevTools-Pinia.png)\nSi al crear el proyecto hemos incorporado Pinia nos ha creado un almacén de ejemplo como el anterior, pero escrito con la sintaxis de Compositon API que sería:\nimport { ref } from 'vue'\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', () =&gt; {\nconst count = ref(0)\nfunction increment() {\ncount.value++\n}\nfunction increment() {\ncount.value--\n}\n\nreturn { count, increment, decrement }\n})\n\nUsar Pinia\nEn cada componente que lo necesitemos podemos usar el almacén de datos. Para ello lo importamos y luego definimos en computed las variables del state a que queramos acceder y en methods las actions que deseemos. Para ello debemos usar los helpers mapState y mapActions en los que indicaremos las variables y métodos del store que queremos usar en este componente:\n//MyComponent.vue\nimport { useCounterStore } from '../stores/conterStore';\nimport { mapState, mapActions } from 'pinia';\n\nexport default {\n...\ncomputed: {\n...mapState(useCounterStore, {\ncount: 'count',\n})\n},\nmethods: {\n...mapActions(useCounterStore, ['increment', 'decrement'])\n}\n}\n\nCon esto se mapean las variables, getters y actions a variables y métodos locales a los que podemos acceder desde this. (por ejemplo this.count o this.increment()).\nGetters\nEn ocasiones no necesitamos una variable del state sino cierta información sobre ella (por ejemplo no todas las tareas del array todos sino sólo las tareas pendientes). En ese caso podemos filtrarlas en cada componente que las necesite o podemos hacer un método en el almacén (dentro de getters) que nos devuelva directamente las tareas filtradas. Estos getters funcionan como las variables computed (sólo se ejecutan de nuevo si cambian los datos de que dependen):\nimport { defineStore } from 'pinia'\n\nexport const useToDoStore = defineStore('todo', {\nstate: () =&gt; ({\n/** @type { { title: string, id: number, done: boolean }[]} */\ntodos: [\n{ id: 1, title: '...', done: true },\n{ id: 2, title: '...', done: false }\n],\nnextId: 3,\n}),\ngetters: {\n// reciben como primer parámetro el 'state'\nfinishedTodos: (state) =&gt; state.todos.filter((todo) =&gt; todo.done),\nunfinishedTodos: (state) =&gt; state.todos.filter((todo) =&gt; !todo.done),\n/**\n* @returns { { title: string, id: number, done: boolean }[]}\n*/\n},\nactions: {\n// any amount of arguments, return a promise or not\naddTodo(title) {\nthis.todos.push({\ntitle,\nid: this.nextId,\ndone: false\n})\nthis.nextId++\n},\n},\n})\n\nCada getter recibe como primer parámetro el state del almacén.\nDentro de los componentes se usan como cualquier variable del state:\nexport default {\n...\ncomputed: {\n...mapState(useToDoStore, {\ntodos: 'todos',\nfinishedTodos: 'finishedTodos',\n})\n},\n\nLos getters pueden recibir parámetros, por ejemplo, para hacer búsquedas:\ngetters: {\ngetTodoById: (state) =&gt; (id) =&gt; state.todos.find((todo) =&gt; todo.id === id)\n}\n\nDesde el componente lo llamaremos con this.getTodoById(2).\nActions\nLa manera de cambiar los datos del almacén es llamando a las acciones que hayamos definido, y que hemos mapeado al componente como métodos locales. Estas acciones pueden recibir tantos parámetros como se desee.\nCada vez que se llama a una acción se registra en las DevTools y podemos ver la acción llamada y los datos que se le han pasado:\n![DevTools - Actions](/img/user/01 Apuntes/Vue Teoria Batoi/img/DevTools-Pinia-actions.png)\nLas acciones pueden hacer llamadas asíncronas. Lo normal es llamar a la BBDD y cuando el servidor responda modificaremos los datos del store.\nimport { defineStore } from 'pinia'\nimport TodoService from '../services/TodoService.js'\n\nexport const useToDoStore = defineStore('todo', {\nstate: () =&gt; {\nreturn {\ntodos: [],\nnextId: 0,\n}\n},\nactions: {\nasync addTodo(title) {\ntry {\nconst newToDo = await TodoService.addTodo({\ntitle,\nid: this.nextId + 1,\nisFinished: false\n});\nthis.nextId++\nthis.todos.push(newToDo)\n} catch(error) {\nthrow error;\n}\n},\n},\n})\n\nSi la acción realiza una llamada asíncrona y el componente que la llama tiene que enterarse de cuándo finaliza debe devolver una promesa (debe declararse con async o envolverse en un return new Promise(...)). En el componente podemos usar await o then / catch para saber cuándo ha acabado la acción:\ntry {\nawait this.addTodo(this.newTodo)\nalert('Añadida la tarea ' + this.newTodo.title)\nthis.$router.push('/todos')\n} catch(error) {\nalert(error)\n}\n\nNOTA: si quien llama a una acción no necesita saber cuándo termina la acción ni su resultado no es necesario llamarla con await.\nstate en formularios\nAunque no es lo habitual, si queremos usar un formulario para modificar un state del store no podemos asociarlo al input con la directiva v-model porque cuando el usuario cambie el valor del input estaría escribiendo directamente sobre un state, lo que debe hacerse por medio de una acción.\nTenemos 2 soluciones al problema:\n\npodemos no usar el v-model sino descomponerlo en un :value y un @input como vimos al hablar de poner un input en un subcomponente\npodemos ponerle al computed de ese state un setter y un getter como vimos en el capítulo de Profundizando en Vue\n\nMás información en la documentación oficial de Pinia.",
		"tags": [ "note"]
},

{
		"title": "07-vuex",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/07-vuex/",
		"content": "Vuex\nTabla de contenidos\n\nVuex\n\nIntroducción\nInstalar y configurar Vuex\nUsar Vuex\n\nAcceder al State desde un componente\nGetters\nMutations\nActions\n\nstate en formularios\nSaber más\n\nIntroducción\nEs un 'State Management Pattern' basado en el patrón Flux que sirve para controlar el flujo de datos en una aplicación.\nEn Vue la comunicación entre componentes se hace hacia abajo mediante props y hacia arriba emitiendo eventos. Ya vimos que cuando distintos componentes que no son padre-hijo tenían que compartir un mismo estado (acceder a los mismos datos) surgían problemas e intentamos solucionarlos con event Bus o store pattern. Estas soluciones pueden servir para pequeñas aplicaciones pero cuando crecen se hace difícil seguir los cambios con estos patrones. Para esos casos debemos usar Vuex, que proporciona un almacén de datos centralizado para todos los componentes de la aplicación y asegura que los datos sólo puedan cambiarse de forma controlada.\nEl uso de Vuex implica mayor complejidad en nuestra aplicación por lo que es recomendable su uso en aplicaciones de tamaño medio o grande (para aplicaciones pequeñas basta con un eventBus o un store pattern hecho por nosotros). Como dijo Dan Abramov, el creador de Redux\n\nLas librerías Flux son como las gafas: lo sabrás cuando las necesites\n\nVuex se integra con las DevTools por lo que es muy sencillo depurar los datos del almacén y los cambios que se producen en ellos. Sin embargo no debemos almacenar todos los datos en Vuex, sólo los que necesitan varios componentes (los datos privados de un componente deben permanecer en él).\nEl flujo de datos de una aplicación podemos verlo (de manera muy simplificada) en el siguiente esquema:\n\nEl estado es el conjunto de datos de nuestra aplicación\nLa vista representa el estado al usuario\nLas acciones son las formas en que podemos cambiar el estado, normalmente en respuesta a entradas del usuario desde la vista\n\nEl estado de los datos se representa en la vista, donde el usuario tiene herramientas que provocan acciones que modifican el estado. Este esquema funciona perfectamente cuando cada componente tiene su propio estado, pero empieza a dar problemas cuando el estado debe compartirse entre varios componentes. Para ese caso ya vimos soluciones como el Event Bus o el state management pattern pero son soluciones difícilmente mantenibles cuando nuestra aplicación crece. En aplicaciones medias o grandes es conveniente usar Vuex.\nVuex centraliza la forma en que nuestros componentes se comunican entre ellos. Con Vuex el flujo de datos podemos verlo de la siguiente manera:\n\nLos componentes de Vue pueden renderizar datos de Vuex y es reactivo frente a ellos (si se modifican se volverá a renderizar el componente). Si el componente quiere modificar estos datos debe enviar (dispatch) acciones que ejecutan un proceso (que puede ser asíncrono, por ejemplo una petición a una API). Cuando se resuelve la acción realiza una confirmación (commit) que muta el estado de la aplicación (aquí podemos depurar con las DevTools) por lo que se renderiza de nuevo el componente para mostrar el nuevo estado. En Vuex almacenaremos tanto datos (accesibles desde cualquier componente) como métodos que se utilicen en más de un componente.\nInstalar y configurar Vuex\nSi al crear nuestro proyecto Vue marcamos en las opciones que incluya Vuex la instalación y configuración de la herramienta se hará automáticamente:\n\nse instala el paquete vuex. Si no marcamos vuex al crear el proyecto debemos instalarlo nosotros\n\nnpm install -S vuex\n\nse crea el fichero de vuex en /src/store/index.js. Es nuestro almacén donde se guardan todas las variables que vaya a usar más de un componente y los métodos para acceder a ellas y modificarlas. Su contenido en Vue2 es\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\nstate: {\n},\nmutations: {\n},\nactions: {\n},\nmodules: {\n},\n})\n\ny en Vue3\nimport { createStore } from 'vuex'\n\nexport default createStore({\nstate: {\n},\nmutations: {\n},\nactions: {\n},\nmodules: {\n},\n})\n\nse importa dicho fichero en el main.js para que el almacén esté disponible para todos los componentes en la variable this.$store. Es igual que pasaba con vue-router:\n\n...\nimport router from './router'\nimport store from './store'\n\nnew Vue({\nrouter,\t\nstore,\nrender: h =&gt; h(App)\n}).$mount('#app')\n\nSi no hemos seleccionado vuex al crear el proyecto deberemos hacer estos 3 pasos nosotros manualmente. También tenemos la opción de no importar el store en el fichero main.js sino importarlo únicamente en cada componente que vaya a utilizarlo.\nUsar Vuex\nEl corazón de Vuex es el store que es un objeto donde almacenar states (datos globales) de la aplicación pero se diferencia de un objeto normal en que:\n\nes reactivo\nsólo se puede modificar haciendo commits de mutaciones\n\nDesde la consola del navegador podemos usar las DevTools para ver nuestro almacén. Para ello vamos a Vue y elegimos la segunda opción (Vuex):\n![DevTools - Vuex](/img/user/01 Apuntes/Vue Teoria Batoi/img/DevTools-Vuex.png)\nAl crear el almacén (normalmente en el fichero src/store/index.js) pondremos en state nuestras variables globales y en mutations los métodos que se pueden usar para cambiarlas, ej.:\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\nstate: {\ncount: 0\n},\nmutations: {\nincrement (state) {\nstate.count++\n},\ndecrement (state) {\nstate.count--\n},\n}\n})\n\nCada mutación recibe como primer parámetro el state del almacén para que pueda modificarlo y el componente lo llama mediante el método commit:\nthis.$store.commit('increment')\n\nEn este ejemplo hemos creado un almacén que tiene un dato (count) y dos mutaciones para cambiar su valor (increment y decrement). Lo usa un componente que muestra el valor del contador e incluye un botón para incrementar su valor y otro para decrementarlo:\n&lt;template&gt;\n&lt;div&gt;\n&lt;p&gt;Valor del contador: { { contador }}&lt;/p&gt;\n&lt;button @click=&quot;incrementa&quot;&gt;Incrementar&lt;/button&gt;\n&lt;button @click=&quot;decrementa&quot;&gt;Decrementar&lt;/button&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nexport default {\ncomputed: {\ncontador() {\nreturn this.$store.state.count\n}\n},\nmethods: {\nincrementa() {\nthis.$store.commit('increment')\n},\ndecrementa() {\nthis.$store.commit('decrement')\n},\n}\n}\n\nSi no hemos importado el almacén en el main.js lo tendremos que importar en cada componente que lo necesite (no es lo habitua):\nimport store from '@/store'\n\nexport default {\ncomputed: {\ncontador() {\nreturn store.state.count\n}\n},\nmethods: {\nincrementa() {\nstore.commit('increment')\n...\n\nAcceder al State desde un componente\nLa mejor forma de acceder a propiedades del almacén es creando métodos computed que cambiarán al cambiar el estado del mismo:\ncomputed: {\ncount () {\nreturn this.$store.state.count\n},\n},\n\nSi queremos usar varias propiedades del store en un componente en vez de hacer un método computed para cada una podemos usar el helper mapState:\nimport { mapState } from 'vuex'\n\ncomputed: mapState([\n'count'\t // map this.count to store.state.count\n])\n\nGetters\nEn ocasiones no necesitamos una variable del state sino cierta información sobre ella (por ejemplo no todas las tareas del array todos sino sólo las tareas pendientes). En ese caso podemos filtrarlas en cada componente que las necesite o podemos hacer un getter en el almacén que nos devuelva directamente las tareas filtradas. Estos getters funcionan como las variables computed (sólo se ejecutan de nuevo si cambian los datos de que dependen):\nexport default new Vuex.Store({\nstate: {\ntodos: [\n{ id: 1, text: '...', done: true },\n{ id: 2, text: '...', done: false }\n]\n},\ngetters: {\npendingTodos: state =&gt; {\nreturn state.todos.filter(todo =&gt; !todo.done)\n},\ndoneTodos: state =&gt; {\nreturn state.todos.filter(todo =&gt; todo.done)\n},\npendingTodosCount: (state, getters) =&gt; {\nreturn getters.pendingTodos.length\n}\n}\n})\n\nCada getter recibe como primer parámetro el state del almacén.\nDentro de los componentes se usan como cualquier variable:\ncomputed: {\npendingTodos () {\nreturn this.$store.getters.pendingTodos\n}\n}\n\nY también podemos usar varios con el helper mapGetters:\nimport { mapGetters } from 'vuex'\n\nexport default {\n// ...\ncomputed: {\n// mix the getters into computed with object spread operator\n...mapGetters([\n'pendingTodos',\n'pendingTodosCount',\n// ...\n])\n}\n}\n\nSi queremos podemos hacer getters también para los states y así no necesitamos mapState sino que accedemos a todo con mapGetters.\nLos getters pueden recibir parámetros, por ejemplo, para hacer búsquedas:\ngetters: {\n// ...\ngetTodoById: (state) =&gt; (id) =&gt; {\nreturn state.todos.find((todo) =&gt; todo.id === id)\n}\n}\n\nY lo llamaremos con this.$store.getters.getTodoById(2).\nMutations\nNOTA: Una mutación no puede hacer una llamada asíncrona (por ejemplo llamar a axios)\nLa única manera de cambiar los datos del almacén es llamando a las mutaciones que hayamos definido, pero no se llaman como si fueran métodos sino que se lanzan (como si fueran eventos) con commit: this.$store.commit('increment').\nLas mutaciones reciben como primer parámetro el store pero pueden recibir otro parámetro adicional, llamado payload, donde incluyamos los datos a pasarle a la mutación:\nmutations: {\naddTodo (state, toDo) {\nstate.todos.push(toDo)\n}\n}\n\nAl llamar a la mutación le pasamos el valor esperado: this.$store.commit('addTodo', this.newTodo).\nCada vez que se llama a una mutación se registra en las DevTools y podemos ver la mutación llamada y los datos que se le han pasado:\n![DevTools - Mutations](/img/user/01 Apuntes/Vue Teoria Batoi/img/DevTools-Vuex-mutations.png)\nSi queremos pasar varios parámetros el payload deberá ser un objeto. En ese caso podemos pasar el nombre de la mutación como propiedad type del objeto:\nthis.$store.commit({\ntype: 'incrementBy',\namount: 10\n})\n\nPodemos llamar a las mutaciones desde un componente, aunque lo habitual es llamar a acciones que ejecuten esas mutaciones. Recuerda que el código de las mutaciones NO puede ser asíncrono, por lo que no pueden, por ejemplo, hacer una llamada a axios.\nPara llamar a la mutación desde un componente haríamos:\nthis.$store.commit('increment'):\n\nAl igual con con el estado o los getters podemos mapear las mutaciones a métodos locales para poder hacer this.increment() en lugar de this.$store.commit('increment') con el helper mapMutatios:\nimport { mapMutations } from 'vuex'\n\nexport default {\n// ...\nmethods: {\n...mapMutations([\n'increment', // map `this.increment()` to `this.$store.commit('increment')`\n'incrementBy' // map `this.incrementBy(amount)`\n// to `this.$store.commit('incrementBy', amount)`\n]),\n// Y podemos hacer 'alias' de las mutaciones\n...mapMutations({\nadd: 'increment' // map `this.add()` to `this.$store.commit('increment')`\n})\n}\n}\n\nActions\nSon métodos del almacén como las mutaciones pero que SÍ pueden hacer llamadas asíncronas. Por tanto es aquí donde haremos las llamadas a la BBDD y cuando el servidor responda modificaremos los datos del store. Lo mejor es no cambiarlos directamente en la action (aunque podría hacerse) sino que la action debería llamar a una mutation que la cambie y así se registra en las DevTools. Las acciones reciben como parámetro un objeto context con las mismas propiedades y métodos que el almacén, lo que permite:\n\nlanzar una mutación con context.commit(\nacceder a los datos con context.state.\nacceder a los getters con context.getters.\nllamar a otras acciones con context.dispatch(\n\n...\nimport axios from 'axios'\n\nexport default new Vuex.Store({\nstate: {\ntodos: []\n},\nmutations: {\naddTodo(state, todo) {\nstate.todos.push(todo);\n},\n},\nactions: {\naddTodo(context, item) {\naxios.post(`${baseURL}/todos`, item)\n.then((response) =&gt; context.commit('addTodo', response.data))\n.catch((error) =&gt; alert(error))\n},\n},\n\nPara llamarla desde un componente hacemos:\nthis.$store.dispatch('addTodo', this.newTodo)\n\nTambién podemos usar la desestructuración de objetos de ES2015 para obtener sólo la parte del contexto que nos interesa:\nactions: {\naddTodo({ commit }, item) {\naxios.post(`${baseURL}/todos`, item)\n.then((response) =&gt; commit('addTodo', response.data))\n.catch((error) =&gt; alert(error))\n},\n\nIgual que antes podemos usar el helper mapActions para mapear acciones y no tener que llamarlas en el componente con this.$store.dispatch('...').\nSi la acción realiza una llamada asíncrona y el componente que la llama tiene que enterarse de cuándo finaliza debe devolver una promesa:\nactions: {\naddTodo(context, item) {\nreturn new Promise((resolve, reject) =&gt; {\naddTodo(context, item) {\naxios.post(`${baseURL}/todos`, item)\n.then((response) =&gt; {\ncontext.commit('addTodo', response.data)\nresolve(response.data)\n})\n.catch((error) =&gt; reject(error))\n}\n},\n},\n\nEn este caso en el componente tenemos los métodos then y catch para saber cuándo ha acabado la acción:\nthis.$store.dispatch('addTodo', this.newTodo)\n.then((todo) =&gt; { \t // se ejecutará si la acción ha hecho un resolve()\nalert('Añadida la tarea ' + todo.id)\nthis.$router.push('/todos')\n})\n.catch((error) =&gt; alert(error))\t// se ejecutará si la acción ha hecho un reject()\n\nNOTA: si quien llama a una acción no necesita saber cuándo termina la acción ni su resultado la acción no es necesario que devuelva una promesa\nstate en formularios\nSi queremos usar un formulario para modificar un state del store no podemos asociarlo al input con la directiva v-model porque cuando el usuario cambie el valor del input estaría escribiendo directamente sobre un state, lo que no puede hacerse más que por medio de una mutación.\nTenemos 2 soluciones al problema:\n\npodemos no usar el v-model sino descomponerlo en un :value y un @input como vimos al hablar de poner un input en un subcomponente\npodemos ponerle al computed de ese state un setter y un getter como vimos en el capítulo de Profundizando en Vue\n\nMás información en la documentación oficial de Vuex.\nSaber más\n\nVuex\nCómo Construir Aplicaciones Complejas y a Gran Escala Vue.js con Vuex\nVuex for Everyone\nVueJS: Introducción a vuex\nManaging State in Vue.js",
		"tags": [ "note"]
},

{
		"title": "08-forms",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/08-forms/",
		"content": "Formularios en Vue\n\nFormularios en Vue\nIntroducción\n\nUtilizar diferentes tipos de inputs\n\ninput normal\nradio button\ncheckbox\ncheckbox múltiple\n\nGenerar los checkbox automáticamente\n\nselect\nEjemplo\n\nValidar formularios\n\nValidar con VeeValidate\n\nValidar otros inputs\nUsar un schema\nValidar con vee-validate y yup\nPersonalizar los mensajes de yup\nValidación personalizada con yup\n\nInputs en subcomponentes\n\nv-model en subcomponente input\n\nEjemplo\nValidación con Vee Validate\n\nSlots\n\nEjemplo\n\nIntroducción\nPara poder tener sincronizado el formulario con nuestros datos utilizamos la directiva v-model en cada campo. Algunos modificadores útiles de v-model son:\n\n.lazy: hace que v-model sincronice al producirse el evento change en vez del input, es decir, que no sincroniza con cada tecla que pulsemos sino cuando acabamos de escribir y salimos del input.\n.number: convierte automáticamente el valor introducido (que se considera siempre String) a Number\n.trim: realiza un trim() sobre el texto introducido\n\nVamos a ver cómo usar los diferentes tipos de campos con Vue.\nUtilizar diferentes tipos de inputs\nPodemos probar el resultado en la documentación de Vue.\ninput normal\nEn este caso simplemente añadimos la directiva v-model al input:\n&lt;label&gt;Nombre:&lt;/label&gt;\n&lt;input type=&quot;text&quot; v-model=&quot;user.nombre&quot;&gt;\n\nradio button\nPonemos en todos los radiobuttons el v-model y a cada uno el value que se guardará al escoger dicha opción:\n&lt;label&gt;Sexo:&lt;/label&gt;\n&lt;input type=&quot;radio&quot; value=&quot;H&quot; name=&quot;sexo&quot; v-model=&quot;user.sexo&quot;&gt;Hombre\n&lt;input type=&quot;radio&quot; value=&quot;M&quot; name=&quot;sexo&quot; v-model=&quot;user.sexo&quot;&gt;Mujer\n\ncheckbox\nIgual que cualquier input, le ponemos el v-model. Si no ponemos un value los valores que se guardarán serán true si está marcado y false si no lo está:\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.acepto&quot;&gt;Acepto las condiciones\n\ncheckbox múltiple\nSe trata de varios checkbox pero cuyos valores se guardan en el mismo campo, que debe ser un array. Le ponemos el v-model y el value que queramos que se guarde. La variable (en este ejemplo user.ciclos será un array y guardará el value de cada checkbox marcado:\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;smx&quot;&gt;Sistemas Microinformáticos y Redes&lt;br&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;asix&quot;&gt;Administración de Sistemas Informáticos y Redes&lt;br&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;dam&quot;&gt;Desarrollo de Aplicaciones Multiplataforma&lt;br&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; value=&quot;daw&quot;&gt;Desarrollo de Aplicaciones Web&lt;br&gt;\n\nSi tenemos marcadas las casillas 1 y 3 el valor de user.ciclos será ['smx', 'dam'].\nGenerar los checkbox automáticamente\nMuchas veces las opciones a mostrar las tendremos en algún objeto (una tabla de la BBDD, ...). En ese caso podemos generar automáticamente un checkbox para cada elemento:\nciclos: [\n{cod: 'smx', desc: 'Sist. Microinformáticos y Redes'},\n{cod: 'asix', desc: 'Adm. de Sistemas Informáticos y Redes'},\n{cod: 'dam', desc: 'Desar. de Aplicaciones Multiplataforma'},\n{cod: 'daw', desc: 'Desar. de Aplicaciones Web'},\n]\n\n&lt;div v-for=&quot;ciclo in ciclos&quot; :key=&quot;ciclo.cod&quot;&gt;\n&lt;input type=&quot;checkbox&quot; v-model=&quot;user.ciclos&quot; :value=&quot;ciclo.cod&quot;&gt;{ { ciclo.desc }}&lt;br&gt;\n&lt;/div&gt;\n\nselect\nLo único que hay que hacer es poner al select la directiva v-model:\n&lt;select v-model=&quot;user.tutor&quot;&gt;\n&lt;option value=''&gt;No es tutor&lt;/option&gt;\n&lt;option value=&quot;smx&quot;&gt;Sistemas Microinformáticos y Redes&lt;/option&gt;\n&lt;option value=&quot;asix&quot;&gt;Administración de Sistemas Informáticos y Redes&lt;/option&gt;\n&lt;option value=&quot;dam&quot;&gt;Desarrollo de Aplicaciones Multiplataforma&lt;/option&gt;\n&lt;option value=&quot;daw&quot;&gt;Desarrollo de Aplicaciones Web&lt;/option&gt;\n&lt;/select&gt;\n\nTambién podemos generar las opciones automáticamente:\n&lt;select v-model=&quot;user.tutor&quot;&gt;\n&lt;option value=''&gt;No es tutor&lt;/option&gt;\n&lt;option v-for=&quot;ciclo in ciclos&quot; :key=&quot;ciclo.cod&quot; :value=&quot;ciclo.cod&quot;&gt;\n{ { ciclo.desc }}\n&lt;/option&gt;\n&lt;/select&gt;\n\nSi queremos que sea un select múltiple sólo tenemos que ponerle el atributo multiple a la etiqueta &lt;select&gt; y hacer que la variable user.tutor sea un array, que se comportará como en los checkbox múltiples.\nEjemplo\n\nValidar formularios\nPodemos validar el formulario &quot;a mano&quot; como hemos visto en JS:\n\nAdemás deberíamos poner clase de error a los inputs con errores para destacarlos, poner el cursor en el primer input erróneo, etc.\nTodo esto es incómodo y poco productivo. Para mejorarlo podemos usar una de las muchísimas librerías para validación de formularios como:\n\nVeeValidate\nvuelidate\nVueFormGenerator\n...\n\nValidar con VeeValidate\nTenéis toda la información así como un tutorial de cómo usar este librería en la documentación de VeeValidate).\nLa forma de instalarla es\nnpm install vee-validate -S\n\nY para usarla simplemente cambiaremos la etiqueta &lt;input&gt; por el componente &lt;Field&gt; y la etiqueta &lt;form&gt; por el componente &lt;Form&gt; pero quitándole el modificador .prevent del escuchador @submit y haciendo que la función manejadora reciba un parámetro llamado values que es un objeto con los valores de los inputs del formulario.\nCada componente Field necesitará un atributo name que es el nombre del campo con el valor de ese input dentro del objeto values. Si el formulario es sólo para recoger datos, no para modificar datos existentes no necesitamos la directiva v-model porque sus valores se guardarán en el objeto values que recibe la función manejadora del @submit. Sin embargo si debe mostrar datos que pueden cambiar tras la carga del componente mantendremos el atributo v-model (como en la práctica que estamos haciendo, que si nos pasan una id cargamos el libro con dicha id y lo mostramos en el formlario para editarlo).\nPara validar un campo se le añade al componente un atributo :rules con la función a ejecutar, que devolverá el mensaje a mostrar en caso de error o true si es correcto. El mensaje se mostrará en un componente llamado ErrorMessage (que deberemos importar y registrar) cuyo atributo name debe ser igual al del campo a validar. Si alguna de las funciones de validación no devuelve true no se ejecuta la función manejadora del submit.\nHabrá que importar los componentes de'vee-validate' que se usen (Form, Field, ErrorMessage) y registrarlos.\nSi no usamos v-model podemos darle un valor por defecto a los inputs (por ejemplo, si estamos editando un objeto que ya tiene valores) pasándole el objeto con los valores al componente &lt;Form&gt; en un atributo llamado initial-values. Pero si cambien esos valores tras cargar el componente no se reflejarán los cambios (para ello debemos usar v-model).\nPor ejemplo si estamos editando el objeto\nproduct = {\nname: 'Ratón óptico',\nprice: '8.95'\n}\n\nel formulario sería:\n&lt;Form :initial-values=&quot;product&quot; @submit=&quot;onSubmit&quot;&gt;\n&lt;Field name=&quot;name&quot; type=&quot;text&quot; /&gt;\n&lt;ErrorMessage name=&quot;name&quot; /&gt;\n\n&lt;Field name=&quot;price&quot; type=&quot;text&quot; /&gt;\n&lt;ErrorMessage name=&quot;price&quot; /&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Guardar&lt;/button&gt;\n&lt;/Form&gt;\n\nSi el objeto product está vacío el formulario aparecerá en blanco pero si contiene datos se mostrarán en el formulario. Sin embargo si modificamos los datos de product esos cambios no se reflejan en el formlario a menos que usemos v-model.\nA continuación tenéis un ejemplo completo de un formulario para validar un email y una contraseña (Fuente https://codesandbox.io/s/vee-validate-basic-example-nc7eh?from-embed=&amp;file=/src/App.vue):\n&lt;template&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;Form @submit=&quot;onSubmit&quot;&gt;\n&lt;Field name=&quot;email&quot; type=&quot;email&quot; :rules=&quot;validateEmail&quot; /&gt;\n&lt;ErrorMessage name=&quot;email&quot; /&gt;\n\n&lt;Field name=&quot;password&quot; type=&quot;password&quot; :rules=&quot;validatePassword&quot; /&gt;\n&lt;ErrorMessage name=&quot;password&quot; /&gt;\n\n&lt;button&gt;Sign up&lt;/button&gt;\n&lt;/Form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Form, Field, ErrorMessage } from &quot;vee-validate&quot;;\n\nexport default {\ncomponents: {\nForm,\nField,\nErrorMessage,\n},\nmethods: {\nonSubmit(values) {\nconsole.log(values);\n},\nvalidateEmail(value) {\n// if the field is empty\nif (!value) {\nreturn &quot;This field is required&quot;;\n}\n\n// if the field is not a valid email\nconst regex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i;\nif (!regex.test(value)) {\nreturn &quot;This field must be a valid email&quot;;\n}\n\n// All is good\nreturn true;\n},\nvalidatePassword(value) {\n// if the field is empty\nif (!value) {\nreturn &quot;This field is required&quot;;\n}\n\n// if the length is less than 8 characters\nif (value.length &lt; 8) {\nreturn &quot;The length of this field must be at least 8 characters&quot;;\n}\n\n// All is good\nreturn true;\n}\n},\n};\n&lt;/script&gt;\n\nPodemos encontrar más información sobre vee-validate en su documentación oficial.\nValidar otros inputs\nPara validar un &lt;select&gt; simplemente lo cambiamos por un &lt;Field as=&quot;select&quot;&gt;. Ejemplo:\n&lt;Field as=&quot;select&quot; name=&quot;autor&quot; class=&quot;form-control&quot; required&gt;\n&lt;option value=&quot;&quot;&gt;--- Selecciona autor ---&lt;/option&gt;\n&lt;option v-for=&quot;autor in autores&quot; :key=&quot;autor.id&quot;\n:value=&quot;autor.id&quot;&gt;\n{{ autor.nombre + ' ' + autor.apellidos }}\n&lt;/option&gt;\n&lt;/Field&gt;\n&lt;ErrorMessage name=&quot;autor&quot; /&gt;\n\nPara un textarea pondremos un &lt;Field as=&quot;textarea&quot;&gt;.\nEn el caso de un checkbox o un radiobutton simplemente añadimos al Field un atributo type indicando su tipo:\n&lt;Field name=&quot;drink&quot; type=&quot;radio&quot; value=&quot;Water&quot; /&gt; Water\n&lt;Field name=&quot;drink&quot; type=&quot;radio&quot; value=&quot;Tea&quot; /&gt; Tea\n&lt;Field name=&quot;drink&quot; type=&quot;radio&quot; value=&quot;Coffee&quot; /&gt; Coffee\n\nSi se trata de varios checkbox con el mismo atributo name en values se recibirá un array con los values de los elementos marcados.\nUsar un schema\nEl problema de validar los datos así es que tenemos varias funciones independientes que validan los distintos inputs lo que dispersa el código de la vaidación.\nPodemos ponerlas todas como propiedades de un objeto que le pasamos como atributo al Form, evitando además tener que poner los atributos rules en cada Field a validar.\nEl ejemplo anterior quedaría:\n&lt;template&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;Form :validation-schema=&quot;mySchema&quot; @submit=&quot;onSubmit&quot;&gt;\n&lt;Field name=&quot;email&quot; type=&quot;email&quot; /&gt;\n&lt;ErrorMessage name=&quot;email&quot; /&gt;\n\n&lt;Field name=&quot;password&quot; type=&quot;password&quot; /&gt;\n&lt;ErrorMessage name=&quot;password&quot; /&gt;\n\n&lt;button&gt;Sign up&lt;/button&gt;\n&lt;/Form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Form, Field, ErrorMessage } from &quot;vee-validate&quot;;\n\nexport default {\ncomponents: {\nForm,\nField,\nErrorMessage,\n},\ndata() {\nreturn {\nmySchema = {\nemail: (value) =&gt; {\nif (!value) return &quot;This field is required&quot;;\nconst regex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i;\nif (!regex.test(value)) return &quot;This field must be a valid email&quot;;\nreturn true;\n},\npassword: (value) =&gt; {\nif (!value) return &quot;This field is required&quot;;\nif (value.length &lt; 8) return &quot;The length of this field must be at least 8 characters&quot;;\nreturn true;\n}\n}\n}\n},\nmethods: {\nonSubmit(values) {\nconsole.log(values);\n},\n},\n};\n&lt;/script&gt;\n\nValidar con vee-validate y yup\nVee-validate 4 también permite usar librerías como yup. En este caso la validación es casi automática como se muestra en la documentación de vee-validate. El ejemplo anterior quedaría:\n&lt;template&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;Form @submit=&quot;onSubmit&quot; :validation-schema=&quot;mySchema&quot;&gt;\n&lt;Field name=&quot;email&quot; type=&quot;email&quot; /&gt;\n&lt;ErrorMessage name=&quot;email&quot; /&gt;\n\n&lt;Field name=&quot;password&quot; type=&quot;password&quot; /&gt;\n&lt;ErrorMessage name=&quot;password&quot; /&gt;\n\n&lt;button&gt;Sign up&lt;/button&gt;\n&lt;/Form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Form, Field, ErrorMessage } from &quot;vee-validate&quot;;\nimport * as yup from 'yup';\n\nexport default {\ncomponents: {\nForm,\nField,\nErrorMessage,\n},\ndata() {\nconst mySchema = yup.object({\nemail: yup.string().required().email(),\npassword: yup.string().required().min(8),\n})\nreturn {\nmySchema\n}\n},\nmethods: {\nonSubmit(values) {\nconsole.log(values);\n},\n},\n};\n&lt;/script&gt;\n\nPersonalizar los mensajes de yup\nPara personalizar un mensaje de error de un campo sólo tenemos que indicar el mensaje al definir la regla del campo:\nconst mySchema = yup.object({\nemail: yup.string().required('El email es obligatorio').email(),\npassword: yup.string().required().min(8, 'La contraseña debe tener al menos 8 caracteres'),\n})\n\nEn este caso hemos personalizado el mensaje del email si no contiene nada y del password si no cumple el min.\nSi queremos personalizar todos los mensajes de error debemos definir un objeto con los nuevos mensajes. Las validaciones no incluidas mantendrán el mensaje original. Ejemplo:\nimport * as yup from 'yup';\nimport { setLocale } from 'yup';\nsetLocale({\nmixed: {\ndefault: 'Campo no válido',\nrequired: 'El campo ${path} no puede estar vacío'\n},\nstring: { // sólo las reglas 'min' de campos 'string'\nmin: 'El campo ${path} debe tener al menos ${max} caracteres'\n},\nnumber: { // sólo las reglas 'min' de campos 'number'\nmin: 'El valor del campo debe ser mayor que ${min}',\n},\n});\n\nValidación personalizada con yup\nSi lo que queremos validar no lo hace ningún validador de yup podemos crear nuestra propia regla usando el validador test() que como 1º parámetro recibe el nombre de la regla, como 2º el mensaje de error a mostrar y como 3º una función que recibe el valor del campo y devolverá true/false indicando si es válido o no. Por ejemplo el campo seed debe ser múltiplo de 7:\nconst mySchema = yup.object({\nseed: yup.number().required().test('seven-multiplo', 'El valor debe ser múltiplo de 7', (value) =&gt; {\nreturn !(value % 7)\n},\n...\n})\n\nInputs en subcomponentes\nLa forma enlazar cada input con su variable correspondiente es mediante la directiva v-model que hace un enlace bidireccional: al cambiar la variable Vue cambia el valor del input y si el usuario cambia el input Vue actualiza la variable automáticamente.\nEl problema lo tenemos si hacemos que los inputs estén en subcomponentes. Si ponemos allí el v-model al escribir en el input se modifica el valor de la variable en el subcomponente (que es donde está el v-model) pero no en el padre.\nPara solucionar este problema tenemos 2 opciones: imitar nosotros en el subcomponente lo que hace v-model o utilizar slots.\nv-model en subcomponente input\nComo los cambios en el subcomponente no se transmiten al componente padre hay que emitir un evento desde el subcomponente que escuche el padre y que proceda a hacer el cambio en la variable.\nLa solución es imitar lo que hace un v-model que en realidad está formado por:\n\nun v-bind para mostrar el valor inicial en el input\nun _v-on:input que se encarga de avisar para que se modifique la variable al cambiar el valor del input\n\nAsí que lo que haremos es:\n\nen el componente del formulario ponemos un v-model que se encargue de actualizar la variable\n\n&lt;form-input v-model=&quot;campo&quot;&gt;&lt;/form-input&gt;\n\nen el subcomponente del inpit ponemos\n\nun v-bind que muestre el valor inicial\nun v-on:input que emita un evento input al padre pasándole el valor actual\n\n&lt;template&gt;\n&lt;div class=&quot;control-group&quot;&gt;\n&lt;!-- id --&gt;\n&lt;label class=&quot;control-label&quot; :for=&quot;nombre&quot;&gt;{ { titulo }}&lt;/label&gt;\n&lt;div class=&quot;controls&quot;&gt;\n&lt;input :value=&quot;value&quot; @input=&quot;$emit('input', $event.target.value)&quot; type=&quot;text&quot; :id=&quot;nombre&quot; :name=&quot;nombre&quot; placeholder=&quot;Escribe el nombre&quot; class=&quot;form-control&quot;&gt;\n&lt;/div&gt;\n&lt;/div&gt;\t\n&lt;/template&gt;\n\nprops: ['value'],\n\nEjemplo\nComponente padre: formulario\n&lt;form class=&quot;form-horizontal&quot;&gt;\n\t&lt;form-input v-model=&quot;user.id&quot; titulo=&quot;Id&quot; nombre=&quot;id&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.name&quot; titulo=&quot;Nombre&quot; nombre=&quot;name&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.username&quot; titulo=&quot;Username&quot; nombre=&quot;username&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.email&quot; titulo=&quot;E-mail&quot; nombre=&quot;email&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.phone&quot; titulo=&quot;Teléfono&quot; nombre=&quot;phone&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.website&quot; titulo=&quot;URL&quot; nombre=&quot;website&quot;&gt;&lt;/form-input&gt;\n\t&lt;form-input v-model=&quot;user.companyName&quot; titulo=&quot;Nombre de la empresa&quot; nombre=&quot;nomEmpresa&quot;&gt;&lt;/form-input&gt;\n&lt;/form&gt;\n\nSubcomponente: form-input\n&lt;template&gt;\n&lt;div class=&quot;control-group&quot;&gt;\n&lt;label class=&quot;control-label&quot; :for=&quot;nombre&quot;&gt;{ { titulo }}&lt;/label&gt;\n&lt;div class=&quot;controls&quot;&gt;\n&lt;input :value=&quot;value&quot; @input=&quot;updateValue($event.target.value)&quot; type=&quot;text&quot; :id=&quot;nombre&quot; :name=&quot;nombre&quot; placeholder=&quot;&quot; class=&quot;form-control&quot;&gt;\n&lt;/div&gt;\n&lt;/div&gt;\t\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'user-form-input',\nprops: ['value', 'titulo', 'nombre'],\nmethods: {\nupdateValue(value) {\n\tthis.$emit('input', value)\n}\n}\n}\n&lt;/script&gt;\n\nValidación con Vee Validate\nEsto mismo podemos hacer si estamos usando VeeValidate para validar nuestro formulario. Tenemos toda la información en la documentación oficial.\nSlots\nYa vimos al hablar de la comunicación entre componentes que un slot es una ranura en un subcomponente que, al renderizarse, se rellena con lo que le pasa el padre.\nEsto podemos usarlo en los formularios de forma que el &lt;input&gt; con el v-model lo pongamos en un slot de forma que está enlazado correctamente en el padre.\nEjemplo\nComponente padre: formulario\n&lt;form class=&quot;form-horizontal&quot;&gt;\n\t&lt;form-input titulo=&quot;Id&quot;&gt;\n&lt;input v-model=&quot;user.id&quot; type=&quot;text&quot; id=&quot;id&quot; name=&quot;id&quot; class=&quot;form-control&quot; disabled&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Nombre&quot;&gt;\n\t &lt;input v-model=&quot;user.name&quot; type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Username&quot;&gt;\n\t &lt;input v-model=&quot;user.username&quot; type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;E-mail&quot;&gt;\n&lt;input v-model=&quot;user.email&quot; type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Teléfono&quot;&gt;\n&lt;input v-model=&quot;user.phone&quot; type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;URL&quot;&gt;\n\t &lt;input v-model=&quot;user.website&quot; type=&quot;text&quot; id=&quot;website&quot; name=&quot;website&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n\t&lt;form-input titulo=&quot;Nombre de la empresa&quot;&gt;\n\t &lt;input v-model=&quot;user.companyName&quot; type=&quot;text&quot; id=&quot;nomEmpresa&quot; name=&quot;nomEmpresa&quot; class=&quot;form-control&quot;&gt;\n\t&lt;/form-input&gt;\n&lt;/form&gt;\n\nSubcomponente: form-input\n&lt;template&gt;\n&lt;div class=&quot;control-group&quot;&gt;\n&lt;label class=&quot;control-label&quot;&gt;{ { titulo }}&lt;/label&gt;\n&lt;div class=&quot;controls&quot;&gt;\n\t &lt;slot&gt;Aquí va un INPUT&lt;/slot&gt;\n&lt;/div&gt;\n&lt;/div&gt;\t\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\nname: 'user-form-input',\nprops: ['value', 'titulo', 'nombre'],\nmethods: {\nupdateValue(value) {\nthis.$emit('input', value)\n}\n}\n}\n&lt;/script&gt;",
		"tags": [ "note"]
},

{
		"title": "09-cosas",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/09-cosas/",
		"content": "Siguientes cosas a aprender en Vue\nAlgunas cosas interesantes que nos pueden ser útiles en nuestros proyectos son:\n\nSiguientes cosas a aprender en Vue\n\nAutenticación\n\nStore\nAPI\nLogin.vue\nRouter\n\nPaso a producción\nVuetify\n\nInstalación\nCrear el layout\nSaber más\n\nTypescript\nSSR (Server Side Rendering)\nCrear aplicaciones móviles con Vue\n\nQuasar\nVue Native\nIonic Vue\n\nNuxt\nConclusión\nAngular\nVue con Laravel\n\nCreación del proyecto\nConfiguramos el proyecto en Vue\nConfiguramos Laravel\nCompilamos Vue\nCreamos la API\nSaber más\n\nAutenticación\nUna parte importante de cualquier aplicación es la autenticación de usuarios. Una de las formas más usadas y sencillas de autenticarnos frente a una API es el uso de tokens: cuando nos logueamos la API nos pasa un token y en cada petición que le hagamos debemos adjuntar dicho token en las cabeceras de la petición, tal y como vimos al final del tema de axios.\nAparte de eso, que es lo básico, hay muchas más cosas que podemos incluir en nuestras aplicaciones. Por ejemplo vamos a hacer una aplicación que:\n\nal loguearnos la API nos pasa un token que guardaremos en el store y también en el localStorage para poder continuar logueados si se recarga la página (recuerda que al recargar se borran todas las variables de nuestro código)\ninterceptaremos todas las peticiones a la API para incluir en las cabeceras el token, si tenemos\ninterceptaremos todas las respuestas a la API y si en alguna el servidor responde con un error 401 (Unauthenticated) reenviaremos al usuario a la página de login para que se loguee pero pasándole como parámetro la página a la que quería ir para que una vez logueado vaya automáticamente a dicha página\nel login hará varias cosas\n\nsi hay token en el localStorage es que ya está logueado (posiblemente se haya recargado la página y al interceptar la respuesta era un 401 porque iba sin token y se ha redireccionado aquí). En este caso simplemente se guarda el token en el store y se vuelve a la página de donde venía la petición. OJO: si el token caduca (que es lo más normal) deberemos mirar si ya ha expirado y en ese caso no se guarda en el store sino que se elimina del localStorage y se hace un login normal\nsi no hay token es que debemos loguearnos así que se muestra el formulario para que el usuario introduzca sus credenciales y se le envían al servidor. Este contestará con un token que deberemos guardar en el store y en el localStorage antes de redireccionar a la página de la que venía la petición o a la página de inicio\n\nen el router indicaremos para qué rutas hay que estar autentificado y antes de cargar cualquiera de ellas (usaremos el hook beforeEach) comprobamos si estamos autenticados y en caso de no estarlo redireccionamos al login, pero pasándole como parámetro la ruta a la que queríamos ir para que se cargue tras loguearse\n\nVeamos el código para hacer todo esto:\nStore\n// Fichero '@/store/index.js'\n...\nmutations: {\nloginUser(state, token) {\nstate.token = token\nlocalStorage.token = token\n},\nlogoutUser(state) {\nstate.token = null\nlocalStorage.removeItem('token')\n},\n},\nactions: {\nlogin(context, user) {\nreturn new Promise ((resolve, reject) =&gt; {\nAPI.users.login(user)\n.then((response) =&gt; {\ncontext.commit('login', response.data)\nresolve(response.data)\n})\n.catch((err) =&gt; reject(err))\n})\n},\n...\n},\n\nLa acción que envía las credenciales del usuario al servidor es una promesa porque el componente Login.vue tiene que saber cuándo se obtiene el token para redireccionar a la página correspondiente.\nLas mutaciones almacenan el token en el store y también en el localStorage.\nAPI\n// Fichero '@/services/API.js'\nimport axios from 'axios'\nimport store from '@/store'\nimport router from '@/router'\n\nconst API_URL = process.env.VUE_APP_API\n\nconst users = {\nlogin: (item) =&gt; axios.post(`${API_URL}/auth/login`, item),\nregister: (user) =&gt; axios.post(`${API_URL}/auth/signup`, user),\n}\n...\n\naxios.interceptors.request.use((config) =&gt; {\nconst token = store.state.user.access_token\nif (token) {\nconfig.headers['Authorization'] = 'Bearer ' + token\n}\nreturn config;\n}, (error) =&gt; {\nreturn Promise.reject(error)\n})\n\naxios.interceptors.response.use((response) =&gt; {\nreturn response\n}, (error) =&gt; {\nif (error.response) {\nswitch (error.response.status) {\ncase 401:\nstore.commit('logout')\nif (router.currentRoute.path !== 'login') {\nrouter.replace({\npath: 'login',\nquery: { redirect: router.currentRoute.path },\n})\n}\n}\n}\nreturn Promise.reject(error)\n})\n\nexport default {\nusers,\n...\n};\n\nInterceptamos las peticiones para incluir el token si lo tenemos.Y también las respuestas porque si es un error 401 hay que loguearse por lo que se cambia el router al login pero se le pasa la dirección de la página en la que se estaba para que tras loguearse se cargue esa página y no la de inicio.\nLogin.vue\n// script de la vista 'Login.vue'\n...\nmounted() {\nif (localStorage.token) {\n// Si el token caduca debemos comprobar que no haya expirado\nthis.$store.commit(&quot;login&quot;, localStorage.token)\nthis.loadPage()\n}\n},\nmethods: {\nsubmit() {\nthis.$store.dispatch(&quot;login&quot;, this.user)\n.then(() =&gt; this.loadPage())\n.catch((err) =&gt; alert(err))\n},\nloadPage() {\nconst redirect = decodeURIComponent(this.$route.query.redirect || '/')\nthis.$router.push({ path: redirect })\n}\n},\n...\n\nRouter\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport store from '../store'\n\nimport Datos from '../views/Datos.vue'\n...\n\nVue.use(VueRouter)\n\nrouter.beforeEach((to, from, next) =&gt; {\nif (to.meta.requireAuth) {\nif (store.token) {\nnext();\n}\nelse {\nnext({\npath: '/login',\nquery: { redirect: to.fullPath }\n})\n}\n}\nelse {\nnext();\n}\n})\n\nconst routes = [\n{\npath: '/datos',\nname: 'Datos',\ncomponent: Datos,\nmeta: {\nrequireAuth: true,\n},\n},\n...\n]\n\nexport default router = new VueRouter({\nmode: 'history',\nbase: process.env.BASE_URL,\nroutes\n})\n\nPara ver algunos ejemplos de cómo gestionar la autenticación en nuestros proyectos Vue podemos consultar cualquiera de estos enlaces:\n\nAuthentication Best Practices for Vue\nVue Authentication And Route Handling Using Vue-router\n\nPaso a producción\nUna vez acabada nuestra aplicación debemos general el build que pasaremos a producción. El build es el conjunto de ficheros compilados, minificados, etc que subiremos al servidor de producción. Para ello tenemos un script en el package.json que se encarga de todo:\nnpm run build\n\nCrea un directorio dist con lo qie hay que subir a producción:\n\nindex.html: HTML\nficheros que hay en /public: imágenes, CSS y cualquier otro fichero estático que hubiera en la carpeta /public, como favicon.ico\nassets: todo lo que ha compilado Vite optimizado y minimizado:\n\nindex-xxxx.js: fichero con todo nuestro código Javascript más el de las librerías usadas\nindex-xxxx-css: fichero con todo nuestro CSS\nimágenes y otros archivos que hubiera en assets\n\nVuetify\nSon varias las librerías para Vue que nos facilitan enormemente la creación de nuestros componentes ya que nos dan un código para los mismos (tanto el template como el Javascript) de manera que simplemente personalizando ese código con nuestros datos ya tenemos un componente totalmente funcional. Entre ellas están Material Design, ElementUI, Vuetify y muchas otras.\nPodemos ver la utilidad de estas librerías consultando, por ejemplo, como crear una Datatable con Vuetify. Vuetify sigue el diseño de Material Design.\nPodemos obtener toda la información sobre esta librería en su página web.\nInstalación\nVue se instala como cualquier otro plugin:\nvue add vuetify\n\nCrear el layout\nEn App.vue borramos todo su contenido y lo sustituimos por el código de layout que deseemos de Vuetify. Para ver el código pinchamos en la imagen del layout deseada y lo copiamos.\nA continuación ponemos el &lt;router-view&gt; donde corresponda.\nCada elemento del menú es una etiqueta &lt;v-list-tile&gt; dentro del &lt;v-navigation-drawer&gt;. Para modificar el menú vamos a Vuetify -&gt; UI components -&gt; Navigation drawers.\nPara cada elemento que queramos añadir:\n\nSu icono está dentro de &lt;v-icon&gt; y para elegirlo vamos a Material Design y elegimos el que queramos. Para modificar su aspecto vamos a Vuetify -&gt; UI components -&gt; Icons y copiamos el código que queramos\nPara que enlace a la ruta que queramos añadimos a la etiqueta &lt;v-list-tile-title&gt; una etiqueta &lt;router-link :to=&quot;{ name: nombre_de_la_ruta }&gt;, ejemplo:\n\n&lt;v-list-tile-title&gt;\n&lt;routerlink :to=&quot;{ name: 'perfil' }&quot;&gt;Perfil&lt;/router-link&gt;\n&lt;/v-list-tile-title&gt;\n\nSi no nos gusta Material Dessign tenemos alternativas como Buefy (que proporciona componentes Vue basados en Bulma) y muchas otras.\nSaber más\n\nVuetifyJS.com\nVuetify Material Framework in 60 minutes\nIntro and Overview of Vuetify.js (Build a CRUD client with Vue.js)\n\nTypescript\nEs Javascript al que se le ha incorporado tipado de datos y otras utilidades. En los apuntes puedes ver una introducción a cómo usarlo en Vue y en Internet tienes infinidad de recursos para aprender más.\nSSR (Server Side Rendering)\nEsta tecnología permite que al obtener la página un robot (haciendo curl miURL) no devuelva sólo la &lt;app&gt; sino el HTML para que los robots la puedan indexar correctamente.\nEl problema que tiene una SPA es que las rutas no existen realmente sino sólo en el front y se generan asíncronamente, lo que dificulta a los robots obtener las páginas de las distintas rutas.\nSSR hace que la primera vez que un usuario accede a la web se sirve entera desde el servidor y el resto de veces ya se sirve desde el front. Eso permite que a un robot se le sirva toda desde el servidor y la puede indexar. Esto no es algo que nos interese en todos los proyectos, sólo en aquellos en que sea importante que estén bien posicionados en los buscadores.\nMás info: Server-Side Rendering.\nExplicación de qué es y cómo funciona en Angular: Angular &amp; SEO\nCrear aplicaciones móviles con Vue\nDiferentes librerías nos permiten que nuestras aplicaciones puedan ejecutarse en móviles tanto Android como iOS. La mayoría utilizan la librería Cordova de Apache2 para tener acceso a los elementos del móvil como notificaciones, cámara, geolocalización, ...\nExisten muchos pero las más utilizadas hoy en día son Quasar, Vue native e Ionic.\nQuasar\nQuasar es un framework basado en VueJS que te permite generar la aplicación de escritorio y la aplicación móvil tanto para Android como para iOS.\nTiene licencia MIT y su UI sigue las guías de Material. Su ventaja sobre los otros es que está creado en Vue y pensado para este framework.\nVue Native\nVue native es otro framework que permite generar aplicaciones móviles nativas usando Vue. En realidad es una capa sobre React Native que permite a Vue usar su API.\nCon ella podemos acceder a los diferentes dispositivos del móvil como la cámara, la geolocalización, el acelerómetro, ... Podemos encontrar en Internet muchos ejemplos de cómo hacer nuestra App con este framework, como este de scotch.io.\nIonic Vue\nIonic es posiblemente el Framework más utilizado para crear aplicaciones móviles nativas a partir de nuestra aplicación web. Está basado en Angular pero desde diciembre de 2020 puede usarse directamente en Vue, y es compatible con Vue3 y su Composition API.\nNuxt\nNuxt es un framework basado en Vue que crea un scaffolding de Vue con todo lo necesario para una aplicación media-grande (incluye rutas, Vuex,...) lo que nos facilita el desarrollo de nuestros proyectos.\nTambién hay otras librerías que nos pueden ser de utilidad como:\n\nFramework7 para crear una aplicación web que use\nWeex para crear aplicaciones nativas para iOS y Android\n\nConclusión\nComo vés existen infinidad de librerías alrededor de Vue para ofrecernos nuevas funcionalidades. Son tantas que el equipo de Vue ha creado AwesomeVue donde se registran parte de estas librerías y a donde podemos acceder en busca de cualquier cosa que necesitemos.\nAngular\nAunque el crecimiento de Vue es muy importante, Angular sigue siendo aún el framework Javascript más demandado por las empresas. Si quieres aprender aquí tienes algunos enlaces de utilidad:\n\nDocumentación oficial de Angular\nEjemplo de CRUD con Angular\n...\n\nVue con Laravel\nEs sencillo crear una SPA completa usando Vue en el Front-end y Laravel para crear el Back-end que sirva la API. Podemos hacerlo como dos proyectos independientes o integrando Vue en Laravel.\nComo proyectos independientes es la forma más sencilla. Simplemente nuestro proyecto Vue hará peticiones a la API desarrollada en Laravel.\nSi queremos integrar Vue dentro del proyecto Laravel el funcionamiento es el siguiente:\n\nLa primera petición le llega al router de Laravel que renderiza el diseño de la SPA\nLas demás peticiones usan la API history.pushState para navegar sin recargar la página y las gestiona el enrutador Vue\n\nVamos a ver en detalle cómo gestionarlo.\nCreación del proyecto\nCreamos el proyecto Laravel. Dentro del mismo instalamos los paquetes que necesitemos para Vue:\nlaravel new laravue\ncd laravue\nnpm install\nnpm i -S vue-router\n\nConfiguramos el proyecto en Vue\nConfiguramos el router de Vue en un nuevo fichero JS (por ejemplo /resources/js/router.js) y lo importamos en el fichero principal, /resources/js/app.js (el equivalente al main.js de un proyecto con vue-cli):\n// Fichero app.js\n...\nimport App from './views/App'\nimport router from './router'\n\nconst app = new Vue({\nel: '#app',\ncomponents: {\nApp\n},\nrouter,\n});\n\nCreamos el fichero /resources/js/App.vue que será el equivalente al App.vue de los proyectos vue-cli:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;Vue Router Demo App&lt;/h1&gt;\n\n&lt;p&gt;\n&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;\n...\n&lt;router-link to=&quot;/about&quot;&gt;Sobre nosotros...&lt;/router-link&gt;\n&lt;/p&gt;\n\n&lt;div class=&quot;container&quot;&gt;\n&lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nConfiguramos Laravel\nCreamos la vista principal en /resources/views/spa.blade.php:\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;{{ str_replace('_','-', app()-&gt;getLocale()) }}&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;meta name=&quot;csrf-token&quot; content=&quot;{{ csrf_token() }}&quot;&gt;\n&lt;title&gt;Vue SPA Demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=&quot;app&quot;&gt;\n&lt;app&gt;&lt;/app&gt;\n&lt;/div&gt;\n\n&lt;script src=&quot;{{ mix('js/app.js') }}&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nNOTA: la línea del &lt;meta CSRF-TOKEN&gt; es para evitar los errores de la consola por no pasar el token csrf.\nConfiguramos /routes/web.php para que sirva siempre esa página:\nRoute::get('/{any}', 'SpaController@index')-&gt;where('any', '.*');\n\npara lo que creamos el controlador:\nphp artisan make:controller SpaController\nhttps://vuex.vuejs.org/guide/forms.html```\ny lo editamos:\n```php\n&lt;?php\nnamespace App\\Http\\Controllers;\nuse Illuminate\\Http\\Request;\n\nclass SpaController extends Controller\n{\npublic function index()\n{\nreturn view('spa');\n}\n}\n\nCompilamos Vue\nAhora simplemente ejecutamos en la terminal\nnpm run dev\n\ny ya tenemos la aplicación en marcha. Si aparece un error de &quot;The Mix manifest does not exist&quot; ejecutaremos npm run prod que crea el fichero mix-manifest.json.\nPara que se compilen automáticamente los cambios que vayamos haciendo en Vue mientras desarrollamos el proyecto ejecutamos npm run watch-poll en una terminal.\nCreamos la API\nPara obtener datos de una API debemos en primer lugar crear la ruta en /routes/api.php:\nRoute::namespace('Api')-&gt;group(function () {\nRoute::get('/alumnos', 'AlumnosController@index');\n});\n\nEsto nos crea sólo la ruta para el verbo GET. Una opción mejor es crear todas las rutas del recurso con:\nRoute::resource('alumnos',’AlumnosController’,['only'=&gt;['index','store','show','update','destroy' ]]);\n\nLa opción only es opcional y permite restringir las rutas que se crearán para que no se muestren las que no utilizaremos (podemos comprobarlo con un php artisan route:list).\nOtra opción es usar apiResources que crea sólo funciones para los métodos API:\nRoute::apiResource('alumnos',’AlumnosController’);\n\nTambién podemos crear las rutas para varios controladores a la vez con resources en vez de resource:\nRoute::resources(\n[\n'alumnos' =&gt; 'Api\\AlumnosController',\n'profes' =&gt; 'Api\\ProfesoresController',\n],\n['only'=&gt;['index','store','show','update','destroy' ]]\n);\n\nLuego creamos el controlador y el recurso:\nphp artisan make:controller Api/AlumnosController --api\n\nLa opción --resource (o -r) crea automáticamente los puntos de entrada para los métodos indicados. La opción --api es igual pero no crea funciones para los métodos create ni edit.\ny el recurso:\nphp artisan make:resource AlumnoResource\n\nUn recurso es un modelo que se debe transformar a un objeto JSON (lo que necesitamos en una API).\ny editamos el controlador:\n&lt;?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Alumno;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Controllers\\Controller;\nuse App\\Http\\Resources\\AlumnoResource;\n\nclass AlumnosController extends Controller {\npublic function index() {\nreturn AlumnoResource::collection(Alumno::paginate(10));\n// Esto devuelve, además del data información para paginar la salida\n\n// lo anterior equivaldría, sin usar el recurso, a\n$alumnos=Alumno::all()-&gt;toArray();\nreturn response()-&gt;json($alumnos);\n}\n\npublic function show($id) {\nreturn new AlumnoResource(Alumno::find($id));\n}\n\npublic function store(Request $request) {\n\n$alumno = Alumno::create([\n'alumno_id' =&gt; $request-&gt;alumno()-&gt;id,\n'nombre' =&gt; $request-&gt;nombre,\n'apellidos' =&gt; $request-&gt;apellidos,\n...\n]);\n\nreturn new AlumnoResource($alumno);\n}\n}\n\nSaber más\n\nBuilding a Vue SPA with Laravel\nLaravel 5.7 + Vue + Vue Router = SPA. Igual pero usando la librería Vuetify",
		"tags": [ "note"]
},

{
		"title": "0x-quasar",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/0x-quasar/",
		"content": "Quasar\nEs un framwork basado en Vue que permite crear aplicaciones multiplataforma (web/desktop/mobile) con un sólo código fuente. Para usarlo podemos integrarlo desde n CDN, añadirlo como un plugin a Vue-cli o utilizar su propio entorno, Quasar CLI, lo que nos permitirá obtener las máximas prestaciones de este framework. Tenéis una comparativa sobre los 3 métodos en la documentación de Quasar.\nInstalar Quasar cli\nNecesitamos tener NodeJs instalado y haremos:\nnpm install -S @quasar/cli\n\nLa opción -g es para que se instale globalmente y así poder tenerlo disponible para cualquier proyecto.\nCrear un proyecto\nSe crea mendiante\nquasar createnombre-proyecto\n\nDetección de plataforma\nQuasar nos permite saber en qué plataforma se está mostrando mediante $q.plataform:\n&lt;div v-if=&quot;$q.plataform.is.desktop&quot;&gt;\nEsto se muestra en un escritorio\n&lt;/div&gt;\n&lt;div v-if=&quot;$q.plataform.is.mobile&quot;&gt;\nEsto se muestra en un móvil\n&lt;/div&gt;\n\nOtros posibles valores de plataforma son electron, cordova, ... Para usarlo debemos importar esta característica:\nimport { Plataform } from 'quasar'",
		"tags": [ "note"]
},

{
		"title": "0x-testing",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/0x-testing/",
		"content": "Testear nuestros componentes\nLa librería que incluye Vue para testear las aplicaciones el vue-test_utils que proporciona herramientas para montar e interactuar con componentes. Para los tests unitarios usaremos Jest.\nTras instalar la librería con npm (será una dependencia de desarrollo) indicaremos al linter que vamos a usar jest para que no genere advertencias al usar sus comandos para lo que modificaremos el fichero .eslintrc.js y añadiremos al apartado env una línea indicando que vamos a usar jest. Dicho apartado quedará:\nenv: {\nnode: true,\njest: true,\n},\n\nSi usamos librerías como Vue-Material o Vuetify y debemos importar ficheros .css de las mismas en nuestros componentes es posible que falle Jest a la hora de pasar los test y nos dará un error de que no puede procesar el fichero porque no es Javascript. Podemos solucionarlo instalando para desarrollo el paquete identuty-obj-proxy y añadiendo una entrada para moduleNameMapper al fichero de configuración de Jest jest.config.js que quedará:\nmodule.exports = {\npreset: '@vue/cli-plugin-unit-jest',\nmoduleNameMapper: {\n&quot;\\\\.(css|less|scss|sass)$&quot;: &quot;identity-obj-proxy&quot;\n},\n}\n\n(fuente: https://stackoverflow.com/questions/46177148/how-to-exclude-css-module-files-from-jest-test-suites)\nTests unitarios\nA la hora de crear el proyecto no escogeremos preset sino que seleccionaremos manualmente las características a instalar y marcaremos la de tests unitarios con Jest que es la librería que usamos en el bloque de Javascript.\nPara ejecutar los tests ejecutaremos en la terminal\nnpm run test:unit\n\nEl projecto está configurado para ejecutar los ficheros de pruebas cuyo nombre acabe por .spec.js. Por defecto se guardan en la carpeta /tests.\nPrimer test: HelloWorld.vue\nEn primer lugar vamos a analizar el test que hay hecho en @/tests/exemple.spec.js para testear el componente HelloWorld.vue:\nimport { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\nit('renders props.msg when passed', () =&gt; {\nconst msg = 'new message'\nconst wrapper = shallowMount(HelloWorld, {\npropsData: { msg }\n})\nexpect(wrapper.text()).toMatch(msg)\n})\n})\n\nLo primero que hay que hacer es importar el plugin de tests de vue y el componente a testear. Dentro de la prueba se monta el componente (shallowMount) y se le pasan las props que necesite (msg). A esta función se le pasa un componente y devuelve la instancia de Vue creada para él y su nodo del DOM.\nComo segundo parámetro se le puede pasar un objeto con opciones a montar en el componente (por ejemplo un data que sustituirá al del componente) o, como en el ejemplo anterior, los parámetros que se le pasan al componente (en propsData).\nAdemás de shallowMount podemos usar (si lo importamos) el método mount que hace lo mismo pero también renderiza los subcomponentes que tenga el componente.\nPor último se comprueba que el texto renderizado por el template del componente incluye el mensaje pasado. La variable wrapper es el nodo DOM raíz del componente y podemos obtener su textContent (.text()), su innerHTML (.html()), sus atributos (.attributes(), y para acceder a uno, por ejemplo la id haríamos .attributes().id ), sus clases (.classes()), etc.Podemos ver todos sus métodos en la documentación oficial de Vue test utils.\nTambién podríamos haber hecho la siguiente comprobación:\nexpect(wrapper.html()).toMatch('&lt;h1&gt;'+msg+'&lt;/h1&gt;')\n\no bien comprobar directamente el valor de prop:\nexpect(wrapper.props().msg).toBe(msg)\n\nComprobar atributos, clases y estilos en línea\nEl componente que vamos a probar es:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;Testing dom attributes&lt;/h1&gt;\n&lt;a href=&quot;https://google.com&quot; class=&quot;link&quot; style=&quot;color:green&quot;&gt;Google&lt;/a&gt; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {};\n&lt;/script&gt;\n\nY el test es:\nimport App from '../src/App.vue'\nimport { shallowMount } from '@vue/test-utils';\n\ndescribe('Testing dom attributes', () =&gt; {\nit('checks href to google ', () =&gt; {\nconst wrapper = shallowMount(App);\nconst a = wrapper.find('a'); //finds an `a` element\nexpect(a.attributes().href).toBe('https://google.com')\n})\n})\n\nSi lo que queremos comprobar son las clases, estas tienen su propio método:\ndescribe('Testing class', () =&gt; {\nit('checks the class to be link', () =&gt; {\nconst wrapper = shallowMount(App);\nconst a = wrapper.find('a'); //finds an `a` element\nexpect(a.classes()).toContain('link')\n})\n})\n\nY lo mismo ocurre para comprobar un estilo:\ndescribe('Testing style', () =&gt; {\nit('checks the inline style color to be green', () =&gt; {\nconst wrapper = shallowMount(App);\nconst a = wrapper.find('a'); //finds an `a` element\nexpect(a.style.color).toBe('green')\n})\n})\n\nComprobar un método de un componente\nEl componente que vamos a probar es:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{{title}}&lt;/h1&gt; &lt;button @click=&quot;changeTitle&quot;&gt;Change title&lt;/button&gt; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ndata: function() {\nreturn {\ntitle: &quot;Hello&quot; };\n},\nmethods: {\nchangeTitle() {\nthis.title = &quot;Hi&quot;; }\n}\n};\n&lt;/script&gt;\n\nY el test es:\nimport { shallowMount } from '@vue/test-utils';\nimport Post from '../src/components/Welcome.vue'\ndescribe('Testing Component Methods', () =&gt; {\nconst wrapper = shallowMount(Post);\n\nit('correctly updates the title when changeTitle is called', () =&gt; {\nexpect(wrapper.vm.title).toBe('Hello'); //initial title Hello\nwrapper.vm.changeTitle(); // calling component method\nexpect(wrapper.vm.title).toBe('Hi'); // title updates to Hi\n})\n})\n\nComprobar que un método es llamado al producirse un evento\nEl componente que vamos a probar es:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{{count}}&lt;/h1&gt;\n&lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\ndata: function() {\nreturn {\ncount:0\n};\n},\nmethods: {\nincrement() {\nthis.count++;\n}\n}\n};\n&lt;/script&gt;\n\nY el test es:\nimport { shallowMount } from '@vue/test-utils';\nimport Post from '../src/components/Counter.vue'\n\ndescribe('Testing native dom events', () =&gt; {\nconst wrapper = shallowMount(Post);\n\nit('calls increment method when button is clicked', () =&gt; {\nconst increment = jest.fn(); // mock function\n// updating method with mock function\nwrapper.setMethods({ increment });\n//find the button and trigger click event\nwrapper.find('button').trigger('click');\nexpect(increment).toBeCalled();\n})\n\n})\n\nFuente: Testing Dom events in Vue.js using Jest and vue-test-utils. Sai gowtham\nComprobar que el DOM reacciona a cambios en una variable reactiva\nDado que Vue realiza las actualizaciones de DOM de forma asíncrona, las comprobaciones sobre las actualizaciones de DOM resultantes del cambio de estado, deberán realizarse en un callback Vue.nextTick.\nit('button click should increment the count text', async () =&gt; {\nexpect(wrapper.text()).toContain('0')\nconst button = wrapper.find('button')\nbutton.trigger('click')\nawait Vue.nextTick()\nexpect(wrapper.text()).toContain('1')\n})\n\nComprobar peticiones asíncronas a servicios ajenos a Vue\nEn muchos casos hacemos peticiones asíncronas, como peticiones a una API. Podéis obtener información en:\n\nDoc Vue test utils\nJest: Mock Functions\n...\n\nNuestro primer test: TodoItem.vue\nEn primer lugar vamos a testear que la propiedad 'done' tiene el valor que se le pasa y que cambia al llamar a la función 'toogleDone':\nimport { shallowMount } from '@vue/test-utils'\nimport Usuario from '@/components/Usuario.vue'\n\ndescribe('componente Usuario.vue', () =&gt; {\nit('debe cambiar el valor a true', () =&gt; {\n/// Crea una instancia del componente\nconst wrapper = shallowMount(Usuario);\n\n/// Evalúa que el valor por defecto sea &quot;false&quot;\nexpect(wrapper.vm.usuarioActivo).toBe(false);\n\n/// Ejecuta el metodo que cambia el valor de la variable a &quot;true&quot;\nwrapper.vm.activarUsuario();\n\n/// Evalúa que el nuevo valor usuarioActivo sea &quot;true&quot;\nexpect(wrapper.vm.usuarioActivo).toBe(true);\n})\n})\n\nTestear Vuex\nNormalmente nuestros componentes usaran Vuex para:\n\nhacer un commit a una mutation\nhacer un dispatch a una action\nacceder a los datos mediante state o getters\n\nTestear mutations\nEs sencillo porque sólo son llamadas Javascript. Ejemplo:\n// store.js\n...\nmutations: {\naddPost(state, post) {\nstate.posts.push(post);\n},\n}\n...\n\n// store.spec.js\nimport { mutations } from &quot;@/store/index.js&quot;\n\ndescribe(&quot;addPost&quot;, () =&gt; {\nit(&quot;adds a post to the state&quot;, () =&gt; {\nconst post = { id: 1, title: &quot;Primer post&quot; }\nconst state = {\nposts: [],\n}\n\nmutations.addPost(state, post)\n\nexpect(state).toEqual({\nposts: [ { id: 1, title: 'Primer post' } ]\n})\n})\n})\n\nTestear actions\n\nEjemplo\nPodéis encontrar un completo ejemplo de cómo testear una aplicación ToDo en Adictos al trabajo - Testing en componentes de Vue.js.\nPodéis encontrar ejemplos más completos en muchas páginas, como:\n\n[Testing Vue]\nVue Testing Handbook: completo tutorial de cómo testear todo en nuestros componentes Vue (props, computed, Vuex, router, ...)\nTesting Vuex\nTesting Vue.js Applications\n[]\n\nFuentes:\n\nVue test utils\nDocumentación oficial de Vue\nReactGo: Vue tutorials\nPruebas unitarias en Vue.js: Setup y primeros pasos. Carlos Solis\n\nTest e2e\nNo comprueban un componente sino un workflow completo, por ejemplo, que el usuario introduce algo como nombre de nueva tarea, pulsa enviar y se añade la tarea a la lista.\nAl pasar los tests arranca un servidor de tests (selenium) y un navegador donde hace las pruebas y luego los cierra.",
		"tags": [ "note"]
},

{
		"title": "10-vue3_composition_api",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/10-vue3-composition-api/",
		"content": "La Composition API de Vue3\n\nLa Composition API de Vue3\n\nIntroducción\nEjemplo básico\nsetup\n\n&lt;script setup&gt;\n\nReactividad en Vue3\nConfiguraciones básicas\n\nProps\nComponents\nComputed\nhooks\nrouter\nwatchEffect y watch\nPinia\n\nReusabilidad: composables\n\nValores devueltos\nPaso de parámetros\nOrganizar el código con composables\n\nIntroducción\nVue3 incluye una importante novedad, la Composition API, aunque podemos seguir usando la Options API clásica de Vue2 donde cada elemento (data, computed, methods, ...) es una opción del componente.\nLa forma de trabajar hasta Vue 2 es mediante la Options API donde definíamos un componente mediante una serie de opciones:\nexport default {\nname: &quot;ComponentName&quot;,\nprops: { ... },\ndata() { return {...} },\ncomputed: { ... },\nmethods: { ... },\nmounted() { ... },\n...\n}\n\nEsto es ideal para pequeñas aplicaciones porque mantiene el código ordenado según su funcionalidad: variables en data, funciones en methods, .... Pero en grandes aplicaciones donde un componente necesita hacer varias cosas (como mostrar datos en una tabla pero que esté paginada y con posibilidad de filtrar, ...) el código crece y esta forma de organizarlo se vuelve algo confusa.\nVue3 permite seguir trabajando así pero incorpora una nueva forma de trabajar con nuestros componentes, la Composition API. En ella se define un hook llamado setup() donde escribimos el código que inicializa el componente y devuelve un objeto con las variables y métodos que podrá usar el resto del componente (por ejemplo el template).\n&lt;script&gt;\nimport { defineProps } from &quot;vue&quot;;\n\nexport default {\nname: &quot;ComponentName&quot;,\nprops: defineProps({ ... }), // Props\nsetup(props, context) {\n// Init logic, lifecycle hooks, etc...\n\nreturn {\n// Data, methods, computed, etc...\n}\n}\n}\n&lt;/script&gt;\n\nLa composition API es especialmente útil en aplicaciones grandes ya que va a permitir que nuestros componentes sean mucho más reutilizables. Además nos va a permitir organizar el código por funcionalidades y no por opciones. Por ejemplo si un componente muestra una serie de datos y tiene filtrado de datos y paginación de los mismos en el data() definiré variables para los datos, variables para el filtrado y variables para la paginación. En computed puede que también tenga métodos para las 3 cosas y el methods tendré varios métodos para cada una de las 3 funcionalidades. La composition API me va a permitir que todo el código (data, computed, methods, ...) referente a la funcionalidad de mostrar los datos esté junto y lo mismo para las funcionalidades de filtrar y de paginar:\n\nCuándo es recomendable usarla:\n\nsi queremos soporte total de Typescript\nsi nuestro componente es demasiado largo y queremos organizarlo por características (features)\npara mejorar la reutilización de código entre componentes\n\nEjemplo básico\nPor ejemplo, un componente que muestra un contador y un botón para incrementarlo, con la Options API sería:\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n// Properties returned from data() becomes reactive state\n// and will be exposed on `this`.\nprops: ['title'],\ndata() {\nreturn {\ncount: 0\n}\n},\nmethods: {\nincrement() {\nthis.count++\n}\n},\nmounted() {\nconsole.log(`The initial count is ${this.count}.`)\n}\n}\n&lt;/script&gt;\n\nEste ejemplo con la Composition API quedaría:\n&lt;script&gt;\nimport { ref, onMounted } from &quot;vue&quot;;\n\nexport default {\nname: &quot;ComponentName&quot;,\nprops: ['title'],\n\nsetup(props, context) {\nconst count = ref(0)\n\nfunction increment() {\ncount.value++\n}\n\nonMounted(() =&gt; {\nconsole.log(`${props.title}: the initial count is ${count.value}.`)\n})\n\nreturn {\ncount,\nincrement,\n}\n}\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\nFijaos que para hacer reactiva una variable hemos de declararla con ref y su valor lo obtenemos dentro de la propiedad .value, aunque en el &lt;template&gt; no es necesario poner el .value. En el caso de objetos (incluidos arrays) se hacen reactivos con reactive como veremos al hablar de la reactividad.\nLas funciones podemos ponerlas como arrow functions:\nconst increment = () =&gt; {\ncount.value++\n}\n\nsetup\nLo primero que hace un componente que usa esta API es ejecutar su método setup, antes de evaluar ninguna otra característica (data, computed, hooks, ...). Por tanto este método no tiene acceso a this como el resto. Para que pueda acceder a datos que pueda necesitar recibe 2 parámetros:\n\nprops: aquí recibe los parámetros pasados al componente. Todos ellos son reactivos y se pueden observar con un watch\ncontext: es un objeto con las propiedades attrs, slots, parent y emit. Nos permite acceder a lo que antes accedíamos desde this.\n\nEl hook setup() se encarga de:\n\ntareas de inicialización del componente: todo lo que antes se hacía en created() o mounted()\ntareas de definición: aquí se definen las variables (que antes estaban en data), variables calculadas (antes computed), funciones (antes methods) o los watchers.\ndevolver los elementos que se puedan usar en el &lt;template&gt; (variables y funciones)\n\n&lt;script setup&gt;\nAdemás de la sintaxis que hemos visto arriba existe una forma 'reducida' de escribir la parte de &lt;script&gt; que es:\n&lt;script setup&gt;\nimport { ref, defineProps, onMounted } from &quot;vue&quot;;\n\nconst props = defineProps(['title'])\nconst count = ref(0)\n\nconst increment = () =&gt; {\ncount.value++\n}\n\nonMounted(() =&gt; {\nconsole.log(`${props.title}: the initial count is ${count.value}.`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\nEn este caso no es necesario exportar nada (por defecto se exportan las variables y funciones definidas).\nEsta es la sintaxis recomendada cuando usamos SFC por simplicidad y rendimiento tal y como se indica en la documentación de Vue3.\nReactividad en Vue3\nEn la composition API de Vue3 sólo las variables recogidas en props son reactivas. Cualquier otra declarada en el setup que queramos que lo sea debemos declararla con ref si es un tipo primitivo o reactive si es un objeto.\nLa función ref envuelve la variable en un Proxy reactivo. El valor de la variable estará en su propiedad .value, aunque desde el template podemos usarla directamente como hemos visto en el código anterior.\nEn el caso de variables de tipos no primitivos (objetos, arrays, ...) se declaran con reactive pero en este caso no es necesario usar la propiedad .value (es lo mismo que hace el método data() en la options API):\n&lt;script setup&gt;\nimport { reactive, defineProps, onMounted } from &quot;vue&quot;;\n\nconst props = defineProps(['title'])\nconst counter = reactive({ count: 0})\n\nconst increment = () =&gt; {\ncounter.count++\n}\n\nonMounted(() =&gt; {\nconsole.log(`${props.title}: the initial count is ${counter.count}.`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;p&gt;El valor del contador es: { { counter.count }}&lt;p&gt;\n&lt;button @click=&quot;increment&quot;&gt;Incrementar&lt;/button&gt;\n&lt;/template&gt;\n\nSin embargo si cambiamos la referencia del objeto (por ejemplo si lo desestructuramos) pierde su reactividad.\nimport { reactive } from &quot;vue&quot;;\n\nconst counter = reactive({ count: 0})\nlet { count } = counter // count no es reactivo\ncount++ // no afecta a counter.count\n\nPara hacerlo reactivo deberíamos usar el método toRef() o toRefs():\nimport { reactive } from &quot;vue&quot;;\n\nconst counter = reactive({ count: 0})\nlet { count } = toRefs(counter) // count SÍ es reactivo\n\nO bien, si queremos trabajar con las propiedades de un objeto podemos declararlas con ref:\nimport { ref } from &quot;vue&quot;;\n\nconst counter = { count: ref(0) }\nlet { count } = counter // count SÍ es reactivo\n\nTambién hay métodos para ver si una variable es reactiva:\n\nisRef(variable)\nisReactive(variable)\n\nPodéis ver esto con más detalle en:\n\nEscuela VUE.\nDocumentación de Vue\n\nConfiguraciones básicas\nProps\nPara tener acceso a las props hay que hacerlas accesibles con defineProps:\n&lt;script setup&gt;\nimport { defineProps } from &quot;vue&quot;;\n\ndefineProps(['title'])\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nSi necesitamos acceder a ellas desde el código las asignamos a una variable:\n&lt;script setup&gt;\nimport { onMounted, defineProps } from &quot;vue&quot;;\n\nconst props = defineProps(['title'])\n\nonMounted(() =&gt; {\nconsole.log(`El parámetro pasado en 'title' es ${props.title}`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;h1&gt;{ { title }}&lt;/h1&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nComponents\nNo necesitamos registrarlos, basta con importarlos y ya se pueden usar:\n&lt;script setup&gt;\nimport ErrorMessages from &quot;./components/ErrorMessages.vue&quot;;\nimport AppNav from &quot;./components/AppNav.vue&quot;;\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;app-nav&gt;&lt;/app-nav&gt;\n&lt;div class=&quot;container&quot;&gt;\n&lt;error-messages&gt;&lt;/error-messages&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nComputed\nEl uso de computed cambia ya que ahora es una función en lugar de un objeto.\n# Options API\ndata(): {\nreturn {\nproductPrice: 100\n}\n},\ncomputed: {\nofferPrice() {\nreturn this.productPrice * 50%\n},\noriginalPrice() {\nreturn this.productPrice\n},\n}\n\n// Composition API\nimport { ref, computed } from &quot;vue&quot;;\n\nconst productPrice = ref(100)\n\nconst offerPrice = computed(() =&gt; productPrice.value * 50%)\nconst originalPrice = computed(() =&gt; productPrice.value)\n...\n\nNOTA: Todas las variables definidas como computed son automáticamente reactivas.\nhooks\nSe les antepone on (ej, onMounted). Ya no son necesarios ni beforeCreated ni created que son sustituidas por el setup.\nPodéis ver esto con más detalle en la documentación de Vue.\nrouter\nPara acceder al router y a la variable route en composition API tenemos que importarlas de vue-router e instanciarlas, ya que no tenemos acceso a this:\nimport { useRouter, useRoute } from 'vue-router'\n\nconst router = useRouter()\nconst route = useRoute()\n\nwatchEffect y watch\nwatch funciona como en Vue2:\n# Vue 3\nimport { ref, watch } from &quot;vue&quot;;\nsetup(props) {\nconst productPrice = ref(props.price);\nwatch(productPrice, (current, prev) =&gt; {\nconsole.log('productPrice current: ' + current + ', prev: ' + prev)\n})\n...\n\nwatchEffect es una función que se ejecuta inmediatamente y cada vez que cambie alguna de sus dependencias reactivas:\nimport { ref, watchEffect } from &quot;vue&quot;;\nsetup(props) {\nconst productPrice = ref(props.price);\nwatchEffect(() =&gt; {\nconsole.log('productPrice current: ' + productPrice.value)\n})\n...\n\nPodemos obtener más información sobre cuándo usar un u otro método en Escuela VUE.\nPinia\nLos ficheros de store no cambian pero sí la forma de usarlos en el componente. Allí se importa el store y cada variable, getter o action que queramos usar en el componente:\n&lt;script setup&gt;\nimport { useCounterStore } from '../stores/counterStore';\nimport { computed } from 'vue';\n\n// store\nconst counterStore = useCounterStore();\n\n//state &amp; getters\nconst count = computed(() =&gt; counterStore.count); // state\nconst lastOperation = computed(() =&gt; counterStore.lastOperation); // getter\n\n//actions\nconst increment = () =&gt; counterStore.increment();\nconst decrement = () =&gt; counterStore.decrement();\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div&gt;\n&lt;p&gt;Counter: { { count }}&lt;/p&gt;\n&lt;p&gt;Last: { { lastOperation }}&lt;/p&gt;\n&lt;button @click=&quot;increment()&quot;&gt;Add&lt;/button&gt;\n&lt;button @click=&quot;decrement()&quot;&gt;Subtract&lt;/button&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\nReusabilidad: composables\nLa principal razón de ser de la composition API es que permite usar funciones composables, que son funciones donde podemos poner código con estado (es decir, que usa variables reactivas). El nombre de las funciones composables por convenio comienza por use y se usan para encapsular código que podrá usar cualquier componente.\nPor ejemplo podemos hacer una composable que nos proporcione la posición actual del ratón:\n// mouse.js\n\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\nconst x = ref(0)\nconst y = ref(0)\n\nfunction update(event) {\nx.value = event.pageX\ny.value = event.pageY\n}\n\nonMounted(() =&gt; window.addEventListener('mousemove', update))\nonUnmounted(() =&gt; window.removeEventListener('mousemove', update))\n\nreturn { x, y }\n}\n\nLa función useMouse proporciona a quien la importe 2 variables reactivas (x e y) donde se encuentra la posición actual del ratón, actualizada por la función update.\nEn cualquier componente donde necesitemos conocer la posición del ratón sólo necesitamos importar esta función:\n&lt;script setup&gt;\nimport { useMouse } from './useMouse';\nconst { x, y } = useMouse();\n&lt;/script&gt;\n\n&lt;template&gt;\nX: { { x }} Y: { { y }}\n&lt;/template&gt;\n\nSiempre que pongamos un escuchador en una composable (como hemos hecho en el onMounted) debemos quitarlo cuando ya no se utilice (en el unMounted).\nValores devueltos\nComo se ve la composable devuelve un objeto formado por variables reactivas (refs) en lugar de un objeto reactivo. Se hace así por convención, lo que permite desestructurar las variables en el componente que las vaya a usar sin perder su reactividad (al desestructurar un reactive deja de serlo).\nSi lo hubiéramos hecho con un reactive NO funcionaría:\n// mouse.js MAL\n\nimport { reactive, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\nconst x = 0\nconst y = 0\n\n...\nreturn reactive({ x, y })\n}\n\nporque entonces al hacer en el componente\nconst { x, y } = useMouse();\n\nlas variables x e y dejarían de ser reactivas.\nPodría hacerse no desestructurando el objeto, pero se prefiere así por claridad, para tener claras qué variables nos proporciona la función:\n&lt;script setup&gt;\nimport { useMouse } from './useMouse';\nconst position = useMouse();\n&lt;/script&gt;\n\n&lt;template&gt;\nX: { { position.x }} Y: { { position.y }}\n&lt;/template&gt;\n\nEsto sí funcionaría pero se recomienda la otra forma: una composable devuelve un array de variables reactivas que se importan (desestructurando el objeto) en el componente que las vaya a usar.\nPaso de parámetros\nPodemos pasar parámetros a las funciones composables en el momento de usarlas y dichos parámetros los recibirá directamente la composable como cualquier otra función.\nPor ejemplo podemos crear useFetch a la que le pasamos una url y hace un fetch para hacer la llamada a esa url y devolver los datos o el error devueltos por el servidor.\nEl componente que quiera usarla haría:\n&lt;script setup&gt;\nimport { useFetch } from './useFetch';\nconst { data, error } = useFetch('https://jsonplaceholder.typicode.com/users/3')\n&lt;/script&gt;\n\n&lt;template&gt;\n&lt;div v-if=&quot;error&quot;&gt;{{ error }}&lt;/div&gt;\n&lt;div v-else&gt;\n// Aquí mostramos los datos recibidos en la variable 'data'\n&lt;/div&gt;\n&lt;/template&gt;\n\nY nuestra función haría:\n// useFetch.js\nimport { ref } from 'vue'\n\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\n\nfetch(url)\n.then((res) =&gt; res.json())\n.then((json) =&gt; (data.value = json))\n.catch((err) =&gt; (error.value = err))\n\nreturn { data, error }\n}\n\nSi el parámetro recibido es reactivo podemos hacer que la función se ejecute cada vez que cambie observándolo con watch o watchEffect:\n// fetch.js\nimport { ref, watch } from 'vue'\n\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\n\nfunction doFetch() {\nfetch(url.value)\n.then((res) =&gt; res.json())\n.then((json) =&gt; (data.value = json))\n.catch((err) =&gt; (error.value = err))\n}\n\nwatch(url, () =&gt; doFetch())\n\nreturn { data, error }\n}\n\nSi nuestras composables pueden recibir parámetros reactivos siempre es una buena práctica que puedan recibir también parámetros primitivos (en el caso anterior daría un error al hacer fetch(url.value) porque url es un string). La forma más correcta de hacerlo sería:\n// fetch.js\nimport { ref, isRef, unref, watchEffect } from 'vue'\n\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\n\nfunction doFetch() {\n// reset state before fetching..\ndata.value = null\nerror.value = null\n// unref() unwraps potential refs\nfetch(unref(url))\n.then((res) =&gt; res.json())\n.then((json) =&gt; (data.value = json))\n.catch((err) =&gt; (error.value = err))\n}\n\nif (isRef(url)) {\n// setup reactive re-fetch if input URL is a ref\nwatchEffect(doFetch)\n} else {\n// otherwise, just fetch once\n// and avoid the overhead of a watcher\ndoFetch()\n}\n\nreturn { data, error }\n}\n\nEn este caso se ha hecho una función que va a funcionar tanto si se le pasa un url estática como si se le pasa una reactiva. Lo que ha cambiado es:\n\nisRef: nos dice si el parámetro pasado es o no reactivo. Si no lo es llama directamente a la función. Si lo es hace\nwatchEffect: cada vez que cambie el valor de url llamará a la función\nunref: devuelve el .value de una variable si es reactiva o la variable si no lo es. Si url es reactiva devuelve url.value y si no devuelve url.\n\nOrganizar el código con composables\nAdemás de para que el código sea fácilmente reutilizable, las composables se usan para sacar código de un componente cuando este es demasiado grande o se encarga de varias funcionalidades. Una vez creadas las funciones se usan en el componente:\n&lt;script setup&gt;\nimport { useFeatureA } from './featureA.js'\nimport { useFeatureB } from './featureB.js'\nimport { useFeatureC } from './featureC.js'\n\nconst { foo, bar } = useFeatureA()\nconst { baz } = useFeatureB(foo)\nconst { qux } = useFeatureC(baz)\n&lt;/script&gt;\n\nSi tenemos que usar una función composable en un componente escrito en modo Options API simplemente añadimos el hook setup y allí la llamamos:\nimport { useMouse } from './mouse.js'\nimport { useFetch } from './fetch.js'\n\nexport default {\nsetup() {\nconst { x, y } = useMouse()\nconst { data, error } = useFetch('...')\nreturn { x, y, data, error }\n},\nmounted() {\n// setup() exposed properties can be accessed on `this`\nconsole.log(this.x)\n}\n// ...other options\n}\n\nAlgunos enlaces útiles:\n\nHow to Create Reusable Components with the Vue 3 Composition API\nWhy I Love Vue 3's Composition API\n\nPodemos encontrar infinidad de composables que podemos usar en nuestro código en la página VueUse.",
		"tags": [ "note"]
},

{
		"title": "21-typescript",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/21-typescript/",
		"content": "Typescript\n\nTypescript\n\nIntroducción\nTypescript en Vue\nTipos de datos\nDefinir variables\n\nCrear custom types\ninterfaces\nCreación automática de interfaces\n\nTipos genéricos\nClases\nDecoradores\n\nIntroducción\nEs un lenguaje basado el Javascript al que le ha añadido definiciones de tipos estáticas y alguna característica más.\nEl hecho de que Javascript permite cambiar dinámicamente el tipo de datos de una variable da lugar a veces a resultados inesperados y dificulta la localización de errores derivados de un uso no adecuado de esto.\nTypescript obliga a definir el tipo de datos de una variable e impide cambiarlo (como sucede en la mayoría de lenguajes de programación) lo que nos obliga a escribir un código más consistente. Esto es especialmente importante en proyectos grandes o en los que colaboran muchos programadores.\nTypescript en Vue\nEl soporte de Typescript en Vue 3 es total ya que este framework ha sido totalmente reescrito en este lenguaje. Cuando creamos un nuevo proyecto una de las opciones que podemos marcar es Typescript con lo que ya tendremos todo preparado para utilizar este lenguaje en nuestro proyecto. Veremos que al crearse el proyecto el fichero main.js ahora se llama main.ts. Además se crea un nuevo fichero llamado tsconfig.json con configuraciones por defecto para Typescript.\nSi queremos añadir Typescript a un proyecto ya existente lo añadiremos como plugin:\nvue add typescript\n\nAl hacerlo nos pregunta, entre otras cosas, si queremos convertir todos nuestros ficheros .js a .ts.\nPara usar TS en un componente tenemos que indicarlo en la etiqueta &lt;script&gt; e importar defineComponent para transformar el objeto que exportamos. Con Javascript definimos un SFC con:\n&lt;script&gt;\nexport default {\nname: ...,\n...\n}\n&lt;/script&gt;\n\nEsto con Typescript se haría:\n&lt;script lang=&quot;ts&quot;&gt;\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\nname: ...,\n...\n})\n&lt;/script&gt;\n\nNo es necesario que todos los componentes estén en Typescript(o Javascript) sino que cada uno puede ser diferente.\nTipos de datos\nLos tipos de datos que podemos encontrar en Javascript son:\n\nString\nNumber\nBoolean\nArray\nTuple (como un array con un número fijo de elementos)\nEnum (permite asignar nombres amigables a conjuntos de números)\nFunction\nObject\nAny (puede ser de cualquier tipo)\nVoid (se aplica a funciones que no devuelven nada)\n\nDefinir variables\nEl tipo de datos de una variable lo indicamos al definirla con el caràcter : (dos puntos):\nlet title: string = 'Aprende Typescript'\nlet numPages: number = 100\nlet isFree: boolean = true\n\nEn los arrays debemos indicar el tipo de datos de los elementos del array:\nlet lenguajes: string[] = ['Typescript', 'Javascript', 'PHP']\nlet notes: number[] = [3, 4.5, 7, 4, 9]\n\nRespecto a los objetos hay que definir el tipo de cada propiedad y a continuación asignarles su valor\nlet Student: {\nname: string;\nage: number;\nmodules: string[];\n} = {\nname: 'Peter Parker',\nage: 20,\nmodules: ['DWEC', 'DWES', 'DAW']\n}\n\nY en las funciones debemos indicar el tipo de datos de sus parámetros y de la propia función:\nlet getFullName = (firstName: string, lastName: string): string =&gt; {\nreturn firstName + ' ' + lastName\n}\n\nCrear custom types\nPodemos definir nuestros propios tipos de datos. Por ejemplo crearemos un tipo para los valores permitidos para la clase de un botón:\ntype buttonType = 'primary' | 'secondary' | 'success' | 'danger'\n\nlet myBtnStyle: buttonType = 'danger'\n\nSi le asigno un valor que no es uno de los definidos en su tipo se producirá un error.\ninterfaces\nUna interface es la definición de los tipos de datos de un objeto, para evitar definirlo como hemos visto antes que es demasiado verbose. Por tanto es como definir nu nuevo tipo de datos.\ntype Modules = 'DWEC' | 'DWES' |'DIW' |'DAW' | 'EIE' | 'Inglés'\n\ninterface Student {\nname: string;\nage: number;\nmodules: Modules[]; // o también modules: Array&lt;Modules&gt;\n}\n\nPodemos centralizar todas las interfaces que se usan en más de un componente en un fichero al que podemos llamar src/types.ts:\ntype Modules = 'DWEC' | 'DWES' |'DIW' |'DAW' | 'EIE' | 'Inglés'\n\nexport interface Student {\nname: string;\nage: number;\nmodules: Modules[];\n}\n\nA veces definimos un objeto vacío pero que cuando tenga datos será de cierto tipo. Para que Typescript no piense que se trata de un objeto sin propiedades lo definiremos con as:\nlet futureStudent = {} as Student\n\nEsto nos permitirá hacer cosas como futureStudent.name = 'Peter Parker' sin que se produzcan errores de tipo. A esto se llama type assertions.\nSi se quiere aplicar un tipo propio a una variable pasada por props debemos importar el helper PropType:\nimport { defineComponent, PropType } from 'vue'\n\nexport default defineComponent({\nprops: {\nStudent: {\ntype: Object as PropType&lt;Student&gt;,\nrequired: true\n}\n},\n})\n\nPara centralizar la definición de tipos se suelen incluir todos los tipos e interfaces en un fichero que llamaremos src/types.ts. Deberemos exportar los tipos y/o interfaces.\nVisual Studio Code incluye la extensión VueDX que nos informa al escribir código si un objeto tiene o no la propiedad que estamos escribiendo. Es muy recomendable instalarla cuando trabajamos con Typescript.\nCreación automática de interfaces\nTenemos utilidades que nos permiten generar automáticamente las interfaces de nuestra aplicación a partir de la documentación de la API o incluso a partir del fichero JSON de los datos.\nUn ejemplo es Quicktype donde pegamos nuestros datos en formato JSON y genera automáticamente las interfaces y types necesarios en typescript.\nTipos genéricos\nA veces nos gustaría que una función pudiera trabajar con distintos tipos de datos. Por ejemplo, una función para añadir un item a una lista podría ser:\nfunction addItemToNumberList(item: number, list: number[]): number[] {\nlist.push(item)\n\nreturn list\n}\n\nconst numberList = addItemToNumberList(123, [])\n\nSi queremos algo similar para listas de cadenas habría que crear otra función pero de tipo string. En lugar de eso podemos decir que el tipo de los parámetros y de la función sea genérico:\nfunction addItemToList&lt;T&gt;(item: T, list: T[]): T[] {\nlist.push(item)\n\nreturn list\n}\n\nconst numberList = addItemList&lt;number&gt;(123, [])\nconst stringList = addItemList&lt;string&gt;('manzanas', [])\n\nClases\nSon muy similares a las de otros lenguajes. Ejemplo:\nclass Student {\npublic name : string; // atributo accesible desde fuera de la clase\nprotected age: number; // accesible desde clases que hereden de Student\nprivate nia : string; // accesible sólo desde la clase Student\n\nconstructor(name:string ,age:number, nia:string){\nthis.name = name;\nthis.age = age;\nthis.nia = nia;\n}\ngetName(){\nreturn this.name;\n}\n\nsetName(name:string){\nthis.name = name;\n}\ngetAge(){\nreturn this.age;\n}\n\nsetAge(age:number){\nthis.age = age;\n}\n\ngetNia(nia:string){\nthis.nia = nia;\n}\n}\n\nLos getters y setters también pueden definirse como:\n...\nget name(){\nreturn this.name;\n}\n\nset name(name:string){\nthis.name = name;\n}\n...}\n\nSería conveniente definir una interfaz para el objeto Student:\ninterface IStudent {\nname: string;\nage: number;\nnia: string\n\ngreeting: () =&gt; void\n}\n\nclass Student implements IStudent {\nconstructor(name:string ,age:number, nia:string){\nthis.name = name;\nthis.age = age;\nthis.nia = nia;\n}\n...\nfunction greetings () {\nconsole.log('Hi ' + this.name)\n}\n}\n\nLa interfaz obliga a las clases que la implementen a definir, al menos, todas las propiedades y todos los métodos de la interfaz.\nDecoradores\nOtra utilidad importante de Typescript son los decoradores que permiten &quot;decorar&quot; un constructor o método, es decir, personalizarlo para que haga algo ligeramente diferente a lo que hace el genérico.",
		"tags": [ "note"]
},

{
		"title": "90-tdd",
		"date":"Mon Sep 15 2025 16:36:13 GMT+0000 (Coordinated Universal Time)",
		"url":"/01-apuntes/vue-teoria-batoi/90-tdd/",
		"content": "Desarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y después refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el est (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).\nUsar TDD en Javascript\nLo más sencillo es usar alguna librería como Mocha. Se trata de un gramework que se ejecuta sobre Node.js y permite crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado. Luego creamos una carpeta para nuestro proyecto y dentro ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
}
]