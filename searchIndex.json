[
{
		"title": "Asignatura de entornos a clientes",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Desarollo Web en entorno cliente/",
		"content": "type note(function(){return this.inputEl.value}) template\naction Sin título\ntemplater true\n\n^button-km7s\nPagina de github de los apuntes",
		"tags": [ "note"]
},

{
		"title": "Desarollo Web en entorno servidor",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Desarollo Web en entorno servidor/",
		"content": "Pagina de github de los apuntes",
		"tags": [ "note"]
},

{
		"title": "Despliegue de aplicaciones WEB",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Despliegue de aplicaciones Web/Despliegue de aplicaciones WEB/",
		"content": "Hola despliege\nSSH",
		"tags": [ "note","despliege"]
},

{
		"title": "Diseño de interfaces WEB",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Diseño de interfaces WEB/",
		"content": "Hola Diseño\nRepositorio de Diseño",
		"tags": [ "note"]
},

{
		"title": "Indice",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "Asignaturas\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-ingles-ingles\">Ingles</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-diseno-de-interfaces-web-diseno-de-interfaces-web\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-despliegue-de-aplicaciones-web-despliegue-de-aplicaciones-web\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>\nHorario:\n\nHora\nLunes\nMartes\nMiercoles\nJueves\nViernes\n\n14:55 - 15:50\nEmpresa\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-diseno-de-interfaces-web-diseno-de-interfaces-web\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\nEmpresa\n\n15:50 - 16:45\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-despliegue-de-aplicaciones-web-despliegue-de-aplicaciones-web\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-diseno-de-interfaces-web-diseno-de-interfaces-web\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\nEmpresa\n\n16:45 - 17:40\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-despliegue-de-aplicaciones-web-despliegue-de-aplicaciones-web\">Despliegue de aplicaciones WEB</a>\nTutoria\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-despliegue-de-aplicaciones-web-despliegue-de-aplicaciones-web\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-ingles-ingles\">Ingles</a>\n\n17:40 - 18:00\nDescanso\nDescanso\nDescanso\nDescanso\nDescanso\n\n18:00 - 18:55\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-despliegue-de-aplicaciones-web-despliegue-de-aplicaciones-web\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-ingles-ingles\">Ingles</a>\n\n18:55 - 19:50\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-diseno-de-interfaces-web-diseno-de-interfaces-web\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-diseno-de-interfaces-web-diseno-de-interfaces-web\">Diseño de interfaces WEB</a>\n\n19:50 - 20:45\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-servidor-desarollo-web-en-entorno-servidor\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-diseno-de-interfaces-web-diseno-de-interfaces-web\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-diseno-de-interfaces-web-diseno-de-interfaces-web\">Diseño de interfaces WEB</a>\n\n20:45 - 21:40\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notes/01-apuntes-desarollo-web-en-entorno-cliente-desarollo-web-en-entorno-cliente\">Desarollo Web en entorno cliente</a>",
		"tags": [ "note","gardenEntry"]
},

{
		"title": "Ingles",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Ingles/",
		"content": "Profesor:\nagendaweb\n21 de noviempre exposicion a las 16:30",
		"tags": [ "note"]
},

{
		"title": "01-sintaxis",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/01-sintaxis/",
		"content": "= en una asignación pero debemos hacerlo siempre igual. Existen muchas guías de estilo y muy buenas: Airbnb, Google, Idiomatic, etc. Para obligarnos a seguir las reglas podemos usar alguna herramienta linter.\n\nTambién es conveniente para mejorar la legibilidad de nuestro código separar las líneas de más de 80 caracteres.\nUsar `",
		"tags": [ "note"]
},

{
		"title": "02.1-objetos",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/02.1-objetos/",
		"content": "Objetos en Javascript\n\nObjetos en Javascript\n\nIntroducción\nPropiedades de un objeto\nMétodos de un objeto\nPropagación de propiedades\nDesestructuración de objetos\nComparación de objetos\nCopia de objetos\nBibliografía\n\nIntroducción\nEn Javascript podemos definir cualquier variable como un objeto declarándola con new (NO se recomienda) o creando un literal object (usando notación JSON). Ejemplo con new (no recomendado):\nconst alumno = new Object()\nalumno.nombre = 'Carlos' // se crea la propiedad 'nombre' y se le asigna un valor\nalumno['apellidos'] = 'Pérez Ortiz' // se crea la propiedad 'apellidos'\nalumno.edad = 19\n\nCreando un literal object (es la forma recomendada) el ejemplo anterior sería:\nconst alumno = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\n\nPropiedades de un objeto\nPodemos acceder a las propiedades con . (punto) o [ ]:\nconsole.log(alumno.nombre) // imprime 'Carlos'\nconsole.log(alumno['nombre']) // imprime 'Carlos'\nlet prop = 'nombre'\nconsole.log(alumno[prop]) // imprime 'Carlos'\n\nSi intentamos acceder a propiedades que no existen no se produce un error, se devuelve undefined:\nconsole.log(alumno.ciclo) // muestra undefined\n\nSin embargo se genera un error si intentamos acceder a propiedades de algo que no es un objeto:\nconsole.log(alumno.ciclo) // muestra undefined\nconsole.log(alumno.ciclo.descrip) // se genera un ERROR\n\nPara evitar ese error antes había que comprobar que existan las propiedades previas:\nconsole.log(alumno.ciclo &amp;&amp; alumno.ciclo.descrip)\n// si alumno.ciclo es un objeto muestra el valor de\n// alumno.ciclo.descrip y si no muestra undefined\n\nCon ES2020 (ES11) se ha incluido el operador de encadenamiento opcional ?. para evitar tener que comprobar esto nosotros:\nconsole.log(alumno.ciclo?.descrip)\n// si alumno.ciclo es un objeto muestra el valor de\n// alumno.ciclo.descrip y si no muestra undefined\n\nPodremos recorrer las propiedades de un objecto con for..in:\nfor (let prop in alumno) {\nconsole.log(prop + ': ' + alumno[prop])\n}\n\nSi el valor de una propiedad es el valor de una variable que se llama como la propiedad no es necesario ponerlo:\nlet nombre = 'Carlos'\n\nconst alumno = {\nnombre, // es equivalente a nombre: nombre\napellidos: 'Pérez Ortiz',\n...\n\nMétodos de un objeto\nUna propiedad de un objeto puede ser una función:\nalumno.getInfo = function() {\nreturn 'El alumno ' + this.nombre + ' ' + this.apellidos + ' tiene ' + this.edad + ' años'\n}\n\nNOTA: No podemos ponerlo con sintaxis arrow function porque no se podría acceder a las propiedades del objeto con this.\nY para llamarlo se hace como con cualquier otra propiedad:\nconsole.log(alumno.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nEJERCICIO: Crea un objeto llamado tvSamsung con las propiedades nombre (&quot;TV Samsung 42&quot;), categoria (&quot;Televisores&quot;), unidades (4), precio (345.95) y con un método llamado importe que devuelve el valor total de las unidades (nº de unidades * precio)\n\nPropagación de propiedades\nEl operador de propagación, ... (3 puntos), permite extraer las propiedades de un objeto. Ejemplo:\nconst personaCarlos = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\nconst alumnoCarlos = {\n...personaCarlos,\nciclo: 'DAW',\ncurso: 2,\n};\n\nEl objeto alumnoCarlos tendrá las propiedades de personaCarlos y las que se le añadan. Si se repiten las propiedades se sobreescriben:\nconst alumnoCarlos = {\n...personaCarlos,\nciclo: 'DAW',\ncurso: 2,\nedad: 20,\n};\n\nDesestructuración de objetos\nSimilar al anterior, permite extraer directamente a variables sólo las propiedades que necesitemos de un objeto. Ejemplo:\nconst personaCarlos = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\n\nfunction muestraNombre({nombre, apellidos}) {\nconsole.log('El nombre es ' + nombre + ' ' + apellidos)\n}\n\nmuestraNombre(personaCarlos)\n\nAunque a la función se le pasa un objeto esta toma como parámetros sólo 2 de sus propiedades y las asigna a las variables nombre y apellidos.\nTambién podemos asignar valores por defecto:\nfunction miProducto({nombre, apellidos = 'Desconocidos'}) {\n...\n\nComparación de objetos\nEn Javascript los objetos se comparan por referencia, no por valor. Por lo que dos objetos con los mismos valores no son iguales:\nconst a = {id:2, name: 'object 2'}\nconst b = {id:2, name: 'object 2'}\nconsole.log(a === b) // muestra false\n\nCopia de objetos\nCuando copiamos una variable de tipo boolean, string o number o se pasa como parámetro a una función se hace una copia de la misma y si se modifica la variable original no es alterada. Ej.:\nlet a = 54\nlet b = a // a = 54 b = 54\nb = 86 // a = 54 b = 86\n\nSin embargo al copiar objetos (y arrays, que son un tipo de objeto) la nueva variable apunta a la misma posición de memoria que la antigua por lo que los datos de ambas son los mismos:\nconst a = {id:2, name: 'object 2'}\nconst b = a\nb.name = 'object 3' // a = {id:2, name: 'object 3'} b = {id:2, name: 'object 3'}\n\nconst a = [54, 23, 12]\nconst b = a // a = [54, 23, 12] b = [54, 23, 12]\nb[0] = 3 // a = [3, 23, 12] b = [3, 23, 12]\n\nconst fecha1 = new Date('2018-09-23')\nconst fecha2 = fecha1 // fecha1 = '2018-09-23' fecha2 = '2018-09-23'\nfecha2.setFullYear(1999) // fecha1 = '1999-09-23' fecha2 = '1999-09-23'\n\nPara obtener una copia independiente de un array o un objeto podemos usar el operador de propagación ... o el método Object.assign. Ejemplo:\nconst a = {id:2, name: 'object 2'}\nconst b = {...a} // ahora ambos objetos contienen lo mismo pero son diferentes\nb.name = 'object 3' // a = {id:2, name: 'object 2'} b = {id:2, name: 'object 3'}\n\nCon Object.assign haremos:\nconst a = {id:2, name: 'object 2'}\nconst b = Object.assign({}, a) // ahora ambos objetos contienen lo mismo pero son diferentes\n\nSin embargo si el objeto tiene como propiedades otros objetos estos se continúan pasando por referencia. Es ese caso lo más sencillo sería hacer:\nconst a = {id: 2, name: 'object 2', address: {street: 'Rue del Percebe', num: 13} }\nconst copiaDeA = JSON.parse(JSON.stringify(a)) // ahora ambos objetos contienen lo mismo pero son diferentes\n\no bien usar la función structuredClone:\nconst a = {id: 2, name: 'object 2', address: {street: 'Rue del Percebe', num: 13} }\nconst b = structuredClone(a) // ahora ambos objetos contienen lo mismo pero son diferentes\n\nEJERCICIO: Dado el objeto a del último ejemplo copialo a un nuevo objeto b con ... y prueba a cambiar las pripiedades id y street de b. ¿Qué pasa con sus valores en a?.\n\nBibliografía\n\nCurso 'Programación con JavaScript'. CEFIRE Xest. Arturo Bernal Mayordomo",
		"tags": [ "note"]
},

{
		"title": "02.2-arrays",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/02.2-arrays/",
		"content": "Arrays\n\nArrays\n\nIntroducción\n\nArrays de objetos\n\nOperaciones con Arrays\n\nlength\nAñadir elementos\nEliminar elementos\nsplice\nslice\nArrays y Strings\nsort\nOtros métodos comunes\n\nFunctional Programming\n\nfilter\nfind\nfindIndex\nevery / some\nmap\nreduce\nforEach\nincludes\nArray.from\n\nRest y Spread\nDesestructuración de arrays\nCopia de arrays\nMap\nSet\n\nIntroducción\nSon un tipo de objeto y no tienen tamaño fijo sino que podemos añadirle elementos en cualquier momento.\nSe recomienda crearlos usando notación JSON:\nconst a = []\nconst b = [2,4,6]\n\naunque también podemos crearlos como instancias del objeto Array (NO recomendado):\nconst a = new Array() // a = []\nconst b = new Array(2,4,6) // b = [2, 4, 6]\n\nSus elementos pueden ser de cualquier tipo, incluso podemos tener elementos de tipos distintos en un mismo array. Si no está definido un elemento su valor será undefined. Ej.:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconsole.log(a[0]) // imprime 'Lunes'\nconsole.log(a[4]) // imprime 6\na[7] = 'Juan' // ahora a = ['Lunes', 'Martes', 2, 4, 6, , , 'Juan']\nconsole.log(a[7]) // imprime 'Juan'\nconsole.log(a[6]) // imprime undefined\nconsole.log(a[10]) // imprime undefined\n\nAcceder a un elemento de un array que no existe no provoca un error (devuelve undefined) pero sí lo provoca acceder a un elemento de algo que no es un array. Con ES2020 (ES11) se ha incluido el operador ?. para evitar tener que comprobar nosotros que sea un array:\nconsole.log(alumnos?.[0])\n// si alumnos es un array muestra el valor de su primer\n// elemento y si no muestra undefined pero no lanza un error\n\nArrays de objetos\nEs habitual almacenar datos en arrays en forma de objetos, por ejemplo:\nconst alumnos = [\n{\nid: 1,\nname: 'Marc Peris',\ncourse: '2nDAW',\nage: 21\n},\n{\nid: 2,\nname: 'Júlia Tortosa',\ncourse: '2nDAW',\nage: 23\n},\n]\n\nOperaciones con Arrays\nVamos a ver los principales métodos y propiedades de los arrays.\nlength\nEsta propiedad devuelve la longitud de un array:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconsole.log(a.length) // imprime 5\n\nPodemos reducir el tamaño de un array cambiando esta propiedad, aunque es una forma poco clara de hacerlo:\na.length = 3 // ahora a = ['Lunes', 'Martes', 2]\n\nAñadir elementos\nPodemos añadir elementos al final de un array con push o al principio con unshift:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\na.push('Juan') // ahora a = ['Lunes', 'Martes', 2, 4, 6, 'Juan']\na.unshift(7) // ahora a = [7, 'Lunes', 'Martes', 2, 4, 6, 'Juan']\n\nEliminar elementos\nPodemos borrar el elemento del final de un array con pop o el del principio con shift. Ambos métodos devuelven el elemento que hemos borrado:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst ultimo = a.pop() // ahora a = ['Lunes', 'Martes', 2, 4] y ultimo = 6\nconst primero = a.shift() // ahora a = ['Martes', 2, 4] y primero = 'Lunes'\n\nsplice\nPermite eliminar elementos de cualquier posición del array y/o insertar otros en su lugar. Devuelve un array con los elementos eliminados. Sintaxis:\nArray.splice(posicion, num. de elementos a eliminar, 1º elemento a insertar, 2º elemento a insertar, 3º...)\n\nEjemplo:\nlet a = ['Lunes', 'Martes', 2, 4, 6]\nlet borrado = a.splice(1, 3) // ahora a = ['Lunes', 6] y borrado = ['Martes', 2, 4]\na = ['Lunes', 'Martes', 2, 4, 6]\nborrado = a.splice(1, 0, 45, 56) // ahora a = ['Lunes', 45, 56, 'Martes', 2, 4, 6] y borrado = []\na = ['Lunes', 'Martes', 2, 4, 6]\nborrado = a.splice(1, 3, 45, 56) // ahora a = ['Lunes', 45, 56, 6] y borrado = ['Martes', 2, 4]\n\nEJERCICIO: Guarda en un array la lista de la compra con Peras, Manzanas, Kiwis, Plátanos y Mandarinas. Haz los siguiente con splice:\n\nElimina las manzanas (debe quedar Peras, Kiwis, Plátanos y Mandarinas)\nAñade detrás de los Plátanos Naranjas y Sandía (debe quedar Peras, Kiwis, Plátanos, Naranjas, Sandía y Mandarinas)\nQuita los Kiwis y pon en su lugar Cerezas y Nísperos (debe quedar Peras, Cerezas, Nísperos, Plátanos, Naranjas, Sandía y Mandarinas)\n\nslice\nDevuelve un subarray con los elementos indicados pero sin modificar el array original (sería como hacer un substr pero de un array en vez de una cadena). Sintaxis:\nArray.slice(posicion, num. de elementos a devolver)\n\nEjemplo:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst subArray = a.slice(1, 3) // ahora a = ['Lunes', 'Martes', 2, 4, 6] y subArray = ['Martes', 2, 4]\n\nEs muy útil para hacer una copia de un array:\nconst a = [2, 4, 6]\nconst copiaDeA = a.slice() // ahora ambos arrays contienen lo mismo pero son diferentes arrays\n\nArrays y Strings\nCada objeto (y los arrays son un tipo de objeto) tienen definido el método .toString() que lo convierte en una cadena. Este método es llamado automáticamente cuando, por ejemplo, queremos mostrar un array por la consola. En realidad console.log(a) ejecuta console.log(a.toString()). En el caso de los arrays esta función devuelve una cadena con los elementos del array dentro de corchetes y separados por coma.\nAdemás podemos convertir los elementos de un array a una cadena con .join() especificando el carácter separador de los elementos. Ej.:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst cadena = a.join('-') // cadena = 'Lunes-Martes-2-4-6'\n\nEste método es el contrario del m .split() que convierte una cadena en un array. Ej.:\nconst notas = '5-3.9-6-9.75-7.5-3'\nconst arrayNotas = notas.split('-') // arrayNotas = [5, 3.9, 6, 9.75, 7.5, 3]\nconst cadena = 'Que tal estás'\nconst arrayPalabras = cadena.split(' ') // arrayPalabras = ['Que`, 'tal', 'estás']\nconst arrayLetras = cadena.split('') // arrayLetras = ['Q','u','e`,' ','t',a',l',' ','e',s',t',á',s']\n\nsort\nOrdena alfabéticamente los elementos del array. Cambia el array además de devolverlo. Ejemplo:\nlet a = ['hola','adios','Bien','Mal',2,5,13,45]\nlet b = a.sort() // b = [13, 2, 45, 5, &quot;Bien&quot;, &quot;Mal&quot;, &quot;adios&quot;, &quot;hola&quot;], pero a también queda ordenado\n\nTambién podemos pasarle una función que le indique cómo ordenar, que devolverá un valor negativo si el primer elemento es mayor, positivo si es mayor el segundo o 0 si son iguales. Ejemplo: ordenar un array de cadenas sin tener en cuenta si son mayúsculas o minúsculas:\nlet a = ['hola','adios','Bien','Mal']\nlet b = a.sort(function(elem1, elem2) {\nif (elem1.toLocaleLowerCase &gt; elem2.toLocaleLowerCase)\nreturn -1\nif (elem1.toLocaleLowerCase &lt; elem2.toLocaleLowerCase)\nreturn 1\nreturn 0\n}) // b = [&quot;adios&quot;, &quot;Bien&quot;, &quot;hola&quot;, &quot;Mal&quot;]\n\nComo más se utiliza esta función es para ordenar arrays de objetos. Por ejemplo si tenemos un objeto alumno con los campos name y age, para ordenar un array de objetos alumno por su edad haremos:\nlet alumnosOrdenado = alumnos.sort(function(alumno1, alumno2) {\nreturn alumno1.age - alumno2.age\n})\n\nUsando arrow functions quedaría más sencillo:\nlet alumnosOrdenado = alumnos.sort((alumno1, alumno2) =&gt; alumno1.age - alumno2.age)\n\nSi que queremos ordenar por un campo de texto en vez de numérico debemos usar la función toLocaleCompare:\nlet alumnosOrdenado = alumnos.sort((alumno1, alumno2) =&gt; alumno1.name.localeCompare(alumno2.name))\n\nEJERCICIO: Haz una función que ordene las notas de un array pasado como parámetro. Si le pasamos [4,8,3,10,5] debe devolver [3,4,5,8,10]. Pruébalo en la consola\n\nOtros métodos comunes\nOtros métodos que se usan a menudo con arrays son:\n\n.concat(): concatena arrays\n\nlet a = [2, 4, 6]\nlet b = ['a', 'b', 'c']\nlet c = a.concat(b) // c = [2, 4, 6, 'a', 'b', 'c']\n\n.reverse(): invierte el orden de los elementos del array\n\nlet a = [2, 4, 6]\nlet b = a.reverse() // b = [6, 4, 2]\n\n.indexOf(): devuelve la primera posición del elemento pasado como parámetro o -1 si no se encuentra en el array\n.lastIndexOf(): devuelve la última posición del elemento pasado como parámetro o -1 si no se encuentra en el array\n\nFunctional Programming\nSe trata de un paradigma de programación (una forma de programar) donde se intenta que el código se centre más en qué debe hacer una función que en cómo debe hacerlo. El ejemplo más claro es que intenta evitar los bucles for y while sobre arrays o listas de elementos. Normalmente cuando hacemos un bucle es para recorrer la lista y realizar alguna acción con cada uno de sus elementos. Lo que hace functional programing es que a la función que debe hacer eso se le pasa como parámetro la función que debe aplicarse a cada elemento de la lista.\nDesde la versión 5.1 javascript incorpora métodos de functional programing en el lenguaje, especialmente para trabajar con arrays:\nfilter\nDevuelve un nuevo array con los elementos que cumplen determinada condición del array al que se aplica. Su parámetro es una función, habitualmente anónima, que va interactuando con los elementos del array. Esta función recibe como primer parámetro el elemento actual del array (sobre el que debe actuar). Opcionalmente puede tener como segundo parámetro su índice y como tercer parámetro el array completo. La función debe devolver true para los elementos que se incluirán en el array a devolver como resultado y false para el resto.\nEjemplo: dado un array con notas devolver un array con las notas de los aprobados. Esto usando programación imperativa (la que se centra en cómo se deben hacer las cosas) sería algo como:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = []\nfor (let i = 0 i++ i &lt; arrayNotas.length) {\nlet nota = arrayNotas[i]\nif (nota &gt; = 5) {\naprobados.push(nota)\n}\n} // aprobados = [5.2, 6, 9.75, 7.5]\n\nUsando functional programming (la que se centra en qué resultado queremos obtener) sería:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(function(nota) {\nif (nota &gt; = 5) {\nreturn true\n} else {\nreturn false\n}\n}) // aprobados = [5.2, 6, 9.75, 7.5]\n\nPodemos refactorizar esta función para que sea más compacta:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(function(nota) {\nreturn nota &gt; = 5 // nota &gt; = 5 se evalúa a 'true' si es cierto o 'false' si no lo es\n})\n\nY usando funciones lambda la sintaxis queda mucho más simple:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(nota =&gt; nota &gt; = 5)\n\nLas 7 líneas del código usando programación imperativa quedan reducidas a sólo una.\n\nEJERCICIO: Dado un array con los días de la semana obtén todos los días que empiezan por 'M'\n\nfind\nComo filter pero NO devuelve un array sino el primer elemento que cumpla la condición (o undefined si no la cumple nadie). Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst primerAprobado = arrayNotas.find(nota =&gt; nota &gt; = 5) // primerAprobado = 5.2\n\nEste método tiene más sentido con objetos. Por ejemplo, si queremos encontrar la persona con DNI '21345678Z' dentro de un array llamado personas cuyos elementos son objetos con un campo 'dni' haremos:\nconst personaBuscada = personas.find(persona =&gt; persona.dni = = = '21345678Z') // devolverá el objeto completo\n\nEJERCICIO: Dado un array con los días de la semana obtén el primer día que empieza por 'M'\n\nfindIndex\nComo find pero en vez de devolver el elemento devuelve su posición (o -1 si nadie cumple la condición). En el ejemplo anterior el valor devuelto sería 0 (ya que el primer elemento cumple la condición). Al igual que el anterior tiene más sentido con arrays de objetos.\n\nEJERCICIO: Dado un array con los días de la semana obtén la posición en el array del primer día que empieza por 'M'\n\nevery / some\nLa primera devuelve true si TODOS los elementos del array cumplen la condición y false en caso contrario. La segunda devuelve true si ALGÚN elemento del array cumple la condición. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst todosAprobados = arrayNotas.every(nota =&gt; nota &gt; = 5) // false\nconst algunAprobado = arrayNotas.some(nota =&gt; nota &gt; = 5) // true\n\nEJERCICIO: Dado un array con los días de la semana indica si algún día empieza por 'S'. Dado un array con los días de la semana indica si todos los días acaban por 's'\n\nmap\nPermite modificar cada elemento de un array y devuelve un nuevo array con los elementos del original modificados. Ejemplo: queremos subir un 10% cada nota:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayNotasSubidas = arrayNotas.map(nota =&gt; nota + nota * 10%)\n\nEJERCICIO: Dado un array con los días de la semana devuelve otro array con los días en mayúsculas\n\nreduce\nDevuelve un valor calculado a partir de los elementos del array. En este caso la función recibe como primer parámetro el valor calculado hasta ahora y el método tiene como 1º parámetro la función y como 2º parámetro al valor calculado inicial (si no se indica será el primer elemento del array).\nEjemplo: queremos obtener la suma de las notas:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst sumaNotas = arrayNotas.reduce((total,nota) =&gt; total + = nota, 0) // total = 35.35\n// podríamos haber omitido el valor inicial 0 para total\nconst sumaNotas = arrayNotas.reduce((total,nota) =&gt; total + = nota) // total = 35.35\n\nEjemplo: queremos obtener la nota más alta:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst maxNota = arrayNotas.reduce((max,nota) =&gt; nota &gt; max ? nota : max) // max = 9.75\n\nEn el siguiente ejemplo gráfico tenemos un &quot;array&quot; de verduras al que le aplicamos una función map para que las corte y al resultado le aplicamos un reduce para que obtenga un valor (el sandwich) con todas ellas:\n\nEJERCICIO: Dado el array de notas anterior devuelve la nota media\n\nforEach\nEs el método más general de los que hemos visto. No devuelve nada sino que permite realizar algo con cada elemento del array.\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\narrayNotas.forEach((nota, indice) =&gt; {\nconsole.log('El elemento de la posición ' + indice + ' es: ' + nota)\n})\n\nincludes\nDevuelve true si el array incluye el elemento pasado como parámetro. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\narrayNotas.includes(7.5) // true\n\nEJERCICIO: Dado un array con los días de la semana indica si algún día es el 'Martes'\n\nArray.from\nDevuelve un array a partir de otro al que se puede aplicar una función de transformación (es similar a map). Ejemplo: queremos subir un 10% cada nota:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayNotasSubidas = Array.from(arrayNotas, nota =&gt; nota + nota * 10%)\n\nPuede usarse para hacer una copia de un array, igual que slice:\nconst arrayA = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayB = Array.from(arrayA)\n\nTambién se utiliza mucho para convertir colecciones en arrays y así poder usar los métodos de arrays que hemos visto. Por ejemplo si queremos mostrar por consola cada párrafo de la página que comience por la palabra 'If' en primer lugar obtenemos todos los párrafos con:\nconst parrafos = document.getElementsByTagName('p')\n\nEsto nos devuelve una colección con todos los párrafos de la página (lo veremos más adelante al ver DOM). Podríamos hacer un for para recorrer la colección y mirar los que empiecen por lo indicado pero no podemos aplicarle los métodos vistos aquí porque son sólo para arrays así que hacemos:\nconst arrayParrafos = Array.from(parrafos)\n// y ya podemos usar los métodos que queramos:\narrayParrafos.filter(parrafo =&gt; parrafo.textContent.startsWith('If'))\n.forEach(parrafo =&gt; alert(parrafo.textContent))\n\nIMPORTANTE: desde este momento se han acabado los bucles for en nuestro código para trabajar con arrays. Usaremos siempre estas funciones!!!\n\nRest y Spread\nPermiten extraer a parámetros los elementos de un array o string (spread) o convertir en un array un grupo de parámetros (rest). El operador de ambos es ... (3 puntos).\nPara usar rest como parámetro de una función debe ser siempre el último parámetro.\nEjemplo: queremos hacer una función que calcule la media de las notas que se le pasen como parámetro y que no sabemos cuántas són. Para llamar a la función haremos:\nconsole.log(notaMedia(3.6, 6.8))\nconsole.log(notaMedia(5.2, 3.9, 6, 9.75, 7.5, 3))\n\nLa función convertirá los parámetros recibidos en un array usando rest:\nfunction notaMedia(...notas) {\nlet total = notas.reduce((total,nota) =&gt; total + = nota)\nreturn total/notas.length\n}\n\nSi lo que queremos es convertir un array en un grupo de elementos haremos spread. Por ejemplo el objeto Math proporciona métodos para trabajar con números como .max que devuelve el máximo de los números pasados como parámetro. Para saber la nota máxima en vez de .reduce como hicimos en el ejemplo anterior podemos hacer:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\n\nlet maxNota = Math.max(...arrayNotas) // maxNota = 9.75\n// si hacemos Math.max(arrayNotas) devuelve NaN porque arrayNotas es un array y no un número\n\nDesestructuración de arrays\nIgual que vimos con las propiedades de los objetos podemos extraer los elementos del array directamente a variables y viceversa. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst [primera, segunda, tercera] = arrayNotas // primera = 5.2, segunda = 3.9, tercera = 6\nconst [primera, , , cuarta] = arrayNotas // primera = 5.2, cuarta = 9.75\nconst [primera, ...resto] = arrayNotas // primera = 5.2, resto = [3.9, 6, 9.75, 3]\n\nTambién se pueden asignar valores por defecto:\nconst preferencias = ['Javascript', 'NodeJS']\nconst [lenguaje, backend = 'Laravel', frontend = 'VueJS'] = preferencias // lenguaje = 'Javascript', backend = 'NodeJS', frontend = 'VueJS'\n\nCopia de arrays\nComo vimos al hablar de objetos (y un array es un tipo particular de objeto) por defecto al asignarlos o pasarlos como parámetro a una función se pasan por referencia, NO se copian por lo que los datos de ambas son los mismos:\nconst a = [54, 23, 12]\nconst b = a // a = [54, 23, 12] b = [54, 23, 12]\nb[0] = 3 // a = [3, 23, 12] b = [3, 23, 12]\n\nSi queremos obtener una copia de un array que sea independiente del original podemos usar ...o Object.assign como vimos con los objetos, pero también podemos obtener una copia con slice o con Array.from:\nconst a = [2, 4, 6]\nconst copiaDeA = [...a]\nconst copiaDeA = a.slice()\nconst otraCopiaDeA = Array.fom(a)\n\nEn todos los casos los arrays contienen lo mismo pero son diferentes y al modificar uno no afectará al resto.\n\nEJERCICIO: Dado el array arr1 con los días de la semana haz un array arr2 que sea igual al arr1. Elimina de arr2 el último día y comprueba quá ha pasado con arr1. Repita la operación con un array llamado arr3 pero que crearás haciendo una copia de arr1.\n\nMap\nEs una colección de parejas de [clave,valor]. Un objeto en Javascript es un tipo particular de Map en que las claves sólo pueden ser texto o números. Se puede acceder a una propiedad con . o [propiedad]. Ejemplo:\nconst persona = {\nnombre: 'John',\napellido: 'Doe',\nedad: 39\n}\nconsole.log(persona.nombre) // John\nconsole.log(persona['nombre']) // John\n\nUn Map permite que la clave sea cualquier cosa (array, objeto, ...). No vamos a ver en profundidad estos objetos pero podéis saber más en MDN o cualquier otra página.\nSet\nEs como un Map pero que no almacena los valores sino sólo la clave. Podemos verlo como una colección que no permite duplicados. Tiene la propiedad size que devuelve su tamaño y los métodos .add (añade un elemento), .delete (lo elimina) o .has (indica si el elemento pasado se encuentra o no en la colección) y también podemos recorrerlo con .forEach.\nUna forma sencilla de eliminar los duplicados de un array es crear con él un Set:\nconst ganadores = ['Márquez', 'Rossi', 'Márquez', 'Lorenzo', 'Rossi', 'Márquez', 'Márquez']\nconst ganadoresNoDuplicados = new Set(ganadores) // {'Márquez, 'Rossi', 'Lorenzo'}\n// o si lo queremos en un array:\nconst ganadoresNoDuplicados = Array.from(new Set(ganadores)) // ['Márquez, 'Rossi', 'Lorenzo']",
		"tags": [ "note"]
},

{
		"title": "03-oop",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/03-oop/",
		"content": "Programación orientada a Objetos en Javascript\n\nProgramación orientada a Objetos en Javascript\n\nIntroducción\nHerencia\nMétodos y propiedades estáticas\nPropiedades y métodos privados y protegidos\nMétodo toString()\nMétodo valueOf()\nOrganizar el código\nEl contexto de this\nMixins\nProgramación orientada a objetos en JS5\nBibliografía\n\nIntroducción\nDesde ES2015 la POO en Javascript es similar a como se hace en otros lenguajes, con clases, herencia, ...:\nclass Alumno {\nconstructor(nombre, apellidos, edad) {\nthis.nombre = nombre\nthis.apellidos = apellidos\nthis.edad = edad\n}\ngetInfo() {\nreturn 'El alumno ' + this.nombre + ' ' + this.apellidos + ' tiene ' + this.edad + ' años'\n}\n}\n\nlet alumno1 = new Alumno('Carlos', 'Pérez Ortiz', 19)\nconsole.log(alumno1.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nNOTA: en las clases no es necesario poner 'use strict' porque por defecto todas las clases ya lo tienen.\n\nEJERCICIO: Crea una clase Productos con las propiedades name, category, units y price y los métodos total que devuelve el importe del producto y getInfo que devolverá: 'Name (category): units uds x price € = total €'. Crea 3 productos diferentes.\n\nHerencia\nUna clase puede heredar de otra utilizando la palabra reservada extends y heredará todas sus propiedades y métodos. Podemos sobrescribirlos en la clase hija (seguimos pudiendo llamar a los métodos de la clase padre utilizando la palabra reservada super -es lo que haremos si creamos un constructor en la clase hija-).\nclass AlumnInf extends Alumno{\nconstructor(nombre, apellidos, edad, ciclo) {\nsuper(nombre, apellidos, edad)\nthis.ciclo = ciclo\n}\ngetInfo() {\nreturn super.getInfo() + ' y estudia el Grado ' + (this.getGradoMedio ? 'Medio' : 'Superior') + ' de ' + this.ciclo\n}\ngetGradoMedio() {\nif (this.ciclo.toUpperCase === 'SMX')\nreturn true\nreturn false\n}\n}\n\nlet cpo = new AlumnInf('Carlos', 'Pérez Ortiz', 19, 'DAW')\nconsole.log(cpo.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años y estudia el Grado Superior de DAW'\n\nEJERCICIO: crea una clase Televisores que hereda de Productos y que tiene una nueva propiedad llamada tamaño. El método getInfo mostrará el tamaño junto al nombre\n\nMétodos y propiedades estáticas\nDesde ES2015 podemos declarar métodos estáticos. Estos métodos se llaman directamente utilizando el nombre de la clase y no tienen acceso al objeto this (ya que no hay objeto instanciado).\nclass User {\n...\nstatic getRoles() {\nreturn [&quot;user&quot;, &quot;guest&quot;, &quot;admin&quot;]\n}\n}\n\nconsole.log(User.getRoles()) // [&quot;user&quot;, &quot;guest&quot;, &quot;admin&quot;]\nlet user = new User(&quot;john&quot;)\nconsole.log(user.getRoles()) // Uncaught TypeError: user.getRoles is not a function\n\nSuelen usarse para crear funciones de la aplicación.\nRecientemente se han introducido también propiedades estáticas, que funcionan directamente desde la clase no desde un objeto, igual que los métodos estáticos. Al ser una adición reciente pueden no funcionar en algunos navegadores.\nPropiedades y métodos privados y protegidos\nA la hora de encapsular el código de las clases es importante el uso de este tipo de elementos pero Javascript sólo los incluye desde ES2019 donde introdujo la sintaxis # para declaralos:\nclass Position {\n#x = 0;\n#y = 0;\n\nconstructor(x, y) {\nthis.#x = x\nthis.#y = y\n}\ngetPosition() {\nreturn { x: this.#x, y: this.#y };\n}\nincreaseX() {\nthis.#x++;\n}\nincreaseY() {\nthis.#y++;\n}\n}\n\nconst myPosition = new Position(20, 10);\nconsole.log(Position.getPosition()); // { x: 20, y: 10 }\nconsole.log(Position.x); // undefined\nconsole.log(Position.y); // undefined\n\nAnteriormente existía una convención de que cualquier propiedad o método que comience por el carácter _ se trata de una propiedad o método protegido y no debería accederse al mismo desde el exterior (aunque en realidad el lenguaje permite hacerlo).\nEstas propiedades y métodos protegidos se heredan como cualquier otro.\nMétodo toString()\nAl convertir un objeto a string (por ejemplo al concatenarlo con un String) se llama al método .toString() del mismo, que por defecto devuelve la cadena [object Object]. Podemos sobrecargar este método para que devuelva lo que queramos:\nclass Alumno {\n...\ntoString() {\nreturn this.apellidos + ', ' + this.nombre\n}\n}\n\nlet carPerOrt = new Alumno('Carlos', 'Pérez Ortiz', 19);\nconsole.log('Alumno:' + carPerOrt) // imprime 'Alumno: Pérez Ortíz, Carlos'\n// en vez de 'Alumno: [object Object]'\n\nEste método también es el que se usará si queremos ordenar una array de objetos (recordad que .sort() ordena alfabéticamente para lo que llama al método .toString() del objeto a ordenar). Por ejemplo, tenemos el array de alumnos misAlumnos que queremos ordenar alfabéticamente. Si la clase Alumno no tiene un método toString habría que hacer como vimos en el tema de Arrays:\nmisAlumnos.sort((alum1, alum2) =&gt; (alum1.apellidos+alum1.nombre).localeCompare(alum2.apellidos+alum2.nombre));\n\nPero con el método toString que hemos definido antes podemos hacer directamente:\nmisAlumnos.sort()\n\nEJERCICIO: modifica las clases Productos y Televisores para que el método que muestra los datos del producto se llame de la manera más adecuada\n\nEJERCICIO: Crea 5 productos y guárdalos en un array. Crea las siguientes funciones (todas reciben ese array como parámetro):\n\nprodsSortByName: devuelve un array con los productos ordenados alfabéticamente\nprodsSortByPrice: devuelve un array con los productos ordenados por importe\nprodsTotalPrice: devuelve el importe total del los productos del array, con 2 decimales\nprodsWithLowUnits: además del array recibe como segundo parámetro un nº y devuelve un array con todos los productos de los que quedan menos de los unidades indicadas\nprodsList: devuelve una cadena que dice 'Listado de productos:' y en cada línea un guión y la información de un producto del array\n\nMétodo valueOf()\nAl comparar objetos (con &gt;, &lt;, ...) se usa el valor devuelto por el método .valueOf() para realizar la comparación:\nclass Alumno {\n...\nvalueOf() {\nreturn this.edad\n}\n}\n\nlet cpo = new Alumno('Carlos', 'Pérez Ortiz', 19)\nlet aat = new Alumno('Ana', 'Abad Tudela', 23)\nconsole.log(cpo &lt; aat) // imprime true ya que 19&lt;23\n\nSi este método no existiera será .toString() el que se usaría.\nOrganizar el código\nLo más conveniente es guardar cada clase en su propio fichero, que llamaremos como la clase con la extensión .class.js. Por ejemplo el fichero de la clase Users seria users.class.js.\nEn dicho fichero exportamos la clase (con export o mejor export default porque sólo hay una) y donde queramos usarla la importamos (import { Users } from 'users.class' o import Users from 'users.class', según cómo la hayamos exportado).\nEl contexto de this\nEl valor de la variable this depende del contexto e que se ejecuta el código. Al crear una instancia de una calse con new this hace referencia a la instancia creada. Pero dentro de una función se crea un nuevo contexto y la variable this pasa a hacer referencia a dicho contexto. Si en el ejemplo anterior hiciéramos algo como esto:\nclass Alumno {\n...\ngetInfo() {\nfunction nomAlum() {\nreturn this.nombre + ' ' + this.apellidos // Aquí this no es la instancia del objeto Alumno\n}\n\nreturn 'El alumno ' + nomAlum() + ' tiene ' + this.edad + ' años'\n}\n}\n\nEste código fallaría porque dentro de la función nomAlum la variable this ya no hace referencia a a instancia del objeto Alumno sino al contexto de la función. Este ejemplo no tiene mucho sentido pero a veces nos pasará en manejadores de eventos.\nSi debemos llamar a una función dentro de un método (o de un manejador de eventos) tenemos varias formas de pasarle el valor de this:\n\nUsando una arrow function que no crea un nuevo contexto por lo que this conserva su valor\n\ngetInfo() {\nconst nomAlum = () =&gt; this.nombre + ' ' + this.apellidos\n\nreturn 'El alumno ' + nomAlum() + ' tiene ' + this.edad + ' años'\n}\n\nPasándole this como parámetro a la función\n\ngetInfo() {\nfunction nomAlum(alumno) {\nreturn alumno.nombre + ' ' + alumno.apellidos\n}\n\nreturn 'El alumno ' + nomAlum(this) +' tiene ' + this.edad + ' años'\n}\n\nGuardando el valor en otra variable (como that)\n\ngetInfo() {\nfunction nomAlum() {\nreturn that.nombre + ' ' + that.apellidos // Aquí this no es el objeto Alumno\n}\n\nlet that = this;\nreturn 'El alumno ' + nomAlum() +' tiene ' + this.edad + ' años'\n}\n\nHaciendo un bind de this (lo veremos de nuevo al hablar de eventos)\n\nclass Alumno {\n...\ngetInfo() {\nfunction nomAlum() {\nreturn this.nombre + ' ' + this.apellidos // Aquí this no es el objeto Alumno\n}\n\nreturn 'El alumno ' + nomAlum.bind(this) + ' tiene ' + this.edad + ' años'\n}\n}\n\nAl llamar a la función nomAlumn le enlazamos (.bind) el valor que queremos que tenga this dentro de ella, en nuestro caso el this de donde hacemos la llamada.\nMixins\nWikipedia define un mixin como una clase que contiene métodos que pueden ser utilizados por otras clases sin necesidad de heredar de ella.\nEn Javascript se trata de un objeto que contiene métodos que podemos aplicar a una clase para datarla de ciertos comportamientos. Por ejemplo:\n// mixin\nlet saludaMixin = {\nsaluda() {\nalert(`Hola, soy ${this.nombre}`)\n}\n}\n\nclass Alumno {\nconstructor(nombre, apellidos, edad) {\n...\n}\n...\n}\n\n// asignamos el mixin a la clase\nObject.assign(Alumno.prototype, saludaMixin);\n\n// Ahora el Alumno puede decir hola\nconst alumno = new User('Carlos', 'Pérez', 25)\nalumno.saluda(); // Hola, soy Carlos\n\nProgramación orientada a objetos en JS5\n\nNOTA: este apartado está sólo para que comprendamos este código si lo vemos en algún programa pero nosotros programaremos como hemos visto antes.\n\nEn Javascript un objeto se crea a partir de otro (al que se llama prototipo). Así se crea una cadena de prototipos, el primero de los cuales es el objeto null.\nLas versiones de Javascript anteriores a ES2015 no soportan clases ni herencia. Si queremos emular en ellas el comportamiento de las clases lo que se hace es:\n\npara crear el constructor se crea una función con el nombre del objeto\npara crear los métodos se aconseja hacerlo en el prototipo del objeto para que no se cree una copia del mismo por cada instancia que creemos:\n\nfunction Alumno(nombre, apellidos, edad) {\nthis.nombre = nombre\nthis.apellidos = apellidos\nthis.edad = edad\n}\nAlumno.prototype.getInfo = function() {\nreturn `El alumno ${this.nombre} ${this.apellidos} tiene ${this.edad} años`\n}\n\nlet cpo = new Alumno('Carlos', 'Pérez Ortiz', 19)\nconsole.log(cpo.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nCada objeto tiene un prototipo del que hereda sus propiedades y métodos (es el equivalente a su clase, pero en realidad es un objeto que está instanciado). Si añadimos una propiedad o método al prototipo se añade a todos los objetos creados a partir de él lo que ahorra mucha memoria.\nBibliografía\n\nCurso 'Programación con JavaScript'. CEFIRE Xest. Arturo Bernal Mayordomo",
		"tags": ["x", "y", "note"]
},

{
		"title": "03.1-vite",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/03.1-vite/",
		"content": "Vite\n\nVite\n\nIntroducción\nCrear un nuevo proyecto\nDesarrollar nuestro proyecto\n\nTrabajar con distintos ficheros de código\n\nNamed export\nDefault export\n\nImágenes\nPaso a producción\nTestear el proyecto\n\nIntroducción\nCuando crece el tamaño de un proyecto y tenemos más ficheros de código (cómo al trabajar con clases) es necesario organizarlos de forma que sea fácil encontrarlos y que no haya problemas de dependencias.\nSin embargo tener muchos ficheros hace que tengamos que importarlos todos, y en el orden adecuado, en nuestro index.html (mediante etiquetas &lt;script src=&quot;...&quot;&gt;) lo que empieza a ser engorroso y reduce el rendimiento al tener el navegador que hacer muchas peticiones HTTP.\nAdemás muchas veces incluimos en el código características del lenguaje que aún no están soportadas por todos los navegadores y cuantos más código usemos más se reduce el número de nevegadores que soportan nuestro código.\nPara evitar este problema se utilizan las herramientas de construcción de proyectos o module bundlers que unen todo el código de los distintos ficheros javascript en un único fichero que es el que se importa en el index.html y hacen los mismo con los ficheros CSS.\nAdemás proporcionan otras ventajas:\n\ntranspilan el código, de forma que podemos usar sentencias javascript que aún no soportan muchos navegadores ya que se convertirán a sentencias que hacen lo mismo pero con código legacy\nminimizan y optimizan el código para que ocupe menos y su carga sea más rápida, reduciendo el nombre de variables y funciones, eliminando espacios en blanco y comentarios, ...\ndicha minimización ofusca el código lo que dificulta que el usuario pueda ver en la consola lo que hace el programa y manipularlo\n\nNosotros usaremos el bundler Vite que, junto con webpack, son los más usados en entorno frontend. Junto a npm tendremos una forma fácil y práctica de empaquetar el código.\nAdemás Vite incorpora un servidor de desarrollo para hacer más cómoda la creación y prueba de nuestros proyectos.\nPara poder usar Vite debemos instalarlo. Como lo usaremos en muchos proyectos lo podemos instalarlo global con\nnpm install -g vite\n\nCrear un nuevo proyecto\nVite necesita Node.js versión 16 o superior aunque lo mejor es tenerlo actualizado para poder utilitzar todas sus plantillas. Para crear un nuevo proyecto haremos:\nnpm create vite@latest\n\n(si no tenemos instalado el paquete create-vite nos preguntará si lo instala)\nAl crear el proyecto nos pregunta qué framework vamos a utilizar (le diremos que Vanilla, es decir, Javascript sin framework) y si como lenguaje usaremos Javascript o Typescript.\nEsto crea el scaffolding de nuestro proyecto que consiste en una carpeta con el mismo nombre que el proyecto y una serie de ficheros en su interior:\nNos preguntará el nombre del proyecto, la plantilla (Vanilla para Javascript sin framework) y el lenguaje que queremos usar (Javascript/Typescript) y se crea una carpeta con el nombre de nuestro proyecto que contiene:\n\nindex.html: html con un div con id app que es donde se cargará la app y una etiqueta script que carga un módulo llamado main.js\nmain.js: es el punto de entrada a la aplicación .Importa los ficheros CSS, imágenes y ficheros JS con funciones o clases y establece el contenido de la página principal\ncounter.js: módulo JS que exporta una función como ejemplo que es usada en el main.js\nstyle.css: fichero donde poner nuestros estilos, con CSS de ejemplo\npublic/: carpeta donde dejar elementos estáticos que no pasarán por vite (como imágenes, ficheros CSS, ...)\nnode_modules: librerías de las dependencias (si usamos alguna)\npackage.json: fichero de configuración del proyecto. Además del nombre y la versión incluye apartados importantes:\n\ndevDependences: dependencias que se usan en desarrollo pero que no se incorporarán al código final\ndependences: dependencias que sí se incluirán en el código final (librerías que estemos usando)\nscripts: para ejecutar el servidor de desarrollo (npm run dev), generar el código final de producción (npm run build) y previsualizarlo en modo producción (npm run preview). Podemos añadir más para tests, etc\n\nSi nuestra aplicación no va a ser muy pequeña como la del ejemplo sino que tendrá diferentes ficheros Javascript, acceso a datos, interfaz de usuario, etc deberíamos organizar en código en carpetas para mejorar su legibilidad. Lo adecuando es dejar en el raíz de nuestro proyecto los ficheros index.html y main.js y crear una carpeta src donde poner el resto de código. En función del tamaño de la aplicación podríamos crear dentro subcarpetas (os propongo un nombre para ellas aunque podéis llamarlas como queráis) para:\n\nmodel: el modelo de datos, es decir, las clases\npages o views: las páginas que tendrá nuestra SPA a las que se navega desde el router (aunque en realidad sólo hay una)\napi: acceso a la API que usemos. Sólo deben conectarse al servidor y transmitir los datos recibidos al resto de la aplicación\ncomponents: web components que usemos para cosntruir las páginas\nservices: métodos síncronos que proporcionan funcionalidad\nsi nuestra aplicación es grande con muchos casos de uso convendría crear una carpeta usecases donde guardarlos. Cada uno debería tener un único método llamado run o execute\ntest: carpeta donde guardar los ficheros de test\n...\n\nNOTA: todos los ficheros javascript de un proyecto con Vite son módulos y en ellos, igual que en las clases, no es necesario poner 'use strict' porque por defecto los módulos ya funcionan así.\nDesarrollar nuestro proyecto\nPara empezar a trabajar ejecutamos desde la terminal el script\nnpm run dev\n\nEsto hace que Vite lance un servidor web en el puerto 5173 donde podemos ver la ejecución de nuestro proyecto.\nTrabajar con distintos ficheros de código\nUna de las razones de usar un bundler es que podemos repartir el código entre varios ficheros de forma que quede más organizado.\nPara que un fichero pueda tener acceso a código de otro fichero hay que hacer 2 cosas:\n\nEl fichero al que queremos acceder debe exportar el código que desea que sea accesible desde otros ficheros\nEl fichero que quiere acceder a ese código debe importarlo a una variable\n\nEsto es lo que hacíamos en el ejercicio de la frase para poder pasar los tests y lo que haremos con los ficheros donde declaremos clases.\nES6 nos proporciona 2 formas de exportar/importar código:\n\nexportar con nombre (named export): export\nexportar por defecto (default export): export default\n\nNamed export\nDe esta manera puedo exportar tantos elementos (funciones, variables, clases, ...) de un fichero como quiera. Por ejemplo, si es un fichero con una única función a exportar:\n// Fichero cuadrado.js\nexport function cuadrado (value) {\nreturn value * value\n}\n\nEn el caso de querer exportar muchas funciones lo más sencillo es exportarlas juntas en un objeto como en el fichero functions.js:\nfunction letras () {\n...\n}\n\nfunction palabras () {\n...\n}\n\nfunction maysc () {\n...\n}\n...\nexport {\n\tletras,\n\tpalabras,\n\tmaysc\n}\n\nSi es un fichero que define una clase la exportamos tal cual:\nexport class Product {\nconstructor() {\n\n}\n...\n}\n\nPara importarlo lo hacemos poniendo lo que queremos importar entre { }. Si se trata de una única función:\nimport { cuadrado } from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + cuadrado(2))\n\nTambién podríamos usar un nombre diferente para lo que importamos:\nimport { cuadrado as cuad} from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + cuad(2))\n\nSi es un fichero con muchas funciones exportadas a un objeto podemos importar sólo las que queramos o todas:\nimport { letras, maysc } from './functions.js'\n\nconsole.log('Las letras de &quot;Hola&quot; son ' + letras(&quot;Hola&quot;))\n\nTambién podemos importarlas todas a un objeto sin indicar sus nombres, con *:\nimport * as MyFunctions from './functions.js'\n\nconsole.log('Las letras de &quot;Hola&quot; son ' + MyFunctions.letras(&quot;Hola&quot;))\n\nPara importar una clase:\nimport { Product } from './product.class'\n\nconst myProd = new Product()\n\nDefault export\nDe esta manera sólo puedo exportar un elemento por fichero, y a la hora de importarlo le doy el nombre que quiera. Por ejemplo, si es un fichero con una única función a exportar:\n// Fichero cuadrado.js\nexport default function cuadrado (value) {\nreturn value * value\n}\n\nY donde vaya a usarlo:\nimport myCuadrado from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + myCuadrado(2))\n\nEn el caso de una clase:\nexport default class Product {\nconstructor() {\n\n}\n...\n}\n\nY para importarla:\nimport Product from './product.class'\n\nconst myProd = new Product()\n\nEn resumen, si exporto con export importo con { } y si exporto con export default importo sin { } pero sólo puedo exportar 1 elemento.\nImágenes\nSi se trata de imágenes estáticas lo más sencillo es ponerlas dentro de la carpeta public y hacer referencia a ellas usando ruta absoluta. Todo lo que está en public se referencia como si estuviera en la raíz de nuestra aplicación:\n&lt;img src=&quot;/vite.png&quot; height=&quot;100px&quot; alt=&quot;Logo de Vite&quot;&gt;\n\nTambién podemos poner las imágenes en la carpeta assets, pero antes de usarlas deberemos imnportarlas. Ejemplo:\nimport viteLogo from './assets/vite.png'\n...\nconst logoHtml = `&lt;img src=&quot;${viteLogo}&quot; height=&quot;100px&quot; alt=&quot;Vite logo&quot;&gt;`\ndocument.body.prepend(logoHtml)\n\nCon Vite también podemos importarlas usando import.meta.url, lo que es útil si no conocemos previamente el nombre del fichero con la imagen (más información en la documentación de Vite):\nfunction getImage(fileName, height, alt) {\nimgUrl = new URL(fileName, import.meta.url).href\nconst imgHtml = `&lt;img src=&quot;${viteLogo}&quot; height=&quot;${height}&quot; alt=&quot;${alt}&quot;&gt;`\n\nreturn logoHtml\n}\n\nPaso a producción\nCuando lo hayamos acabado y queramos subirlo a producción ejecutaremos\nnpm run build\n\nque crea la carpeta /dist con los ficheros que debemos subir al servidor web de producción:\n\nindex.html\ncualquier fichero que tengamos en /public\ncarpeta assets con\n\nfichero JS con todo el código que necesita el proyecto\nfichero CSS con todos los estilos del proyecto\notros ficheros importados en el JS como imágenes, ...\n\nTestear el proyecto\nSi queremos testear el proyecto deberemos usar una herramienta de testing y crear los tests adecuados. Lo más sencillo es usar Vitest que es muy similar a Jest pero preparado para interacutar fácilmente con Vite.\nLo primero es importarlo como dependencia de producción (no lo usaremos en producción)\nnpm install --save-dev vitest\n\no abreviado\nnpm i -D vitest\n\nDebemos añadir un nuevo script en el package.json que le indique a vite que queremos usarlo para testear:\n&quot;scripts&quot;: {\n\t\t...\n&quot;test&quot;: &quot;vitest&quot;\n},\n\nCrearemos los tests en una carpeta en la raíz de nuestro proyecto llamada /test y en ella crearemos los diferentes fichero cuya extensión será .spec.js o .test.js. Cada vez que queramos pasar los tests ejecutaremos\nnpm run test\n\nPodéis obtener más información en infinidad de páginas de internet, como el Curso DWEC de Jose Castillo, y en la web oficial de vite.",
		"tags": [ "note"]
},

{
		"title": "03.1-webpack",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/03.1-webpack/",
		"content": "Webpack\nCuando trabajamos con clases la mejor forma de organizar el código es poniendo cada clase un su propio fichero javascript. Esto reduce el acoplamiento de nuestro código y nos permite reutilizar una clase en cualquier proyecto en que la necesitemos.\nSin embargo tener muchos ficheros hace que tengamos que importarlos todos, y en el orden adecuado, en nuestro index.html (mediante etiquetas &lt;script src=&quot;...&quot;&gt;) lo que empieza a ser engorroso.\nPara evitar este problema se utilizan los module bundlers o empaquetadores de código que unen todo el código de los distintos ficheros javascript en un único fichero que es el que se importa en el index.html.\nAdemás proporciona otras ventajas:\n\ntranspila el código, de forma que podemos usar sentencias javascript que aún no soportan muchos navegadores ya que se convertirán a sentencias que hacen lo mismo pero con código legacy\nminimiza y optimiza el código para que ocupe menos y su carga sea más rápida\nofusca el código al minimizarlo lo que dificulta que el usuario pueda ver en la consola lo que hace el programa y manipularlo\n\nNosotros usaremos el bundler *webpack que es el más usado en entorno frontend. Junto a npm tendremos una forma fácil y práctica de empaquetar el código.\nTrabajar con distintos ficheros\nPara que un fichero pueda tener acceso a código de otro fichero hay que hacer 2 cosas:\n\nEl fichero al que queremos acceder debe exportar el código que desea que sea accesible desde otros ficheros\nEl fichero que quiere acceder a ese código debe importarlo a una variable\n\nEsto es lo que hacíamos en el ejercicio de la frase para poder pasar los tests y lo que haremos con los ficheros donde declaramos clases.\nExportamos el código\nEn el caso de un fichero con una función a exportar será lo que exportaremos. Por ejemplo:\n// Fichero cuadrado.js\nconst cuadrado = (value) =&gt; value * value\nmodule.exports = cuadrado\n\nEn el caso de querer exportar muchas funciones lo más sencillo es exportarlas juntas en un objeto como en el fichero functions.js:\nmodule.exports = {\n\tletras,\n\tpalabras,\n\tmaysc,\n\ttitulo,\n\tletrasReves,\n\tpalabrasReves,\n\tpalindromo\n}\n\nAquí estamos exportando un objeto que contiene una serie de funciones\nSi es un fichero que define una clase la exportamos tal cual:\nclass Product {\nconstructor() {\n\n}\n...\n}\nmodule.exports = Product\n\nLo importamos donde queramos usarlo\nEn el fichero donde vayamos a usar dicho código lo importamos a una variable. Si se trata de una única función:\nconst cuadrado = require('./cuadrado.js')\nconsole.log('El cuadrado de 2 es ' + cuadrado(2))\n\nSi es un fichero con muchas funciones exportadas a un objeto podemos importar sólo las que queramos o todas:\nconst functions = require('./functions.js')\nconsole.log('Las letras de &quot;Hola&quot; son ' + functions.letras(&quot;Hola&quot;) + ' y al revés es ' + functions.letrasReves('Hola'))\n\no bien\nconst { letras, letrasReves } = require('./functions.js')\nconsole.log('Las letras de &quot;Hola&quot; son ' + letras(&quot;Hola&quot;) + ' y al revés es ' + letrasReves('Hola'))\n\nPara usar una clase la importamos:\nconst Product = require('./product.class')\nconst myProd = new Product()\n\nUsar webpack\nUna vez que tenemos nuestro código correctamente exportado e importado vamos a usar webpack para empaquetarlo.\nLo primero que habría que hacer es crear nuestro proyecto si no lo hemos hecho ya mediante npm init. Esto inicializa el proyecto y crea el fichero package.json. Recuerda escribir jest cuando nos pregunte por los tests.\nPara usar webpack simplemente lo incluímos mediante npm:\nnpm i -D webpack webpack-cli\n\nLa opción -D instala webpack como dependencia de desarrollo, lo que significa que en la versión de producción del código no se incluirá.\nPara instalar todas nuestras dependencias y que se cree la carpeta node_modules ejecutamos npm install.\nAhora ya estamos listos para usar webpack. Como hemos dicho es un module bundler, es decir, un empaquetador de código. Toma el fichero que le indiquemos como fichero principal (por defecto el ./src/index.js), lo junta con todas sus dependencias (sus require y los de sus dependencias) y los transpila a un único fichero (por defecto ./dist/main.js) que es el que se enlaza en el index.html. Además minimiza y optimiza dicho código al generarlo.\nPara generar el código empaquetado ejecutamos\nnpx webpack --mode=development\n\nEste código hay que ejecutarlo cada vez que se hagan cambios en el código. Si no quieres tener que ejecutarlo cada vez se puede lanzar con la opción --watch que deja la consola abierta y ejecuta el comando automáticamente cuando guardamos cualquiera de los ficheros del proyecto:\nnpx webpack --mode=development --watch\n\nSi nuestro fichero principal no es src/index.js lo indicaremos con la opción --entry:\nnpx webpack --entry=scripts/main.js --mode=development\n\nCuando usamos webpack le tenemos que indicar que tipo de código de salida queremos:\n\ndevelopment: webpack permite &quot;seguir&quot; la ejecución del código desde la consola ya que &quot;mapea&quot; el código generado al original de forma que en la consola vemos como si se ejecutara nuestro código (los distintos ficheros) en vez del código generado por webpack que es el que realmente se está ejecutando\nproduction: minimiza y optimiza el código para producción y ya no es posible desde la consola acceder al código original. Es lo que haremos para generar el código que subiremos al servidor de producción (NUNCA subimos el código de desarrollo).\n\nPodéis obtener más información en infinidad de páginas de internet y en la web oficial de webpack. Las diferentes opciones que podemos pasarle a este comando las podemos consultar en la página del CLI de webpack.",
		"tags": [ "note"]
},

{
		"title": "04-DOM",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/04-DOM/",
		"content": "Document Object Model (DOM)\n\nDocument Object Model (DOM)\n\nIntroducción\nAcceso a los nodos\nAcceso a nodos a partir de otros\n\nPropiedades de un nodo\n\nManipular el árbol DOM\n\nAñadir nuevos nodos con innerHTML\n\nAtributos de los nodos\n\nEstilos de los nodos\nAtributos de clase\nAtributos de datos\n\nIntroducción\nLa mayoría de las veces que programamos con Javascript es para que se ejecute en una página web mostrada por el navegador. En este contexto tenemos acceso a ciertos objetos que nos permiten interactuar con la página (DOM) y con el navegador (Browser Object Model, BOM).\nEl DOM es una estructura en árbol que representa todos los elementos HTML de la página y sus atributos. Todo lo que contiene la página se representa como nodos del árbol y mediante el DOM podemos acceder a cada nodo, modificarlo, eliminarlo o añadir nuevos nodos de forma que cambiamos dinámicamente la página mostrada al usuario.\nLa raíz del árbol DOM es document y de este nodo cuelgan el resto de elementos HTML. Cada uno constituye su propio nodo y tiene subnodos con sus atributos, estilos y elementos HTML que contiene.\nPor ejemplo, la página HTML:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;title&gt;Página simple&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nse convierte en el siguiente árbol DOM:\n![Árbol DOM](/img/user/01 Apuntes/Javascript Teoria Batoi/img/domSimple.png)\nCada etiqueta HTML suele originar 2 nodos:\n\nElement: correspondiente a la etiqueta\nText: correspondiente a su contenido (lo que hay entre la etiqueta y su par de cierre)\n\nCada nodo es un objeto con sus propiedades y métodos.\nEl ejemplo anterior está simplificado porque sólo aparecen los nodos de tipo elemento pero en realidad también generan nodos los saltos de línea, tabuladores, espacios, comentarios, etc. En el siguiente ejemplo podemos ver TODOS los nodos que realmente se generan. La página:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;My Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Header&lt;/h1&gt;\n&lt;p&gt;\nParagraph\n&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nse convierte en el siguiente árbol DOM:\n\nAcceso a los nodos\nLos principales métodos para acceder a los diferentes nodos son:\n\n.getElementById(id): devuelve el nodo con la id pasada. Ej.:\n\nlet nodo = document.getElementById('main'); // nodo contendrá el nodo cuya id es _main_\n\n.getElementsByClassName(clase): devuelve una colección (similar a un array) con todos los nodos de la clase indicada. Ej.:\n\nlet nodos = document.getElementsByClassName('error'); // nodos contendrá todos los nodos cuya clase es _error_\n\nNOTA: las colecciones son similares a arrays (se accede a sus elementos con [indice]) pero no se les pueden aplicar sus métodos filter, map, ... a menos que se conviertan a arrays con Array.from()\n\n.getElementsByTagName(etiqueta): devuelve una colección con todos los nodos de la etiqueta HTML indicada. Ej.:\n\nlet nodos = document.getElementsByTagName('p'); // nodos contendrá todos los nodos de tipo _&lt;p&gt;_\n\n.getElementsByName(name): devuelve una colección con todos los nodos que contengan un atributo name con el valor indicado. Ej.:\n\nlet radiosSexo = document.getElementsByName('sexo'); // radiosSexo contendrá todos los nodos con ese atributo (seguramente radiobuttons con name=&quot;sexo&quot;)\n\n.querySelector(selector): devuelve el primer nodo seleccionad por el selector CSS indicado. Ej.:\n\nlet nodo = document.querySelector('p.error'); // nodo contendrá el primer párrafo de clase _error_\n\n.querySelectorAll(selector): devuelve una colección con todos los nodos seleccionados por el selector CSS indicado. Ej.:\n\nlet nodos = document.querySelectorAll('p.error'); // nodos contendrá todos los párrafos de clase _error_\n\nNOTA: al aplicar estos métodos sobre document se seleccionará sobre la página pero podrían también aplicarse a cualquier nodo y en ese caso la búsqueda se realizaría sólo entre los descendientes de dicho nodo.\nTambién tenemos 'atajos' para obtener algunos elementos comunes:\n\ndocument.documentElement: devuelve el nodo del elemento &lt;html&gt;\ndocument.head: devuelve el nodo del elemento &lt;head&gt;\ndocument.body: devuelve el nodo del elemento &lt;body&gt;\ndocument.title: devuelve el nodo del elemento &lt;title&gt;\ndocument.link: devuelve una colección con todos los hiperenlaces del documento\ndocument.anchor: devuelve una colección con todas las anclas del documento\ndocument.forms: devuelve una colección con todos los formularios del documento\ndocument.images: devuelve una colección con todas las imágenes del documento\ndocument.scripts: devuelve una colección con todos los scripts del documento\n\nEJERCICIO: Para hacer los ejercicios de este tema descárgate esta página de ejemplo y ábrela en tu navegador. Obtén por consola, al menos de 2 formas diferentes:\n\nEl elemento con id 'input2'\n\ndocument.getElementById('input2') o document.querySelector('#input2')\n\nLa colección de párrafos\n\ndocument.getElementsByTagName('p') o document.querySelectorAll('p')\n\nLo mismo pero sólo de los párrafos que hay dentro del div 'lipsum'\n\nEl formulario (ojo, no la colección con el formulario sino sólo el formulario)\nTodos los inputs\nSólo los inputs con nombre 'sexo'\nLos items de lista de la clase 'important' (sólo los LI)\n\nAcceso a nodos a partir de otros\nEn muchas ocasiones queremos acceder a cierto nodo a partir de uno dado. Para ello tenemos los siguientes métodos que se aplican sobre un elemento del árbol DOM:\n\nelemento.parentElement: devuelve el elemento padre de elemento\nelemento.children: devuelve la colección con todos los elementos hijo de elemento (sólo elementos HTML, no comentarios ni nodos de tipo texto)\nelemento.childNodes: devuelve la colección con todos los hijos de elemento, incluyendo comentarios y nodos de tipo texto por lo que no suele utilizarse\nelemento.firstElementChild: devuelve el elemento HTML que es el primer hijo de elemento\nelemento.firstChild: devuelve el nodo que es el primer hijo de elemento (incluyendo nodos de tipo texto o comentarios)\nelemento.lastElementChild, elemento.lastChild: igual pero con el último hijo\nelemento.nextElementSibling: devuelve el elemento HTML que es el siguiente hermano de elemento\nelemento.nextSibling: devuelve el nodo que es el siguiente hermano de elemento (incluyendo nodos de tipo texto o comentarios)\nelemento.previousElementSibling, elemento.previousSibling: igual pero con el hermano anterior\nelemento.hasChildNodes: indica si elemento tiene o no nodos hijos\nelemento.childElementCount: devuelve el nº de nodos hijo de elemento\nelemento.closest(selector): devuelve el ancestro más cercano que coincide con el selector. Por ejemplo si el elemento es un &lt;td&gt; de una tabla entonces elemento.closest('table') devolverá la tabla a la que pertenece\n\nIMPORTANTE: a menos que me interesen comentarios, saltos de página, etc siempre debo usar los métodos que sólo devuelven elementos HTML, no todos los nodos.\n![Recorrer el árbol DOM](/img/user/01 Apuntes/Javascript Teoria Batoi/img/domRelaciones.png)\n\nEJERCICIO: Siguiento con la página de ejemplo obtén desde la consola, al menos de 2 formas diferentes:\n\nEl primér párrafo que hay dentro del div 'lipsum'\nEl segundo párrafo de 'lipsum'\nEl último item de la lista\nLa label de 'Escoge sexo'\n\nPropiedades de un nodo\nLas principales propiedades de un nodo son:\n\nelemento.innerHTML: todo lo que hay entre la etiqueta que abre elemento y la que lo cierra, incluyendo otras etiquetas HTML. Por ejemplo si elemento es el nodo &lt;p&gt;Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;&lt;/p&gt;\n\nlet contenido = elemento.innerHTML; // contenido='Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;'\n\nelemento.textContent: todo lo que hay entre la etiqueta que abre elemento y la que lo cierra, pero ignorando otras etiquetas HTML. Siguiendo con el ejemplo anterior:\n\nlet contenido = elemento.textContent; // contenido='Esta página es muy simple'\n\nelemento.value: devuelve la propiedad 'value' de un &lt;input&gt; (en el caso de un &lt;input&gt; de tipo text devuelve lo que hay escrito en él). Como los &lt;inputs&gt; no tienen etiqueta de cierre (&lt;/input&gt;) no podemos usar .innerHTML ni .textContent. Por ejemplo si elem1 es el nodo &lt;input name=&quot;nombre&quot;&gt; y elem2 es el nodo &lt;input tipe=&quot;radio&quot; value=&quot;H&quot;&gt;Hombre\n\nlet cont1 = elem1.value; // cont1 valdría lo que haya escrito en el &lt;input&gt; en ese momento\nlet cont2 = elem2.value; // cont2=&quot;H&quot;\n\nOtras propiedades:\n\nelemento.innerText: igual que textContent\nelemento.focus: da el foco a elemento (para inputs, etc). Para quitarle el foco elemento.blur\nelemento.clientHeight / elemento.clientWidth: devuelve el alto / ancho visible del elemento\nelemento.offsetHeight / elemento.offsetWidth: devuelve el alto / ancho total del elemento\nelemento.clientLeft / elemento.clientTop: devuelve la distancia de elemento al borde izquierdo / superior\nelemento.offsetLeft / elemento.offsetTop: devuelve los píxels que hemos desplazado elemento a la izquierda / abajo\n\nEJERCICIO: Obtén desde la consola, al menos de 2 formas:\n\nEl innerHTML de la etiqueta de 'Escoge sexo'\nEl textContent de esa etiqueta\nEl valor del primer input de sexo\nEl valor del sexo que esté seleccionado (difícil, búscalo por Internet)\n\nManipular el árbol DOM\nVamos a ver qué métodos nos permiten cambiar el árbol DOM, y por tanto modificar la página:\n\ndocument.createElement('etiqueta'): crea un nuevo elemento HTML con la etiqueta indicada, pero aún no se añade a la página. Ej.:\n\nlet nuevoLi = document.createElement('li');\n\nelemento.append(elementos o texto): añade al DOM los parámetros pasados como últimos hijos de elemento. Se le puede pasar tanto un nodo DOM como una cadena de texto (para la que se creará su nodo de texto correspondiente) y que se le pueden pasar varios parámetros para crear varios nodos. Ej.:\n\nnuevoLi.append('Nuevo elemento de lista'); // añade el texto pasado al elemento LI creado\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nmiPrimeraLista.append(nuevoLi); // añade LI como último hijo de UL, es decir al final de la lista\n\nelemento.prepend(elementos o texto): como el anterior pero en lugar de añadirlos como últimos hijos los añade antes del primer hijo.\n\nconst primerLi = document.createElement('li');\nprimerLi.append('Primer elemento de lista');\nlet miPrimeraLista = document.getElementsByTagName('ul')[0];\nmiPrimeraLista.prepend(nuevoLi);\n\nelemento.after(elementos o texto): como append pero en lugar de añadirlos como últimos hijos los añade como los siguientes hermanos de elemento.\n\nconst otroLi = document.createElement('li');\notroLi.append('Segundo elemento de lista');\nprimerLi.after(otroLi);\n\nelemento.before(elementos o texto): como el anterior pero los añade como los anteriores hermanos de elemento.\nelemento.remove(): borra el nodo elemento del documento.\nelemento.replaceWith(nuevoNodo): reemplaza el nodo elemento con el nuevoNodo pasado\n\nlet primerElementoDeLista = document.getElementsByTagName('ul')[0].firstChild; // selecciona el 1º LI de miPrimeraLista\nprimerElementoDeLista.replaceChild(nuevoLi); // reemplaza el 1º elemento de la lista con nuevoLi\n\nelementoAClonar.cloneNode(boolean): devuelve un clon de elementoAClonar o de elementoAClonar con todos sus descendientes según le pasemos como parámetro false o true. Luego podremos insertarlo donde queramos.\n\nOtros métodos menos usados son:\n\ndocument.createTextNode('texto'): crea un nuevo nodo de texto con el texto indicado, que luego tendremos que añadir a un nodo HTML. Normalmente no se usa porque append y el resto de métodos anteriores ya lo crean automáticamente. Ej.:\n\nlet textoLi = document.createTextNode('Nuevo elemento de lista');\n\nelemento.appendChild(nuevoNodo): añade nuevoNodo como último hijo de elemento y lo devuelve. Se diferencia con append en que sólo permite un parámetro y éste debe ser un nodo, no puede ser texto. Por eso no suele usarse. Ejemplo:\n\nnuevoLi.appendChild(textoLi); // añade el texto creado al elemento LI creado\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nmiPrimeraLista.appendChild(nuevoLi); // añade LI como último hijo de UL, es decir al final de la lista\n\nelemento.insertBefore(nuevoNodo, nodo): añade nuevoNodo como hijo de elemento antes del hijo nodo. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.insertBefore(nuevoLi, primerElementoDeLista); // añade LI al principio de la lista\n\nelemento.removeChild(nodo): borra nodo de elemento y por tanto se elimina de la página. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.removeChild(primerElementoDeLista); // borra el primer elemento de la lista\n// También podríamos haberlo borrado sin tener el padre con:\nprimerElementoDeLista.parentElement.removeChild(primerElementoDeLista);\n\nelemento.replaceChild(nuevoNodo, viejoNodo): reemplaza viejoNodo con nuevoNodo como hijo de elemento. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.replaceChild(nuevoLi, primerElementoDeLista); // reemplaza el 1º elemento de la lista con nuevoLi\n\nOJO: Si añado con el método append o appendChild un nodo que estaba en otro sitio se elimina de donde estaba para añadirse a su nueva posición. Si quiero que esté en los 2 sitios deberé clonar el nodo y luego añadir el clon y no el nodo original.\nAñadir nuevos nodos con innerHTML\nSupongamos que tenemos un DIV cuya id es myDiv al que queremos añadir al final dos párrafos, el último de ellos con un texto en negrita. El código podría ser:\nlet miDiv = document.getElementById('myDiv');\nlet nuevoParrafo = document.createElement('p');\nnuevoParrafo.textContent = 'Párrafo añadido al final';\nlet ultimoParrafo = document.createElement('p');\nconst textoNegrita = document.createElement('strong');\ntextoNegrita.textContent = 'con texto en negrita';\nultimoParrafo.append('Último párrafo ', textoNegrita);\nmiDiv.append(nuevoParrafo, ultimoParrafo);\n\nSi utilizamos la propiedad innerHTML el código a usar es mucho más simple:\nlet miDiv = document.getElementById('myDiv');\nmiDiv.innerHTML += '&lt;p&gt;Párrafo añadido al final&lt;/p&gt;&lt;p&gt;Último párrafo &lt;strong&gt;con texto en negrita&lt;/strong&gt;&lt;/p&gt;';\n\nOJO: La forma de añadir el último párrafo (línea #3: miDiv.innerHTML+='&lt;p&gt;Párrafo añadido al final&lt;/p&gt;';) aunque es válida no es muy eficiente ya que obliga al navegador a volver a pintar TODO el contenido de miDIV.\nPodemos ver más ejemplos de creación y eliminación de nodos en W3Schools.\n\nEJERCICIO: Añade a la página:\n\nUn nuevo párrafo al final del DIV 'lipsum' con el texto &quot;Nuevo párrafo añadido por javascript&quot; (fíjate que una palabra está en negrita)\nUn nuevo elemento al formulario tras el 'Dato 1' con la etiqueta 'Dato 1 bis' y el INPUT con id 'input1bis' que al cargar la página tendrá escrito &quot;Hola&quot;\n\nAtributos de los nodos\nPodemos ver y modificar los valores de los atributos de cada elemento HTML y también añadir o eliminar atributos:\n\nelemento.attributes: devuelve un array con todos los atributos de elemento\nelemento.hasAttribute('nombreAtributo'): indica si elemento tiene o no definido el atributo nombreAtributo\nelemento.getAttribute('nombreAtributo'): devuelve el valor del atributo nombreAtributo de elemento. Para muchos elementos este valor puede directamente con elemento.atributo.\nelemento.setAttribute('nombreAtributo', 'valor'): establece valor como nuevo valor del atributo nombreAtributo de elemento. También puede cambiarse el valor directamente con elemento.atributo=valor.\nelemento.removeAttribute('nombreAtributo'): elimina el atributo nombreAtributo de elemento\n\nA algunos atributos comunes como id, title o className (para el atributo class) se puede acceder y cambiar como si fueran una propiedad del elemento (elemento.atributo). Ejemplos:\nelemento.id = 'primera-lista';\n// es equivalente ha hacer:\nelemento.setAttribute('id', 'primera-lista');\n\nEstilos de los nodos\nLos estilos están accesibles como el atributo style. Cualquier estilo es una propiedad de dicho atributo pero con la sintaxis camelCase en vez de kebab-case. Por ejemplo para cambiar el color de fondo (propiedad background-color) y ponerle el color rojo al elemento miPrimeraLista haremos:\nmiPrimeraLista.style.backgroundColor = 'red';\n\nDe todas formas normalmente NO CAMBIAREMOS ESTILOS a los elementos sino que les pondremos o quitaremos clases que harán que se le apliquen o no los estilos definidos para ellas en el CSS.\nAtributos de clase\nYa sabemos que el aspecto de la página debe configurarse en el CSS por lo que no debemos aplicar atributos style al HTML. En lugar de ello les ponemos clases a los elementos que harán que se les aplique el estilo definido para dicha clase.\nComo es algo muy común en lugar de utilizar las instrucciones de elemento.setAttribute('className', 'destacado') o directamente elemento.className='destacado' podemos usar la propiedad classList que devuelve la colección de todas las clases que tiene el elemento. Por ejemplo si elemento es &lt;p class=&quot;destacado direccion&quot;&gt;...:\nlet clases=elemento.classList; // clases=['destacado', 'direccion'], OJO es una colección, no un Array\n\nAdemás dispone de los métodos:\n\n.add(clase): añade al elemento la clase pasada (si ya la tiene no hace nada). Ej.:\n\nelemento.classList.add('primero'); // ahora elemento será &lt;p class=&quot;destacado direccion primero&quot;&gt;...\n\n.remove(clase): elimina del elemento la clase pasada (si no la tiene no hace nada). Ej.:\n\nelemento.classList.remove('direccion'); // ahora elemento será &lt;p class=&quot;destacado primero&quot;&gt;...\n\n.toogle(clase): añade la clase pasada si no la tiene o la elimina si la tiene ya. Ej.:\n\nelemento.classList.toogle('destacado'); // ahora elemento será &lt;p class=&quot;primero&quot;&gt;...\nelemento.classList.toogle('direccion'); // ahora elemento será &lt;p class=&quot;primero direccion&quot;&gt;...\n\n.contains(clase): dice si el elemento tiene o no la clase pasada. Ej.:\n\nelemento.classList.contains('direccion'); // devuelve true\n\n.replace(oldClase, newClase): reemplaza del elemento una clase existente por una nueva. Ej.:\n\nelemento.classList.replace('primero', 'ultimo'); // ahora elemento será &lt;p class=&quot;ultimo direccion&quot;&gt;...\n\nTened en cuenta que NO todos los navegadores soportan classList por lo que si queremos añadir o quitar clases en navegadores que no lo soportan debemos hacerlo con los métodos estándar, por ejemplo para añadir la clase 'rojo':\nlet clases = elemento.className.split(&quot; &quot;);\nif (clases.indexOf('rojo') == -1) {\nelemento.className += ' ' + 'rojo';\n}\n\nAtributos de datos\nHTML5 permite agregar atributos personalizados no visuales a las etiquetas utilizando data-*. Estos atributos pueden ser accesibles a través de JavaScript usando dataset.\n&lt;article\nid=&quot;electriccars&quot;\ndata-columns=&quot;3&quot;\ndata-index-number=&quot;12314&quot;\ndata-parent=&quot;cars&quot;&gt;\n...\n&lt;/article&gt;\n\nlet article = document.getElementById('electriccars');\nconsole.log(article.dataset.columns); // 3\nconsole.log(article.dataset.indexNumber); // 12314\n\nFuente: Curso DWEC de José Castillo",
		"tags": ["3", "note"]
},

{
		"title": "04.1-MVC",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/04.1-MVC/",
		"content": "El patrón Modelo-Vista-Controlador\nModelo-vista-controlador (MVC) es un patrón de arquitectura de software muy utilizado en la actualidad en desarrollo web (y también en muchas aplicaciones de escritorio). Este patrón propone separar la aplicación en componentes distintos: el modelo, la vista y el controlador:\n\nEl modelo representa y gestiona los datos o información con la que trabaja la aplicación que normalmente serán variables extraidas de una base de datos. Normalmente el modelo no tiene conocimiento de las otras partes de la aplicación.\nLa vista muestra al usuario el modelo (información y lógica de negocio) en un formato adecuado para interactuar con él (usualmente la interfaz de usuario). Es la intermediaria entre la aplicación y el usuario\nEl controlador es el encargado de coordinar el funcionamiento de la aplicación. Responde a los eventos del usuario para lo que hace peticiones al modelo (para obtener o cambiar la información) y a la vista (para que muestre al usuario dicha información).\n\nAdemás de etos componentes usualmente tendremos otros como:\n\nLos servicios que controlan la comunicación con el servidor y otras fuentes externas de datos. Gestionan los accesos a la información, tanto consultas como actualizaciones, implementando también los privilegios de acceso que se hayan descrito en las especificaciones de la aplicación (lógica de negocio).\nLas rutas gestionan la navegación y las rutas de la aplicación en SPA.\n\nEste patrón de arquitectura de software se basa en las ideas de reutilización de código y la separación de conceptos, características que buscan facilitar la tarea de desarrollo de aplicaciones y su posterior mantenimiento.\nUna aplicación sin MVC\nSi una aplicación no utiliza este modelo la función que modifique los datos debe además reflejar dicha modificación en la página para que la vea el usuario. Por ejemplo vamos a hacer una aplicación para gestionar un almacén. Entre otras muchas cosas tendrá una función (podemos llamarle addProduct) que se encargue de añadir un nuevo producto al almacén y dicha función deberá realizar:\n\nañadir el nuevo producto al almacén (por ejemplo añadiéndolo a un array de productos)\npintar en la página ese nuevo producto (por ejemplo añadiendo una nueva línea a una tabla donde se muestran los productos)\n\n// La función que se ejecuta cuando el usuario envía el\n// formulario para añadir un producto debería hacer:\ndocument.getElementById('product-form').addEventListener('submit', async (event) =&gt; {\nevent.preventDefault()\n// Coge los datos del formlario\nconst name = document.getElementById('product-form-name').value\nconst price = document.getElementById('product-form-name').price\n...\n// Valida cada dato\nif (!name || name.length &lt; 5 || ...)\n...\n// Añade el producto a la BBDD\nconst prod = await addProductToDatabase(payload)\nlet newProd = new Product(prod.id, prod.name, prod.price, prod.units)\nthis.products.push(newProd)\n...\n// Pinta en la página el nuevo producto\nconst DOMproduct = document.createElement('tr')\nDOMproduct.innerHTML = `\n&lt;td&gt;${newProd.id}&lt;/td&gt;\n&lt;td&gt;${newProd.name}&lt;/td&gt;\n&lt;td&gt;${newProd.price}&lt;/td&gt;\n&lt;td&gt;${newProd.units}&lt;/td&gt;`\ndocument.getElementById('products-table').apendChild(DOMproduct)\n// Gestiona los posibles errores producidos en todo este proceso\n...\n})\n\nComo vemos, se va a convertir en una función muy grande y que se encarga de muchas cosas distintas por lo que va a ser difícil mantener ese código. Además toda la función es muy dependiente del HTML (en muchas partes se buscan elementos por su id).\nNuestro patrón MVC\nEn una aplicación muy sencilla podemos no seguir este modelo pero en cuanto la misma se complica un poco es imprescindible programar siguiendo buenas prácticas ya que si no lo hacemos nuestro código se volverá rápidamente muy difícil de mantener.\nHay muchas formas de implementar este modelo. Si estamos haciendo un proyecto con OOP podemos seguir el patrón MVC usando clases. Si sólo usamos programación estructurada será igual pero en vez de clases y métodos tendremos funciones.\nPara organizar el código crearemos subcarpetas dentro de la carpeta src:\n\nmodel: aquí incluiremos las clases que constituyen el modelo de nuestra aplicación\nview: aquí crearemos un fichero JS que será el encargado de la GUI de nuestra aplicación, el único dependiente del HTML. Nuestro fichero será una clase que representa toda la vista aunque en aplicaciones mayores lo normal es tener clases para cada página, etc\ncontroller: aquí crearemos el fichero JS que contendrá el controlador de la aplicación\nservices: aquí crearemos el fichero JS que se encargará de comunicarse con el servidor y proporcionar los datos al modelo\n\nDe este forma, si quiero cambiar la forma en que se muestra algo voy directamente a la vista y modifico la función que se ocupa de ello.\nLa vista será una clase cuyas propiedades serán elementos de la página HTML a los que accedamos frecuentemente, para no tener que buscarlos cada vez y para que estén disponibles para el controlador. Contendrá métodos para renderizar los distintos elementos de la vista.\nEl controlador será una clase cuyas propedades serán el modelo y la vista, de forma que pueda acceder a ambos elementos. Tendrá métodos para las distintas acciones que pueda hacer el usuario (y que se ejecutarán como respuesta a dichas acciones, como veremos en el tema de eventos). Cada uno de esos métodos llamará a métodos del modelo (para obtener o cambiar la información necesaria) y posteriormente de la vista (para reflejar esos cambios en lo que ve el usuario).\nPor su parte el modelo gestionará los datos de la aplicación llamando a los servicios para obtener datos del servidor o guardar en él las modificaciones pertinentes.\nEl fichero principal de la aplicación instanciará un controlador y lo inicializará.\nPor ejemplo, siguiendo con la aplicación para gestionar un almacén. El modelo constará de la clase Store que es nuestro almacén de productos (con métodos para añadir o eliminar productos, etc) y la clase Product que gestiona cada producto del almacén (con métodos para crear un nuevo producto, etc).\nEl fichero principal sería algo como:\n\nmain.js\n\nconst storeApp = new Controller()\t\t// crea el controlador\nstoreApp.init()\t\t\t\t// lo inicializa\n\n// En desarrollo podemos añadir algunas líneas que luego quitaremos para\n// imitar acciones del usuario y así ver el funcionamiento de la aplicación:\nstoreApp.addProductToStore({ name: 'Portátil Acer Travelmate E2100', price: 523.12 })\nstoreApp.changeProduct({ id: 1, price: 515.95 })\nstoreApp.deleteProduct(1)\n\ncontroller/index.js\n\nexport default class Controller {\nconstructor() {\nthis.store = new Store(1)\t\t// crea el modelo, un Store con id 1\nthis.view = new View()\t\t// crea la vista\n}\n\ninit() {\n// inicializa la vista y el modelo, si es necesario\nthis.store.init()\nthis.view.init()\t\t\t\n\n// Le indica a la vista qué funciones callback se encargarán\n// de responder a los eventos del usuario (siguiente tema)\nthis.view.setSubmitHandler(this.handleSubmitProductForm.bind(this))\n}\n\t\nhandleSubmitProductForm(payload) {\n// haría las comprobaciones necesarias sobre los datos\nif (!payload.name || payload.name.length &lt; 5 || ...) {\nthis.view.showErrorMessage('error', 'Datos incorrectos')\nreturn\n}\n...\n// y luego dice al modelo que añada el producto\ntry {\nconst newProd = this.store.addProduct(prod)\n// si lo ha hecho le dice a la vista que lo pinte\t\nthis.view.renderNewProduct(newProd)\t\n} catch(err) {\nthis.view.showErrorMessage('error', 'Error al añadir el producto')\n}\n}\n...\n}\n\nmodel/store.class.js\n\nexport default class Store {\nconstructor (id) {\nthis.id=Number(id)\nthis.products=[]\n}\n\naddProduct(payload) {\n// llama a métodos de los servicios para que añada el producto\nconst prod = await addProductToDatabase(payload)\nlet newProd = new Product(prod.id, prod.name, prod.price, prod.units)\nthis.products.push(newProd)\nreturn newProd\n}\n...\n}\n\nmodel/product.class.js\n\nexport default class Product {\nconstructor (id, name, price, units) {\nthis.id = id\nthis.name = name\nthis.price = price\nthis.units = units\n}\n...\n}\n\nview/index.js\n\nexport default class View {\nconstructor {\nthis.messageDiv = document.getElementById('messages')\nthis.productForm = document.getElementById('product-form')\nthis.productsList = document.getElementById('products-table')\n}\n\ninit() {\n...\t\t\t// inicializa la vista, si es necesario\n}\n\nsetSubmitHandler(callback) {\n// código para que el controlador llame a la función callback\n// cuando se envíe el formulario de añadir un producto\nthis.productForm.addEventListener('submit', (event) =&gt; {\nevent.preventDefault()\nconst name = document.getElementById('product-form-name').value\nconst price = document.getElementById('product-form-name').price\n...\ncallback({ name, price, ... })\n})\n}\n\nrenderNewProduct(prod) {\n// código para añadir a la tabla el producto pasado añadiendo una nueva fila\nconst DOMproduct = document.createElement('tr')\nDOMproduct.innerHTML = `\n&lt;td&gt;${newProd.id}&lt;/td&gt;\n&lt;td&gt;${newProd.name}&lt;/td&gt;\n&lt;td&gt;${newProd.price}&lt;/td&gt;\n&lt;td&gt;${newProd.units}&lt;/td&gt;`\nthis.productsList.apendChild(DOMproduct)\n}\n\nshowMessage(type, message) {\n// código para mostrar mensajes al usuario y no tener que usar los alert\nconst DOMmessage = document.createElement('div')\n...\nthis.messageDiv.apendChild(DOMmessage)\n}\n}\n\nPodéis obtener más información y ver un ejemplo más completo en https://www.natapuntes.es/patron-mvc-en-vanilla-javascript/",
		"tags": [ "note"]
},

{
		"title": "05-BOM",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/05-BOM/",
		"content": "Browser Object Model (BOM)\n\nBrowser Object Model (BOM)\n\nIntroducción\nTimers\nObjetos del BOM\n\nObjeto window\n\nDiálogos\n\nObjeto location\nObjeto history\nObjeto navigator\nOtros objetos\n\nIntroducción\nEn este tema veremos cómo acceder a objetos que nos permitan interactuar con el navegador (Browser Object Model, BOM).\nUsando los objetos BOM podemos:\n\nAbrir, cambiar y cerrar ventanas\nEjecutar código en cierto tiempo (timers)\nObtener información del navegador\nVer y modificar propiedades de la pantalla\nGestionar cookies, ...\n\nTimers\nPermiten ejecutar código en el futuro (cuando transcurran los milisegundos indicados). Hay 2 tipos:\n\nsetTimeout(función, milisegundos): ejecuta la función pasada como parámetro una sóla vez, cuando transcurran los milisegundos indicados\nsetInterval(función, milisegundos): ejecuta la función cada vez que transcurran los milisegundos indicados, hasta que sea cancelado el timer. A ambas se le pueden pasar más parámetros tras los milisegundos y serán los parámetros que recibirá la función a ejecutar.\n\nAmbas funciones devuelven un identificador que nos permitirá cancelar la ejecución del código usando:\n\nclearTiemout(identificador)\nclearInterval(identificador)\n\nEjemplo:\nconst idTimeout = setTimeout(() =&gt; alert('Timeout que se ejecuta al cabo de 1 seg.'), 1000);\n\nlet i = 1;\nconst idInterval = setInterval(() =&gt; {\n\talert('Interval cada 3 seg. Ejecución nº: '+ i++);\nif (i === 5) {\nclearInterval(idInterval);\nalert('Fin de la ejecución del Interval');\n\t}\n}, 3000);\n\nEJERCICIO: Ejecuta en la consola cada una de esas funciones\n\nEn lugar de definir la función a ejecutar podemos llamar a una función que ya exista:\nfunction showMessage() {\nalert('Timeout que se ejecuta al cabo de 1 seg.')\n}\n\nconst idTimeout=setTimeout(showMessage, 1000);\n\nPero en ese caso hay que poner sólo el nombre de la función, sin () ya que si los ponemos se ejecutaría la función en ese momento y no transcurrido el tiempo indicado.\nSi necesitamos pasarle algún parámetro a la función lo añadiremos como parámetros de setTimeout o setInterval después del intervalo:\nfunction showMessage(msg) {\nalert(msg)\n}\n\nconst idTimeout = setTimeout(showMessage, 1000, 'Timeout que se ejecuta al cabo de 1 seg.');\n\nObjetos del BOM\nAl contrario que para el DOM, no existe un estándar de BOM pero es bastante parecido en los diferentes navegadores.\nObjeto window\nRepresenta la ventana del navegador y es el objeto principal. De hecho puede omitirse al llamar a sus propiedades y métodos, por ejemplo, el método setTimeout() es en realidad window.setTimeout().\nSus principales propiedades y métodos son:\n\n.name: nombre de la ventana actual\n.status: valor de la barra de estado\n.screenX/.screenY: distancia de la ventana a la esquina izquierda/superior de la pantalla\n.outerWidth/.outerHeight: ancho/alto total de la ventana, incluyendo la toolbar y la scrollbar\n.innerWidth/.innerHeight: ancho/alto útil del documento, sin la toolbar y la scrollbar\n.open(url, nombre, opciones): abre una nueva ventana. Devuelve el nuevo objeto ventana. Las principales opciones son:\n\n.toolbar: si tendrá barra de herramientas\n.location: si tendrá barra de dirección\n.directories: si tendrá botones Adelante/Atrás\n.status: si tendrá barra de estado\n.menubar: si tendrá barra de menú\n.scrollbar: si tendrá barras de desplazamiento\n.resizable: si se puede cambiar su tamaño\n.width=px/.height=px: ancho/alto\n.left=px/.top=px: posición izq/sup de la ventana\n\n.opener: referencia a la ventana desde la que se abrió esta ventana (para ventanas abiertas con open)\n.close(): la cierra (pide confirmación, a menos que la hayamos abierto con open)\n.moveTo(x,y): la mueve a las coord indicadas\n.moveBy(x,y): la desplaza los px indicados\n.resizeTo(x,y): la da el ancho y alto indicados\n.resizeBy(x,y): le añade ese ancho/alto\n.pageXoffset / pageYoffset: scroll actual de la ventana horizontal / vertical\nOtros métodos: .back(), .forward(), .home(), .stop(), .focus(), .blur(), .find(), .print(), …\nNOTA: por seguridad no se puede mover una ventana fuera de la pantalla ni darle un tamaño menor de 100x100 px ni tampoco se puede mover una ventana no abierta con .open() o si tiene varias pestañas\n\nEJERCICIO: Ejecuta desde la consola:\n\nabre una nueva ventana de dimensiones 500x200px en la posición (100,200)\nescribe en ella (con document.write) un título h1 que diga 'Hola'\nmuévela 300 px hacia abajo y 100 a la izquierda\nciérrala\n\nPuedes ver un ejemplo de cómo abrir ventanas en este vídeo.\n\nEJERCICIO: Haz que a los 2 segundos de abrir la página se abra un popup con un mensaje de bienvenida. Esta ventana tendrá en su interior un botón Cerrar que permitirá que el usuario la cierre haciendo clic en él. Tendrá el tamaño justo para visualizar el mensaje y no tendrá barras de scroll, ni de herramientas, ni de dirección... únicamente el mensaje.\n\nDiálogos\nHay 3 métodos del objeto window que ya conocemos y que nos permiten abrir ventanas de diálogo con el usuario:\n\nwindow.alert(mensaje): muestra un diálogo con el mensaje indicado y un botón de 'Aceptar'\nwindow.confirm(mensaje): muestra un diálogo con el mensaje indicado y botones de 'Aceptar' y 'Cancelar'. Devuelve true si se ha pulsado el botón de aceptar del diálogo y false si no.\nwindow.prompt(mensaje [, valor predeterminado]): muestra un diálogo con el mensaje indicado, un cuadro de texto (vacío o co el valor predeterminado indicado) y botones de 'Aceptar' y 'Cancelar'. Si se pulsa 'Aceptar' devolverá un string con el valor que haya en el cuadro de texto y si se pulsa 'Cancelar' o se cierra devolverá null.\n\nObjeto location\nContiene información sobre la URL actual del navegador y podemos modificarla. Sus principales propiedades y métodos son:\n\n.href: devuelve la URL actual completa\n.protocol, .hostname, .port: devuelve el protocolo, host y puerto respectivamente de la URL actual\n.pathname, hash, search: devuelve la ruta al recurso actual, el gragmento (#...) y la cadena de búsqueda (?...) respectivamente\n.reload(): recarga la página actual\n.assign(url): carga la página pasada como parámetro\n.replace(url): ídem pero sin guardar la actual en el historial\n\nEJERCICIO: Ejecuta en la consola\n\nmuestra la ruta completa de la página actual\nmuestra el servidor de esta página\ncarga la página de Google usando el objeto location\n\nObjeto history\nPermite acceder al historial de páginas visitadas y navegar por él:\n\n.length: muestra el número de páginas almacenadas en el historial\n.back(): vuelve a la página anterior\n.forward(): va a la siguiente página\n.go(num): se mueve num páginas hacia adelante o hacia atrás (si num es negativo) en el historial\n\nEJERCICIO: desde la consola vuelve a la página anterior\n\nObjeto navigator\nNos da información sobre el navegador y el sistema en que se ejecuta:\n\n.userAgent: muestra información sobre el navegador que usamos\n.language: muestra el idioma del navegador\n.languages: muestra los idiomas instalados en el navegador\n.appVersion: versión del navegador\n.appName: nombre del navegador\n.appCodeName: nombre en código del navegador\n.product: producto del navegador\n.platform: sistema en el que se ejecuta el navegador\n...\n\nTambién incluye objetos con sus propias API para poder interactuar con el sistema:\n\n.geolocation: devuelve un objeto con la localización del dispositivo (sólo funciona en https)\n.storage: permite acceder a los datos almacenados en el navegador (los veremos en detalle más adelante)\n.clipboard: permite copiar texto al portapapeles del usuario con .writeText() (sólo funciona en https)\n.mediaDevices: permite acceder a los dispositivos multimedia del usuario\n.serviceWorker: permite trabajar con service workers\n...\n\nEJERCICIO: desde la consola muestra la información del navegador, su lenguaje y del sistema en que se ejecuta\n\nOtros objetos\nOtros objetos que incluye BOM son:\n\nscreen: nos da información sobre la pantalla\n\n.width/.height: ancho/alto total de la pantalla (resolución)\n.availWidth/.availHeight: igual pero excluyendo la barra del S.O.\n...\n\nEJERCICIO: obtén desde la consola todas las propiedades width/height y availWidth/availHeight del objeto scrren. Compáralas con las propiedades innerWidth/innerHeight y outerWidth/outerHeight de window.",
		"tags": [ "note"]
},

{
		"title": "06-eventos",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/06-eventos/",
		"content": "Eventos\n\nEventos\n\nIntroducción\nCómo escuchar un evento\n\nEvent listeners\n\nTipos de eventos\n\nEventos de página\nEventos de ratón\nEventos de teclado\nEventos de toque\nEventos de formulario\n\nLos objetos this y event\n\nBindeo del objeto this\n\nPropagación de eventos\ninnerHTML y escuchadores de eventos\nDelegación de eventos\nEventos personalizados\n\nIntroducción\nNos permiten detectar acciones que realiza el usuario o cambios que suceden en la página y reaccionar en respuesta a ellas. Existen muchos eventos diferentes (podéis ver la lista en w3schools) aunque nosotros nos centraremos en los más comunes.\nJavascript nos permite ejecutar código cuando se produce un evento (por ejemplo el evento click del ratón) asociando al mismo una función. Hay varias formas de hacerlo.\nCómo escuchar un evento\nLa manera tradicional de asociar código a un evento era añadiendo un atributo con el nombre del evento a escuchar (con 'on' delante) en el elemento HTML. Por ejemplo, para ejecutar código al producirse el evento 'click' sobre un botón se escribía:\n&lt;input type=&quot;button&quot; id=&quot;boton1&quot; onclick=&quot;alert('Se ha pulsado');&quot; /&gt;\n\nUna mejora era llamar a una función que contenía el código:\n&lt;input type=&quot;button&quot; id=&quot;boton1&quot; onclick=&quot;clicked()&quot; /&gt;\n\nfunction clicked() {\nalert('Se ha pulsado');\n}\n\nComo se trata de poner un atributo al elemento podemos usar DOM para evitar &quot;ensuciar&quot; con código la página HTML:\ndocument.getElementById('boton1').onclick = function () {\nalert('Se ha pulsado');\n}\n\nIMPORTANTE: si asociamos un evento a un elemento que aún no existe (porque aún no lo ha renderizado el navegador) no se produce ningún error pero cuando posteriormente se renderice ese elemento no tendrá asociado el evento. Para evitarlo siempre es conveniente poner los escuchadores de los eventos dentro de una función que se ejecute cuando sepamos que ya se ha renderizado toda la página, es decir tras producirse:\n\nel evento load de la ventana: se produce cuando se han cargado todos los elementos HTML de la página (incluyendo imágenes, ficheros, etc) y se ha creado el árbol DOM\nel evento DOMContentLoaded del documento: se produce cuando se ha creado el árbol DOM pero no se han cargado imágenes, hojas de estilo, ni subframes. Es el ideal para realizar acciones del DOM sin tener que esperar a que se carguen las imágenes y el CSS\n\nLo mismo habría que hacer con cualquier código que modifique el árbol DOM. El código correcto sería:\nwindow.onload = function() {\ndocument.getElementById('boton1').onclick = function() {\nalert('Se ha pulsado');\n}\n}\n\no mejor\ndocument.onDOMContentLoaded = () =&gt; {\ndocument.getElementById('boton1').onclick = function() {\nalert('Se ha pulsado');\n}\n}\n\nEvent listeners\nPero esta forma tradicional de poner escuchadores a los eventos lo es la más adecuada. La forma recomendada de hacerlo es usando el modelo avanzado de registro de eventos del W3C, mediante el método addEventListener que recibe como primer parámetro el nombre del evento a escuchar (sin 'on') y como segundo parámetro la función a ejecutar cuando se produzca (OJO, sin paréntesis):\ndocument.getElementById('boton1').addEventListener('click', pulsado);\n...\nfunction pulsado() {\nalert('Se ha pulsado');\n}\n\nHabitualmente se usan funciones anónimas ya que no necesitan ser llamadas desde fuera del escuchador:\ndocument.getElementById('boton1').addEventListener('click', () =&gt; {\nalert('Se ha pulsado');\n});\n\nSi queremos pasarle algún parámetro a la función manejadora (cosa bastante poco usual) debemos usar obligatoriamente funciones anónimas como escuchadores de eventos:\n\nNOTA: igual que antes debemos estar seguros de que se ha creado el árbol DOM antes de poner un escuchador por lo que se recomienda ponerlos siempre dentro una función asociada a window.addEventListener(&quot;load&quot;, ...) o mejor a document.addEventListener(&quot;DOMContentLoaded&quot;, ...).\nUna ventaja de esta forma de poner escuchadores es que podemos poner varios escuchadores para el mismo evento y se ejecutarán todos ellos. Para eliminar un escuchador se usa el método removeEventListener.\ndocument.getElementById('boton1').removeEventListener('click', pulsado);\n\nNOTA: no se puede quitar un escuchador si hemos usado una función anónima, para quitarlo debemos usar como escuchador una función con nombre.\nTipos de eventos\nSegún qué o dónde se produce un evento estos se clasifican en:\nEventos de página\nSe producen en el documento HTML:\n\nload: se produce cuando termina de cargarse la página. Es útil para hacer acciones que requieran que la página esté cargada\nDOMContentLoaded: se produce cuando se ha cargado el árbol DOM pero no se han cargado imágenes, hojas de estilo, ni subframes. Es el ideal para realizar acciones del DOM sin tener que esperar a que se carguen las imágenes y el CSS\nunload: al destruirse el documento (ej. cerrar)\nbeforeUnload: antes de destruirse (podríamos mostrar un mensaje de confirmación)\nresize: si cambia el tamaño del documento (porque se redimensiona la ventana)\n\nEventos de ratón\nLos produce el usuario con el ratón:\n\nclick / dblclick: cuando se hace click/doble click sobre un elemento\nmousedown / mouseup: al pulsar/soltar cualquier botón del ratón\nmouseover / mouseout: cuando el puntero del ratón entra/sale del elemento (tb. podemos usar mouseenter / mouseleave)\nmousemove: se produce continuamente mientras el puntero se mueva dentro del elemento\n\nNOTA: si hacemos doble click sobre un elemento la secuencia de eventos que se produciría es: mousedown -&gt; mouseup -&gt; click -&gt; mousedown -&gt; mouseup -&gt; click -&gt; dblclick\n\nEJERCICIO: Pon un escuchador desde la consola al botón 1 de la página de ejemplo de DOM para que al hacer click se muestre el un alert con 'Click sobre botón 1'. Ponle otro para que al pasar el ratón sobre él se muestre 'Entrando en botón 1'.\n\nEventos de teclado\nLos produce el usuario al usar el teclado:\n\nkeydown: se produce al presionar una tecla y se repite continuamente si la tecla se mantiene pulsada\nkeyup: cuando se deja de presionar la tecla\nkeypress: acción de pulsar y soltar (sólo se produce en las teclas alfanuméricas)\n\nNOTA: el orden de secuencia de los eventos es:\nkeyDown -&gt; keyPress -&gt; keyUp\nEventos de toque\nSe producen al usar una pantalla táctil:\n\ntouchstart: se produce cuando se detecta un toque en la pantalla táctil\ntouchend: cuando se deja de pulsar la pantalla táctil\ntouchmove: cuando un dedo es desplazado a través de la pantalla\ntouchcancel: cuando se interrumpe un evento táctil.\n\nEventos de formulario\nSe producen en los formularios:\n\nfocus / blur: al obtener/perder el foco el elemento\nchange: al perder el foco un &lt;input&gt; o &lt;textarea&gt; si ha cambiado su contenido o al cambiar de valor un &lt;select&gt; o un &lt;checkbox&gt;\ninput: al cambiar el valor de un &lt;imput&gt; o &lt;textarea&gt; (se produce cada vez que escribimos una letra es estos elementos)\nselect: al cambiar el valor de un &lt;select&gt; o al seleccionar texto de un &lt;imput&gt; o &lt;textarea&gt;\nsubmit / reset: al enviar/recargar un formulario\n\nLos objetos this y event\nAl producirse un evento se generan automáticamente en su función manejadora 2 objetos:\n\nthis: siempre hace referencia al elemento que contiene el código en donde se encuentra la variable this. En el caso de una función manejadora será el elemento que tiene el escuchador que ha recibido el evento. OJO: se sobreescribe el valor anterior de this por lo que si queremos conservarlo debemos guardarlo en otra variable antes de entrar en la función manejadora.\nevent: es un objeto y la función manejadora lo recibe como parámetro. Tiene propiedades y métodos que nos dan información sobre el evento, como:\n\n.type: qué evento se ha producido (click, submit, keyDown, ...)\n.target: el elemento donde se produjo el evento (puede ser this o un descendiente de this, como en el ejemplo siguiente)\n.currentTarget: el elemento que contiene el escuchador del evento lanzado (normalmente el mismo que this). Por ejemplo si tenemos un &lt;p&gt; al que le ponemos un escuchador de 'click' que dentro tiene un elemento &lt;span&gt;, si hacemos click sobre el &lt;span&gt; event.target será el &lt;span&gt; que es donde hemos hecho click (está dentro de &lt;p&gt;) pero tanto &lt;this&gt; como event.currentTarget será &lt;p&gt; (que es quien tiene el escuchador que se está ejecutando).\n.relatedTarget: en un evento 'mouseover' event.target es el elemento donde ha entrado el puntero del ratón y event.relatedTarget el elemento del que ha salido. En un evento 'mouseout' sería al revés.\n.cancelable: si el evento puede cancelarse. En caso afirmativo se puede llamar a event.preventDefault() para cancelarlo\n.preventDefault(): si un evento tiene un escuchador asociado se ejecuta el código de dicho escuchador y después el navegador realiza la acción que correspondería por defecto al evento si no tuviera escuchador (por ejemplo un escuchador del evento click sobre un hiperenlace hará que se ejecute su código y después saltará a la página indicada en el href del hiperenlace). Este método cancela la acción por defecto del navegador para el evento. Por ejemplo si el evento era el submit de un formulario éste no se enviará o si era un click sobre un hiperenlace no se irá a la página indicada en él.\n.stopPropagation: un evento se produce sobre un elemento y todos su padres. Por ejemplo si hacemos click en un &lt;span&gt; que está en un &lt;p&gt; que está en un &lt;div&gt; que está en el BODY el evento se va propagando por todos estos elementos y saltarían los escuchadores asociados a todos ellos (si los hubiera). Si alguno llama a este método el evento no se propagará a los demás elementos padre.\ndependiento del tipo de evento tendrá más propiedades:\n\neventos de ratón:\n\n.button: qué botón del ratón se ha pulsado (0: izq, 1: rueda; 2: dcho).\n.screenX / .screenY: las corrdenadas del ratón respecto a la pantalla\n.clientX / .clientY: las coordenadas del ratón respecto a la ventana cuando se produjo el evento\n.pageX / .pageY: las coordenadas del ratón respecto al documento (si se ha hecho un scroll será el clientX/Y más el scroll)\n.offsetX / .offsetY: las coordenadas del ratón respecto al elemento sobre el que se produce el evento\n.detail: si se ha hecho click, doble click o triple click\n\neventos de teclado: son los más incompatibles entre diferentes navegadores. En el teclado hay teclas normales y especiales (Alt, Ctrl, Shift, Enter, Tab, flechas, Supr, ...). En la información del teclado hay que distinguir entre el código del carácter pulsado (e=101, E=69, €=8364) y el código de la tecla pulsada (para los 3 caracteres es el 69 ya que se pulsa la misma tecla). Las principales propiedades de event son:\n\n.key: devuelve el nombre de la tecla pulsada\n.which: devuelve el código de la tecla pulsada\n.keyCode / .charCode: código de la tecla pulsada y del carácter pulsado (según navegadores)\n.shiftKey / .ctrlKey / .altKey / .metaKey: si está o no pulsada la tecla SHIFT / CTRL / ALT / META. Esta propiedad también la tienen los eventos de ratón\n\nNOTA: a la hora de saber qué tecla ha pulsado el usuario es conveniente tener en cuenta:\n\npara saber qué carácter se ha pulsado lo mejor usar la propiedad key o charCode de keyPress, pero varía entre navegadores\npara saber la tecla especial pulsada mejor usar el key o el keyCode de keyUp\ncaptura sólo lo que sea necesario, se producen muchos eventos de teclado\npara obtener el carácter a partir del código: String fromCharCode(codigo);\n\nLo mejor para familiarizarse con los diferentes eventos es consultar los ejemplos de w3schools.\n\nEJERCICIO: Pon desde la consola un escuchador al BODY de la página de ejemplo para que al mover el ratón en cualquier punto de la ventana del navegador, se muestre en algún sitio (añade un DIV o un P al HTML) la posición del puntero respecto del navegador y respecto de la página.\n\nEJERCICIO: Pon desde la consola un escuchador al BODY de la página de ejemplo para que al pulsar cualquier tecla nos muestre en un alert el key y el keyCode de la tecla pulsada. Pruébalo con diferentes teclas\n\nBindeo del objeto this\nEn ocasiones no queremos que this sea el elemento sobre quien se produce el evento sino que queremos conservar el valor que tenía antes de entrar a la función manejadora. Por ejemplo, si la función manejadora es un método de una clase en this tenemos el objeto de la clase sobre el que estamos actuando pero al entrar en la función manejadora del evento se sobreescribe esta variable.\nPodríamos guardarla en otra variable antes de entrar en la función manejadora como vimos en el tema de POO, por ejemplo:\nlet that = this;\ndocument.getElementById('acepto').addEventListener('click', function() {\n// Aquí dentro this será el elemento sobre el que se ha hecho click\n// y that será el objeto que tenía antes de entrar en la función manejadora\n});\n\nPero también podemos usar el método .bind(), que nos permite pasarle a una función el valor que queremos darle a la variable this dentro de dicha función:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(variable));\n\nEn este ejemplo el valor de this dentro de la función aceptado será _variable_en lugar de event.currentTarget.\nEn el ejemplo que habíamos comentado de un manejador dentro de una clase, para mantener el valor de this y que haga referencia al objeto sobre el que estamos actuando haríamos:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(this));\n\npor lo que el valor de this dentro de la función aceptado será el mismo que tenía fuera, es decir, la instancia del objeto.\nEsto es lo que hacíamos en la práctica de DOM cuando le pasábamos a las funciones manejadoras del submit y el click del formulario en la vista métodos del controlador con el objeto this bindeado:\nthis.view.setBookSubmitHandler(this.handleSubmitBook.bind(this));\nthis.view.setBookRemoveHandler(this.handleRemoveBook.bind(this));\n\nSin ese bindeo esos métodos perderían la referencia a la instancia del controlador y no podrían acceder a sus propiedades y métodos.\nPodemos bindear, es decir, pasarle a la función manejadora más variables declarándolas como parámetros de bind. El primer parámetro será el valor de this y los demás serán parámetros que recibirá la función antes de recibir el parámetro event que será el último. Por ejemplo:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(var1, var2));\n...\nfunction aceptado(param1, param2, event) {\n// Aquí dentro tendremos los valores\n// this = var1\n// param1 = var2\n// param2 = var3\n// event es el objeto con la información del evento producido\n}\n\nPropagación de eventos\nNormalmente en una página web los elementos HTML se solapan unos con otros, por ejemplo, un &lt;span&gt; está en un &lt;p&gt; que está en un &lt;div&gt; que está en el &lt;body&gt;. Si ponemos un escuchador del evento click a todos ellos se ejecutarán todos ellos, pero ¿en qué orden?.\nPues el W3C establecíó un modelo en el que primero se disparan los eventos de fuera hacia dentro (primero el &lt;body&gt;) y al llegar al más interno (el &lt;span&gt;) se vuelven a disparar de nuevo pero de dentro hacia afuera. La primera fase se conoce como fase de captura y la segunda como fase de burbujeo (bubbling). Cuando ponemos un escuchador con addEventListener el tercer parámetro indica en qué fase debe dispararse:\n\ntrue: en fase de captura\nfalse (valor por defecto): en fase de burbujeo\n\nPor tanto, por defecto se disparará el escuchador más interno (el del &lt;span&gt;) y continuará el resto hasta el más externo (&lt;body&gt;) como si fuera una burbuja que sale afuera desde el interior.\nPodéis ver un ejemplo en:\n\nSin embargo si al método .addEventListener le pasamos un tercer parámetro con el valor true el comportamiento será el contrario, lo que se conoce como captura y el primer escuchador que se ejecutará es el del &lt;body&gt; y el último el del &lt;span&gt; (podéis probarlo añadiendo ese parámetro a los escuchadores del ejemplo anterior).\nEn cualquier momento podemos evitar que se siga propagando el evento ejecutando el método .stopPropagation() en el código de cualquiera de los escuchadores.\nPodéis ver las distintas fases de un evento en la página domevents.dev.\ninnerHTML y escuchadores de eventos\nComo los escuchadores de eventos se asocian a un elemento, si lo borramos desaparecerá el escuchador aunque luego lo volvamos a pintar no tendrá escuchador a menos que se lo pongamos de nuevo.\nPor ejemplo, si cambiamos el contenido de la propiedad innerHTML de un elemento todos los escuchadores de eventos de sus elementos hijos desaparecen ya que es como eliminar su contenido y volverlo a renderizar.\nEso pasaría en este ejemplo en que tenemos una tabla de datos donde al hacer dobleclick en cada fila se muestra su id. La función que añade una nueva fila podría ser:\nfunction renderNewRow(data) {\nlet miTabla = document.getElementById('tabla-datos');\nlet nuevaFila = `&lt;tr id=&quot;${data.id}&quot;&gt;&lt;td&gt;${data.dato1}&lt;/td&gt;&lt;td&gt;${data.dato2}...&lt;/td&gt;&lt;/tr&gt;`;\nmiTabla.innerHTML += nuevaFila;\ndocument.getElementById(data.id).addEventListener('dblclick', event =&gt; alert('Id: '+ event.target.id));\n\nSin embargo así sólo la última fila añadida tendría escuchador ya que la línea miTabla.innerHTML += nuevaFila borra todo el contenido de myTabla y lo vuelve a renderizar pero ya no tendría escuchadores, excepto el de nuevaFila que lo ponemos después de renderizarlo.\nLa forma correcta de hacerlo sería:\nfunction renderNewRow(data) {\nlet miTabla = document.getElementById('tabla-datos');\nlet nuevaFila = document.createElement('tr');\nnuevaFila.id = data.id;\nnuevaFila.innerHTML = `&lt;td&gt;${data.dato1}&lt;/td&gt;&lt;td&gt;${data.dato2}...&lt;/td&gt;`;\nnuevaFila.addEventListener('dblclick', event =&gt; alert('Id: ' + event.target.id) );\nmiTabla.appendChild(nuevaFila);\n\nDe esta forma además mejoramos el rendimiento ya que el navegador sólo tiene que renderizar el nodo correspondiente a la nuevaFila y no todas las filas de la tabla como pasaba con el primer código.\nDelegación de eventos\nEs un patrón de diseño que nos permite no tener que poner un escuchador a cada elemento sino uno global que haga el trabajo de todos.\nPor ejemplo si queremos escuchar cuándo hacemos click en cada celda de la tabla en lugar de poner un escuchador en cada una (que podría tener cientos) pongo sólo 1 en la tabla y mediante la propiedad event.target puedo saber sobre qué celda en concreto se ha hecho click. Esto además seguirá funcionando si dinámicamente añado nuevas celdas a la tabla ya que no son ellas las que tienen el escuchador sino la propia tabla.\nNOTA: ten en cuenta que a veces el evento se produce en alguna etiqueta interna al elemento por lo que event.target no sería el elemento que buscamos sino su descendiente. Por ejemplo si hay una imagen en la celda el event.target podría ser la &lt;img&gt; y no la &lt;td&gt;. Para asegurarnos de llegar al elemento deseado podemos usar el selector closest() que vimos en el DOM (tdClicked = event.target.closest('td')).\nPodéis ver más ejemplos de delegación de eventos en El Tutorial de JavaScript Moderno.\nEventos personalizados\nTambién podemos mediante código lanzar manualmente cualquier evento sobre un elemento con el método dispatchEvent() e incluso crear eventos personalizados, por ejemplo:\nconst event = new Event('build');\n\n// Listen for the event.\nelem.addEventListener('build', (e) =&gt; { /* ... */ });\n\n// Dispatch the event.\nelem.dispatchEvent(event);\n\nIncluso podemos añadir datos al objeto event si creamos el evento con new CustomEvent(). Podéis obtener más información en la página de MDN.",
		"tags": [ "note"]
},

{
		"title": "07-globales",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/07-globales/",
		"content": "==",
		"tags": [ "note"]
},

{
		"title": "08-forms",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/08-forms/",
		"content": "Validación de formularios\nÍndice:\n\nValidación de formularios\n\nIntroducción\n\nValidación del navegador incorporada en HTML5\nValidación mediante la API de validación de formularios\n\nEjemplo\n\nyup\n\nExpresiones regulares\n\nPatrones\nMétodos\n\nIntroducción\nEn este tema vamos a ver cómo realizar una de las acciones principales de Javascript que es la validación de formularios en el lado cliente.\nSe trata de una verificación útil porque evita enviar datos al servidor que sabemos que no son válidos pero NUNCA puede sustituir a la validación en el lado servidor ya que en el lado cliente se puede manipular el código desde la consola para que se salte las validaciones que le pongamos.\nPodéis encontrar una guía muy completa de validación de formularios en el lado cliente el la página de MDN web docs que ha servido como base para estos apuntes.\nAdemás, al final de este tema, veremos una pequeña introducción a las expresiones regulares en Javascript.\nBásicamente tenemos 2 maneras de validar un formulario en el lado cliente:\n\nusar la validación incorporada en HTML5 y dejar que sea el navegador quien se encargue de todo\nrealizar nosotros la validación mediante Javascript\n\nLa ventaja de la primera opción es que no tenemos que escribir código sino simplemente poner unos atributos a los INPUT que indiquen qué se ha de validar. La principal desventaja es que no tenemos ningún control sobre el proceso, lo que provocará cosas como:\n\nel navegador valida campo a campo: cuando encuentra un error en un campo lo muestra y hasta que no se soluciona no valida el siguiente lo que hace que el proceso sea molesto para el usuario que no ve todo lo que hay mal de una vez\nlos mensajes son los predeterminados del navegador y en ocasiones pueden no ser muy claros para el usuario\nlos mensajes se muestran en el idioma en que está configurado el navegador, no en el de nuestra página\n\nValidación del navegador incorporada en HTML5\nFunciona añadiendo atributos a los campos del formulario que queremos validar. Los más usados son:\n\nrequired: indica que el campo es obligatorio. La valdación fallará si no hay nada escrito en el input. En el caso de un grupo de radiobuttons se pone sobre cualquiera de ellos (o sobre todos) y obliga a que haya seleccionada una opción cualquiera del grupo\npattern: obliga a que el contenido del campo cumpla la expresión regular indicada. Por ejemplo para un código postal sería pattern=&quot;^[0-9]{5}$&quot;\nminlength / maxlength: indica la longitud mínima/máxima del contenido del campo\nmin / max: indica el valor mínimo/máximo del contenido de un campo numérico\n\nTambién producen errores de validación si el contenido de un campo no se adapta al type indicado (email, number, ...) o si el valor de un campo numérico no cumple con el step indicado.\nCuando el contenido de un campo es valido dicho campo obtiene automáticamente la pseudoclase :valid y si no lo es tendrá la pseudoclase :invalid lo que nos permite poner reglas en nuestro CSS para destacar dichos campos, por ejemplo:\ninput:invalid {\nborder: 2px dashed red;\n}\n\nAdemás de las anteriores tenemos las pseudoclases :required, :optional, que nos permiten poner reglas de estilo a los campos obligatorios o no, y :focus para el campo con el foco.\nLa validación del navegador se realiza al enviar el formulario. Si encuentra un error lo muestra, se detiene la validación del resto de campos y no se envía el formulario.\nValidación mediante la API de validación de formularios\nMediante Javscript tenemos acceso a todos los campos del formulario por lo que podemos hacer la validación como queramos, pero es una tarea pesada, repetitiva y que provoca código spaguetti difícil de leer y mantener más adelante.\nPara hacerla más simple podemos usar la API de validación de formularios de HTML5 que permite que sea el navegador quien se encargue de comprobar la validez de cada campo pero las acciones (mostrar mensajes de error, no enviar el formulario, ...) las realizamos desde Javascript.\nEsto nos da la ventaja de:\n\nlos requisitos de validación de cada campo están como atributos HTML de dicho campo por lo que son fáciles de ver\nnos evitamos la mayor parte del código dedicada a comprobar si el contenido del campo es válido. Nosotros mediante la API sólo preguntamos si se cumplen o no y tomamos las medidas adecuadas\naprovechamos las pseudo-clases :valid o :invalid que el navegador pone automáticamente a los campos por lo que no tenemos que añadirles clases para desacarlos\n\nLas principales propiedades y métodos que nos proporciona esta API son:\n\ncheckValidity(): método booleano que nos dice si el campo al que se aplica es o no válido. También se puede aplicar al formulario para saber si es válido o no\nvalidationMessage: en caso de que un campo no sea válido esta propiedad contiene el texto del error de validación proporcionado por el navegador. Si es válido esta propiedad es una cadena vacía\nsetCustomValidity(mensaje): añade un error personalizado al campo (que ahora ya NO será válido para el navegador) con el mensaje pasado como parámetro. Por ejemplo podemos usarlo para indicar que el nick elegido no es válido porque ya está en uso por otro usuario. Para quitar este error se hace setCustomValidity('')\nvalidity: es un objeto que tiene propiedades booleanas para saber qué requisito del campo es el que falla:\n\nvalueMissing: indica si no se cumple el atributo required (es decir, valdrá true si el campo tiene el atributo required pero no se ha introducido nada en él)\ntypeMismatch: indica si el contenido del campo no cumple con su atributo type (ej. type=&quot;email&quot;)\npatternMismatch: indica si no se cumple con el pattern indicado en su atributo\ntooShort / tooLong: indican si no se cumple el atributo minlength o maxlength respectivamente\nrangeUnderflow / rangeOverflow: indica si no se cumple el atributo min / max\nstepMismatch: indica si no se cumple el atributo step del campo\ncustomError: indica al campo se le ha puesto un error personalizado con setCustomValidity\nvalid: indica si es campo es válido\n\n...\n\nEn la página de W3Schools podéis ver algún ejemplo básico de esto. También a continuación tenéis un ejemplo simple del valor de las diferentes propiedades involucradas en la validación de un campo de texto que es obligatorio y cuyo tamaño debe estar entre 5 y 50 caracteres:\n\nPara validar un formulario nosotros pero usando esta API debemos añadir a la etiqueta &lt;form&gt; el atributo novalidate que hace que no se encargue el navegador de mostrar los mensajes de error ni de decidir si se envía o no el formulario (aunque sí valida los campos) sino que lo haremos nosotros.\nEjemplo\nUn ejemplo sencillo de validación de un formulario podría ser:\n\nindex.html\n\n&lt;form novalidate&gt;\n&lt;label for=&quot;nombre&quot;&gt;Por favor, introduzca su nombre (entre 5 y 50 caracteres): &lt;/span&gt;\n&lt;input type=&quot;text&quot; id=&quot;nombre&quot; name=&quot;nombre&quot; required minlength=&quot;5&quot; maxlength=&quot;50&quot;&gt;\n&lt;span class=&quot;error&quot;&gt;&lt;/label&gt;\n&lt;br /&gt;\n&lt;label for=&quot;mail&quot;&gt;Por favor, introduzca una dirección de correo electrónico: &lt;/label&gt;\n&lt;input type=&quot;email&quot; id=&quot;mail&quot; name=&quot;mail&quot; required minlength=&quot;8&quot;&gt;\n&lt;span class=&quot;error&quot;&gt;&lt;/span&gt;\n&lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;\n&lt;/form&gt;\n\nmain.js\n\nconst form = document.getElementsByTagName('form')[0];\n\nconst nombre = document.getElementById('nombre');\nconst nombreError = document.querySelector('#nombre + span.error');\nconst email = document.getElementById('mail');\nconst emailError = document.querySelector('#mail + span.error');\n\nform.addEventListener('submit', (event) =&gt; {\nif(!form.checkValidity()) {\nevent.preventDefault();\n}\nnombreError.textContent = nombre.validationMessage;\nemailError.textContent = email.validationMessage;\n});\n\nstyle.css\n\n.error {\ncolor: red;\n}\n\ninput:invalid {\nborder: 2px dashed red;\n}\n\nEstamos usando\n\nvalidationMessage para mostrar el posible error de cada campo, o quitar el error cuando el campo sea válido\ncheckValidity() para no enviar/procesar el formulario si contiene errores\n\nSi no nos gusta el mensaje del navegador y queremos personalizarlo podemos hacer una función que reciba un &lt;input&gt; y usando su propiedad validity devuelva un mensaje en función del error detectado:\nfunction customErrorValidationMessage(input) {\nif (input.checkValidity()) {\nreturn ''\n}\nif (input.validity.valueMissing) {\nreturn 'Este campo es obligatorio'\n}\nif (input.validity.tooShort) {\nreturn `Debe tener al menos ${input.minLength} caracteres`\n}\n// Y seguiremos comprobando cada atributo que hayamos usado en el HTML\nreturn 'Error en el campo' // por si se nos ha olvidado comprobar algo\n}\n\nY ahora en vez de nombreError.textContent = nombre.validationMessage haremos nombreError.textContent = customErrorValidationMessage(nombre).\nSi tenemos que validar algo que no puede hacerse mediante atributos HTML (por ejemplo si el nombre de usuario ya está en uso) deberemos hacer la validación &quot;a mano&quot; y en caso de no ser válido ponerle un error con .setCustomValidity(), pero debemos recordar quitar el error si todo es correcto o el formulario siempre será inválido. Modificando el ejemplo:\nconst nombre = document.getElementById('nombre');\nconst nombreError = document.querySelector('#nombre + span.error');\n\nform.addEventListener('submit', (event) =&gt; {\nif (nombreEnUso(nombre.value)) {\nnombre.setCustomValidity('Ese nombre de usuario ya está en uso')\n} else {\nnombre.setCustomValidity('') // Se quita el error personalizado\n}\n\nif(!form.checkValidity()) {\n...\n}\n})\n\nFicheros en formularios\nHay infinidad de páginas donde poder consultar cómo validar ficheros e imágenes en un formulario. Os recomiendo:\n\nCurso DWEC de José Castillo\nw3schools\ndeveloper.mozilla.org.\n\nyup\nExisten múltiples librerías que facilitan enormenmente el tedioso trabajo de validar un formulario. Un ejemplo es yup.\nExpresiones regulares\nLas expresiones regulares permiten buscar un patrón dado en una cadena de texto. Se usan mucho a la hora de validar formularios o para buscar y reemplazar texto. En Javascript se crean poniéndolas entre caracteres / (o instanciándolas de la clase RegExp, aunque es mejor de la otra forma):\nlet cadena='Hola mundo';\nlet expr=/mundo/;\nexpr.test(cadena); // devuelve true porque en la cadena se encuentra la expresión 'mundo'\n\nPatrones\nLa potencia de las expresiones regulares es que podemos usar patrones para construir la expresión. Los más comunes son:\n\n[..] (corchetes): dentro se ponen varios caracteres o un rango y permiten comprobar si el carácter de esa posición de la cadena coincide con alguno de ellos. Ejemplos:\n\n[abc]: cualquier carácter de los indicados ('a' o 'b' o 'c')\n[^abc]: cualquiera excepto los indicados\n[a-z]: cualquier minúscula (el carácter '-' indica el rango entre 'a' y 'z', incluidas)\n[a-zA-Z]: cualquier letra\n\n( | ) (pipe): debe coincidir con una de las opciones indocadas:\n\n(x|y): la letra x o la y (sería equivalente a [xy]\n(http|https): cualquiera de las 2 palabras\n\nMetacaracteres:\n\n. (punto): un único carácter, sea el que sea\n\\d: un dígito (\\D: cualquier cosa menos dígito)\n\\s: espacio en blanco (\\S: lo opuesto)\n\\w: una palabra o carácter alfanumérico (\\W lo contrario)\n\\b: delimitador de palabra (espacio, ppio, fin)\n\\n: nueva línea\n\nCuantificadores:\n\n+: al menos 1 vez (ej. [0-9]+ al menos un dígito)\n*: 0 o más veces\n?: 0 o 1 vez\n{n}: n caracteres (ej. [0-9]{5} = 5 dígitos)\n{n,}: n o más caracteres\n{n,m}: entre n y m caracteres\n^: al ppio de la cadena (ej.: ^[a-zA-Z] = empieza por letra)\n$: al final de la cadena (ej.: [0-9]$ = que acabe en dígito)\n\nModificadores:\n\n/i: que no distinga entre Maysc y minsc (Ej. /html/i = buscará html, Html, HTML, ...)\n/g: búsqueda global, busca todas las coincidencias y no sólo la primera\n/m: busca en más de 1 línea (para cadenas con saltos de línea)\n\nEJERCICIO: contruye una expresión regular para lo que se pide a continuación y pruébala con distintas cadenas:\n\nun código postal\nun NIF formado por 8 números, un guión y una letra mayúscula o minúscula\nun número de teléfono y aceptamos 2 formatos: XXX XX XX XX o XXX XXX XXX. EL primer número debe ser un 6, un 7, un 8 o un 9\n\nMétodos\nLos usaremos para saber si la cadena coincide con determinada expresión o para buscar y reemplazar texto:\n\nexpr.test(cadena): devuelve true si la cadena coincide con la expresión. Con el modificador /g hará que cada vez que se llama busque desde la posición de la última coincidencia. Ejemplo:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/g;\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime false, hay solo dos coincidencias\n\nlet reg2 = /am/gi; // ahora no distinguirá mayúsculas y minúsculas\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true. Ahora tenemos 3 coincidencias con este nuevo patrón\n\nexpr.exec(cadena): igual pero en vez de true o false devuelve un objeto con la coincidencia encontrada, su posición y la cadena completa:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/gi;\nconsole.log(reg.exec(str)); // Imprime [&quot;am&quot;, index: 2, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime [&quot;am&quot;, index: 5, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime [&quot;Am&quot;, index: 15, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime null\n\ncadena.match(expr): igual que exec pero se aplica a la cadena y se le pasa la expresión. Si ésta tiene el modificador /g devolverá un array con todas las coincidencis:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/gi;\nconsole.log(str.match(reg)); // Imprime [&quot;am&quot;, &quot;am&quot;, &quot;Am&quot;}\n\ncadena.search(expr): devuelve la posición donde se encuentra la coincidencia buscada o -1 si no aparece\ncadena.replace(expr, cadena2): devuelve una nueva cadena xon las coincidncias de la cadena reemplazadas por la cedena pasada como 2º parámetro:\n\nlet str = &quot;I am amazed in America&quot;;\nconsole.log(str.replace(/am/gi, &quot;xx&quot;)); // Imprime &quot;I xx xxazed in xxerica&quot;\n\nconsole.log(str.replace(/am/gi, function(match) {\nreturn &quot;-&quot; + match.toUpperCase() + &quot;-&quot;;\n})); // Imprime &quot;I -AM- -AM-azed in -AM-erica&quot;\n\nNo vamos a profundizar más sobre las expresiones regulares. Es muy fácil encontrar por internet la que necesitemos en cada caso (para validar un e-mail, un NIF, un CP, ...). Podemos aprender más en:\n\nw3schools\nregular-expressions.info\nhtml5pattern atributo\ny muchas otras páginas\n\nTambién, hay páginas que nos permiten probar expresiones regulares con cualquier texto, como regexr.",
		"tags": [ "note"]
},

{
		"title": "09-ajax",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/09-ajax/",
		"content": "Ajax\n\nAjax\n\nIntroducción\n\nMétodos HTTP\nJson Server\nREST client\n\nEl objeto XMLHttpRequest\n\nEventos de XMLHttpRequest\nEjemplos de envío de datos\n\nEnviar datos al servidor en formato JSON\nEnviar datos al servidor en formato URIEncoded\nEnviar ficheros al servidor con FormData\n\nCallbakcs, Promesas y Async/Await\n\nSi Ajax fuera síncrono...\nSolución mala\nAlgo mejor: Funciones callback\nSolución buena: Promesas\nLa mejor solución: usar Async/Await\n\nfetch\n\nPropiedades y métodos de la respuesta de fetch\nGestión de errores con fetch\nOtros métodos de petición con fetch\n\nHacer varias peticiones simultáneamente. Promise.all\nOrganizar bien el código\n\nEl fichero .env\nDistintas peticiones, distintos ficheros\n\nSingle Page Application\nResumen de llamadas asíncronas\nCORS\n\nIntroducción\nAJAX es el acrónimo de Asynchronous Javascript And XML (Javascript asíncrono y XML) y es lo que usamos para hacer peticiones asíncronas al servidor desde Javascript. Cuando hacemos una petición al servidor no nos responde inmediatamente (la petición tiene que llegar al servidor, procesarse allí y enviarse la respuesta que llegará al cliente).\nLo que significa asíncrono es que la página no permanecerá bloqueada esperando esa respuesta sino que continuará ejecutando su código e interactuando con el usuario, y en el momento en que llegue la respuesta del servidor se ejecutará la función que indicamos al hacer la llamada Ajax. Respecto a XML, es el formato en que se intercambia la información entre el servidor y el cliente, aunque actualmente el formato más usado es JSON que es más simple y legible.\nBásicamente Ajax nos permite poder mostrar nuevos datos enviados por el servidor sin tener que recargar la página, que continuará disponible mientras se reciben y procesan los datos enviados por el servidor en segundo plano.\n\nSin Ajax cada vez que necesitamos nuevos datos del servidor la página deja de estar disponible para el usuario hasta que se recarga con lo que envía el servidor. Con Ajax la página está siempre disponible para el usuario y simplemente se modifica (cambiando el DOM) cuando llegan los datos del servidor:\n\nFuente Uniwebsidad\nMétodos HTTP\nLas peticiones Ajax usan el protocolo HTTP (el mismo que utiliza el navegador para cargar una página). Este protocolo envía al servidor unas cabeceras HTTP (con información como el userAgent del navegador, el idioma, etc), el tipo de petición y, opcionalmente, datos o parámetros (por ejemplo en la petición que procesa un formulario se envían los datos del mismo).\nHay diferentes tipos de petición que podemos hacer:\n\nGET: suele usarse para obtener datos sin modificar nada (equivale a un SELECT en SQL). Si enviamos datos (ej. la ID del registro a obtener) suelen ir en la url de la petición (formato URIEncoded). Ej.: locahost/users/3, https://jsonplaceholder.typicode.com/users o www.google.es?search=js\nPOST: suele usarse para añadir un dato en el servidor (equivalente a un INSERT). Los datos enviados van en el cuerpo de la petición HTTP (igual que sucede al enviar desde el navegador un formulario por POST)\nPUT: es similar al POST pero suele usarse para actualizar datos del servidor (como un UPDATE de SQL). Los datos se envían en el cuerpo de la petición (como en el POST) y la información para identificar el objeto a modificar en la url (como en el GET). El servidor hará un UPDATE sustituyendo el objeto actual por el que se le pasa como parámetro\nPATCH: es similar al PUT pero la diferencia es que en el PUT hay que pasar todos los campos del objeto a modificar (los campos no pasados se eliminan del objeto) mientras que en el PATCH sólo se pasan los campos que se quieren cambiar y en resto permanecen como están\nDELETE: se usa para eliminar un dato del servidor (como un DELETE de SQL). La información para identificar el objeto a eliminar se envía en la url (como en el GET)\nexisten otros tipos que no veremos aquí (como HEAD, PATCH, etc)\n\nEl servidor acepta la petición, la procesa y le envía una respuesta al cliente con el recurso solicitado y además unas cabeceras de respuesta (con el tipo de contenido enviado, el idioma, etc) y el código de estado. Los códigos de estado más comunes son:\n\n2xx: son peticiones procesadas correctamente. Las más usuales son 200 (ok) o 201 (created, como respuesta a una petición POST satisfactoria)\n3xx: son códigos de redirección que indican que la petición se redirecciona a otro recurso del servidor, como 301 (el recurso se ha movido permanentemente a otra URL) o 304 (el recurso no ha cambiado desde la última petición por lo que se puede recuperar desde la caché)\n4xx: indican un error por parte del cliente, como 404 (Not found, no existe el recurso solicitado) o 401 (Not authorized, el cliente no está autorizado a acceder al recurso solicitado)\n5xx: indican un error por parte del servidor, como 500 (error interno del servidor) o 504 (timeout, el servidor no responde).\n\nEn cuanto a la información enviada por el servidor al cliente normalmente serán datos en formato JSON o XML (cada vez menos usado) que el cliente procesará y mostrará en la página al usuario. También podría ser HTML, texto plano, ...\nEl formato JSON es una forma de convertir un objeto Javascript en una cadena de texto para poderla enviar, por ejemplo el objeto\nlet alumno = {\nid: 5,\nnombre: Marta,\napellidos: Pérez Rodríguez\n}\n\nse transformaría en la cadena de texto\n{ &quot;id&quot;: 5, &quot;nombre&quot;: &quot;Marta&quot;, &quot;apellidos&quot;: &quot;Pérez Rodríguez&quot; }\n\ny el array\nlet alumnos = [\n{\nid: 5,\nnombre: &quot;Marta&quot;,\napellidos: &quot;Pérez Rodríguez&quot;\n},\n{\nid: 7,\nnombre: &quot;Joan&quot;,\napellidos: &quot;Reig Peris&quot;\n},\n]\n\nen la cadena:\n[{ &quot;id&quot;: 5, &quot;nombre&quot;: Marta, &quot;apellidos&quot;: Pérez Rodríguez }, { &quot;id&quot;: 7, &quot;nombre&quot;: &quot;Joan&quot;, &quot;apellidos&quot;: &quot;Reig Peris&quot; }]\n\nPara convertir objetos en cadenas de texto JSON y viceversa Javascript proporciona 2 funciones:\n\nJSON.stringify(objeto): recibe un objeto JS y devuelve la cadena de texto correspondiente. Ej.: const cadenaAlumnos = JSON.stringify(alumnos)\nJSON.parse(cadena): realiza el proceso inverso, convirtiendo una cadena de texto en un objeto. Ej.: const alumnos = JSON.parse(cadenaAlumnos)\n\nEJERCICIO: Vamos a realizar diferentes peticions HTTP a la API https://jsonplaceholder.typicode.com, en concreto trabajaremos contra la tabla todos con tareas para hacer. Las peticiones GET podríamos hacerlas directamente desde el navegador pero para el resto debemos instalar alguna de las extensiones de cliente REST en nuestro navegador. Por tanto instalaremos dicha extensión (por ejemplo Advanced Rest Client para Chrome o Rested para Firefox y haremos todas las peticiones desde allí (incluyendo los GET) lo que nos permitirá ver los códigos de estado devueltos, las cabeceras, etc.\nLo que queremos hacer en este ejercicio es:\n\nobtener todas las tareas (devuelve un array con todas las tareas y el código devuelto será 200 - Ok)\n![GET all](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Ajax-GETall.png)\n\nobtener la tarea con id 55 (devuelve el objeto de la tarea 55 y el código devuelto será 200 - Ok)\n![GET one](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Ajax-GETone.png)\n\nobtener la tarea con id 201 (como no existe devolverá un objeto vacío y como código de error 404 - Not found)\n![GET Non Existent](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Ajax-GETnonExistent.png)\n\ncrear una nueva tarea. En el cuerpo de la petición le pasaremos sus datos: userID: 1, title: Prueba de POST y completed: false. No se le pasa la id (de eso se encarga la BBDD). La respuesta debe ser un código 201 (created) y el nuevo registro creado con todos sus datos incluyendo la id. Como es una API de prueba en realidad no lo está añadiendo a la BBDD por lo que si luego hacemos una petición buscando esa id nos dirá que no existe.\n![POST](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Ajax-POST.png)\n\nmodificar con un PATCH la tarea con id 55 para que su title sea 'Prueba de POST'. Devolverá el nuevo registro con un código 200. Como veis al hacer un PATCH los campos que no se pasan se mantienen como estaban\n![PATCH](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Ajax-PATCH.png)\n\nmodificar con un PUT la tarea con id 55 para que su title sea 'Prueba de POST'. Devolverá el nuevo registro con un código 200. Como veis en esta API los campos que no se pasan se eliminan; en otras los campos no pasados se mantienen como estaban\n![PUT](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Ajax-PUT.png)\n\neliminar la tarea con id 55. Como veis esta API devuelve un objeto vacío al eliminar; otras devuelven el objeto eliminado\n![DELETE](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Ajax-DELETE.png)\n\nJson Server\nLas peticiones Ajax se hacen a un servidor que proporcione una API. Como ahora no tenemos ninguno podemos utilizar Json Server que es un servidor API-REST que funciona bajo Node.js (que ya tenemos instalado para usar NPM) y que utiliza un fichero JSON como contenedor de los datos en lugar de una base de datos.\nPara instalarlo en nuestra máquina (lo instalaremos global para poderlo usar en todas nuestras prácticas) ejecutamos:\nnpm install -g json-server\n\nPara que sirva un fichero datos.json:\njson-server datos.json\n\nLe podemos poner la opción --watch ( o -w) para que actualice los datos si se modifica el fichero .json externamente (si lo editamos).\nEl fichero datos.json será un fichero que contenga un objeto JSON con una propiedad para cada &quot;tabla&quot; de nuestra BBDD. Por ejemplo, si queremos simular una BBDD con las tablas users y posts vacías el contenido del fichero será:\n{\n&quot;users&quot;: [],\n&quot;posts&quot;: []\n}\n\nLa API escucha en el puerto 3000 y servirá los diferentes objetos definidos en el fichero .json. Por ejemplo:\n\nhttp://localhost:3000/users: devuelve un array con todos los elementos de la tabla users del fichero .json\nhttp://localhost:3000/users/5: devuelve un objeto con el elemento de la tabla users cuya propiedad id valga 5\n\nTambién pueden hacerse peticiones más complejas como:\n\nhttp://localhost:3000/users?rol=3: devuelve un array con todos los elementos de users cuya propiedad rol valga 3\n\nPara más información: https://github.com/typicode/json-server.\nSi queremos acceder a la API desde otro equipo (no desde localhost) tenemos que indicar la IP de la máquina que ejecuta json-server y que se usará para acceder, por ejemplo si vamos a ejecutarlo en la máquina 192.168.0.10 pondremos:\njson-server --host 192.168.0.10 datos.json\n\nY la ruta para acceder a la API será http://192.168.0.10:3000.\n\nEJERCICIO: instalar json-server en tu máquina. Ejecútalo indicando un nombre de fichero que no existe: como verás crea un fichero json de prueba con 3 tablas: posts, comments y profiles. Ábrelo en tu navegador para ver los datos\n\nREST client\nPara probar las peticiones GET podemos poner la URL en la barra de direcciones del navegador pero para probar el resto de peticiones debemos instalar en nuestro navegador una extensión que nos permita realizar las peticiones indicando el método a usar, las cabeceras a enviar y los datos que enviaremos a servidor, además de la URL.\nExisten multitud de aplicaciones para realizar peticiones HTTP, como Advanced REST client. Cada navegador tiene sus propias extensiones para hacer esto, como Advanced Rest Client para Chrome o RestClient para Firefox.\nEl objeto XMLHttpRequest\nHasta ahora hemos hecho un repaso a lo que es el protocolo HTTP. Ahora que lo tenemos claro y hemos instalado un servidor que nos proporciona una API (json-server) vamos a realizar peticiones HTTP en nuestro código javascript usando Ajax.\nPara hacer una petición debemos crear una instancia del objeto XMLHttpRequest que es el que controlará todo el proceso. Los pasos a seguir son:\n\nCreamos la instancia del objeto: const peticion=new XMLHttpRequest()\nPara establecer la comunicación con el servidor ejecutamos el método .open() al que se le pasa como parámetro el tipo de petición (GET, POST, ...) y la URL del servidor: peticion.open('GET', 'https://jsonplaceholder.typicode.com/users')\nOPCIONAL: Si queremos añadir cabeceras a la petición HTTP llamaremos al método .setRequestHeader(). Por ejemplo si enviamos datos con POST hay que añadir la cabecera Content-type que le indica al servidor en qué formato van los datos: peticion.setRequestHeader('Content-type', 'application/x-www-form-urlencoded)\nEnviamos la petición al servidor con el método .send(). A este método se le pasa como parámetro los datos a enviar al servidor en el cuerpo de la petición (si es un POST, PUT o PATCH le pasaremos una cadena de texto con los datos a enviar: peticion.send('dato1='+encodeURIComponent(dato1)+'&amp;dato2='+encodeURIComponent(dato2))). Si es una petición GET o DELETE no le pasaremos datos (peticion.send())\nPonemos un escuchador al objeto peticion para saber cuándo está disponible la respuesta del servidor\n\nEventos de XMLHttpRequest\nTenemos diferentes eventos que el servidor envía para informarnos del estado de nuestra petición y que nosotros podemos capturar. El evento readystatechange se produce cada vez que el servidor cambia el estado de la petición. Cuando hay un cambio en el estado cambia el valor de la propiedad readyState de la petición. Sus valores posibles son:\n\n0: petición no iniciada (se ha creado el objeto XMLHttpRequest)\n1: establecida conexión con el servidor (se ha hecho el open)\n2: petición recibida por el servidor (se ha hecho el send)\n3: se está procesando la petición\n4: petición finalizada y respuesta lista (este es el evento que nos interesa porque ahora tenemos la respuesta disponible)\nA nosotros sólo nos interesa cuando su valor sea 4 que significa que ya están los datos. En ese momento la propiedad status contiene el estado de la petición HTTP (200: Ok, 404: Not found, 500: Server error, ...) que ha devuelto el servidor. Cuando readyState vale 4 y status vale 200 tenemos los datos en la propiedad responseText (o responseXML si el servidor los envía en formato XML).\n\nEl siguiente ejemplo nos enseña cómo se producen los distintos eventos en una petición asíncrona:\nconst peticion = new XMLHttpRequest();\nconsole.log(&quot;Estado inicial de la petición: &quot; + peticion.readyState);\npeticion.open('GET', 'https://jsonplaceholder.typicode.com/users');\nconsole.log(&quot;Estado de la petición tras el 'open': &quot; + peticion.readyState);\npeticion.send();\nconsole.log(&quot;Petición hecha&quot;);\npeticion.addEventListener('readystatechange', function() {\nconsole.log(&quot;Estado de la petición: &quot; + peticion.readyState);\nif (peticion.readyState === 4) {\nif (peticion.status === 200) {\nconsole.log(&quot;Datos recibidos:&quot;);\nlet usuarios = JSON.parse(peticion.responseText); // Convertirmos los datos JSON a un objeto\nconsole.log(usuarios);\n} else {\nconsole.log(&quot;Error &quot; + peticion.status + &quot; (&quot; + peticion.statusText + &quot;) en la petición&quot;);\n}\n}\n})\nconsole.log(&quot;Petición acabada&quot;);\n\nEl resultado de ejecutar ese código es el siguiente:\n![Ejemplo 1: consola](/img/user/01 Apuntes/Javascript Teoria Batoi/img/ajax-ej1.png)\nFijaos cuándo cambia de estado (readyState) la petición:\n\nvale 0 al crear el objeto XMLHttpRequest\nvale 1 cuando abrimos la conexión con el servidor\nluego se envía al servidor y es éste el que va informando al cliente de cuándo cambia su estado\n\nMUY IMPORTANTE: notad que la última línea ('Petición acabada') se ejecuta antes que las de 'Estado de la petición'. Recordad que es una petición asíncrona y la ejecución del programa continúa sin esperar a que responda el servidor.\nComo normalmente no nos interesa cada cambio en el estado de la petición sino que sólo queremos saber cuándo ha terminado de procesarse tenemos otros eventos que nos pueden ser de utilidad:\n\nload: se produce cuando se recibe la respuesta del servidor. Equivale a readyState===4. En status tendremos el estado de la respuesta\nerror: se produce si sucede algún error al procesar la petición (de red, de servidor, ...)\ntimeout: si ha transcurrido el tiempo indicado y no se ha recibido respuesta del servidor. Podemos cambiar el tiempo por defecto modificando la propiedad timeout antes de enviar la petición\nabort: si se cancela la petición (se hace llamando al método .abort() de la petición)\nloadend: se produce siempre que termina la petición, independientemente de si se recibe respuesta o sucede algún error (incluyendo un timeout o un abort)\n\nEste es un ejemplo de código que sí podríamos usar para este tipo de peticiones:\nconst peticion=new XMLHttpRequest();\npeticion.open('GET', 'https://jsonplaceholder.typicode.com/users');\npeticion.send();\npeticion.addEventListener('load', function() {\nif (peticion.status===200) {\nlet usuarios=JSON.parse(peticion.responseText);\n// procesamos los datos que tenemos en usuarios\n} else {\nmuestraError(peticion);\n}\n})\npeticion.addEventListener('error', muestraError);\npeticion.addEventListener('abort', muestraError);\npeticion.addEventListener('timeout', muestraError);\n\nfunction muestraError(peticion) {\nif (peticion.status) {\nconsole.log(&quot;Error &quot;+peticion.status+&quot; (&quot;+peticion.statusText+&quot;) en la petición&quot;);\n} else {\nconsole.log(&quot;Ocurrió un error o se abortó la conexión&quot;);\n}\n}\n\nRecuerda que tratamos con peticiones asíncronas por lo que tras la línea\npeticion.addEventListener('load', function() {\n\nno se ejecuta la línea siguiente\nif (peticion.status===200) {\n\nsino la de\npeticion.addEventListener('error', muestraError);\n\nUna petición asíncrona es como pedir una pizza: tras llamar por teléfono lo siguiente no es ir a la puerta a recogerla sino que seguimos haciendo cosas por casa y cuando suena el timbre de casa entonces vamos a la puerta a por ella.\nEjemplos de envío de datos\nPodemos enviar datos al servidor en el cuerpo de la petición http. Siempre deberemos indicar en una cabecera de la petición en qué formato enviamos los datos y en función de dicho formato se hace la petición de diferente manera.\nVamos a ver algunos ejemplos de envío de datos al servidor con POST. Supondremos que tenemos una página con un formulario para dar de alta nuevos productos:\n&lt;form id=&quot;addProduct&quot;&gt;\n&lt;label for=&quot;name&quot;&gt;Nombre: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;descrip&quot;&gt;Descripción: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;descrip&quot; id=&quot;descrip&quot; required&gt;&lt;br&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Añadir&lt;/button&gt;\n&lt;/form&gt;\n\nEnviar datos al servidor en formato JSON\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst newProduct={\nname: document.getElementById(&quot;name&quot;).value,\ndescrip: document.getElementById(&quot;descrip&quot;).value,\n}\nconst peticion=new XMLHttpRequest();\npeticion.open('POST', 'https://localhost/products');\npeticion.setRequestHeader('Content-type', 'application/json'); // Siempre tiene que estar esta línea si se envían datos\npeticion.send(JSON.stringify(newProduct)); // Hay que convertir el objeto a una cadena de texto JSON para enviarlo\npeticion.addEventListener('load', function() {\n// procesamos los datos\n...\n})\n})\n\nPara enviar el objeto hay que convertirlo a una cadena JSON con la función JSON.stringify(). Siempre que enviamos datos al servidor debemos decirle el formato que tienen en la cabecera de Content-type:\npeticion.setRequestHeader('Content-type', 'application/json');\n\nEnviar datos al servidor en formato URIEncoded\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst name=document.getElementById(&quot;name&quot;).value;\nconst descrip=document.getElementById(&quot;descrip&quot;).value;\n\nconst peticion=new XMLHttpRequest();\npeticion.open('GET', 'https://localhost/products');\npeticion.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\npeticion.send('name='+encodeURIComponent(name)+'&amp;descrip='+encodeURIComponent(descrip));\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nEn este caso los datos se envían como hace el navegador por defecto en un formulario. Recordad siempre codificar lo que introduce el usuario para evitar problemas con caracteres no estándar y ataques SQL Injection u otros.\nEnviar ficheros al servidor con FormData\nFormData es una interfaz de XMLHttpRequest que permite construir fácilmente pares de clave=valor para enviar los datos de un formulario. Se envían en el mismo formato en que se enviarían directamente desde un formulario (&quot;multipart/form-data&quot;) por lo que no hay que poner encabezado de 'Content-type'.\nDe esta manera podemos enviar ficheros al servidor, no sólo valores de texto.\nVamos a añadir al formulario un campo donde el usuario pueda subir la foto del producto:\n&lt;form id=&quot;addProduct&quot;&gt;\n&lt;label for=&quot;name&quot;&gt;Nombre: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;descrip&quot;&gt;Descripción: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;descrip&quot; id=&quot;descrip&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;photo&quot;&gt;Fotografía: &lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;photo&quot; id=&quot;photo&quot; required&gt;&lt;br&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Añadir&lt;/button&gt;\n&lt;/form&gt;\n\nPodemos enviar al servidor todo el contenido del formulario:\ndocument.getElementById('addProduct').addEventListener('submit', (event) =&gt; {\n...\nconst peticion=new XMLHttpRequest();\nconst datosForm = new FormData(document.getElementById('addProduct'));\n// Automáticamente ha añadido todos los inputs, incluyendo tipo 'file', blob, ...\n// Si quisiéramos añadir algún dato más haríamos:\nformData.append('otrodato', 12345);\n// Y lo enviamos\npeticion.open('POST', 'https://localhost/products');\npeticion.send(datosForm);\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nTambién podemos enviar sólo los campos que queramos:\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst formData=new FormData(); // creamos un formData vacío\nformData.append('name', document.getElementById('name').value);\nformData.append('descrip', document.getElementById('descrip').value);\nformData.append('photo', document.getElementById('photo').files[0]);\n\nconst peticion=new XMLHttpRequest();\npeticion.open('POST', 'https://localhost/products');\npeticion.send(formData);\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nPodéis ver más información de cómo usar formData en MDN web docs.\nCallbakcs, Promesas y Async/Await\nPara ver un ejemplo real de cómo e haría una llamada a Ajax vamos a hacer una página que muestre en una tabla los posts del usuario indicado en un input. En resumen lo que hacemos es:\n\nEl usuario de nuestra aplicación introduce el código del usuario del que queremos ver sus posts\nTenemos un escuchador para que al introducir un código de un usuario llamamos a una función getPosts() que:\n\nSe encarga de hacer la petición Ajax al servidor\nSi se produce un error se encarga de informar al usuario de nuestra aplicación\n\nCuando se reciben los datos del servidor deben pintarse en la tabla\n\nSi Ajax fuera síncrono...\nSi Ajax no fuera una petición asíncrona el código de todo esto será algo como el siguiente (ATENCIÓN, este código NO FUNCIONA):\n\nPero esto no funciona porque el valor de posts siempre es undefined. Esto es porque cuando se llama a getPosts esta función no devuelve nada (por eso posts es undefined) sino que devuelve los datos tiempo después, cuando el servidor contesta, pero entonces ya no hay nadie escuchando.\nSolución mala\nLa solución es que todo el código, no sólo de la petición Ajax sino también el de qué hacer con los datos cuando llegan, se encuentre en la función que pide los datos al servidor:\n\nEste código sí que funcionaría pero tiene una pega: tenemos que tratar los datos (en este caso pintarlos en la tabla) en la función que gestiona la petición porque es la que sabe cuándo están disponibles esos datos. Y sabemos que una función no debería tener 2 responsabilidades diferentes (obtener los datos del servidor y renderizarlos en la página).\nAlgo mejor: Funciones callback\nEsto se podría mejorar usando una función callback. La idea es que creamos una función que procese los datos (renderPosts) y se la pasamos a getPosts para que la llame cuando tenga los datos:\n\nHemos creado una función que se ocupa de renderizar los datos y se la pasamos a la función que gestiona la petición para que la llame cuando los datos están disponibles. Utilizando la función callback hemos conseguido que getPosts() se encargue sólo de obtener los datos y cuando los tenga los pasa a la encargada de pintarlos en la tabla.\nSolución buena: Promesas\nSin embargo hay una forma más limpia de resolver una función asíncrona y que el código se parezca al primero que hicimos que no funcionaba, donde la función getPosts() sólo debía ocuparse de obtener los datos y devolverlos a quien se los pidió. Ese código era:\n...\nlet idUser = document.getElementById('id-usuario').value;\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número');\n} else {\nconst posts = getPosts(idUser);\n// y aquí usamos los datos recibidos, en este caso para pintar los posts\n}\n...\n\nComo dijimos esto NO funciona, a menos que convirtamos a getPosts() en una promesa. Cuando se realiza una llamada a una promesa quien la llama puede usar unos métodos (.then() y .catch()) que NO SE EJECUTARÁN hasta que la promesa se haya resuelto (es decir, hasta que el servidor haya contestado):\n\n.then(_function(datos) { ... }_): se ejecuta cuando la promesa se haya resuelto satisfactoriamente. Su parámetro es una función que recibe como parámetro los datos que haya devuelto la promesa (que serán los datos pedidos al servidor)\n.catch(function(datos) { ... }): se ejecuta cuando se haya rechazado la promesa (si ha fallado, normalmente porque se ha recibido una respuesta errónea del servidor). Esta función recibe como parámetro la información pasada por la promesa al ser rechazada (que será información sobre el error producido).\n\nDe esta manera nuestro código quedaría:\n...\nlet idUser = document.getElementById('id-usuario').value\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número')\n} else {\ngetPosts(idUser)\n.then((posts) =&gt; { // aquí ya tenemos los datos en 'posts'\ntbody.innerHTML = ''\nposts.forEach((post) =&gt; {\nconst newPost = document.createElement('tr')\nnewPost.innerHTML = `\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;`\ntbody.appendChild(newPost)\n})\ndocument.getElementById('num-posts').textContent = posts.length\n})\n// en el .catch() está el tratamiento de errores\n.catch((error) =&gt; console.error(error))\n}\n\nPara convertir a getPosts() en una promesa sólo tenemos que &quot;envolverla&quot; en la instrucción\nreturn new Promise((resolve, reject) =&gt; {\n// Aquí el contenido de GetPosts()\n})\n\nEsto hace que devuelva un objeto de tipo Promise (return new Promise()) cuyo parámetro es una función que recibe 2 parámetros:\n\nresolve: función callback a la que se llamará cuando se resuelva la promesa satisfactoriamente\nreject: función callback a la que se llamará si se resuelve la promesa con errores\n\nEl funcionamiento es:\n\ncuando la promesa se resuelva satisfactoriamente getPosts llama a la función resolve() y le pasa los datos recibidos por el servidor. Esto hace que se ejecute el método then de la llamada a la promesa que recibirá como parámetro esos datos\nsi se produce algún error se rechaza la promesa llamando a la función reject() y pasando como parámetro la información del fallo producido y esto hará que se ejecute el .catch en la función que llamó a la promesa\n\nPor tanto nuestra función getPosts ahora quedará así:\nfunction getPosts(idUser) {\nreturn new Promise((resolve, reject) =&gt; {\nconst peticion = new XMLHttpRequest();\npeticion.open('GET', SERVER + '/posts?userId=' + idUser);\npeticion.send();\npeticion.addEventListener('load', () =&gt; {\nif (peticion.status === 200) {\nresolve(JSON.parse(peticion.responseText));\n} else {\nreject(&quot;Error &quot; + peticion.status + &quot; (&quot; + peticion.statusText + &quot;) en la petición&quot;);\n}\n})\npeticion.addEventListener('error', () =&gt; reject('Error en la petición HTTP'));\n})\n}\n\nFijaos que el único cambio es la primera línea donde convertimos nuestra función en una promesa, y que luego para &quot;devolver&quot; los datos en lugar de hacer un return, que ya hemos visto que no funciona, se hace un resolve si todo ha ido bien o un reject si ha fallado.\nDesde donde llamamos a la promesa nos suscribimos a ella usando los métodos .then() y .catch() que hemos visto anteriormente.\nBásicamente lo que nos van a proporcionar las promesas es un código más claro y mantenible ya que el código a ejecutar cuando se obtengan los datos asíncronamente estará donde se piden esos datos y no en una función escuchadora o en una función callback.\nUtilizando promesas vamos a conseguir que la función que pide los datos sea quien los obtiene y los trate o quien informa si hay un error.\nEl código del ejemplo de los posts usando promesas sería el siguiente:\n\nNOTA: Fijaos que los errores del servidor SIEMPRE llegan a la consola. En el ejemplo anterior me aparecerán 2 veces: la primera que es el error original y la segunda donde lo pinto yo con el console.error.\nPodéis consultar aprender más en MDN web docs.\nLa mejor solución: usar Async/Await\nLas promesas son una mejora respecto a los callbacks pero aún así el código puede ser difícil de leer y mantener. Para solucionar esto se introdujeron en ES2017 las palabras reservadas async y await que permiten escribir código asíncrono de una manera más clara y sencilla.\nLa palabra reservada async se pone delante de una función e indica que esa función va a devolver una promesa. La palabra reservada await se pone delante de una llamada a una promesa y le indica a Javascript que espere a que esa promesa se resuelva antes de continuar con la ejecución del código.\nUsando esto sí funcionaría el primer ejemplo que hicimos:\nlet idUser = document.getElementById('id-usuario').value;\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número');\n} else {\nconst posts = await getPosts(idUser);\n// y aquí SÍ recibimos los datos porque ponemos AWAIT, en este caso para pintar los posts\n}\n\nY la función getPosts() quedaría igual que la que hicimos con promesas.\nAquí el tratamiento de errores se hace con un try/catch:\ntry {\nconst posts = await getPosts(idUser);\n} catch (error) {\nconsole.error(error);\n}\n\nUsando async/await nuestro código se asemeja a un código síncrono ya que no continuan ejecutándose las instrucciones que hay después de un await hasta que esa petición se ha resuelto. Podemos anteponer un await a cualquier llamada a una función asíncrona, como una promesa, un setTimeout, ...\nCualquier función que realice un await pasa a ser asíncrona ya que no se ejecuta al instante toda ella sino que se espera un tiempo. Para indicarlo debemos anteponer la palabra async a su declaración function. Al hacer esto automáticamente se &quot;envuelve&quot; esa función en una promesa (o sea que esa función pasa a devolver una promesa, a la que podríamos ponerle un await o un .then()).\nPodéis ver algunos ejemplos del uso de async / await en la página de MDN.\nfetch\nComo el código a escribir para hacer una petición Ajax es largo y siempre igual, la API Fetch permite realizar una petición Ajax genérica que directamente devuelve una promesa.\nBásicamente lo que hace es encapsular en una función todo el código que se repite siempre en una petición AJAX (crear la petición, hacer el open, el send, escuchar los eventos, ...). La función fetch se similar a la función getPosts que hemos creado antes pero genérica para que sirva para cualquier petición pasándole la URL. Lo que internamente hace es algo similar a:\nfunction fetch(url) {\nreturn new Promise((resolve, reject) =&gt; {\nconst peticion = new XMLHttpRequest();\npeticion.open('GET', url);\npeticion.send();\npeticion.addEventListener('load', () =&gt; {\nresolve(peticion.responseText);\n})\npeticion.addEventListener('error', () =&gt; reject('Network Error'));\n})\n}\n\nFijaos en 2 cosas que cambian respecto a nuestra función getPosts():\n\nfetch devuelve los datos &quot;en crudo&quot; por lo que si la respuesta está en formato JSON habrá con convertirlos. Para ello dispone de un método (.json()) que hace el JSON.parse. Este método devuelve una nueva promesa a la que nos suscribimos con un nuevo .then. Ejemplo.:\n\nfetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser)\n.then(response =&gt; response.json()) // los datos son una cadena JSON\n.then(myData =&gt; { // ya tenemos los datos en _myData_ como un objeto o array\n// Aquí procesamos los datos (en nuestro ejemplo los pintaríamos en la tabla)\nconsole.log(myData)\n})\n.catch(err =&gt; console.error(err));\n\nEse mismo ejemplo usando async/await sería:\ntry {\nconst response = await fetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser);\nconst myData = await response.json();\nconsole.log(myData);\n} catch (err) {\nconsole.error(err);\n}\n\nfetch llama a resolve siempre que el servidor conteste, sin comprobar si la respuesta es de éxito (200, 201, ...) o de error (4xx, 5xx). Por tanto siempre se ejecutará el then excepto si se trata de un error de red y el servidor no responde\n\nPropiedades y métodos de la respuesta de fetch\nLa respuesta devuelta por fetch() tiene las siguientes propiedades y métodos:\n\nstatus: el código de estado devuelto por el servidor (200, 404, ...)\nstatusText: el texto correspondiente a ese código (Ok, Not found, ...)\nok: booleano que vale true si el status está entre 200 y 299 y false en caso contrario\njson(): devuelve una promesa que se resolverá con los datos de la respuesta convertidos a un objeto (les hace un JSON.parse())\notros métodos para convertir los datos según el formato que tengan: text(), blob(), formData(), ... Todos devuelven una promesa con los datos de distintos formatos convertidos.\n\nEl ejemplo que hemos visto con las promesas, usando fetch quedaría:\n\nEste ejemplo fallaría si hubiéramos puesto mal la url: contestaría con un 404 pero se ejecutaría el then intentando pintar unos posts que no tenemos.\nEl ejemplo con async/await y fetch sería:\n\nGestión de errores con fetch\nSegún MDN la promesa devuelta por la API fetch sólo es rechazada en el caso de un error de red, es decir, el .catch sólo saltará si no hemos recibido respuesta del servidor; en caso contrario la promesa siempre es resuelta.\nPor tanto para saber si se ha resuelto satisfactoriamente o no debemos comprobar la propiedad .ok de la respuesta. El código correcto del ejemplo anterior gestionando los posibles errores del servidor sería:\ntry {\nconst response = await fetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser);\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst myData = await response.json();\nconsole.log(myData);\n} catch (err) {\nconsole.error(err);\n}\n\nEn este caso si la respuesta del servidor no es ok lanzamos un error que es interceptado por nuestro propio catch\nOtros métodos de petición con fetch\nLos ejemplos anteriores hacen peticiones GET al servidor. Para peticiones que no sean GET la función fetch() admite un segundo parámetro con un objeto con la información a enviar en la petición HTTP. Ej.:\nfetch(url, {\nmethod: 'POST', // o 'PUT', 'GET', 'DELETE'\nbody: JSON.stringify(data), // los datos que enviamos al servidor en el 'send'\nheaders:{\n'Content-Type': 'application/json'\n}\n}).then(...)\n\nEjemplo de una petición para añadir datos:\nfetch(url, {\nmethod: 'POST',\nbody: JSON.stringify(data), // los datos que enviamos al servidor en el 'send'\nheaders:{\n'Content-Type': 'application/json'\n}\n})\n.then(response =&gt; {\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nreturn response.json()\n})\n.then(datos =&gt; {\nalert('Datos recibidos')\nconsole.log(datos)\n})\n.catch(err =&gt; {\nalert('Error en la petición HTTP: ' + err.message);\n})\n\nPodéis ver mś ejemplos en MDN web docs y otras páginas.\nHacer varias peticiones simultáneamente. Promise.all\nEn ocasiones necesitamos hacer más de una petición al servidor. Por ejemplo para obtener los productos y sus categorías podríamos hacer:\nfunction getData() {\ngetTable('/categories')\n.then((categories) =&gt; categories.forEach((category) =&gt; renderCategory(category)))\n.catch((error) =&gt; renderErrorMessage(error))\ngetTable('/products')\n.then((products) =&gt; products.forEach((product) =&gt; renderProduct(product)))\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\nfunction getTable(table) {\nreturn new Promise((resolve, reject) =&gt; {\nfetch(SERVER + table)\n.then(response =&gt; {\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nreturn response.json()\n})\n.then((data) =&gt; resolve(data))\n.catch((error) =&gt; reject(error))\n})\n}\n\nPero si para renderizar los productos necesitamos tener las categorías este código no nos lo garantiza ya que el servidor podría devolver antes los productos aunque los pedimos después.\nUna solución sería no pedir los productos hasta tener las categorías:\nfunction getData() {\ngetTable('/categories')\n.then((categories) =&gt; {\ncategories.forEach((category) =&gt; renderCategory(category))\ngetTable('/products')\n.then((products) =&gt; products.forEach((product) =&gt; renderProduct(product)))\n.catch((error) =&gt; renderErrorMessage(error))\n})\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\npero esto hará más lento nuestro código al no hacer las 2 peticiones simultáneamente. La solución es usar el método Promise.all() al que se le pasa un array de promesas a hacer y devuelve una promesa que:\n\nse resuelve en el momento en que todas las promesas se han resuelto satisfactoriamente o\nse rechaza en el momento en que alguna de las promesas es rechazada\n\nEl código anterior de forma correcta sería:\nfunction getData() {\nPromise.all([\ngetTable('/categories')\ngetTable('/products')\n])\n.then(([categories, products]) =&gt; {\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n})\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\nLo mismo pasa si en vez de promesas usamos async/await. Si hacemos:\nasync function getTable(table) {\nconst response = await fetch(SERVER + table)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync function getData() {\nconst responseCategories = await getTable('/categories');\nconst responseProducts = await getTable('/products');\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n}\n\ntenemos el problema de que no comienza la petición de los productos hasta que se reciben las categorías. La solución con Promise.all() sería:\nasync function getData() {\nconst [categories, products] = await Promise.all([\ngetTable('/categories')\ngetTable('/products')\n])\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n}\n\nOrganizar bien el código\nEl fichero .env\nEn los ejemplos anteriores estamos guardando la URL a la que hacer la petición a la API en una constante a la que estamos llamando SERVER. Esto plantea algunos problemas:\n\nsi tenemos varios ficheros que hacen peticiones a la API deberemos declararla en todos ellos\nsi cambia hay que cambiarla en todos los ficheros y en ese caso tenemos que cambiar nuestro código\n\nPara evitarlo podemos almacenar ete tipo de cosas en el fichero .env. Se trata de un fichero donde guardar las configuraciones de la aplicación, como la URL de la API.\nPor medio de Vite podemos acceder a todas las variables de .env que comiencen por VITE_ por medio del objeto import.meta.env por lo que en nuestro código en vez de darle el valor a SERVER podríamos haber puesto:\nconst SERVER = import.meta.env.VITE_URL_API\n\nY en el fichero .env ponemos\nVITE_URL_API=http://localhost:3000\n\nEl fichero .env por defecto se sube al repositorio por lo que no debemos poner información sensible (como usuarios o contraseñas). Para ello tenemos un fichero .env.local que no se sube, o bien debemos añadir al .gitignore dicho fichero. Si el fichero con la configuración no lo subimos al repositorio es conveniente tener un fichero .env.exemple, que sí se sube, con valores predeterminados para las distintas variables, que quien quiera desplegar nuestra aplicación deberá cambiar por sus valores adecuados en producción. Además del .env y el .env.local también hay distintos ficheros que son usados en desarrollo (.env.development) y en producción (.env.production) y que pueden tener distintos datos según el entorno en que nos encontramos. Por ejemplo en el de desarrollo el valor de VITE_URL_API podría ser &quot;http://localhost:3000&quot; si usamos json-server mientras que en el de producción tendríamos la ruta del servidor de producción de la API.\nDistintas peticiones, distintos ficheros\nLas peticiones a la API deberíamos ponerlas en un fichero aparte para tener nuestro código organizado. Y peticiones a diferentes tipos de datos también deberían estar en ficheros diferentes. Por ejemplo si necesitamos obtener datos de posts y de usuarios podríamos crear una carpeta /repositories y dentro los ficheros posts.repository.js y users.repository.js.\nDentro de cada fichero haremos diferentes funciones y métodos para los diferentes tipos de petición, por ejemplo:\nconst SERVER = import.meta.env.VITE_URL_API\n\nasync getAllPosts() {\nconst response = await fetch(SERVER + '/posts')\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync getPostById(idPost) {\nconst response = await fetch(SERVER + `/posts/${idPost}`)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync insertPost(newPost) {\nconst response = await fetch(SERVER + '/posts', {\nmethod: 'POST',\nbody: JSON.stringify(newPost),\nheaders:{\n'Content-Type': 'application/json'\n}\n})\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nexport {\ngetAllPosts,\ngetPostById,\ninsertPost\n}\n\nY donde necesitemos los datos haremos:\nimport { getAllPosts } from &quot;../repositories/posts.repositories&quot;\n\nconst posts = await getAllPosts()\n\nUsando clases el ejemplo quedaría:\nconst SERVER = import.meta.env.VITE_URL_API\n\nexport default class PostsRepository {\nasync getAllPosts() {\nconst response = await fetch(SERVER + '/posts')\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync getPostById(idPost) {\nconst response = await fetch(SERVER + `/posts/${idPost}`)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync insertPost(newPost) {\nconst response = await fetch(SERVER + '/posts', {\nmethod: 'POST',\nbody: JSON.stringify(newPost),\nheaders:{\n'Content-Type': 'application/json'\n}\n})\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n}\n\nY donde necesitemos los datos haremos:\nimport PostsRepository from &quot;../repositories/posts.repositories&quot;\n\nconst repository = new PostsRepository()\nconst posts = await repository.getAllPosts()\n\nSingle Page Application\nAjax es la base para construir SPAs que permiten al usuario interactuar con una aplicación web como si se tratara de una aplicación de escritorio (sin &quot;esperas&quot; que dejen la página en blanco o no funcional mientras se recarga desde el servidor).\nEn una SPA sólo se carga la página de inicio (es la única página que existe) que se va modificando y cambiando sus datos como respuesta a la interacción del usuario. Para obtener los nuevos datos se realizan peticiones al servidor (normalmente Ajax). La respuesta son datos (JSON, XML, …) que se muestran al usuario modificando mediante DOM la página mostrada (o podrían ser trozos de HTML que se cargan en determinadas partes de la página, o ...).\nResumen de llamadas asíncronas\nUna llamada Ajax es un tipo de llamada asíncrona que podemos hacer en Javascript aunque hay muchas más, como un setTimeout() o las funciones manejadoras de eventos. Como hemos visto, para la gestión de las llamadas asíncronas tenemos varios métodos y los más comunes son:\n\nfunciones callback (no recomendado)\npromesas\nasync / await\nlibrerías, como axios\n\nCuando se produce una llamada asíncrona el orden de ejecución del código no es el que vemos en el programa ya que el código de respuesta de la llamada no se ejecutará hasta completarse esta. Podemos ver un ejemplo de esto extraído de todoJS usando funciones callback.\nAdemás, si hacemos varias llamadas tampoco sabemos el qué orden se ejecutarán sus respuestas ya que depende de cuándo el servidor finalice cada una, como podemos ver en este otro ejemplo.\nSi usamos funciones callback y necesitamos que cada función no se ejecute hasta que haya terminado la anterior debemos llamarla en la respuesta a la función anterior lo que provoca un tipo de código difícil de leer llamado callback hell.\nPara evitar esto surgieron las promesas que permiten evitar las funciones callback tan difíciles de leer. Podemos ver el primer ejemplo usando promesas. Y si necesitamos ejecutar secuencialmente las funciones evitaremos la pirámide de llamadas callback como vemos en este ejemplo.\nAún así el código no es muy claro. Para mejorarlo surgió async y await como vemos en este ejemplo. Estas funciones forman parte del estándar ES2017 por lo que no están soportadas por navegadores muy antiguos (aunque siempre podemos transpilar con Babel).\nFuente: todoJs: Controlar la ejecución asíncrona\nCORS\nCross-Origin Resource Sharing (CORS) es un mecanismo de seguridad que incluyen los navegadores y que por defecto impiden que se pueden realizar peticiones Ajax desde un navegador a un servidor con un dominio diferente al de la página cargada originalmente.\nSi necesitamos hacer este tipo de peticiones necesitamos que el servidor al que hacemos la petición añada en su respuesta la cabecera Access-Control-Allow-Origin donde indiquemos el dominio desde el que se pueden hacer peticiones (o * para permitirlas desde cualquier dominio).\nEl navegador comprobará las cabeceras de respuesta y si el dominio indicado por ella coincide con el dominio desde el que se hizo la petición, esta se permitirá.\nComo en desarrollo normalmente no estamos en el dominio de producción (para el que se permitirán las peticiones) podemos instalar en el navegador la extensión allow CORS que al activarla deshabilita la seguridad CORS en el navegador.\nPodéis ampliar la información en numerosaas páginas web como &quot;Entendiendo CORS y aplicando soluciones&quot;.",
		"tags": [ "note"]
},

{
		"title": "10-apis",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/10-apis/",
		"content": "APIs HTML5: Drag And Drop. Local Storage. Geolocalización. API de Google Maps\n\nAPIs HTML5: Drag And Drop. Local Storage. Geolocalización. API de Google Maps\n\nIntroducción\nHTML Drag And Drop API\nAlmacenamiento en el cliente: API Storage\n\nA tener en cuenta\nStorage vs cookies\nCookies\n\nGeolocation API\nGoogle Maps API\n\nIntroducción\nEn este tema varemos diferentes APIs incluidas en HTML5 (como la de Local Storage) y otras que se han hecho muy populares como la de Google Maps.\nHTML5 incluye un buen número de APIs que facilitan el trabajo con cosas complejas, como\n\nAPIs para manejo de audio y vídeo\nAPIs para manejo de formularios\nAPI de dibujo canvas (en el módulo de DIW)\n\nAquí comentaremos Storage, Drag&amp;Drop, Geolocation, File Access, Communication, Web Workers, History y Offline\nHTML Drag And Drop API\nCon HTML5 es muy sencillo arrastrar y soltar elementos en una página web. Podemos arrastrar y soltar cualquier nodo DOM (una imagen, un archivo, enlaces, texto seleccionado, ...). Para ello sólo es necesario que ese elemento tenga el atributo dragable=&quot;true&quot;. Si le ponemos false no se podrá arrastrar y si no definimos el atributo podrá o no arrastrarse según el valor predeterminado del navegador (en la mayoría son dragables las imágenes, los links y las selecciones de texto).\nAl arrastrar y soltar intervienen 2 elementos diferentes:\n\nel elemento que estamos arrastrando\nel elemento sobre el cual lo soltamos\n\nPara poder realizar la operación event tiene una propiedad llamada dataTransfer que es un objeto en el que almacenamos qué elemento estamos arrastrando (o cualquier otra cosa que queramos) y así cuando se suelte sobre el elemento destino éste último pueda saber quién se le ha soltado.\nLos pasos para arrastrar y soltar un elemento son:\n\nEl elemento debe ser draggable\nCapturamos el evento dragstart. Este evento se produce sobre un elemento cuando comenzamos a arrastrarlo. Deberemos almacenar en el dataTransfer quién está siendo arrastrado (si no guardamos nada se guarda automáticamente su src si es una imagen o su href si es un enlace). Indicaremos el tipo del dato que estamos almacenando (texto plano, HTML, fichero, etc) y su valor. Ej.:\n\n&lt;img id=&quot;imgGoogle&quot; src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Google.png/320px-Google.png&quot;&gt;\n&lt;div id=&quot;zonaDrop1&quot; class=&quot;drop&quot;&gt;\n&lt;p&gt;Puedes soltar aquí la imagen&lt;/p&gt;\n&lt;/div&gt;\n&lt;div id=&quot;zonaDrop2&quot; class=&quot;drop&quot;&gt;\n&lt;p&gt;Y también aquí&lt;/p&gt;\n&lt;/div&gt;\n\ndocument.getElementById('imgGoogle').addEventListener('dragstart', (event) =&gt; {\nevent.dataTransfer.setData('text/plain', event.target.id); // Estamos guardando el texto 'imgGoogle'\n})\n\nCapturamos el evento dragover. Este evento se produce cada pocas décimas de segundo sobre elemento sobre el que se está arrastrando algo. Por defecto no se puede soltar un elemento en ningún sitio así que capturamos este evento para evitar que el navegador haga la acción por defecto e impida que se suelte lo que estamos arrastrando. Ej.:\n\ndocument.getElementById('zonaDrop1').addEventListener('dragover', (event) =&gt; {\nevent.preventDefault();\n})\ndocument.getElementById('zonaDrop2').addEventListener('dragover', (event) =&gt; {\nevent.preventDefault();\n})\n\nCapturamos el evento drop. Este evento se produce sobre elemento sobre el que se suelta lo que estábamos arrastrando. Lo que haremos es evitar el comportamiento por defecto del navegador (que en caso de imágenes o enlaces es cargarlos en la página), obtener quién se ha soltado a partir del objeto dataTransfer y realizar lo que queramos, que normalmente será añadir el objeto arrastrado como hijo del objeto sobre el que se ha hecho el drop. Ej.:\n\ndocument.getElementById('zonaDrop1').addEventListener('drop', (event) =&gt; {\nevent.preventDefault();\nconst data=event.dataTransfer.getData(&quot;text/plain&quot;); // Obtenemos ìmgGoogle'\nevent.target.appendChild(document.getElementById(data));\n})\ndocument.getElementById('zonaDrop2').addEventListener('drop', (event) =&gt; {\nevent.preventDefault();\nconst data=event.dataTransfer.getData(&quot;text/plain&quot;); // Obtenemos ìmgGoogle'\nevent.target.appendChild(document.getElementById(data));\n})\n\nPodéis ver el funcionamiento de este ejemplo:\n\nNOTA: si hacemos draggable un elemento, por ejemplo un párrafo, ya no se puede seleccionar con el ratón ya que al pinchar y arrastrar se mueve, no se selecciona. Para poder seleccionarlo debemos pinchar y arrastrar el ratón con las teclas Ctrl+Alt pulsadas o hacerlo con el teclado. Ejemplo:\n\nPodemos obtener más información de esta API MDN web docs.\n\nEJERCICIO: mira y modifica el ejemplo de w3schools para entender bien el funcionamiento del Drag&amp;Drop (ten en cuenta que en vez de .addEventListener() las llamadas a los escuchadores están puestas como atributos del HTML pero el funcionamiento es el mismo).\n\nAlmacenamiento en el cliente: API Storage\nAntes de HTML5 la única manera que tenían los programadores de guardar algo en el navegador del cliente (como sus preferencias, su idioma predeterminado para nuestra web, etc) era utilizando cookies. Las cookies tienen muchas limitaciones y es engorroso trabajar con ellas.\nHTML5 incorpora la API de Storage para subsanar esto. Además existen otros métodos de almacenamiento en el cliente más avanzados como IndexedDB (es un estándar del W3C pero aún con poco soporte entre los navegadores).\nEl funcionamiento de la API Storage es muy sencillo: dentro del objeto window tendremos los objetos localStorage y sessionStorage donde podremos almacenar información en el espacio de almacenamiento local (5 o 10 MB por sitio web según el navegador, que es mucho más de lo que teníamos con las cookies). La principal diferencia entre ellos es que la información almacenada en localStorage nunca expira, permanece allí hasta que la borremos (nosotros o el usuario) mientras que la almacenada en sessionStorage se elimina automáticamente al cerrar la sesión el usuario.\nSólo los navegadores muy antiguos (Internet Explorer 7 y anteriores) no soportan esta característica. Puedo saber si el navegador soporta o no esta API simplemente mirando su typeof:\nif (typeof(Storage) === 'undefined') // NO está soportado\n\nTanto localStorage como sessionStorage son como un objeto global al que tengo acceso desde el código. Lo que puedo hacer con ellos es:\n\nGuardar un dato: localStorage.setItem('dato', 'valor') o también localStorage.dato = 'valor'\nRecuperar un dato: let miDato=localStorage.getItem('dato') o también let miDato = localStorage.dato\nBorrar datos: localStorage.removeItem('dato') para borrar 'dato'. Si quiero borrar TODO lo que tengo localStorage.clear()\nSaber cuántos datos tenemos: localStorage.length\n\nSólo podemos guardar objetos primitivos (cadenas, números, ...) por lo que si queremos guardar un objeto o un array hay que convertirlo a una cadena JSON con localStorage.setItem('dato', JSON.stringify('objeto')). Para recuperar el objeto haremos let miObjeto = JSON.parse(localStorage.getItem('dato')).\nCada vez que cambia la información que tenemos en nuestro localStorage se produce un evento storage. Si, por ejemplo, queremos que una ventana actualice su información si otra cambia algún dato del storage haremos:\nwindow.addEventListener(&quot;storage&quot;, actualizaDatos);\n\ny la función 'actualizaDatos' podrá leer de nuevo lo que hay y actuar en consecuencia.\n\nEJERCICIO: comprueba qué tienes almacenado en el localStorage y el sessionStorage de tu navegador. Guarda y recupera algunas variables. Luego cierra el navegador y vuelve a abrir la página. ¿Están las variables guardadas en localStorage? ¿Y las de sessionStorage?\n\nPuedes ver un ejemplo en este vídeo de cómo almacenar en el Storage datos del usuario.\nA tener en cuenta\nlocalStorage, sessionStorage y cookies almacenan información en un navegador específico del cliente, y por tanto:\n\nNo podemos asegurar que permanece ahí\nPuede ser borrada/manipulada\nPuede ser leída, por lo que NO es adecuada para almacenar información sensible pero sí para preferencias del usuario, marcadores de juegos, etc\n\nPodríamos usar localStorage para almacenar localmente los datos con los que trabaja una aplicación web. Así conseguiríamos minimizan los accesos al servidor y que la velocidad de la aplicación sea mucho mayor al trabajar con datos locales. Pero periódicamente debemos sincronizar la información con el servidor.\nStorage vs cookies\nVentajas de localStorage:\n\n5 o 10 MB de almacenamiento frente a 4 KB de las cookies\nTodas las cookies del dominio se envían al servidor con cada petición al mismo lo que aumenta el tráfico innecesariamente\n\nVentajas de las cookies:\n\nSoportadas por navegadores muy antiguos\nLas cookies ofrecen algo de protección frente a XSS (Cross-Site Scripting) y Script injection\n\nCookies\nSon pequeños ficheros de texto y tienen las siguientes limitaciones:\n\nMáximo 300 cookies, si hay más se borran las antiguas\nMáximo 4 KB por cookie, si nos pasamos se truncará\nMáximo 20 cookies por dominio\n\nCada cookie almacena los siguientes datos:\n\nNombre de la cookie (obligatorio)\nValor de la misma\nexpires: timestamp en que se borrará (si no pone nada se borra al salir del dominio)\nmax-age: en lugar de expires podemos indicar aquí los segundos que durará la cookie antes de expirar\npath: ruta desde dónde es accesible (/: todo el dominio, /xxx: esa carpeta y subcarpetas). Si no se pone nada sólo lo será desde la carpeta actual\ndomain: dominio desde el que es accesible. Si no ponemos nada lo será desde este dominio y sus subdominios\nsecure: si aparece indica que sólo se enviará esta cookie con https\n\nUn ejemplo de cookie sería:\nusername=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC;\n\nSe puede acceder a las cookies desde document.cookie que es una cadena con las cookies de nuestras páginas. Para trabajar con ellas conviene que creemos funciones para guardar, leer o borrar cookies, por ejemplo:\n\nCrear una nueva cookie\n\nfunction setCookie(cname, cvalue, cexpires, cpath, cdomain, csecure) {\ndocument.cookie = cname + '=' + cvalue +\n(cexpires?';expires='+cexpires.toUTCString():'') +\n(cpath?';path='+cpath:'') +\n(cdomain?';domain='+cdomain:'') +\n(csecure?';secure':'')\n}\n\nLeer una cookie\n\nfunction getCookie(cname) {\nif(document.cookie.length &gt; 0){\nstart = document.cookie.indexOf(cname + '=')\nif (start != -1) { // Existe la cookie, busquemos dónde acaba su valor\n//El inicio de la cookie, el nombre de la cookie mas les simbolo '='\nstart = start + nombre.length + 1\n//Buscamos el final de la cookie (es el simbolo ';')\nend = document.cookie.indexOf(';', start + cname.length + 1)\nif (end === -1) { // si no encuentra el ; es que es la última cookie\nend = document.cookie.length;\n}\nreturn document.cookie.substring(start + cname.length + 1, end)\n}\n}\nreturn '' // Si estamos aquí es que no hemos encontrado la cookie\n}\n\nBorrar una cookie\n\nfunction delCookie(cname) {\nreturn document.cookie = cname + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;'\n}\n\nPodéis ver en este vídeo un ejemplo de cómo trabajar con cookies, aunque como ya hemos dicho lo recomendable es trabajar con Storage.\nGeolocation API\nEsta API permite a la aplicación web acceder a la localización del usuario si éste da su permiso. Muchos navegadores sólo permiten usarlo en páginas seguras (https).\nPodemos acceder a esta API mediante el objeto geolocation de navigator. Para saber si nuestro navegador soporta o no la API podemos hacer:\nif (geolocation in navigator) // devuelve true si está soportado\n\nPara obtener la posición este objeto proporciona el método navigator.geolocation.getCurrentPosition() que hace una petición asíncrona. Cuando se reciba la posición se ejecutará la función callback que pasemos como parámetro y que recibirá las coordenadas de la localización. Podemos pasar otra como segundo parámetro que se ejecutará si se produce algú error y que recibirá un objeto con la propiedad code que indica el error producido. Ej.:\nnavigator.geolocation.getCurrentPosition(\n(position) =&gt; {\npinta_posicion(position.coords.latitude, position.coords.longitude)\n},\n(error) =&gt; {\nswitch(error.code) {\ncase error.PERMISSION_DENIED: // El usuario no autoriza al navegador a acceder a la localización\nmsg = 'El usuario ha denegado la petición de geolocalización'\nbreak\ncase error.POSITION_UNAVAILABLE: // No se puede obtener la localización\nmsg = 'La información de localización no está disponible.'\nbreak\ncase error.TIMEOUT: // Ha expirado el tiempo para obtener la localización\nmsg = 'Ha expirado el tiempo para obtener la localización'\nbreak\ncase error.UNKNOWN_ERROR:\nmsg = 'Se ha producido un error desconocido.'\nbreak\n}\nmuestra_error(msg)\n}\n)\n\nSi queremos ir obteniendo continuamente la posición podemos usar el método .watchPosition() que tiene los mismos parámetros y funciona igual pero se ejecuta repetidamente. Este método devuelve un identificador para que lo podemos detener cuando queremos con .clearWatch(ident). Ej.:\nconst watchIdent = navigator.geolocation.watchPosition(\n(position) =&gt; pinta_posicion(position.coords.latitude, position.coords.longitude),\n(error) =&gt; muestra_error(error)\n)\n...\n// Cuando queremos dejar de obtener la posición haremos\nnavigator.geolocation.clearWatch(watchIdent)\n\nLas principales propiedades del objeto de localización (algunas sólo estarán disponible cuando usemos un GPS) son:\n\ncoords.latitude: latitud\ncoords.longitude: longitud\ncoords.accuracy: precisión (en metros)\ncoords.altitude: altitud (en metros, sobre el nivel del mar)\ncoords.altitudeAccuracy: precisión de la altitud\ncoords.heading: orientación (en grados)\ncoords.speed: velocidad (en metros/segundo)\ntimestamp: tiempo de respuesta UNIX\n\nPodemos pasarle como tercer parámetro al método getCurrentPosition un objeto JSON con una o más de estas propiedades:\n\nenableHighAccuracy: true/false que indica si el dispositivo debe usar todo lo posible para obtener la posición con mayor precisión (por defecto false porque consume más batería y tiempo)\ntimeout: milisegundos a esperar para obtener la posición antes de lanzar un error (por defecto es 0, espera indefinidamente)\nmaximumAge: milisegundos que guarda la última posición en caché. Si se solicita una nueva posición antes de expirar el\ntiempo, el navegador devuelve directamente el dato almacenado\n\nPodemos obtener más información de esta API en MDN web docs y ver y modificar ejemplos en w3schools y muchas otras páginas. i\nGoogle Maps API\nPara poder utilizar la API en primer lugar debemos obtener una API KEY de Google.\nUna vez hecho para incluir un mapa en nuestra web debemos cargar la librería para lo que incluiremos en nuestro código el script:\n&lt;script async defer\nsrc=&quot;https://maps.googleapis.com/maps/api/js?key=ESCRIBE_AQUI_TU_API_KEY&amp;callback=initMap&quot;&gt;\n&lt;/script&gt;\n\n(el parámetro callback será el encargado de llamar a la función initMap() que inicie el mapa)\nAhora incluir un mapa es tán sencillo como crear un nuevo objeto de tipo Map que recibe el elemento DOM donde se pintará (un div normalmente) y un objeto con los parámetros del mapa (como mínimo su centro y el zoom):\nlet map\nfunction initMap() {\nmap = new google.maps.Map(document.getElementById('map'), {\ncenter: { lat: 38.6909085, lng: -0.4963000000000193 },\nzoom: 12\n})\n}\n\nPor su parte añadir un marcador es igual de simple. Creamos una instancia de la clase Marker a la que le pasamos al menos la posición, el mapa en que se creará y un título para el marcador:\nlet marker = new google.maps.Marker({\nposition: { lat: 38.6909085, lng: -0.4963000000000193 },\nmap: map,\ntitle: 'CIP FP Batoi'\n})\n\nAquí tenéis el ejemplo anterior:\n\nPodemos obtener más información de esta API en Google Maps Plataform, en el tutorial de w3schools y en muchas otras páginas.",
		"tags": [ "note"]
},

{
		"title": "11-mas",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/11-mas/",
		"content": "Más cosas a aprender en Javascript\n\nMás cosas a aprender en Javascript\n\nIntroducción\nWebComponents\nWebSockets\nWebWorkers\nTypescript\njQuery\n\nIntroducción\nHace unos años Javscript era considerado un lenguaje de programación de segunda categoría, que se usaba para hacer molestas páginas web. Hoy en día el navegador es la aplicación más importante de un equipo y con él, además de navegar, se ejecutan todo tipo de aplicaciones. Además HTML5 y JavaScript han pasado de estar solo en nuestro navegador a ser un pilar básico de las plataformas móviles, de aplicaciones de escritorio e incluso JavaScript lo encontramos en servidores (con Node.js) o como lenguaje estándar de algunos entornos de escritorio (como GNOME para Linux).\nPor ello HTML5 y Javascript siguen su contínuo crecimiento... y su contínua evolución que les permite hacer cada vez más cosas. En esta página vamos a hablar muy brevemente de algunas de las características que están incorporando.\nWebComponents\nSon distintas tecnologías que podemos usar (todas o alguna de ellas) para crear componentes reutilizables para nuestras páginas HTML. Las tecnologías que hay tras los Web Components son:\n\nCustom Elements: permite crear elementos HTML personalizados, es decir, nuevas etiquetas definidas por nosotros con funcionalidad propia. Por ejemplo\n\n&lt;comp-calendar\nmode=&quot;month&quot;\ndate=&quot;2020-02-23&quot;\non-select=&quot;dateSelected()&quot; &gt;\n&lt;/comp-calendar&gt;\n\nHTML Templates: la etiqueta &lt;template&gt; permite definir fragmentos de código HTML que no serán renderizados y que usaremos más adelante. Pueden incluir slots o huecos a los que se pasa un contenido\nShadow DOM: permite asociar un DOM oculto a un elemento. Esto permite que tenga su propio código JS y estilos CSS aislados del resto del DOM\nES Modules: Es el estándar de ECMAScript para importar módulos Javascript.\n\nUn WebComponent es un elemento que creamos y que tiene su propia representación (HTML) y funcionalidad (establecida con Javascript). Este elemento es reusable y compartible y se contruye sin librerías externas, sólo con HTML5, ES6 y CSS3.\nAlgunos ejemplos de componentes útiles que podríamos usar son:\n\ncomponente para loguearnos mediante Google, Facebook, etc\ncomponente que me muestre el tiempo en una ciudad\ncomponente para hacer un modal\n...\n\nHay infinidad de páginas donde podemos aprender más sobre WebComponents y cómo crear nuestro propio componente, como:\n\nWeb Components | MDN\nIntroduction - webcomponents.org\n¿Qué son los WebComponents? - Javascript en español\nCarlos Azaustre - Cómo crear un WebComponent de forma nativa\n...\n\nEn resumen debemos crear un fichero donde definimos la clase de nuestro componente que debe heredar de HTMLElement. Es conveniente que su nombre (y por tanto el de la etiqueta que usaremos para mostrarlo) tenga al menos 2 palabras para evitar que pueda entrar en conflicto con posibles futuras etiquetas de HTML (por ejemplo podría ser &lt;social-login&gt; o &lt;my-weather&gt;). En esta clase definiremos el HTML y el estilo que tendrá nuestro componente, así como su comportamiento.\nActualmente no todos los navegadores ofrecen soporte para WebComponents. Esto junto al hecho de que frameworks como Vue, Angular o React ofrecen soluciones con sus propios componentes han hecho que el uso de los WebComponents no acabe de despegar. A pesar de ello hay lugares como WebComponents.org donde podemos encontrar un catálogo de componentes hechos y que podemos usar en nuestras páginas.\nPor su parte Google ha desarrollado la librería Polymer para ayudarnos a crear nuestros propios componentes basados en WebComponents y los principales frameworks JS como Angular o Vue permiten crear sus propios componentes de forma muy sencilla, com veremos en el bloque de Vue.\nWebSockets\nWebSockets es una tecnología basada en el protocolo ws que permite establecer una conexión continua full-duplex entre un cliente (puede ser un navegador) y un servidor. La conexión siempre la abre el cliente pero una vez abierta no se cierra por lo que el servidor puede comunicar en cualquier momento con el cliente y enviarle información.\nEjemplo:\nlet exampleSocket=new WebSocket(uri);\nexampleWebsocjet.onopen=function(event) {\nconsole.log('Se ha establecido la conexión');\n}\nexampleSocket.onclose=function(event) {\nconsole.log('Se ha cerrado la conexión');\n}\nexampleSocket.onerror=function(event) {\nconsole.log('Se ha producido un error en la conexión');\n}\nexampleSocket.onmessage=function(event) {\nconsole.log('Se ha recibido el mensaje:' + event.data);\n}\n\nEl uri de la conexión deberá usar el protocolo ws (o wss), no http (ej. &quot;ws://miservidor.com/socketserver&quot;). El evento open se produce cuando la propiedad readyState cambia a OPEN y el close cuando cambia su valor a CLOSED. Cada vez que se reciba algo del servidor se produce el evento message y en la propiedad data del mismo tendremos lo que se nos ha enviado.\nPara enviar algo al servidor usamos el mátodo .send. Lo que le enviamos ex texto en formato utf-8 (o un objeto convertido a JSON):\nexampleSocket.send('Your message');\nexampleSocket.send(JSON.stringify(msg));\n\nTambién podemos enviar (y recibir) imágenes (convertidas a ArrayBuffer) o ficheros como un objeto Blob.\nPara cerrar la conexión llamamos al método .close():\nexampleSocket.close();\nconsole.log('Conexión cerrada');\n\nPara programar la parte del servidor podemos usar librerías que nos ayudan como PHP-WebSockets, SocketIO, ...\nLas aplicaciones de esta tecnología son muchas:\n\nJuegos multjugador\nAplicaciones de chat\nActualización en tiempo real de cotizaciones de bolsa, recursos en uso o cualquier otra información\n...\n\nPodemos practicar con www.websocket.org que tiene un servidor websocket que devuelve lo que le enviamos. En esta web también tenemos ejemplos de aplicaciones.\nSaber más:\n\nMDN: Escribiendo aplicaciones con WebSockets\nWebSocket - El Tutorial de JavaScript Moderno\nCarlos Azaustre: Crear chat con WebSockets\n\nWebWorkers\nEn principio Javascript se ejecuta en un único hilo de ejecución pero esta tecnología permite ejecutar scripts en segundo plano en hilos separados que se ejecutan en segundo plano y se comunican con la tarea que los crea mediante el envío de mensajes.\nCuando se está ejecutando un script la página no responde hasta que finaliza su ejecución. Si el script lo ejecuta un web worker la página será funcional (podemos interactuar con ella) ya que le ejecución del script se realiza en segundo plano en otro hilo.\nHay 3 tipos de WebWorkers:\n\nDedicated Workers: Estos son los más comunes y se ejecutan en un hilo dedicado al contexto del script que los creó. No comparten recursos con otros scripts y son útiles para tareas intensivas que requieren mucho procesamiento.\nShared Workers: Pueden ser compartidos por varios scripts ejecutándose en diferentes ventanas, pestañas o iframes dentro del mismo dominio. Son ideales para aplicaciones que necesitan coordinar tareas entre múltiples instancias de la misma aplicación web.\nService Workers: Actúan como servidores proxy que se ejecutan en segundo plano y gestionan eventos de red como las peticiones HTTP. Son esenciales para crear aplicaciones web progresivas (PWAs) que funcionen sin conexión y mejoren la velocidad de carga.\n\nPodéis ver un ejemplo de cómo crear un WebWorker para generar números primos en el Curso DWEC de Jose Castillo\nSaber más:\n\nCurso DWEC de Jose Castillo\nMDN - Usando WebWorkers\nw3schools - HTML5 Web Workers\n\nTypescript\nTypeScript es un lenguaje de programación libre y de código abierto desarrollado y mantenido por Microsoft. Es un superconjunto de JavaScript, que esencialmente añade tipado estático y objetos basados en clases. TypeScript extiende la sintaxis de JavaScript, por tanto cualquier código JavaScript existente debería funcionar sin problemas.\nPuede que la principal diferencia entre ambos es que Typescript obliga al tipado de las variables (y por supuesto no permite cambios de tipo) lo que evita muchos errores a la hora de programar.\nAlgunos frameworks y librerías, como Angular, utilizan TS en lugar de JS como lenguaje, que luego es transpilado a JS a la hora de generar la aplicación para producción.\nQuizá el inconveniente es que es algo más difícil que JS pero como está basado en él y la sintaxis es prácticamente igual el esfuerzo de aprender TS para un programador JS es muy pequeño.\nSaber más:\n\nWikipedia - Typescript\nTypescriptlang\n\njQuery\nSe trata de una biblioteca que nos facilita enormemente el trabajo con el DOM ya que tiene &quot;atajos&quot; para muchas instrucciones, por ejemplo para poner 'Hola mundo' como contenido de un elemento cuya id es mensaje:\n// Código con Javascript sólo\ndocument.getElementById('mensaje').textContent = 'Hola mundo'\n\n// Código con jQuery\n$('#mensaje').text('Hola mundo')\n\nOtra ventaja de jQuery es que permite trabajar con conjuntos de elementos sin tener que hacer un forEach (lo hace internamente). Por ejemplo para poner un escuchador que muestre un alert 'Párrafo pinchado' al hacer click sobre cualquier párrafo de la clase 'importante' tendríamos que hacer:\n// Código con Javascript sólo\nArray.from(document.querySelectorAll('p.importante'))\n.forEach(parrafo =&gt; parrafo.addEventListener('click', () =&gt; alert('Párrafo pinchado'))\n\n// Código con jQuery\n$('p.importante').click(() =&gt; alert('Párrafo pinchado'))\n\nComo vemos, básicamente nos permite hacer lo mismo pero escribiendo mucho menos código. También incluye funciones para cosas que en Javascript requieren varias líneas de código como animaciones o Ajax. Por ejemplo una pertición para mostrar en una tabla con id posts todos los posts del servidor jsonplaceholder tendremos que hacer:\n// Código con Javascript sólo\nconst SERVER = 'https://jsonplaceholder.typicode.com';\n\nfunction getPosts() { // Función que pide los datos al servidor\nreturn new Promise(function(resolve, reject) {\nlet peticion = new XMLHttpRequest();\npeticion.open('GET', SERVER + '/posts');\npeticion.send();\npeticion.addEventListener('load', function() {\nif (peticion.status === 200) {\nresolve(JSON.parse(peticion.responseText));\n} else {\nreject(&quot;Error &quot; + this.status + &quot; (&quot; + this.statusText + &quot;) en la petición&quot;);\n}\n})\npeticion.addEventListener('error', () =&gt; reject('Error en la petición HTTP'));\n})\n}\n\nfunction renderPosts() { // Función que los muestra en la página\ngetPosts(idUser)\n.then((posts) =&gt; {\ndocument.querySelector('#posts tbody').innerHTML = ''; // borramos su contenido\nposts.forEach((post) =&gt; {\nconst newPost = document.createElement('tr');\nnewPost.innerHTML = `\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;`;\ndocument.querySelector('#posts tbody').appendChild(newPost);\n})\n})\n.catch((error) =&gt; console.error(error))\n}\n\nUsando jQuery es mucho más sencillo. En primer lugar no hay que hacer la función que hace la petición al servidor porque hay uns función que hace eso: $.ajax y sus derivadas $.get, $.post, ... Además la parte de pintar los datos es también mucho más corta:\n// Código con jquery\nconst SERVER = 'https://jsonplaceholder.typicode.com';\n\nfunction renderPosts() { // Función que los muestra en la página\n$.get(SERVER + '/posts')\n.done((posts) =&gt; {\n$('#posts tbody').text(''); // borramos el contenido de la tabla\nposts.forEach(post =&gt; $('#posts tbody').append(\n`&lt;tr&gt;\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;\n&lt;/tr&gt;`\n))\n})\n.fail((error) =&gt; console.error(error))\n}\n\nEncontraréis infinidad de tutoriales por Internet donde aprender jQuery, por ejemplo unos vídeos de Didacticode que podéis encontrar en https://didacticode.com/curso/curso-de-jquery/ (tenéis que registraros para tener acceso a muchos cursos de Javascript y &quot;derivados&quot; pero vale la pena) o directamente en su canal de Youtube.",
		"tags": [ "note"]
},

{
		"title": "12-tests",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/12-tests/",
		"content": "Testing\nTabla de contenidos\n\nTesting\n\nIntroducción al testing\n\nTesting en Javascript\n\nInstalar npm\nInstalar jest\nTranspilar nuestro código\n\nUsando Babel con Jest\n\nUsando Webpack\n\nInstalar webpack\nEjecutar webpack\nEnlazar el fichero generado en el HTML\n\nTestear la UI\n\nUsar jest\n\nMatchers\nTest suites\nMocks\nTestear promesas\nHooks de Jest\n\nDesarrollo guiado por pruebas (TDD)\n\nIntroducción al testing\nEs fundamental que nuestro código tenga un cierto nivel de calidad para minimizar los fallos del programa, más cuanto más compleja es la aplicación que estamos desarrollando. Para ello debemos testearlo y dicho testeo seguramente incluirá test automáticos. Dichos test nos permiten:\n\ncomprobar que nuestro código responde como se espera de él\nevitar los errores de regresión (fallos tras incluir una nueva funcionalidad en cosas que antes funcionaban en nuestro programa)\nincluso mejoran la documentación del proyecto ya que el test indica cómo debe funcionar mi código\n\nComo ya sabéis existen varios tipos de tests:\n\nunitarios: prueban un trozo de código que sólo hace una cosa (habitualmente una función)\nde integración: prueban que varias partes del código funcionan bien juntas\nde aceptación: prueba que el código permite hacer algo que el cliente quiere qu pueda hacerse\n\nDe momento desarrollaremos tests unitarios. Estos tienen 3 partes:\n\nPreparación (Arrange): perparamos el código para poder probarlo, por ejemplo, creamos las variables u objetos a probar\nActuación (Act): realizamos la acción, por ejemplo, llamamos a la función\nAserción (Assert): comprobamos que el resultado es el esperado\n\nEjemplo:\ntest('wordCount() returns 2 when the input is &quot;Hello world&quot;', () =&gt; {\n// Arrange\nconst string = 'Hello world';\n\n// Act\nconst result = wordCount(string);\n\n// Assert\nexpect(result).toBe(2);\n});\n\nTesting en Javascript\nTenemos muchas herramientas para hacer tests unitarios. Usaremos una llamada Jest. Para instalarla usaremos el gestor de paquetes npm que es el más utlizado para usar bibliotecas y sus dependencias en el FrontEnd.\nInstalar npm\nnpm es el gestor de dependencias de nodejs y aprenderemos más de él en el bloque de Vue. Debemos instalar NodeJS para tener npm. Esto podemos hacerlo desde el repositorio de nuestra distribución (con apt install nodejs) pero no se instalará la última versión. Es mejor seguir las indicaciones de la página oficial de NodeJS. Aquí tenéis cómo hacerlo para distribuciones basadas en Debian/Ubuntu.\nInstalar jest\nUna vez instalado npm crearemos una carpeta para cada proyecto que vayamos a hacer y lo inicializamos ejecutando dentro de ella:\nnpm init\n\nEste comando crea un nuevo proyecto y nos pedirá información sobre el mismo. Cuando nos pregunten por la herramienta para hacer tests escribiremos jest. Tras ello tendremos ya creado el fichero package.json de nuestra aplicación (es el fichero donde se configura el proyecto y sus dependencias). En el apartado de scripts encontramos uno llamado test que lo que hace es ejecutar jest:\n&quot;scripts&quot;: {\n&quot;test&quot;: &quot;jest&quot;\n}\n\nAhora falta instalar jest, lo que haremos con:\nnpm install --save-dev jest\n\nEstamos instalando jest sólo como dependencia de desarrollo ya que no lo necesitaremos en producción (lo mismo abreviado sería npm i -D jest).\nAunque, como vamos a utilizar jest en muchos proyectos distintos, es más conveniente instalarlo globalmente con\nnpm i -g jest\n\nDe esta forma no tendremos que instalar jest en cada nuevo proyecto, sólo hacer el npm init.\nLas dependencias que instalemos están en el directorio node_modules. Si estamos usando git debemos asegurarnos de incluir este directorio en nuestro fichero .gitignore (si no tenemos ese fichero podemos crearlo simplemente con echo &quot;node_modules&quot; &gt; .gitignore).\nTranspilar nuestro código\nVamos a crear las funciones de nuestro código en un fichero JS y para que se puedan usar el otro fichero Javascript (el de los tests) debemos exportarlas con module.exports. El fichero de test deberá importarlas con require (se explica más adelante, en el apartado de Usar Jest). Por ejemplo, tenemos un fichero llamado suma.js que contiene la función add que suma 2 números pasados por parámetro:\nfunction add(a, b) {\nreturn a + b;\n}\nmodule.exports = add;\n\nEl fichero de test, suma.test.js (normalmente le llamaremos igual pero anteponiendo .test a la extensión .js) contiene los test a ejecutar:\nconst add = require('./suma')\n\ndescribe('Addition', () =&gt; {\ntest('given 3 and 7 as inputs, should return 10', () =&gt; {\nconst expected = 10;\nconst actual = add(3,7);\nexpect(actual).toEqual(expected)\n});\n\ntest('given -4 and 2 as inputs, should return -2', () =&gt; {\nconst expected = -2;\nconst actual = add(-4,2);\nexpect(actual).toEqual(expected)\n});\n});\n\nLo que hace es:\n\nimporta la función que exporta suma.js y la almacena en la constante add. Ya pude llamar a esa función\nel bloque describe permite agrupar varios tests relacionados bajo un mismo nombre\ncada sentencia test es un test que se realizará\n\nSi ejecutamos los tests en la terminal (npm run test) muestra un error ya que Jest no sabe cómo gestionar las sentencias ECMAScript import y export. Para solucionarlo debemos transpilar nuestro código de manera que Jest pueda entenderlo. Podemos hacerlo de 2 maneras:\n\ninstalando el transpilador Babel y configurando Jest para que transpile el código\nutilizando un bundler como Webpack. En este caso no sólo transpilamos el código sino que juntamos todos nuestros ficheros JS en uno sólo que será el que enlazaremos en el fichero HTML de nuestra aplicación. Es la solución si queremos que nuestro código funcione en el navegador además de poder pasar los tests.\n\nUsando Babel con Jest\nSi queremos sólo poder pasar los tests pero no vamos a usar ese código en el navegador sólo tenemos que instalar el transpilador Babel:\nnpm add jest babel-jest @babel/core @babel/preset-env\n\nY crear 2 ficheros para configurarlo y que sepa trabajar junto a Jest:\n\njest.config.json\n\n{\n&quot;transform&quot;: {\n&quot;^.+\\\\.jsx?$&quot;: &quot;babel-jest&quot;\n}\n}\n\n.babelrc\n\n{\n&quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n}\n\nAhora ya podemos ejecutar los test y comprobar que nuestro código los pasa.\nEn la siguiente página explica cómo configurar npm y jest con babel (sin usar webpack) e integrarlo con Travis-CI, la herramienta de integracion continua de GitHub:\n\nAutomate NPM releases with Jest, codecov.io, Semantic Release, and TravisCI\n\nUsando Webpack\nCon la configuración anterior nuestro código es transpilado para ejecutar los tests, pero dará error si intentamos ejecutarlo en el navegador porque allí no está transpilado. Podemos solucionarlo usando webpack para empaquetar y transpilar el código (por tanto no sería necesario realizar lo indicado en al apartado anterior).\nWebpack el un bundler o empaquetador de código que además puede usar transpiladores para convertir nuestro código que usa versiones modernas de ECMAscript en otro soportado por la mayoría de navegadores.\nPor tanto nos va a permitir, entre otras cosas:\n\nTener en nuestro index.html una sóla entrada de script (&lt;script src=&quot;./dist/main.js'&gt;) en lugar de una para cada archivo que estemos utilizando (index.js, functions.js, ...)\nAdemás podremos usar instrucciones como module.exports para exportar funciones o require para importarlas en otro fichero Javascript, que sin traspilar provocarían errores en el navegador\n\nExisten infinidad de páginas que nos enseñan las mil posibilidades que tiene webpack, pero nosotros por ahora sólo necesitamos:\nInstalar webpack\nTenemos que instalar webpack y webpack-cli. Como son dependencias de desarrollo (en producción no las necesitaremos) ejecutamos:\nnpm i -D webpack webpack-cli\n\nEjecutar webpack\nSe ejecuta con el comando npx webpack y hay que indicarle:\n\ncuál es nuestro archivo Javascript principal de nuestro código (si no lo ponemos supondrá que es ./src/index.js)\ncuál será el archivo que creará de salida (por defecto ./dist/main.js)\nsi estamos en desarrollo o en producción, para permitir o no depurar el código generado\n\nSiguiendo con el ejemplo anterior de la suma crearemos un fichero index.js dentro de src/ que importará el fichero suma.js (con el comando requirecomo se hace en el fichero de tests) y que contendrá el resto de código de la aplicación (como pedir al usuario los números a sumar, mostrar el resultado, ...). Para que webpack empaquete y transpile esos 2 ficheros (index.js y suma.js) ejecutaremos en la terminal:\nnpx webpack --mode=development\n\nEnlazar el fichero generado en el HTML\nPor último, en nuestro index.html debemos incluir sólo el main.js generado por webpack &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;\nTestear la UI\nSi queremos hacer tests unitarios de los cambios que produce nuestro código en la página web hay varios frameworks que podemos usar, pero también podemos hacerlo sin usar ninguno, usando sólo los módulos de Node que ya tenemos instalados y Jest, en concreto su herramienta jsdom que usa para emular un navegador.\nPara usarlo debemos instalar la librería Testing Library. Para ello, tras configurar nuestro proyecto con Babel como hemos visto antes, instalaremos para desarrollo los paquetes @testing-library/dom y @testing-library/jest-dom:\nnpm i -D @testing-library/dom @testing-library/jest-dom\n\nEn el fichero de test debemos poner al principio:\nconst { fireEvent, getByText } = require('@testing-library/dom')\nimport '@testing-library/jest-dom/extend-expect'\nimport { JSDOM } from 'jsdom'\nimport fs from 'fs'\nimport path from 'path'\n\ny antes de ejecutar cada test cargamos nuestra página HTML con:\nconst html = fs.readFileSync(path.resolve(__dirname, '../index.html'), 'utf8');\n\nOJO: sólo debemos cargar así la página si confiamos totalmente en el código que vamos a probar (en este caso es nuestro código) y no deberíamos hacerlo para código de terceros.\nLuego ya podemos acceder al HTML y mirar si existen ciertas etiquetas o su contenido, como en este ejemplo:\nconst { fireEvent, getByText } = require('@testing-library/dom')\nimport '@testing-library/jest-dom/extend-expect'\nimport { JSDOM } from 'jsdom'\nimport fs from 'fs'\nimport path from 'path'\n\nconst html = fs.readFileSync(path.resolve(__dirname, '../index.html'), 'utf8');\n\nlet dom\nlet container\n\ndescribe('index.html', () =&gt; {\nbeforeEach(() =&gt; {\n// Constructing a new JSDOM with this option is the key\n// to getting the code in the script tag to execute.\n// This is indeed dangerous and should only be done with trusted content.\n// https://github.com/jsdom/jsdom#executing-scripts\ndom = new JSDOM(html, { runScripts: 'dangerously' })\ncontainer = dom.window.document.body\n})\n\nit('renders a heading element', () =&gt; {\nexpect(container.querySelector('h1')).not.toBeNull()\nexpect(getByText(container, 'Almacén central - ACME SL')).toBeInTheDocument()\n})\n})\n\nAdemás de getByText para comprobar los elementos de la página tenemos otras queries que podemos utilizar.\nFuente: How to Unit Test HTML and Vanilla JavaScript Without a UI Framework\nUsar jest\nLa documentación oficial proporciona muy buena información de cómo usarlo. En resumen, en los ficheros con las funciones que vayamos a testear debemos 'exportar' esas funciones para que las pueda importar el fichero de test. Lo haremos con module.exports:\nfunction suma(a, b) {\nreturn a + b;\n}\nmodule.exports = suma;\n\nSi tenemos varias funciones podemos exportar un objeto con todas ellas:\nmodule.exports:\nfunction suma(a, b) {\nreturn a + b;\n}\nmodule.exports = { suma, resta, multiplica, divide };\n\nEn el fichero de test (que normalmente se llamará como el original más test antes de la extensión, por ejemplo funciones.test.js) importamos esas funciones con un require:\nconst suma = require('./funciones');\n\ny ya podemos acceder llamar a la función 'suma' desde el fichero de test. Si queremos importar varias funciones haremos:\nconst funciones = require('./funciones');\n\ny accederemos a cada una como 'funciones.suma', ...\nYa podemos crear nuestro primer test para probar la función suma:\ntest('Suma 1 + 1 devuelve 2', () =&gt; {\nexpect(funciones.suma(1, 1)).toBe(2);\n});\n\nPara crear un test usamos la instrucción test (o it) a la que le pasamos como primer parámetro un nombre descriptivo de lo que hace y como segundo parámetro la función que realiza el test. En general usaremos expect y le pasamos como parámetro la llamada a la función a testear y comparamos el resultado devuelto usando un matcher.\nMatchers\nLos más comunes son:\n\ntoBe(): compara el resultado del expect con lo que le pasamos como parámetro. Sólo sirve para valores primitivos (number, string, boolean, ...) no para arrays ni objetos\ntoBeCLoseTo(): se usa para números de punto flotante. expect(0.1 + 0.2).toBe(0.3) fallaría por el error de redondeo\ntoEqual(): como el anterior pero para objetos y arrays. Comprueba cada uno de los elementos el objeto o array\ntoBeLessThan, toBeLessThanOrEqual, toBeGreaterThan, toBeGreaterThanOrEqual: para comparaciones &lt;, &lt;=, &gt;, &gt;=\ntoBeTruthy: el valor devuelvo es verdadero o asimilable a verdadero (si fuera la condición de un if se ejecutaría el then)\ntoBeFalsy: el valor devuelvo es falso o asimilable a falso (si fuera la condición de un if se ejecutaría el else)\ntoBeUndefined: el valor es undefined\ntoBeDefined: el valor NO es undefined\ntoBeNull: el valor devuelto es null\ntoMatch: el valor devuelto debe cumplir con la expresión regular pasada\ntoContain: el array devuelto debe contener el elemento pasado como parámetro\ntoHaveLength: el array o el string devueltos debe tener la longitud indicada\n\nPara comprobar si una función ha lanzado una excepción se usa toThrow. Podemos comprobar sólo que haya lanzado un error, que sea de un tipo determinado, el mensaje exacto que tiene o si el mensaje cumple con una expresión regular:\nfunction compileAndroidCode() {\nthrow new Error('you are using the wrong JDK');\n}\n\ntest('compiling android goes as expected', () =&gt; {\nexpect(compileAndroidCode).toThrow();\nexpect(compileAndroidCode).toThrow(Error);\nexpect(compileAndroidCode).toThrow('you are using the wrong JDK');\nexpect(compileAndroidCode).toThrow(/JDK/);\n});\n\nPodemos obtener la lsita completa de matchers en al documentación oficial de Jest.\nTest suites\nEn muchas ocasiones no vamos a pasar un único test sino un conjunto de ellos. En ese caso podemos agruparlos en un test suite que definimos con la instruacción describe a la que pasamos un nombre que la describa y una función que contiene todos los tests a pasar:\ndescribe('Funciones aritméticas', () =&gt; {\ntest('Suma 1 + 1 devuelve 2', () =&gt; {\nexpect(funciones.suma(1, 1)).toBe(2);\n});\n\ntest('Resta 2 - 1 devuelve 1', () =&gt; {\nexpect(funciones.resta(2, 1)).toBe(1);\n});\n});\n\nMocks\nMuchas veces debemos testear partes del código que llaman a otras funciones pero no nos interesa que se ejecuten esas funciones sino simplemente saber si se han llamado o no y con qué parámetros. Para eso se definen las fuciones mock. Consiste en declarar en nuestro fichero de test una función a la que llama el código como función de jest.\nPor ejemplo, tenemos un método de un controlador llamado addProduct que llama a otro de la vista llamado renderProduct para renderizar algo. Nosotros sólo queremos testear que se llama a la vista y que el parámetro que se le pasa es el adecuado. En nuestro test haremos:\nrenderProduct = jest.fn();\n\ntest('renderProduct called once with product {id: 1, name: &quot;Prod 1&quot;, price: 49.99}', () =&gt; {\nconst product = {id: 1, name: &quot;Prod 1&quot;, price: 49.99};\n\nrenderProduct(product);\nrenderProduct({});\n\n\texpect(renderProduct.mock.calls.length).toBe(2);\n\texpect(renderProduct.mock.calls[0][0]).toEqual(newProd);\n\texpect(renderProduct.mock.calls[1][0]).toEqual({});\n})\n\nEn realidad no se llama a la función real sino a la definida por el mock y podemos ver las veces que ha sido llamada (fn.mock.calls.length) o el primer parámetro pasado en la primera llamada (fn.mock.calls[0][0]) o en la segunda (fn.mock.calls[1][0]).\nPodéis obtener toda la información en la documentación de jest.\nTambién podemos encontrar muchos ejemplos en otras webs, como en adalab\nTestear promesas\nPara testear una función que devuelve una promesa debemos hacerlo de diferente manera. Por ejemplo tenemos una función 'getData' que devuelve una promesa. Para testearla:\ntest('getData devuelve un arrya de 3 elementos', () =&gt; {\nreturn getData().then(data =&gt; expect(data).toHaveLength(3) );\n});\n\nNo olvidéis poner el 'return', si no el test acabará sin esperar a que se resuelva la promesa. Si lo que queremos es comprobar que la promesa es rechazada haremos:\ntest('getData devuelve un arrya de 3 elementos', () =&gt; {\nexpect.assertions(1);\nreturn getData().catch(err =&gt; expect(err).toMatch('404');\n});\n});\n\nEn este caso esperamos que devuelva un error que contenga '404'. Hay que poner la línea de expect.assertions para evitar que una promesa cumplida no haga que falle el test.\nEn la documentación oficial de Jest podemos encontrar información de cómo probar todo tipo de llamadas asíncronas (callback, async/await, ...).\nHooks de Jest\nPermiten ejecutar código antes o depués de pasar cada test o el conjunto de ellos. Son:\n\nafterEach(): Después de cada prueba.\nafterAll(): Después de todas las pruebas.\nbeforeEach(): Antes de cada prueba.\nbeforeAll(): Antes de todas las pruebas.\n\nPor ejemplo podemos querer inicializar la base de datos antes de pasar cada test:\nbeforeAll(() =&gt; {\ninitializeCityDatabase();\n});\n\nSi se trata de una función asíncrona habrá que añadirle un 'return' igual que hacíamos con las promesas:\nbeforeAll(() =&gt; {\nreturn initializeCityDatabase();\n});\n\nafterAll(() =&gt; {\nreturn clearCityDatabase();\n});\n\ntest('city database has Vienna', () =&gt; {\nexpect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () =&gt; {\nexpect(isCity('San Juan')).toBeTruthy();\n});`\n\nDesarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y luego el código que las pase. Por último deberíamos refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el test (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).",
		"tags": [ "note"]
},

{
		"title": "README",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/README/",
		"content": "BLOQUE 1 - El lenguaje Javascript\nEn este primer bloque vamos a conocer el lenguaje Javascript. El bloque se divide en:\n\nIntroducción a Javascript\n1-Sintaxis: Variables. Funciones. Estructuras y bucles. Tipos de datos. Buenas prácticas\n\nIntroducción a los test en Javascript\n\n2.1-Objetos: Introducción a los objetos en Javascript\n2.2-Arrays: Métodos. Functional Programming. Referencia vs copia. Rest y Spread. Desestructuración de arrays. Map. Set\n\nVite: Cómo usar vite\nWebpack: Cómo usar webpack\n\n3-Programación Orientada a Objetos: Introducción. Clases. POO en JS5\n4-Browser Object Model - BOM: Timers. Objetos del BOM (window,\n5-Ajax. Promesas. SPA\n6-Document Object Model - DOM: Acceso a nodos. Acceso desde otros nodos. Manipular el árbol DOM. Atributos de los nodos\n\n6.1-MVC: Cómo usaremos el patrón MVC para crear la UI de nuestra aplicación\nlocation, history, otros objetos)\n\n7-Eventos: Escuchadores. Tipos de eventos. Los objetos this y event. Propagación de eventos (bubbling)\n8-Objetos nativos: Funciones globales. Objetos nativos del lenguaje: Math, Date, RegExp, ...\n9-Validación de formularios: Validación de formularios. La API de validación de formularios. Expresiones regulares\n\n10-APIs HTML5: Drag and drop. API Storage. Geolocalización. API de Google Maps\n11-Más cosas a aprender...: WebComponents. WebSockets. WebWorkers. Typescript.\n12-Tests: Testear JS con Jest\n\nIntroducción a Javascript\n\nBLOQUE 1 - El lenguaje Javascript\nIntroducción a Javascript\n\nIntroducción\n\nUn poco de historia\nSoporte en los navegadores\n\nHerramientas\n\nLa consola del navegador\nEditores\nEditores on-line\n\nIncluir javascript en una página web\nMostrar información\n\nBibliografía\n\nIntroducción\nEn las páginas web el elemento fundamental es el fichero HTML con la información a mostrar en el navegador. Posteriormente surgió la posibilidad de &quot;decorar&quot; esa información para mejorar su apariencia, lo que dio lugar al CSS. Y también se pensó en dar dinamismo a las páginas y apareció el lenguaje Javascript.\nEn un primer momento las 3 cosas estaban mezcladas en el fichero HTML pero eso complicaba bastante el poder leer esa página a la hora de mantenerla por lo que se pensó en separar los 3 elementos básicos:\n\nHTML: se encarga de estructurar la página y proporciona su información, pero es una información estática\nCSS: es lo que da forma a dicha información, permite mejorar su apariencia, permite que se adapte a distintos dispositivos, ...\nJavascript: es el que da vida a un sitio web y le permite reaccionar a las acciones del usuario\n\nPor tanto nuestras aplicaciones tendrán estos 3 elementos y lo recomendable es que estén separados en distintos ficheros:\n\nEl HTML lo tendremos habitualmente en un fichero index.html, normalmente en una carpeta llamada public\nEl CSS lo tendremos en uno o más ficheros con extensión .css dentro de una carpeta llamada styles\nEL JS estará en ficheros con extensión .js en un directorio llamado scripts\n\nLas características principales de Javascript son:\n\nes un lenguaje interpretado, no compilado\nse ejecuta en el lado cliente (en un navegador web), aunque hay implementaciones como NodeJS para el lado servidor\nes un lenguaje orientado a objetos (podemos crear e isntanciar objetos y usar objetos predefinidos del lenguaje) pero basado en prototipos (por debajo un objeto es un prototipo y nosotros podemos crear objetos sin instanciarlos, haciendo copias del prototipo)\nse trata de un lenguaje débilmente tipado, con tipificación dinámica (no se indica el tipo de datos de una variable al declararla e incluso puede cambiarse)\n\nLo usaremos para:\n\nCambiar el contenido de la página\nCambiar los atributos de un elemento\nCambiar la apariencia de algo\nValidar datos de formularios\n...\n\nSin embargo, por razones de seguridad, Javascript no nos permite hacer cosas como:\n\nAcceder al sistema de ficheros del cliente\nCapturar datos de un servidor (puede pedirlo y el servidor se los servirá, o no)\nModificar las preferencias del navegador\nEnviar e-mails de forma invisible o crear ventanas sin que el usuario lo vea\n...\n\nUn poco de historia\nJavascript es una implementación del lenguaje ECMAScript (el estándar que define sus características). El lenguaje surgió en 1997 y todos los navegadores a partir de 2012 soportan al menos la versión ES5.1 completamente. En 2015 se lanzó la 6ª versión, inicialmente llamada ES6 y posteriormente renombrada como ES2015, que introdujo importantes mejoras en el lenguaje y que es la versión mínima que usaremos nosotros. Desde entonces van saliendo nuevas versiones cada año que introducen cambios pequeños. La última es la ES2024.\nLas principales mejoras que introdujo ES2015 son: clases de objetos, let, for..of, Map, Set, Arrow functions, Promesas, spread, destructuring, ...\nSoporte en los navegadores\nLos navegadores no se adaptan inmediatamente a las nuevas versiones de Javascript por lo que puede ser un problema usar una versión muy moderna ya que puede haber partes de los programas que no funcionen en los navegadores de muchos usuarios. En la página de Kangax podemos ver la compatibilidad de los diferentes navegadores con las distintas versiones de Javascript. También podemos usar CanIUse para buscar la compatibilidad de un elemento concreto de Javascript así como de HTML5 o CSS3.\nSi queremos asegurar la máxima compatibilidad debemos usar la versión ES5 (pero nos perdemos muchas mejoras del lenguaje) o mejor, usar la ES6 (o posterior) y después transpilar nuestro código a la version ES5. De esto se ocupan los transpiladores (Babel es el más conocido) por lo que no suponen un esfuerzo extra para el programador.\nHerramientas\nLa consola del navegador\nEs la herramienta que más nos va a ayudar a la hora de depurar nuestro código. Abrimos las herramientas para el desarrollador (en Chrome y Firefox pulsando la tecla F12) y vamos a la pestaña Consola:\n![Consola](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Consola.png)\nAllí vemos mensajes del navegador como errores y advertencias que genera el código y todos los mensajes que pongamos en el código para ayudarnos a depurarlo (usando los comandos console.log y console.error).\nAdemás en ella podemos escribir instrucciones Javascript que se ejecutarán mostrando su resultado. También la usaremos para mostrar el valor de nuestras variables y para probar código que, una vez que funcione correctamente, lo copiaremos a nuestro programa.\nPodemos obtener ayuda sobre el funcionamiento de la consola en la web de Mozilla.\n\nEJERCICIO: abre la consola y prueba las funciones alert, confirm y prompt.\n\nSiempre depuraremos los programas desde aquí (ponemos puntos de interrupción, vemos el valor de las variables, ...).\n![Consola - depurar](/img/user/01 Apuntes/Javascript Teoria Batoi/img/Consola-depurar.png)\nEs fundamental dedicar tiempo a saber utilizar la consola porque nos facilitará enormemente la tarea de depurar nuestro código. Podéis encontrar infinidad de páginas en internet donde nos explican en profundidad el uso de la consola, como Debugging en el navegador.\nEditores\nPodemos usar el que más nos guste, desde editores tan simples como NotePad++ hasta complejos IDEs. La mayoría soportan las últimas versiones de la sintaxis de Javascript (Netbeans, Eclipse, Visual Studio, Sublime, Atom, Kate, Notepad++, ...). Yo voy a utilizar Visual Studio Code o Sublime text por su sencillez y por los plugins que incorpora para hacer más cómodo mi trabajo. En Visual Studio Code instalaré algún plugin como:\n\nSonarLint: es más que un linter y me informa de todo tipo de errores pero también del código que no cumple las recomendaciones (incluye gran número de reglas). Marca el código mientras lo escribimos y además podemos ver todas las advertencias en el panel de Problemas (Ctrl+\nVetur: lo instalaremos en el segundo bloque. Necesario para trabajar con los ficheros de Vue\n\nEditores on-line\nSon muy útiles porque permiten ver el código y el resultado a la vez. Normalmente tienen varias pestañas o secciones de la página donde poner el código HTML, CSS yJavascript y ver su resultado.\nAlgunos de los más conocidos son Codesandbox, Fiddle, Plunker, CodePen, ...aunque hay muchos más.\n\nEjemplo de 'Hello World' en Fiddle:\n\nEjemplo de 'Hello World' en CodePen:\n\nSee the Pen\nHello World Codepen by Kevin Schweickhardt (@kscatcensus)\non CodePen.\n\nIncluir javascript en una página web\nEl código Javascript va entre etiquetas &lt;script&gt;. Puede ponerse en el &lt;head&gt; o en el &lt;body&gt;. Funciona como cualquier otra etiqueta y el navegador la interpreta cuando llega a ella (va leyendo y ejecutando el fichero línea a línea). Podéis ver en este vídeo un ejemplo muy simple de cómo se ejecuta el código en el HEAD y en el BODY.\nLo mejor en cuanto a rendimiento es ponerla al final del &lt;body&gt; para que no se detenga el renderizado de la página mientras se descarga y se ejecuta el código. También podemos ponerlo en el &lt;head&gt; pero usando los atributos async y/o defer (en Internet encontraréis mucha información sobre esta cuestión, por ejemplo aquí.\nComo se ve en el primer vídeo, es posible poner el código directamente entre la etiqueta &lt;script&gt; y su etiqueta de finalización pero lo correcto es que esté en un fichero externo (con extensión .js) que cargamos mediante el atributo src de la etiqueta. Así conseguimos que la página HTML cargue más rápido (si lo ponemos al final del BODY o usamos async) y además no mezclar HTML y JS en el mismo fichero, lo mejora la legibilidad del código y facilita su mantenimento:\n&lt;script src=&quot;./scripts/main.js&quot;&gt;&lt;/script&gt;\n\nMostrar información\nJavascript permite mostrar al usuario ventanas modales para pedirle o mostrarle información. Las funciones que lo hacen son:\n\nwindow.alert(mensaje): Muesta en una ventana modal mensaje con un botón de Aceptar para cerra la ventana.\nwindow.confirm(mensaje): Muesta en una ventana modal mensaje con botones de Aceptar y Cancelar. La función devuelve true o false en función del botón pulsado por el usuario.\nwindow.prompt(mensaje [, valor predeterminado]): Muesta en una ventana modal mensaje y debajo tiene un campo donde el usuario puede escribir, junto con botones de Aceptar y Cancelar. La función devuelve el valor introducido por el usuario como texto (es decir que si introduce 54 lo que se obtiene es &quot;54&quot;) o false si el usuario pulsa Cancelar.\n\nTambién se pueden escribir las funciones sin window. (es decir alert('Hola') en vez de window.alert('Hola')) ya que en Javascript todos los métodos y propiedades de los que no se indica de qué objeto son se ejecutan en el objeto window.\nSi queremos mostrar una información para depurar nuestro código no utilizaremos alert(mensaje) sino console.log(mensaje) o console.error(mensaje). Estas funciones muestran la información pero en la consola del navegador. La diferencia es que console.error la muestra como si fuera un error de Javascript.\nBibliografía\n\nCurso &quot;Programación con JavaScript&quot;. CEFIRE Xest. Arturo Bernal Mayordomo\nCurso de JavaScript y TypeScript de Arturo Bernal en Youtube\nMDN Web Docs. Moz://a. https://developer.mozilla.org/es/docs/Web/JavaScript\nIntroducción a JavaScript. Librosweb. http://librosweb.es/libro/javascript/\nCurso de Javascript (Desarrollo web en entorno cliente). Ada Lovecode - Didacticode (90 vídeos) de Laura Folgado\nApuntes Desarrollo Web en Entorno Cliente (DWEC). Sergi García Barea",
		"tags": [ "note"]
},

{
		"title": "TDD-mocha",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/TDD-mocha/",
		"content": "Desarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y después refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el est (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).\nUsar TDD en Javascript\nLo más sencillo es usar alguna librería como Mocha. Se trata de un gramework que se ejecuta sobre Node.js y permite crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado. Luego creamos una carpeta para nuestro proyecto y dentro ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
},

{
		"title": "ejercicios",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/ejercicios/",
		"content": "Ejercicios de Javascript\n\nTable of Contents generated with DocToc\n\nEjercicios de Javascript\n\n1.- Sintaxis\n\n1.1 Frase\n\n2.- Arrays\n3.- POO\n\n3.1.- Productos de un almacén\n3.2.- Carro de compra\n\n4.- DOM\n5.- BOM\n6.- Eventos\n7.- Objetos globales\n8.- Ajax\n9.- APIs\n\n1.- Sintaxis\n1.1 Frase\nVamos a pedir al usuario que introduzca una frase y a continuación mostraremos en la consola:\n\nel número de letras y de palabras que tiene\nla frase en mayúsculas\nla frase con la primera letra de cada palabra en mayúsculas\nla frase escrita con las letras al revés\nla frase escrita con las palabras al revés\nsi es o no un palíndromo (si se lee igual al revés) pero omitiendo espacios en blanco y sin diferenciar mayúsculas y minúsculas.\n\nEj.: con la frase introducida “La ruta nos aporto otro paso natural” se mostraría\n\n36 letras y 7 palabras\nLA RUTA NOS APORTO OTRO PASO NATURAL\nLa Ruta Nos Aporto Otro Paso Natural\nlarutan osap orto otropa son atur aL\nnatural paso otro aporto nos ruta La\nSí es un palíndromo\n\nIntenta usar en cada caso el bucle más adecuado. Las funciones split y join (lo opuesto) de String y Array nos pueden ayudar a algunas cosas.\nRECUERDA:\n\nel código deberá estar en un fichero externo y se incluirá al final del body\ndebes comentarlo para tener claro qué hace\ntanto el código JS como el HTML deben estar correctamente indentados\nten en cuenta los datos que pueden “estropearnos” el programa: introducir un dato de un tipo que no te esperas, omitir algún parámetro, ...\nusa las recomendaciones indicadas: 'use strict', ...\nel código debe ser lo más limpio y claro posible, sin variables o código innecesario\nsiempre es bueno refactorizar el código: cuando nuestro programa ya funciona bien le damos un “repaso” para mejorar su claridad (y lo volvemos a probar)\n\n2.- Arrays\nVamos a hacer un programa que va pidiendo al usuario que introduzca las notas de un examen y las va guardando en un array. El usuario puede introducir una sóla nota o varias separadas por un guión (ej. 4,5 - 6 - 8,75) y se continuará pidiendo notas al usuario hasta que éste pulse 'Cancelar'. Recuerda que en Javascript el símbolo decimal es el punto pero el usuario puede introducir decimales con la coma.\nCada nota introducida se almacenará en un array y una vez que estén todas se mostrará por la consola:\n\nel array con los datos suministrados por el usuario\nel array &quot;limpiado&quot;: quitaremos del mismo todo lo que no sean números o no estén entre 0 y 10\nel nº total de aprobados y sus notas\nel nº total de suspensos y sus notas\nla nota del 1º suspenso y su posición en el array\nla nota media del examen\n\nSiempre que sea posible utilizaremos métodos de arrays en lugar de bucles.\n3.- POO\n3.1.- Productos de un almacén\nEn este ejercicio vamos a trabajar con los productos de un almacén, para lo que crearemos las clases:\n\nProduct: cada producto será un objeto con las propiedades cod, name, price y units (las unidades que tenemos de ese producto). Si no le pasamos unidades al constructor su número por defecto será 1. Esta clase tendrá los siguientes métodos:\n\nchangeUnits: recibe la cantidad a aumentar (positiva o negativa) e incrementa (o decrementa) las unidades en la cantidad recibida. Si se intentan restar más unidades de las que hay no hace nada y devuelve false y en otro caso cambia las unidades y devuelve true\nproductImport: devuelve el importe total del producto (su precio multiplicado por el nº de unidades)\nademás si se intenta imprimir el producto se mostrará su descripción, sus unidades entre paréntesis, su precio y el importe total, como en el siguiente ejemplo: TV Samsung MP45 (5): 235,95 €/u =&gt; 1179,75 €\n\nStore: es el almacén de productos y tendrá las propiedades id (código numérico que nos pasan al crear el almacén) y products (array de productos que al crearlo estará vacío) y los métodos:\n\nfindProduct: recibe un código de producto y devuelve el producto que tiene dicho código o null si ese código no existe en el almacén\naddProduct: recibe como parámetro el código y unidades a añadir y, opcionalmente, el nombre y precio (si se trata de un producto nuevo) y lo añade al almacén. Si ya existe el código suma al producto las unidades indicadas y si no existe crea un nuevo producto en el array. Devuelve true\ndelProduct: recibe como parámetro el código y las unidades a quitar de un producto y lo resta del almacén. Devuelve true a menos que haya menos unidades de las que quieren restarse, en cuyo caso no hace nada y devuelve false\ntotalImport: devuelve el valor total de los productos del almacén\norderByDescrip: devuelve el array de productos ordenado por el nombre\norderByUnits: devuelve el array de productos ordenado por unidades descendente\n\nPara probar que funciona correctamente ejecutaremos en nuestro fichero main.js:\nlet almacen=new Store(1);\nalmacen.addProduct(1, 4, 'TV Samsung MP45', 345.95);\nalmacen.addProduct(2, 8, 'Portátil Acer Travelmate 200', 245.95);\nalmacen.addProduct(3, 15, 'Impresora Epson LX-455', 45.95);\nalmacen.addProduct(4, 25, 'USB Kingston 16GB', 5.95);\n\nconsole.log('LISTADO DEL ALMACÉN');\nalmacen.products.forEach(prod=&gt;console.log(prod.toString()));\n\nalmacen.addProduct(5, 15, 'USB Kingston 64GB', 15.95);\nalmacen.delProduct(3, 11);\nalmacen.delProduct(3, 7);\nalmacen.addProduct(1, 9);\n\nconsole.log('LISTADO DEL ALMACÉN');\nalmacen.products.forEach(prod=&gt;console.log(prod.toString()));\n\nAdemás en nuestro main.js haremos que se muestren por consola todos los productos de los que tenemos menos de 5 unidades en stock o cuyo importe es inferior a 150 €.\n3.2.- Carro de compra\nVamos a permitir que los usuarios hagan compras on-line para lo que crearemos una clase para los carritos de la compra:\n\nCart: esta clase la usaremos para crear carritos de compra con los productos a comprar. Es como la clase Store pero tiene además la propiedad user con el identificador del usuario que hace la compra y que nos lo pasarán al crear el carrito. Respecto a sus métodos son igual que los de la clase Store pero:\n\nel método delProduct eliminará el producto del array de productos si sus unidades son 0\ntendrá dos nuevos métodos addToCart y removeFromCart que nos permitan añadir y quitar productos del carro y que recibirán como parámetros el código del producto y las unidades a añadir o quitar.\n\nNOTA: la variable del almacén será una variable global en el fichero main.js\n4.- DOM\nVamos a mostrar en una tabla los products de nuestro almacén. Cada fila corresponderá a un producto y se mostrará su código, nombre, unidades, precio por unidad e importe. Debajo de la tabla mostraremos el importe total del almacén. En el fichero index.html crearemos la tabla vacía y el párrafo para poner el importe total.\nPara simplificar nuestro código a la clase Product le añadiremos el método toTR que devolverá el código HTML para mostrar una fila con los datos del producto y a la clase Store le añadiremos el método toHTML que devolverá el código HTML que insertaremos dentro de la tabla del almacén.\nAdemás cada vez que creemos un carrito se mostrará en la página una nueva UL con su código y su usuario. Cada artículo del carro será una LI de la UL y al final habrá una LI con el importe total del carro. Ej.:\n\nCarro 2 - juan\n\n1 x TV Samsung MP45 (345.95 €) = 345.95 €\n3 x USB Kingston 16GB (5.95 €) = 17.85 €\nImporte total: 353.80 €\n\nNOTA: podemos hacer algo para que sea más fácil crear los elementos del DOM tal y como hems hecho para crear la tabla???.\nOPCIONAL: mejorar la presentación usando bootstrap. Pondremos la tabla del almacén y debajo los carritos, 2 por fila.\n5.- BOM\n6.- Eventos\nBotones y enlaces para el ejercicio del almacén\n7.- Objetos globales\nFechas, ...\n8.- Ajax\nLeer y guardar el almacén (y los carritos?)\n9.- APIs",
		"tags": [ "note"]
},

{
		"title": "xx-tests",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/Javascript Teoria Batoi/xx-tests/",
		"content": "Usar TDD en Javascript\nLo más sencillo es usar alguna librería como Jest, Mocha o Vitests (una adaptación de Jest para Vite). Se trata de librerías que se ejecutan sobre Node.js y permiten crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado.\nUso de Vitest\nPodéis obtener información sobre cómo hacer test con Vitest en muchas páginas de Internet como:\n\nCurso DWEC de Jose Castillo\nVitest\n\nUso de Mocha\nPara instalarlo ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
},

{
		"title": "1. Arquitecturas WEB",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/1. Arquitecturas Web/1. Arquitecturas WEB/",
		"content": "Arquitectures Web\nUna arquitectura web defineix l'estructura i el comportament dels components d'una aplicació web, incloent com es comuniquen entre ells i amb els usuaris finals. Aquesta arquitectura pot abastar des de la interfície d'usuari en el client fins als serveis de backend i bases de dades en el servidor.\nLes arquitectures web són fonamentals en el desenvolupament d'aplicacions web modernes per diverses raons:\n\nEscalabilitat: Les arquitectures ben dissenyades permeten que les aplicacions web gestionen un nombre creixent d'usuaris i dades sense sacrificar el rendiment. Per exemple, una arquitectura de microserveis facilita l'escalabilitat horitzontal, ja que cada servei es pot escalar independentment.\nMantenibilitat: Una bona arquitectura facilita el manteniment i l'actualització de les aplicacions. Mitjançant la separació de preocupacions (per exemple, en una arquitectura de tres capes), es poden fer canvis en una part del sistema sense afectar altres parts.\nSeguretat: Les arquitectures web poden incorporar diverses capes de seguretat per protegir les dades i les comunicacions. Això inclou mesures com l'autenticació, l'autorització, la xifratge de dades, i la protecció contra atacs comuns com les injeccions SQL i el cross-site scripting (XSS).\nRendiment: L'arquitectura de l'aplicació web afecta directament el seu rendiment. Una arquitectura ben dissenyada optimitza el temps de resposta i la gestió de recursos, millorant l'experiència de l'usuari. L'ús de tècniques com la caché, el balanç de càrrega, i la compressió de contingut són exemples d'estratègies per millorar el rendiment.\nFlexibilitat i Adaptabilitat: Les arquitectures modernes permeten l'ús de diverses tecnologies i eines per a diferents parts del sistema, proporcionant flexibilitat i permetent una adaptació ràpida als canvis tecnològics. Això és especialment rellevant amb l'adopció de pràctiques DevOps i l'ús de contenidors i orquestradors com Docker i Kubernetes.\nCol·laboració i Desplegament: Un bon disseny arquitectònic facilita la col·laboració entre equips de desenvolupament, ja que clarifica les responsabilitats i els punts d'integració. També permet un desplegament més eficient i automatitzat, reduint els riscos d'errors i millorant el temps de lliurament.\n\n1.Tipus d'Arquitectures Web\nA continuació, es descriuen alguns dels principals tipus d'arquitectures web, cadascun amb les seves pròpies característiques, avantatges i desavantatges:\nArquitectura Client-Servidor\nEn aquest model, el client (generalment un navegador web) envia sol·licituds al servidor, que processa aquestes sol·licituds i envia les respostes corresponents.\nDiagrama:\n\nCaracterístiques:\n\nEl client és responsable de la interfície d'usuari.\nEl servidor maneja la lògica d'aplicació i l'accés a les dades.\n\nAvantatges:\n\nSeparació de responsabilitats.\nFacilita el manteniment i la seguretat.\n\nDesavantatges:\n\nPot tenir problemes de rendiment amb moltes sol·licituds simultànies.\n\nArquitectura de Tres Capes\nAquesta arquitectura divideix l'aplicació en tres nivells: la capa de presentació, la capa de lògica d'aplicació, i la capa de dades.\nDiagrama:\n\nCaracterístiques:\n\nLa capa de presentació gestiona la interfície d'usuari.\nLa capa de lògica d'aplicació processa les dades i executa la lògica de negoci.\nLa capa de dades emmagatzema i recupera la informació.\n\nAvantatges:\n\nFacilita l'escalabilitat.\nMillora la seguretat, ja que les dades no són directament accessibles des del client.\n\nDesavantatges:\n\nPot ser més complexa de desenvolupar i mantenir.\n\nArquitectura de Microserveis\nEls microserveis descomponen una aplicació en una sèrie de serveis petits i independents, cadascun executant una funció específica.\nDiagrama:\n\nCaracterístiques:\n\nCada microservei es pot desplegar, actualitzar, i escalar independentment.\nUtilitzen protocols lleugers com HTTP/REST o gRPC per comunicar-se.\n\nAvantatges:\n\nMillora l'escalabilitat i la flexibilitat.\nFacilita l'ús de diferents tecnologies per a diferents serveis.\n\nDesavantatges:\n\nPot ser complexa de gestionar i coordinar.\nRequereix una infraestructura de desplegament i monitorització més robusta.\n\nRecursos Addicionals\n\nDocumentació sobre Arquitectures de Software: Software Architecture Guide\nTutorial de Microserveis: Microservices Tutorial\n\nResum\nLes arquitectures web són fonamentals per al desenvolupament d'aplicacions eficients i escalables. La selecció de l'arquitectura adequada depèn de les necessitats específiques del projecte, incloent-hi consideracions de rendiment, escalabilitat, seguretat i mantenibilitat.\n2. Pàgines Web Estàtiques vs. Dinàmiques\nPàgines estàtiques\nLes pàgines web estàtiques són aquelles en què el contingut no canvia en funció de les accions de l'usuari. Estan construïdes amb HTML i CSS, i cada pàgina es carrega de manera independent des del servidor.\nAvantatges\n\nSenzillesa: Fàcils de crear i mantenir.\nRendiment: Temps de càrrega ràpid perquè no requereixen processament addicional.\nSeguretat: Menys vulnerabilitats, ja que no hi ha lògica de servidor ni bases de dades.\n\nDesavantatges\n\nFlexibilitat: Difícils de modificar a gran escala sense eines automatitzades.\nInteractivitat: Limitada, ja que no poden respondre a les accions de l'usuari de manera dinàmica.\n\nExemple Pràctic\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Pàgina Estàtica&lt;/title&gt;\n&lt;style&gt;\nbody { font-family: Arial, sans-serif; }\n.content { margin: 20px; }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;content&quot;&gt;\n&lt;h1&gt;Benvingut!&lt;/h1&gt;\n&lt;p&gt;Aquesta és una pàgina web estàtica.&lt;/p&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nPàgines dinàmiques\nLes pàgines web dinàmiques són aquelles en què el contingut pot canviar en funció de les accions de l'usuari o altres factors. Utilitzen llenguatges de guions o d'scripting. Els llenguatges de guions sovint s’utilitzen per ampliar les prestacions que ofereix un altre llenguatge, entorn o aplicació. En aquest sentit són molt utilitzats en el desenvolupament d’aplicacions web:\n\nScripts de navegadors web. S’utilitzen per ampliar les capacitats de l’HTML i per inserir accions en pàgines web. Permeten crear efectes especials i aporten interactivitat. Els scripts són interpretats i executats en la màquina client pel navegador web, el qual ha d’incorporar l’intèrpret del llenguatge. Un exemple de llenguatge d’aquest tipus molt utilitzat és JavaScript.\nScripts de servidor. Són programes que permeten donar funcionalitats a les pàgines web que no es poden resoldre només amb els scripts de navegador. Els scripts de servidor permeten dotar de certa “intel·ligència” els llocs web, la qual cosa fa que generin pàgines diferents segons les circumstàncies. Exemples de llenguatges de servidor són PHP, Python, Node.js, entre altres.\n\nAvantatges\nActualització en Temps Real\n\nDescripció: Les pàgines es poden actualitzar automàticament sense necessitat de recarregar tota la pàgina.\nCas d'Ús: Un portal de notícies que mostra articles nous sense necessitat de recarregar la pàgina.\n\nPersonalització del Contingut\n\nDescripció: Permet adaptar el contingut a les preferències i el comportament de l'usuari.\nCas d'Ús: Una botiga en línia que mostra recomanacions de productes basades en l'historial de navegació i compres de l'usuari.\n\nInteractivitat Avançada\n\nDescripció: Facilita la creació d'aplicacions web interactives que poden respondre a les accions de l'usuari en temps real.\nCas d'Ús: Aplicacions de xarxes socials que mostren actualitzacions i notificacions en temps real.\n\nGestió Eficient de Contingut\n\nDescripció: Permet gestionar grans quantitats de contingut de manera més eficient, mostrant només el contingut rellevant en funció de la sol·licitud de l'usuari.\nCas d'Ús: Un sistema de gestió de continguts (CMS) que permet als administradors editar i publicar articles de manera dinàmica.\n\nDesavantatges\n\nComplexitat: Més difícils de crear i mantenir, ja que requereixen programació tant al client com al servidor.\nRendiment: Poden ser més lentes a causa de la necessitat de processament al servidor.\nSeguretat: Exposades a més vulnerabilitats, com injeccions SQL, si no es prenen les precaucions adequades.\n\nImpacte en Aplicacions Modernes\nMillora de l'Experiència d'Usuari\n\nLes aplicacions modernes utilitzen la generació dinàmica de pàgines per oferir una experiència més fluida i responsiva. Per exemple, aplicacions com Gmail i Google Docs permeten als usuaris interactuar amb el contingut en temps real sense interrupcions.\n\nOptimització del Rendiment\n\nLa generació dinàmica de pàgines permet carregar només el contingut necessari, reduint la càrrega inicial i millorant el rendiment general de l'aplicació. Això és especialment útil en aplicacions complexes amb molta interactivitat.\n\nCapacitat de Resposta a les Sol·licituds de l'Usuari\n\nAplicacions com Facebook i Twitter utilitzen la generació dinàmica per actualitzar el feed en temps real, oferint als usuaris informació actualitzada immediatament.\n\nExemple Pràctic (PHP)\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Pàgina Dinàmica&lt;/title&gt;\n&lt;style&gt;\nbody { font-family: Arial, sans-serif; }\n.content { margin: 20px; }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;content&quot;&gt;\n&lt;h1&gt;Benvingut!&lt;/h1&gt;\n&lt;p&gt;Aquesta pàgina ha estat generada a les &lt;?php echo date('H:i:s'); ?&gt;.&lt;/p&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nComparativa entre Pàgines Web Estàtiques i Dinàmiques\n\nCaracterística\nPàgines Web Estàtiques\nPàgines Web Dinàmiques\n\nContingut\nFix, no canvia\nVariable, pot canviar\n\nComplexitat\nBaixa\nAlta\n\nInteractivitat\nLimitada\nAlta\n\nRendiment\nAlt\nPot ser baix\n\nSeguretat\nAlta\nDepèn de la implementació\n\nFlexibilitat\nBaixa\nAlta\n\nSEO\nBona\nDepèn de la implementació\n\nTemps de Desenvolupament\nCurt\nLlarg\n\nActualització del Contingut\nManual\nAutomàtica\n\nCost de Manteniment\nBaix\n\nRecursos Addicionals\n\nArticle sobre els avantatges de les pàgines dinàmiques\nCurs sobre generació dinàmica de pàgines web\nDocumentació de HTML: MDN HTML Guide\nDocumentació de CSS: MDN CSS Guide\nDocumentació de PHP: PHP Documentation\nDocumentació de JavaScript (MDN): MDN JavaScript Guide\nDocumentació de Node.js: Node.js Documentation\nDocumentació de React: React Documentation\n\nResum\nLes pàgines web estàtiques són adequades per a llocs web senzills amb contingut fix, mentre que les pàgines web dinàmiques són necessàries per a aplicacions més complexes que requereixen interactivitat i contingut variable. La decisió entre utilitzar una pàgina estàtica o dinàmica dependrà de les necessitats específiques del projecte i dels recursos disponibles. Les SPA ofereixen una experiència d'usuari molt rica però poden tenir desavantatges en termes de SEO i temps de càrrega inicial.\n3. Models d'Execució\nEls models d'execució de codi en el desenvolupament web es poden dividir principalment en dos tipus: execució al client i execució al servidor. Cada model té les seves pròpies característiques, avantatges i desavantatges que cal considerar a l'hora de dissenyar una aplicació web.\nExecució de Codi al Client (FrontEnd)\nL'execució de codi al client es realitza al navegador web de l'usuari. Els llenguatges utilitzats principalment per a l'execució al client són HTML, CSS i JavaScript.\nAvantatges\n\nInteractivitat: Permet la creació d'experiències d'usuari riques i interactives.\nReducció de la càrrega del servidor: El processament es fa al dispositiu de l'usuari, disminuint la càrrega del servidor.\nActualització instantània: Canvis en l'UI poden ser reflectits immediatament sense necessitat de recarregar la pàgina.\n\nDesavantatges\n\nSeguretat: El codi del client és visible i modificable pels usuaris, la qual cosa pot representar un risc de seguretat.\nCompatibilitat: Pot haver-hi diferències en la manera com diferents navegadors interpreten el codi.\n\nExemple de codi\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Exemple Client&lt;/title&gt;\n&lt;style&gt;\nbody { font-family: Arial, sans-serif; }\n.content { margin: 20px; }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=&quot;content&quot;&gt;\n&lt;h1&gt;Hola, món!&lt;/h1&gt;\n&lt;button onclick=&quot;mostrarMissatge()&quot;&gt;Fes clic aquí&lt;/button&gt;\n&lt;p id=&quot;missatge&quot;&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\nfunction mostrarMissatge() {\ndocument.getElementById('missatge').innerText = 'Has fet clic al botó!';\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nExecució de Codi al Servidor (BackEnd)\nL'execució de codi al servidor es realitza al servidor web abans que els resultats es retornin al navegador del client. Els llenguatges habituals inclouen PHP, Python, Ruby, Node.js, entre altres.\nAvantatges\n\nSeguretat: El codi del servidor no és accessible pels usuaris finals, la qual cosa augmenta la seguretat.\nPotència: Els servidors solen ser més potents que els dispositius dels usuaris, permetent processar operacions més complexes.\n\nDesavantatges\n\nLatència: Les sol·licituds al servidor poden ser lentes a causa de la distància física i la càrrega del servidor.\nEscalabilitat: Pot ser necessari més esforç per escalar una aplicació a mesura que augmenta el nombre d'usuaris.\n\nExemple de codi\n// server.js\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) =&gt; {\nres.statusCode = 200;\nres.setHeader('Content-Type', 'text/plain');\nres.end('Hola, món!\\n');\n});\n\nserver.listen(port, hostname, () =&gt; {\nconsole.log(`El servidor s'està executant a http://${hostname}:${port}/`);\n});\n\nSingle Page Application (SPA)\nUna Single Page Application (SPA) és un tipus d'aplicació web que carrega una única pàgina HTML i dinàmicament actualitza el contingut a mesura que l'usuari interactua amb l'aplicació, utilitzant JavaScript per a gestionar la lògica i les actualitzacions de la interfície d'usuari.\nAvantatges\n\nExperiència d'usuari millorada: Les SPA ofereixen una navegació més ràpida i fluida, similar a una aplicació d'escriptori.\nMenys càrrega del servidor: Menys sol·licituds al servidor ja que només es carrega una pàgina inicialment.\nDesenvolupament modular: Facilita la creació de components reutilitzables.\n\nDesavantatges\n\nSEO: Les SPA poden ser menys amigables amb els motors de cerca.\nCarregada inicial: Pot requerir una major càrrega inicial de recursos, afectant el temps de càrrega inicial.\nGestió de l'estat complexa: Pot ser més complicat gestionar l'estat de l'aplicació.\n\nExemple Pràctic (React)\n// index.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;Exemple SPA&lt;/title&gt;\n&lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n// index.js\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction App() {\nconst [message, setMessage] = useState('');\n\nconst handleClick = () =&gt; {\nsetMessage('Has fet clic al botó!');\n};\n\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Hola, món!&lt;/h1&gt;\n&lt;button onClick={handleClick}&gt;Fes clic aquí&lt;/button&gt;\n&lt;p&gt;{message}&lt;/p&gt;\n&lt;/div&gt;\n);\n}\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('root'));\n\nComparativa entre Execució de Codi al Client,al Servidor i el SPA\n\nCaracterística\nClient-Side\nServer-Side\nSingle Page Application (SPA)\n\nExecució\nNavegador del client\nServidor\nNavegador del client\n\nLlenguatges\nJavaScript, HTML, CSS\nPHP, Node.js, Python, Java\nJavaScript, HTML, CSS\n\nTemps de Resposta\nImmediata (després de la càrrega)\nDepèn de la comunicació amb el servidor\nBaixa (després de la càrrega inicial)\n\nSeguretat\nMés exposat a vulnerabilitats\nMés controlat\nMitjana\n\nRecursos\nLimitats pels recursos del client\nRecursos del servidor\nLimitats pels recursos del client\n\nAccés a Dades\nNo pot accedir directament a bases de dades\nAccés directe a bases de dades\nGeneralment via API\n\nInteractivitat\nElevada, pot respondre ràpidament a les accions de l'usuari\nMés difícil d'aconseguir sense Ajax o websockets\nMolt Alta\n\nProcessament\nMenys capacitat de procés\nAlta capacitat de procés\nProcessament distribuit\n\nCarrega del servidor\nBaixa\nAlta\nBaixa\n\nLatència\nBaixa\nPot ser alta\nBaixa (després de la càrrega inicial)\n\nAccés a recursos locals\nLimitat al navegador\nComplet accés al sistema del servidor\nLimitat al navegador\n\nSEO\nMitjana\nAlta\nBaixa\n\nTemps de càrrega inicial\nRàpid\nDepèn de la complexitat\nPot ser lent\n\nComparativa entre desenvolupadors\n\nPerfil\nFerramenta\nTecnologia\n\nFront-end / client\nNavegador Web\nHTML + CSS + JavaScript\n\nBack-end / servidor\nServidor Web + BBDD\nPHP, Python, Ruby, Java / JSP, .Net / .asp\n\n!!! tip &quot;Perfil Full-stack&quot;\nEn les ofertes de treball quan fan referència a un Full-stack developer, estan buscant un perfil que domina tant el front-end com el back-end.\nRecursos addicionals\n\nDocumentació de JavaScript (MDN): MDN JavaScript Guide\nGuia de Node.js: Node.js Documentation\nDocumentació de React: React Documentation\n\nResum\nLa decisió sobre si utilitzar l'execució de codi al client, al servidor o una SPA depèn de les necessitats específiques de l'aplicació i els recursos disponibles. Comprendre les diferències clau i els avantatges de cada model ajudarà a prendre decisions informades i a desenvolupar aplicacions web eficients i segures.\n4. Servidors Web\nUn servidor web és un programa que serveix contingut web estàtic com HTML, CSS, JavaScript, imatges i altres fitxers als clients a través del protocol HTTP o HTTPS. El servidor web gestiona les sol·licituds entrants dels clients (navegadors web) i retorna les respostes adequades.\nFuncionalitats dels Servidors Web\nServei de Contingut Estàtic\n\nDescripció: Proporciona fitxers estàtics com HTML, CSS, JavaScript, imatges i altres recursos directament als clients.\nExemple: Quan un usuari sol·licita una pàgina HTML, el servidor web envia el fitxer HTML corresponent al navegador de l'usuari.\n\nGestió de Peticions HTTP\n\nDescripció: Maneja sol·licituds HTTP de clients, com GET, POST, PUT, DELETE, i retorna les respostes adequades amb els codis d'estat corresponents.\nExemple: Un servidor web processa una sol·licitud GET per una pàgina web i retorna el contingut de la pàgina amb un codi d'estat 200 (OK).\n\nRedirecció i Reescriptura d'URLs\n\nDescripció: Permet la redirecció de peticions a diferents URLs i la reescriptura d'URLs per millorar l'accessibilitat i la SEO.\nExemple: Reescriptura d'URLs amigables per als usuaris, com convertir example.com/page?id=123 a example.com/page/123.\n\nSuport per a HTTPS\n\nDescripció: Proporciona connexions segures utilitzant el protocol HTTPS, que xifra les dades entre el client i el servidor.\nExemple: Un servidor web configurat amb un certificat SSL/TLS que permet connexions segures a través de HTTPS.\n\nExemples de Servidors Web\nApache HTTP Server\n\nDescripció: Un servidor web de codi obert molt utilitzat, conegut per la seva flexibilitat i extensibilitat.\nFuncionalitats: Suport per a mòduls que afegeixen funcionalitats com l'autenticació, la reescriptura d'URLs i la compressió de contingut.\n\nNginx\n\nDescripció: Un servidor web i servidor intermediari de codi obert, dissenyat per gestionar moltes connexions simultànies amb un ús eficient dels recursos.\nFuncionalitats: Actua com a servidor proxy invers, equilibrador de càrrega i servidor de fitxers estàtics.\n\nMicrosoft Internet Information Services (IIS)\n\nDescripció: Un servidor web i d'aplicacions de Microsoft per a plataformes Windows.\nFuncionalitats: Suport per a aplicacions ASP.NET, autenticació integrada i eines de gestió robustes.\n\nMecanismes d'Execució de Codi en Servidors Web\nLlenguatges interpretats: PHP, Python\nEl codi es processa línia per línia en temps real, permetent una major flexibilitat durant el desenvolupament, ja que els canvis poden ser implementats i testats immediatament sense necessitat de recompilar tot el projecte.\n&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;&lt;?php echo &quot;Hola, món!&quot;; ?&gt;&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nLlenguatges compilats: Java\nEl codi es compila abans de ser executat, el que significa que és transformat en un format executable per la màquina abans de la seva execució. Això sol millorar el rendiment, ja que el codi compilat s'executa més ràpidament que el codi interpretat.\n// Exemple simplificat d'un servlet Java\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class HelloWorldServlet extends HttpServlet {\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\nthrows ServletException, IOException {\nresponse.setContentType(&quot;text/html&quot;);\nPrintWriter out = response.getWriter();\nout.println(&quot;&lt;h1&gt;Hola, món!&lt;/h1&gt;&quot;);\n}\n}\n\nIntermediari: Node.js\nPermet la programació asíncrona i escalable amb JavaScript, oferint la capacitat de gestionar moltes connexions simultànies de manera eficient. Això és especialment útil per a aplicacions que necessiten alta concurrència, com aplicacions en temps real.\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) =&gt; {\nres.send('Hola, món!');\n});\n\napp.listen(3000, () =&gt; {\nconsole.log('Servidor escoltant a http://localhost:3000');\n});\n\nLlenguatges i Tecnologies de Programació Web en Entorn Servidor\nEls mecanismes d'execució de codi en els servidors web permeten que les aplicacions generin contingut dinàmic, gestionin dades i interaccions d'usuaris de manera eficient. A continuació es descriuen diversos llenguatges i com funcionen en el context del servidor.\nPHP\n\nDescripció: PHP és un llenguatge interpretat popularment utilitzat per a la creació de pàgines web dinàmiques.\nMecanisme: El codi PHP s'incrusta dins dels fitxers HTML i es processa en temps real pel servidor web abans de ser enviat al client.\n\nNode.js\n\nDescripció: Node.js permet la programació asíncrona i escalable amb JavaScript.\nMecanisme: Utilitza un model basat en esdeveniments que permet la gestió de moltes connexions simultànies sense bloquejar-se.\n\nJava (JSP/Servlets)\n\nDescripció: Java s'utilitza per a aplicacions empresarials amb alta complexitat i escalabilitat.\nMecanisme: El codi Java es compila abans d'executar-se, millorant el rendiment. Els servlets i JSP gestionen les sol·licituds HTTP i generen contingut dinàmic.\n\nPython (Django/Flask)\n\nDescripció: Python és conegut per la seva sintaxi clara i les seves biblioteques extensives. Django i Flask són frameworks populars.\nMecanisme: Django utilitza un ORM per interactuar amb bases de dades, mentre que Flask és més lleuger i flexible.\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\nreturn 'Hola, món!'\n\nif __name__ == '__main__':\napp.run()\n\nRuby (Ruby on Rails)\n\nDescripció: Ruby és apreciat per la seva elegància i facilitat d'ús. Ruby on Rails és un framework popular.\nMecanisme: Ruby on Rails segueix el patró MVC, facilitant el desenvolupament d'aplicacions web estructurades.\n\nclass WelcomeController &lt; ApplicationController\ndef index\nrender plain: &quot;Hola, món!&quot;\nend\nend\n\nGo\n\nDescripció: Go és un llenguatge de programació desenvolupat per Google, conegut per la seva eficiència i concurrència.\nMecanisme: Go permet la creació de servidors web ràpids i escalables, utilitzant goroutines per gestionar múltiples connexions de manera eficient.\n\npackage main\n\nimport (\n&quot;fmt&quot;\n&quot;net/http&quot;\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\nfmt.Fprintf(w, &quot;Hola, món!&quot;)\n}\n\nfunc main() {\nhttp.HandleFunc(&quot;/&quot;, helloHandler)\nhttp.ListenAndServe(&quot;:8080&quot;, nil)\n}\n\nComparativa entre llenguatges\n\nLlenguatge\nAvantatges\nDesavantatges\nUsos Comuns\n\nPHP\nAmplament utilitzat, gran comunitat, fàcil d'aprendre\nSeguretat (cal bones pràctiques), rendiment inferior a altres llenguatges\nAplicacions web, CMS com WordPress\n\nPython\nSenzillesa i llegibilitat, gran quantitat de biblioteques, potent per a prototips\nRendiment inferior en algunes àrees, gestió de concurrència\nAplicacions web (Django, Flask), anàlisi de dades\n\nNode.js\nAlta velocitat, no bloqueig (event-driven), gran ecosistema (NPM)\nPot ser complicat per a grans aplicacions, gestió de callbacks\nAplicacions en temps real, serveis web\n\nJava\nRendiment elevat, robustesa, seguretat, escalabilitat\nVerborrea, aprenentatge més complex\nAplicacions empresarials, sistemes grans, Android\n\nRecursos Addicionals:\n\nClient-side vs Server-side\nApache HTTP Server Documentation\nNginx Official Documentation\nMicrosoft IIS Documentation\nW3Schools: PHP Tutorial\nNode.js Documentation\nDjango Documentation\nFlask Documentation\nRuby on Rails Guides\nGo Documentation\nComparació de llenguatges\nCriteris per apendre un llenguatge de programació\n\nResum\nUn servidor web serveix contingut estàtic com HTML, CSS, JavaScript i imatges als clients a través de HTTP o HTTPS. Gestiona sol·licituds entrants i retorna respostes adequades. Exemples de servidors web inclouen Apache, Nginx i Microsoft IIS, cadascun amb funcionalitats úniques com la redirecció d'URLs, suport per a HTTPS i gestió de peticions HTTP. A més, utilitzen llenguatges interpretats (PHP, Python), compilats (Java) i intermediaris (Node.js) per executar codi.\n5. Servidors d'Aplicacions\nUn servidor d'aplicacions és un tipus de servidor dissenyat per executar aplicacions web dinàmiques i gestionar la lògica de negoci d'una aplicació. Aquest servidor actua com una capa intermèdia entre el client (navegador web) i les bases de dades o altres serveis de backend, proporcionant un entorn d'execució per a aplicacions web.\nPrincipals Funcionalitats dels Servidors d'Aplicacions\nGestió de Sessions\n\nDescripció: Manteniment de l'estat de l'usuari durant la seva interacció amb l'aplicació.\nExemple: Sessions PHP que emmagatzemen informació de l'usuari.\n\nConcurrència\n\nDescripció: Capacitat per gestionar múltiples peticions simultànies de manera eficient.\nExemple: Node.js gestiona peticions de manera asíncrona.\n\nSeguretat\n\nDescripció: Autenticació i autorització dels usuaris per accedir a diferents parts de l'aplicació.\nExemple: Utilització de JWT (JSON Web Tokens) per autenticar usuaris en una aplicació Node.js.\n\nRelació entre Servidors Web i Servidors d'Aplicacions\nIntegració i Col·laboració\nEls servidors web treballen conjuntament amb els servidors d'aplicacions per gestionar les sol·licituds de manera eficient. Mentre que el servidor web maneja les sol·licituds HTTP i serveix contingut estàtic, el servidor d'aplicacions processa la lògica de negoci i genera contingut dinàmic.\nExemple de Configuració\n\nServidor Web (Nginx): Actua com a proxy invers, encaminant les sol·licituds dinàmiques al servidor d'aplicacions.\nServidor d'Aplicacions (Node.js): Gestiona les sol·licituds dinàmiques, executa la lògica de negoci i retorna les respostes al servidor web.\n\nConfiguració de Nginx com a Proxy Invers\nserver {\nlisten 80;\nserver_name example.com;\n\nlocation / {\nproxy_pass http://localhost:3000;\nproxy_set_header Host $host;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\n}\n}\n\nConfiguració servidor d'aplicacions Node.js\n\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) =&gt; {\nres.send('Hola, món!');\n});\n\napp.listen(3000, () =&gt; {\nconsole.log('Servidor escoltant a http://localhost:3000');\n});\n\nAquesta col·laboració permet una gestió eficient de les sol·licituds i una millor distribució de la càrrega, millorant el rendiment i l'escalabilitat de les aplicacions web.\nExemples de Servidors d'Aplicacions\nApache Tomcat\n\nDescripció: Un servidor d'aplicacions de codi obert per a aplicacions web Java.\nFuncionalitats: Suporta servlets Java i JavaServer Pages (JSP), facilitant l'execució d'aplicacions Java.\n\nMicrosoft Internet Information Services (IIS)\n\nDescripció: Un servidor web i d'aplicacions de Microsoft per a plataformes Windows.\nFuncionalitats: Suporta aplicacions ASP.NET, autenticació integrada, i eines de gestió robustes.\n\nJBoss EAP (Enterprise Application Platform)\n\nDescripció: Un servidor d'aplicacions Java EE de codi obert desenvolupat per Red Hat.\nFuncionalitats: Proporciona un entorn robust per a la implementació d'aplicacions empresarials amb suport per a diversos frameworks Java.\n\nNode.js\n\nDescripció: Una plataforma per a l'execució de codi JavaScript en el servidor.\nFuncionalitats: Permet la programació asíncrona, ideal per a aplicacions en temps real i escalables com xats i jocs multijugador.\n\n!!! info\nTant els servidors web com els servidors d'aplicacions s'estudien en el mòdul de &quot;Desplegament d'Aplicacions Web&quot;.\nRecursos addicionals\n\nWhat is an Application Server?\nApache Tomcat Documentation\nJBoss Documentation\nGlassFish Documentation\nSpring Framework Documentation\n\nResum\nEls servidors d'aplicacions executen aplicacions dinàmiques i proporcionen serveis empresarials. Es diferencien dels servidors web en què no només serveixen contingut estàtic, sinó que també processen lògica d'aplicació i interaccions de base de dades. Exemples inclouen Apache Tomcat, JBoss i GlassFish, utilitzats per a aplicacions Java. També donen suport a tecnologies com servlets, JSP, EJB i frameworks com Spring, facilitant la construcció d'aplicacions robustes i escalables.\n6.Frameworks de Programació en Entorn Servidor\nUn framework és una plataforma de desenvolupament que proporciona una estructura estandarditzada per a la creació d'aplicacions web. Facilita i accelera el procés de desenvolupament oferint biblioteques de codi preescrit, components reutilitzables i un conjunt de bones pràctiques. Els frameworks ajuden els desenvolupadors a centrar-se en la funcionalitat de l'aplicació en lloc de preocupar-se pels aspectes bàsics i repetitius de la programació.\nPrincipals Frameworks en Entorn Servidor\nExpress.js\n\nDescripció: Express.js és un framework web minimalista per a Node.js. Proporciona eines senzilles i flexibles per a la creació d'aplicacions web i API.\nCaracterístiques:\n\nMiddleware per a gestionar peticions HTTP.\nSistema d'enrutament senzill i modular.\nSuport per a motors de plantilles com Pug i EJS.\n\nAvantatges:\n\nLleuger i flexible.\nGran comunitat de suport i moltes extensions disponibles.\n\nInconvenients:\n\nRequereix més configuració manual comparat amb altres frameworks.\n\nDjango\n\nDescripció: Django és un framework de programació web d'alt nivell per a Python que permet un desenvolupament ràpid i un disseny net i pragmàtic.\nCaracterístiques:\n\nInclou un ORM (Object-Relational Mapping) potent.\nSistema d'administració automàtic.\nSeguretat integrada.\n\nAvantatges:\n\nPromou les bones pràctiques de desenvolupament.\nMolt complet, amb moltes funcionalitats &quot;out-of-the-box&quot;.\n\nInconvenients:\n\nPot ser massa gran per a aplicacions petites.\n\nLaravel\n\nDescripció: Laravel és un framework PHP elegant i expressiu que ofereix un conjunt complet d'eines i recursos per a construir aplicacions web.\nCaracterístiques:\n\nSistema d'enrutament senzill i potent.\nEloquent ORM per a una interacció fàcil amb bases de dades.\nSistema de templates Blade.\n\nAvantatges:\n\nGran comunitat i abundant documentació.\nFacilitat per a desenvolupar aplicacions robustes i escalables.\n\nInconvenients:\n\nPot tenir una corba d'aprenentatge per als nous desenvolupadors.\n\nComparativa dels Frameworks\n\nCaracterística\nExpress.js\nDjango\nLaravel\n\nIdioma de programació\nJavaScript\nPython\nPHP\n\nORM\nNo integrat, però es pot utilitzar Sequelize o Mongoose\nSí (integrat)\nSí (integrat, Eloquent ORM)\n\nSistema d'enrutament\nSí\nSí\nSí\n\nMotor de plantilles\nSuport per Pug, EJS, etc.\nSí (Django Templates)\nSí (Blade)\n\nSistema d'administració\nNo\nSí\nNo\n\nComunitat\nGran\nGran\nGran\n\nFacilitat d'aprenentatge\nModerada\nModerada\nModerada\n\nDocumentació\nExcel·lent\nExcel·lent\nExcel·lent\n\nSeguretat\nDepèn de la configuració\nAlta, amb funcions integrades\nAlta, amb funcions integrades\n\nCom Trieu un Framework?\nLa selecció del framework adequat per a un projecte depèn de diversos factors:\n\nTipus de Projecte: Aplicacions en temps real, aplicacions CRUD, aplicacions amb necessitats específiques de seguretat, etc.\nIdioma de Programació: Si el teu equip està més familiaritzat amb JavaScript, Python o PHP, per exemple.\nEscalabilitat i Rendiment: Alguns frameworks són més adequats per a aplicacions petites, mentre que altres gestionen millor aplicacions de gran escala.\nEcosistema i Comunitat: La disponibilitat de biblioteques, plugins i la mida de la comunitat poden influir en la decisió.\nFacilitat d'ús i Documentació: Un bon framework ha de tenir una documentació clara i fàcil d'entendre, així com una corba d'aprenentatge adequada per al teu equip.\n\nRecursos Addicionals:\n\nNode.js Official Documentation: Node.js\nExpress.js Official Documentation: Express.js\nDjango Official Documentation: Django\nLaravel Documentation: Laravel\n\n7. Entorn de treball\nEntorn de desenvolupament integrat (IDE)\nEn este curso utilitzarem Visual Studio Code com a editor de codi. Existixen altres alternatives, com PHP Storm.\nGitHub Classroom\nUs haureu de registrar ja que l'utilitzarem durant el curs per la còpia de repositoris i entrega de treballs.\nMetodologia de treball amb el github classroom\n\nSe proporcionarà a l'alumnat un enllaç amb la invitació.\nAccedint a l'enllaç a cada alumne se li crearà un repositori individual en l'organització.\nL'alumnat treballa en el seu repositori assignat. Se'l pot baixar per treballar en local.\nInicialment, l'alumne crea una branca nova sobre la que va a treballar.\nQuan vullga sol.licitar ajuda o revisió del professor, l'alumne genera una pull request a la branca principal del seu repositori en la que cita al professor per tal que reba una notificació.\nEl profesor proporciona retroalimentació mitjançant comentaris en la pull request o en un determinat commit individual.\nOpcionalment es poden utilitzar els issues y les cites d'usuari per sol·licitar la intervenció del profesor.\nQuan l'alumne finalitza la tasca, genera una últim pull request\nEl profesor revisa la pull request i opcionalment fa comentaris.\n\nEntorns de desenvolupament local\nPera fer correr les aplicacions de servidor ens cal, com a mínim, un servidor web, l'interpret de php i un motor de base de dades. Hem de distinguir l'entorn de desenvolupament, on anem a programar i mantindre la nostra aplicació, de l'entorn de producció, on anem a executar-la.\nNormalment el primer depén de nosaltres mentre que el segon pot dependre de l'empresa on s'allotjarà la nostra web. Per a preparar el nostre entorn de desenvolupament podem optar per:\n\nQualsevol solució LAMP (Linux, Apache, Mysql, PHP). Als que haurem d'afegir, una vegada els projectes es facen grans composer, git i les opcions de la part de client.\nUna màquina virtual ja configurada.\nUna solució docker.\n\nLa primera solució és senzilla d'implementar però no hauria de ser la nostra primera opció per:\n\nEstem possant en funcionament en la nostra màquina una sèrie de serveis que normalment no fariem, baixant el rendiment de la màquina i obrint vulnerabilitats.\nSi treballem en grup, les instal·lacions i el funcionament no són iguals, depenen del sistema operatiu que té instal·lat cadascú. Allò que li funciona a ú pot ser no li funciona a un altre. Això és inevitable quan el projecte es complica i es perd molt de temps.\nPassa el mateix quan passem a l'entorn de producció.\n\nLa segona solució soluciona els dos primers problemes, doncs tots els desenvolupadors poden tindre virtualitzada, la mateixa màquina. Encara que si la màquina no la fem nosaltres sinó que utilitzem alguna ja configurada (vagrant) o si ens cal instal·lar alguna cosa més, ho hauria de fer tot l'equip.\nAixí i tot, tindriem les següents desaventatges:\n\nA l'instal·lar una maquina virtual sencera ocupa recursos del sistema.\nLa màquina instal·la més coses de les necessàries habitualment.\nNo reprodueix l'entorn de producció.\n\nLa tercera opció té les següents característiques:\n\nAl principi és més difícil de possar en funcionamet ja que calen coneixements de docker.\nTots els desenvolupadors comparteixen entorn encara que utilitzen màquines o sistemes operatius diferents.\nSi hi ha algun canvi de configuració de l'entorn és fácilment transladable a tots els desenvolupadors.\nEs poden crear tants entorns de desenvolupament com projectes diferents hi hajen.\nEls contenidors ocupen pocs recursos.\nEls projectes es poden possar en producció utilitzan una solució docker de manera inmediata.\n\nXAMPP\nXAMPP (https://www.apachefriends.org/es/index.html) és una distribució composta amb el programari necessari per a desenvolupar en entorn servidor. Es compon de les següents eines sobre la base de les seues sigles:\nDes de la pròpia pàgina es pot descarregar l'arxiu executable per al sistema operatiu del nostre ordinador. Es recomana llegir la FAQ de cada sistema operatiu amb instruccions per a la seua posada en marxa.\n!!! note &quot;Acrònim&quot;\n* X per al sistema operatiu (d'aquí ve que es conega altrament com LAMP o WAMP).\n* A per a Apatxe.\n* M per a MySQL / MariaDB. També inclou phpMyAdmin per a l'administració de la base de dades des d'una interfície web.\n* P per a PHP.\n* P per a Perl.\n!!! note &quot;XAMPP en Windows&quot;\nSi treballes amb el teu propi ordinador, XAMPP és una solució més senzilla que Docker, sobretot si treballes amb Windows com a sistema operatiu.\nDocker\nDocker (https://www.docker.com) és un gestor de contenidors, considerant un contenidor com un mètode de virtualització del sistema operatiu.\nL'ús de contenidors requereix menys recursos que una màquina virtual, per tant, el seu llançament i detenció són més ràpids que les màquines virtuals.\nAixí doncs, Docker permet crear, provar i implementar aplicacions ràpidament, a partir d'una sèrie de plantilles que es coneixen com a imatges de Docker.\nPer a això, instal·larem Docker Desktop (https://www.docker.com/products/docker-desktop) en els nostres entorns de desenvolupament (el qual ja inclou en nucli de Docker i l'eina docker compose).\nAl llarg del curs anirem creant diferents contenidors amb els serveis necessaris, de manera que cada vegada només treballem amb el programari mínim.\n!!! note &quot;Docker en windows&quot;\nPer a instal·lar-ho en Windows, és necessari instal·lar prèviament WSL 2, el qual és un subsistema de Linux dins de Windows.\nPlantilla Inicial : Servidor Web nginx + PHP + MySQL + phpMyAdmin\nDocker es basa en l'ús d'imatges per a crear contenidors. Docker Compose simplifica el treball amb múltiples contenidors, i per això, per a facilitar l'arranc, ens centrarem en Docker Compose utilitzant una plantilla que únicament contindrà com a serveis Nginx i PHP.\nPer a facilitar la posada en marxa, us facilite un repositori, disponible per a la seua descarrega mitjançant el git clone.\n\nGrup A: github classroom Nginx/PHP\nGrup B: github classroom Nginx/PHP\n\nL'haureu de possar en un directori fàcilment localitzable i amb un nom significatiu, ja que serà el vostre directori de treball.\nDins d'este repositori, el fitxer 'docker-compose.yaml' indica quines màquines ha de montar i té el següent aspecte\n=== &quot;Nginx i PHP&quot;\n``` yaml\n# Services\nservices:\n# Nginx Service\nnginx:\nimage: nginx:1.19\nports:\n- 80:80\nvolumes:\n- ./src:/var/www/php\n- ./.docker/nginx/conf.d:/etc/nginx/conf.d\ndepends_on:\n- php\n# PHP Service\nphp:\nbuild: ./.docker/php/\nworking_dir: /var/www/php\nexpose:\n- 9000\nvolumes:\n- ./src:/var/www/php\n- ./.docker/php/conf.d/Xdebug.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n- ./.docker/php/conf.d/error_reporting.ini:/usr/local/etc/php/conf.d/error_reporting.ini\n```\nPer arrencar les màquines o podem fer des de la consola amb\ndocker compose up -d\n\nSi volem accedir a un terminal interactiu dins del contenidor:\ndocker exec -it nombreContenedor bash\n\nAltres comandos que podem arribar a utilitzar són:\n\ndocker ps: Veure els contenidors que es estan executant\ndocker ps -a: Veure tots els contenidors\ndocker start nombreContenedor: Arrancar un contenidor\ndocker images: Veure les imatges que tenim descarregades\n\n!!! tip &quot;Docker stack&quot;\nExisteixen diverses opcions mitjançant Docker que ofereixen solucions completes i empaquetes per a tot el stack de desenvolupament. Com a exemple tenim Devilbox (http://devilbox.org) i Laradock (https://laradock.io)\nUna altra forma més senzilla per a llançar de nou els contenidors i gestionar-los una vegada creats és utilitzar la interfície gràfica que ofereix Docker Desktop:\n\nArranc de contenidor mitjançant Docker Desktop\n\n!!! note &quot;Tot funciona&quot;\nHeu de comprovar que a l'accedir a http://localhost/phpinfo.php en el vostre navegador se us obre una pàgina amb la configuració de php.\nTambé si accediu a http://localhost:8000 veureu la pàgina d'accès a phpmyadmin.\n!!! important &quot;Directoris de php&quot;\nSi us fixeu en les carpetes que us ha creat el repositori veureu que les pàgines que pot executar (directori arrel de la nostra web) es troba a php/src. Les pàgines que anem a crear , de moment, les haureu de ficar ahí.\n8. Referències\nLlibres Recomanats\n\nWeb Architecture: Core Concepts de Richard N. Taylor, Nenad Medvidovic i Eric Dashofy\n\nAquest llibre ofereix una visió profunda sobre els conceptes bàsics i els principis fonamentals de les arquitectures web, incloent-hi patrons de disseny i les millors pràctiques.\n\nRESTful Web APIs de Leonard Richardson i Mike Amundsen\n\nSe centra en el disseny i la construcció d'APIs web RESTful, un component essencial de les arquitectures modernes basades en serveis web.\n\nBuilding Microservices: Designing Fine-Grained Systems de Sam Newman\n\nExplora el disseny de microserveis, una arquitectura emergent que permet crear aplicacions escalables i flexibles.\n\nDocumentació Oficial i Guies\n\nThe Twelve-Factor App\n\nUna metodologia per construir aplicacions web modernes que són fàcilment escalables i mantenibles.\n\nDocumentació de l'Arquitectura de PWA (Progressive Web Apps)\n\nGuia detallada sobre el disseny i la implementació d'aplicacions web progressives, que combinen el millor de les aplicacions web i mòbils.\n\nCursos en Línia\n\nCoursera - Web Application Architectures\n\nCurs que proporciona una visió general de les arquitectures d'aplicacions web, incloent-hi clients i servidors, HTTP, i serveis web.\n\nUdacity - Full Stack Web Developer Nanodegree\n\nAquest programa cobreix temes com arquitectures de servidor, autenticació, i API RESTful.\n\nRecursos Addicionals\n\nMicroservices.io\n\nRecursos sobre patrons de microserveis, arquitectures i millors pràctiques per implementar microserveis amb èxit.\n\nMartin Fowler's Blog\n\nUn blog que cobreix diversos aspectes de l'arquitectura del programari, incloent-hi articles sobre disseny de microserveis i altres arquitectures emergents.\n\nExemples i Tutorials\n\nDigitalOcean Community Tutorials\n\nOfereix tutorials pràctics sobre una àmplia gamma de temes relacionats amb l'arquitectura web, des de configuració de servidors fins a desplegament d'aplicacions.\n\nMozilla Developer Network (MDN) Web Docs\n\nUn recurs complet per aprendre sobre tecnologies del costat del servidor, protocols web, i altres conceptes clau de les arquitectures web.\n\nRepositoris de Codi\n\nAwesome Scalability\n\nUna col·lecció de recursos i exemples sobre escalabilitat, arquitectures web i disseny de sistemes distribuits.\n\nGitHub Microservices Examples\n\nRepositoris de codi font en GitHub que il·lustren com implementar microserveis i altres arquitectures web modernes.\n\n9.AutoAvaluació\nExercici 1: Models d'execució de codi\nPregunta:\nExplica les principals diferències entre el model d'execució de codi en client i en servidor.\nOpcions:\n\na) El codi en client s'executa al servidor, mentre que el codi en servidor s'executa al navegador del client.\n\nb) El codi en client s'executa al navegador del client, mentre que el codi en servidor s'executa al servidor.\n\nc) Ambdós s'executen al servidor.\n\nd) Ambdós s'executen al navegador del client.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0, length = radios.length; i < length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) El codi en client s'executa al navegador del client, mentre que el codi en servidor s'executa al servidor.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Avantatges de la generació dinàmica de pàgines\nPregunta:\nQuins són els avantatges de la generació dinàmica de pàgines web? Selecciona totes les que apliquen.\nOpcions:\n\na) Reducció de la càrrega del servidor.\n\nb) Personalització del contingut per usuari.\n\nc) Major interactivitat amb l'usuari.\n\nd) Menor temps de càrrega inicial de la pàgina.\n\nfunction checkAnswer2() {\nvar correctAnswers = [\"b\", \"c\"];\nvar checkboxes = document.getElementsByName('question2');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són b) Personalització del contingut per usuari i c) Major interactivitat amb l'usuari.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Mecanismes d'execució de codi en els servidors web\nPregunta:\nQuins dels següents són mecanismes d'execució de codi en els servidors web?\nOpcions:\n\na) CGI (Common Gateway Interface).\n\nb) API Gateway.\n\nc) Servlets.\n\nd) Totes les anteriors.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"d\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0, length = radios.length; i < length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és d) Totes les anteriors.\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Funcionalitats dels servidors d'aplicacions\nPregunta:\nQuines són algunes de les funcionalitats proporcionades pels servidors d'aplicacions?\nOpcions:\n\na) Gestió de sessions.\n\nb) Autenticació d'usuaris.\n\nc) Generació de pàgines estàtiques.\n\nd) Gestió de transaccions.\n\nfunction checkAnswer4() {\nvar correctAnswers = [\"a\", \"b\", \"d\"];\nvar checkboxes = document.getElementsByName('question4');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Gestió de sessions, b) Autenticació d'usuaris, d) Gestió de transaccions.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Llenguatges i tecnologies relacionades amb la programació web en entorn servidor\nPregunta:\nQuins dels següents llenguatges i tecnologies són utilitzats en la programació web en entorn servidor?\nOpcions:\n\na) PHP.\n\nb) SQL.\n\nc) HTML.\n\nd) JavaScript.\n\ne) Java.\n\nfunction checkAnswer5() {\nvar correctAnswers = [\"a\", \"b\", \"e\"];\nvar checkboxes = document.getElementsByName('question5');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) PHP, b) SQL, e) Java.\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Integració dels llenguatges de marques amb els llenguatges de programació\nPregunta:\nCom s'integren els llenguatges de marques com HTML amb els llenguatges de programació com PHP?\nOpcions:\n\na) Utilitzant etiquetes especials de PHP dins del codi HTML.\n\nb) Convertint tot el codi HTML a PHP.\n\nc) No es poden integrar.\n\nd) Utilitzant un altre llenguatge de programació per connectar-los.\n\nfunction checkAnswer6() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question6');\nvar userAnswer;\nfor (var i = 0, length = radios.length; i < length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Utilitzant etiquetes especials de PHP dins del codi HTML.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Eines i frameworks de programació en entorn servidor\nPregunta:\nQuines són algunes de les eines i frameworks més utilitzats en la programació web en entorn servidor?\nOpcions:\n\na) Laravel.\n\nb) Django.\n\nc) React.\n\nd) Node.js.\n\ne) Spring Boot.\n\nfunction checkAnswer7() {\nvar correctAnswers = [\"a\", \"b\", \"d\", \"e\"];\nvar checkboxes = document.getElementsByName('question7');\nvar userAnswers = [];\nfor (var i = 0, length = checkboxes.length; i < length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nvar resultText = (userAnswers.length === correctAnswers.length && userAnswers.every((val, index) => val === correctAnswers[index]))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Laravel, b) Django, d) Node.js, e) Spring Boot.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": [ "note"]
},

{
		"title": "1.1 Entornos de desarrollo",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/1. Arquitecturas Web/1.1 Entornos de desarrollo/",
		"content": "Entorn de desenvolupament\nPera fer correr les aplicacions de servidor ens cal, com a mínim, un servidor web, l'interpret de php i un motor de base de dades. Hem de distinguir l'entorn de desenvolupament, on anem a programar i mantindre la nostra aplicació, de l'entorn de producció, on anem a executar-la.\nNormalment el primer depén de nosaltres mentre que el segon pot dependre de l'empresa on s'allotjarà la nostra web. Per a preparar el nostre entorn de desenvolupament podem optar per:\n\nQualsevol solució LAMP (Linux, Apache, Mysql, PHP). Als que haurem d'afegir, una vegada els projectes es facen grans composer, git i les opcions de la part de client.\nUna màquina virtual ja configurada.\nUna solució docker.\n\nLa primera solució és senzilla d'implementar però no hauria de ser la nostra primera opció per:\n\nEstem possant en funcionament en la nostra màquina una sèrie de serveis que normalment no fariem, baixant el rendiment de la màquina i obrint vulnerabilitats.\nSi treballem en grup, les instal·lacions i el funcionament no són iguals, depenen del sistema operatiu que té instal·lat cadascú. Allò que li funciona a ú pot ser no li funciona a un altre. Això és inevitable quan el projecte es complica i es perd molt de temps.\nPassa el mateix quan passem a l'entorn de producció.\n\nLa segona solució soluciona els dos primers problemes, doncs tots els desenvolupadors poden tindre virtualitzada, la mateixa màquina. Encara que si la màquina no la fem nosaltres sinó que utilitzem alguna ja configurada (vagrant) o si ens cal instal·lar alguna cosa més, ho hauria de fer tot l'equip.\nAixí i tot, tindriem les següents desaventatges:\n\nA l'instal·lar una maquina virtual sencera ocupa recursos del sistema.\nLa màquina instal·la més coses de les necessàries habitualment.\nNo reprodueix l'entorn de producció.\n\nPot ser molt útil, per exemple, quan la fem servir per desenvolupar en un framework, que ja ve configurat per fer-lo funcionar inmediatament i amb totes les característiques instal·lades.\nLa tercera opció té les següents característiques:\n\nAl principi és més difícil de possar en funcionamet ja que calen coneixements de docker.\nTots els desenvolupadors comparteixen entorn encara que utilitzen màquines o sistemes operatius diferents.\nSi hi ha algun canvi de configuració de l'entorn és fácilment transladable a tots els desenvolupadors.\nEs poden crear tants entorns de desenvolupament com projectes diferents hi hajen.\nEls contenidors ocupen pocs recursos.\nEls projectes es poden possar en producció utilitzan una solució docker de manera inmediata.\n\nXAMPP\nXAMPP (https://www.apachefriends.org/es/index.html) és una distribució composta amb el programari necessari per a desenvolupar en entorn servidor. Es compon de les següents eines sobre la base de les seues sigles:\n\nX per al sistema operatiu (d'aquí ve que es conega altrament com LAMP o WAMP).\nA per a Apatxe.\nM per a MySQL / MariaDB. També inclou phpMyAdmin per a l'administració de la base de dades des d'una interfície web.\nP per a PHP.\nl'última P per a Perl.\n\nDes de la pròpia pàgina es pot descarregar l'arxiu executable per al sistema operatiu del nostre ordinador. Es recomana llegir la FAQ de cada sistema operatiu amb instruccions per a la seua posada en marxa.\n!!! note &quot;XAMPP en Windows&quot;\nSi treballes amb el teu propi ordinador, XAMPP és una solució més senzilla que Docker, sobretot si treballes amb Windows com a sistema operatiu.\nDocker\nDocker (https://www.docker.com) és un gestor de contenidors, considerant un contenidor com un mètode de virtualització del sistema operatiu.\nL'ús de contenidors requereix menys recursos que una màquina virtual, per tant, el seu llançament i detenció són més ràpids que les màquines virtuals.\nAixí doncs, Docker permet crear, provar i implementar aplicacions ràpidament, a partir d'una sèrie de plantilles que es coneixen com a imatges de Docker.\nPer a això és necessari tindre instal·lat Docker Desktop (https://www.docker.com/products/docker-desktop) en els nostres entorns de desenvolupament (el qual ja inclou en nucli de Docker i l'eina docker compose). Per a instal·lar-ho en Windows, és necessari instal·lar prèviament WSL 2, el qual és un subsistema de Linux dins de Windows.\nAl llarg del curs anirem creant diferents contenidors amb els serveis necessaris, de manera que cada vegada només treballem amb el programari mínim.\n!!! caution &quot;Versions&quot;\nAl llarg del curs usarem PHP 8.1. Respecte a Docker, per a escriure les anotacions hem utilitzat la versio 20.10 i la versio 2.19 de docker compose. Finalment, la versió de Docker Desktop que hem utilitzat és la 4.0.\nInstal·lació de docker\nLa instal·lació de docker dependrà del sistema operatiu que estem utilitzant. Ací anem a vore la que efecturan els que utilitzen linux, amb el sistema operatiu linux-mint o ubuntu , que és el que ve instal·lat en les imatges suministrades. Per a mac o windows s'haurà de mirar la pàgina web de docker\nEns donem privilegis\nsudo su\n\nUtilitzant els repositoris de docker l'instal·lem:\necho &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable&quot; | tee /etc/apt/sources.list.d/docker.list\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -\n\napt update\n\napt install docker-ce docker-ce-cli containerd.io pigz\n\nDonem permisos a l'usuari afegint-lo al grup de docker\nusermod -aG docker $USER\n\nOn $USER és el teu usuari.\nTambé haurem d'instal·lar el docker-compose\ncurl -SL &quot;https://github.com/docker/compose/releases/download/v2.10.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n\nchmod +x /usr/local/bin/docker-compose\n\nI provem\ndocker --version\n\nFaltarà engegar el servei de docker per a poder executar contenidors\nsudo systemctl start docker.service\n\nPlantilla Servidor Web + PHP\nDocker es basa en l'ús d'imatges per a crear contenidors. Docker Compose simplifica el treball amb múltiples contenidors, i per això, per a facilitar l'arranc, ens centrarem en Docker Compose utilitzant una plantilla que únicament contindrà com a serveis Nginx i PHP.\nPer a facilitar la posada en marxa, us facilite un repositori en github classroom Nginx/PHP disponible per a la seua descàrrega. L'haureu de possar en un directori fàcilment localitzable i amb un nom significatiu, ja que serà el vostre directori de treball.\nDins d'este repositori, el fitxer 'docker-compose.yaml' indica quines màquines ha de montar i té el següent aspecte\n=== &quot;Nginx i PHP&quot;\n``` yaml\n# Services\nservices:\n# Nginx Service\nnginx:\nimage: nginx:1.19\nports:\n- 80:80\nvolumes:\n- ./src:/var/www/php\n- ./.docker/nginx/conf.d:/etc/nginx/conf.d\ndepends_on:\n- php\n# PHP Service\nphp:\nbuild: ./.docker/php/\nworking_dir: /var/www/php\nexpose:\n- 9000\nvolumes:\n- ./src:/var/www/php\n- ./.docker/php/conf.d/Xdebug.ini:/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini\n- ./.docker/php/conf.d/error_reporting.ini:/usr/local/etc/php/conf.d/error_reporting.ini\n# Más info en\n# https://tech.osteel.med/posts/docker-for-local-web-development-part-1-a-basic-lemp-stack\n# Lanzar con\n# docker-compose up -d\n# Ver los logs con\n# docker-compose logs -f\n```\nPer arrencar les màquines o podem fer des de la consola amb\ndocker compose up -d\n\nSi volem accedir a un terminal interactiu dins del contenidor:\ndocker exec -it nombreContenedor bash\n\nAltres comandos que podem arribar a utilitzar són:\n\ndocker ps: Veure els contenidors que es estan executant\ndocker ps -a: Veure tots els contenidors\ndocker start nombreContenedor: Arrancar un contenidor\ndocker images: Veure les imatges que tenim descarregades\n\nUna altra forma més senzilla per a llançar de nou els contenidors i gestionar-los una vegada creats és utilitzar la interfície gràfica que ofereix Docker Desktop:\n\n!!! tip &quot;Docker stack&quot;\nExisteixen diverses opcions mitjançant Docker que ofereixen solucions completes i empaquetes per a tot el stack de desenvolupament. En posteriors sessions utilitzarem tant Devilbox (http://devilbox.org) com Laradock (https://laradock.io)\n!!! question &quot;Però vull saver com funciona...&quot;\nEn el mòdul de Desplegament d'aplicacions estudiareu en profunditat, a més de Docker, Apatxe i altres serveis que ens serviran d'ajuda per al desenvolupament en entorn servidor.\nTot funciona\nHeu de comprovar que a l'accedir a http://localhost en el vostre navegador se us obre una pàgina de salutació.\nEntorn de desenvolupament\nEn este curso utilitzarem PHP Storm com a entorn de desenvolupament. Existixen altres alternatives, com Visual Studio Code.\nInstal·lació\nPodem fer-ho de manera automàtica utilitzant snap. Per fer-ho amb linux-mint\nsudo rm /etc/apt/preferences.d/nosnap.pref\nsudo apt update\nsudo apt install snapd\nsudo snap install phpstorm --classic\n\nTambé es pot instal·lar baixant-se el paquet de la pàgina web.\nLlicència\nPodeu sol·licitar una llicència a i.gomismullor@edu.gva.es\nEntorn de proves\nLa màquina docker ve configurada amb codeception i una col·leció de proves per als exercicis que desenvoluparem al llarg de les primeres unitats.\nS'ha creat un shell per executar totes les proves\nsh test.sh\n\nGitHub Classroom\nUs podeu registrar\nMetodologia de treball amb el github classroom\n\nSe proporcionarà a l'alumnat un enllaç amb la invitació.\nAccedint a l'enllaç a cada alumne se li crearà un repositori individual en l'organització.\nL'alumnat treballa en el seu repositori assignat. Se'l pot baixar per treballar en local.\nInicialment, l'alumne crea una branca nova sobre la que va a treballar.\nQuan vullga sol.licitar ajuda o revisió del professor, l'alumne genera una pull request a la branca principal del seu repositori en la que cita al professor per tal que reba una notificació.\nEl profesor proporciona retroalimentació mitjançant comentaris en la pull request o en un determinat commit individual.\nOpcionalment es poden utilitzar els issues y les cites d'usuari per sol·licitar la intervenció del profesor.\nQuan l'alumne finalitza la tasca, genera una últim pull request\nEl profesor revisa la pull request i opcionalment fa comentaris.\n\nReferències\n\nCurs de introducció a Docker, per Sergi García Barea : https://sergarb1.github.io/CursoIntroduccionADocker/\nArticle Arquitectures Web i sa evolució\n\nVideos\n\nTriar un llenguatge de programació\n\nInstal.Lació entorn de desenvolupament",
		"tags": [ "note"]
},

{
		"title": "Introducción a PHP",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/2. Introduccion a PHP/Introducción a PHP/",
		"content": "=, `",
		"tags": [ "note"]
},

{
		"title": "Programación en Web",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/3. Programacion en WEB/Programación en Web/",
		"content": "Programació Web\n1. Mecanismes per al Manteniment de la Informació en Aplicacions Web\nHTTP és un protocol stateless, sense estat. En les aplicacions web modernes, és essencial gestionar l'estat del client per proporcionar una experiència d'usuari fluida i personalitzada.\nPer això, se simula l'estat mitjançant l'ús de cookies, tokens o la sessió. L'estat és necessari per a processos com ara el carret de la compra, operacions associades a un usuari, etc...\nA continuació es detallen diversos mecanismes per mantenir aquesta informació, així com els seus avantatges i desavantatges.\nCookies\nLes cookies són petits fitxers de text emmagatzemats al navegador de l'usuari. Són àmpliament utilitzades per mantenir l'estat del client entre sol·licituds HTTP, ja que HTTP és un protocol sense estat.\nAvantatges de les Cookies\n\nPersistència: Les cookies poden mantenir-se durant períodes llargs definits per l'atribut expires o max-age.\nAccessibilitat: Es poden accedir des de qualsevol pàgina del mateix domini.\nSimplicitat: Fàcils d'implementar i gestionar.\n\nDesavantatges de les Cookies\n\nSeguretat: Poden ser objectiu d'atacs com XSS (Cross-Site Scripting) si no es gestionen correctament.\nLimitacions de mida: Les cookies estan limitades a 4KB de dades.\nPrivadesa: Les dades de l'usuari poden ser vulnerables si no es protegeixen adequadament.\n\nMillors Pràctiques\n\nUtilitzar l'atribut HttpOnly per evitar l'accés a les cookies des de JavaScript.\nConfigurar SameSite per prevenir atacs CSRF.\nEmmagatzemar únicament informació essencial i no sensible.\n\nSessions\nLes sessions són un mecanisme que permet associar dades a un usuari durant una sessió específica. Aquestes dades s'emmagatzemen al servidor, mentre que el client només guarda un identificador de sessió.\nAvantatges de les Sessions\n\nSeguretat: Les dades sensibles es mantenen al servidor.\nCapacitat d'emmagatzematge: No limitades per la mida de les cookies.\nCompartició de dades: Facilita la compartició d'estat entre diferents components d'una aplicació web.\n\nDesavantatges de les Sessions\n\nEscalabilitat: Requereix memòria addicional al servidor, la qual cosa pot ser problemàtica amb molts usuaris.\nPersistència limitada: Normalment només duren mentre el navegador està obert, tret que es configuri d'una altra manera.\n\nMillors Pràctiques\n\nEmmagatzemar únicament referències o identificadors a la sessió.\nUtilitzar eines com Redis per a una gestió eficient de sessions en entorns escalables.\n\nWeb Storage\nEl Web Storage és una API del navegador que permet emmagatzemar dades al client de manera més senzilla i amb més capacitat que les cookies tradicionals. Inclou dos mecanismes principals: localStorage i sessionStorage.\nCaracterístiques del Web Storage\n\nlocalStorage: Permet emmagatzemar dades que persisteixen fins que s'elimina explícitament, fins i tot després de tancar el navegador.\nsessionStorage: Les dades es mantenen només durant la sessió del navegador i s'esborren quan es tanca la pestanya o finestra.\n\nAvantatges\n\nCapacitat d'Emmagatzematge: Ofereix més espai (fins a 5-10MB) que les cookies.\nAPI Simple: Proporciona una interfície senzilla per emmagatzemar i recuperar dades.\n\nUsos Comuns\n\nManteniment de l'Estat del Client: Pot guardar dades de sessió i preferències de l'usuari que no cal enviar al servidor.\nSincronització amb l'Entorn Servidor: Es pot utilitzar per emmagatzemar dades que després es sincronitzen amb el servidor, millorant el rendiment i l'experiència d'usuari.\n\nConsideracions de Seguretat\n\nAccessibilitat: Les dades són accessibles per JavaScript, per la qual cosa s'ha de tenir cura amb les vulnerabilitats XSS.\nDades Sensibles: Evita emmagatzemar dades sensibles o confidencials.\n\nTot i que Web Storage s'executa al costat del client, entendre les seves funcionalitats pot ajudar els desenvolupadors del servidor a dissenyar sistemes més robustos i eficaços, on la cooperació entre client i servidor maximitza l'eficiència de l'aplicació web.\nTokens d'Autenticació\nEls JSON Web Tokens (JWT) són un estàndard obert que defineix una manera compacta i autònoma d'enviar informació entre dues parts de manera segura com a objecte JSON. S'utilitzen habitualment per a l'autenticació en aplicacions web.\nAvantatges dels JWT\n\nEstatut autònom: Porten tota la informació necessària, eliminant la necessitat de mantenir sessions al servidor.\nEscalabilitat: Milloren l'escalabilitat en aplicacions distribuïdes.\nSeguretat: Es poden signar digitalment per assegurar la seva autenticitat.\n\nDesavantatges dels JWT\n\nRevocació complexa: Una vegada emesos, és difícil revocar-los sense mantenir una llista negra.\nSobrecarrega de dades: Si els tokens són grans, poden afectar el rendiment, especialment en xarxes de baixa latència.\n\nMillors Pràctiques\n\nUtilitzar signatura HS256 o RS256 per garantir la integritat del token.\nNo emmagatzemar dades sensibles directament al token.\n\nCache del Navegador\nEl cache del navegador s'utilitza per emmagatzemar còpies temporals de recursos web per millorar el rendiment i reduir la càrrega del servidor.\nAvantatges del Cache\n\nRendiment: Redueix el temps de càrrega dels recursos.\nOptimització: Disminueix l'ample de banda requerit.\n\nDesavantatges del Cache\n\nConsistència: Pot servir dades obsoletes si no es gestiona correctament.\nControl: Requereix configuració per evitar el caching indesitjat de dades dinàmiques.\n\nMillors Pràctiques\n\nConfigurar els encapçalaments HTTP correctament (Cache-Control, ETag) per gestionar l'actualització de recursos.\n\nSincronització Offline\nLa sincronització offline es refereix a la capacitat d'una aplicació web de funcionar sense connexió a Internet, sincronitzant dades quan es recupera la connexió.\nTècniques i Eines\n\nIndexedDB: Emmagatzema grans volums de dades estructurades dins del navegador.\nService Workers: Gestionen peticions de xarxa, proporcionant funcionalitats offline i cache avançat.\n\nMillors Pràctiques\n\nGestionar conflictes de dades quan es torna a estar en línia.\nUtilitzar estratègies de sincronització optimitzades per minimitzar l'ample de banda i el temps de sincronització.\n\nSeguretat de les Cookies i Sessions\nLa seguretat és fonamental en la gestió de cookies i sessions per protegir les dades dels usuaris de possibles atacs.\nPràctiques de Seguretat\n\nCSRF: Utilitzar tokens CSRF per validar sol·licituds d'accions sensibles.\nXSS: Sanear les dades d'entrada i utilitzar capçaleres de seguretat (Content-Security-Policy) per prevenir XSS.\nSecure Flag: Marcar les cookies amb l'atribut Secure perquè només s'enviïn a través de connexions HTTPS.\n\nConclusió\nLa selecció del mecanisme adequat per al manteniment de l'estat en una aplicació web depèn de les necessitats específiques de l'aplicació, el volum de dades, els requisits de seguretat i l'arquitectura del sistema. Avaluar cada tècnica pel que fa a avantatges i desavantatges ajudarà a prendre decisions informades i construir aplicacions web més segures i eficients.\n2.Exemples de Cookies i Sessions en PHP\nCookies\nLes cookies s'emmagatzemen en el array global $_COOKIE. El que col·loquem dins del array, es guardarà en el client. Cal tindre present que el client pot no voler emmagatzemar-les.\nExisteix una limitació de 20 cookies per domini i 300 en total en el navegador.\nEn PHP, per a crear una cookie s'utilitza la funció setcookie:\n&lt;?php\nsetcookie(\n'nom_cookie',\n'valor_cookie',\n[\n'expires' =&gt; time() + 3600, // 1 hora\n'path' =&gt; '/',\n'domain' =&gt; '', // Domini actual\n'secure' =&gt; true, // Només HTTPS\n'httponly' =&gt; true, // Només accessible via HTTP\n'samesite' =&gt; 'Lax' // o 'Strict' o 'None'\n]\n);\n?&gt;\n\nDestacar que el nom no pot contindre espais ni el caràcter ;. Respecte al contingut de la cookie, no pot superar els 4 KB.\nConsideracions de seguretat per a cookies:\nHTTPOnly: Assegura't que les cookies que contenen informació sensible no siguin accessibles per JavaScript utilitzant l'atribut HttpOnly.\nSecure: Utilitza l'atribut Secure per assegurar que les cookies només es transmeten en connexions HTTPS.\nSameSite: Defineix correctament l'atribut SameSite per a prevenir atacs CSRF (Cross-Site Request Forgery).\nPer exemple, mitjançant cookies podem comprovar la quantitat de visites diferents que realitza un usuari:\n&lt;?php\n$accesosPagina = 0;\nif (isset($_COOKIE['accesos'])) { \n$accesosPagina = $_COOKIE['accesos']; // recuperamos una cookie\nsetcookie('accesos', ++$accesosPagina); // le asignamos un valor\n}\n?&gt;\n\n!!! tip &quot;Inspeccionant les cookies&quot;\nSi volem veure que contenen les cookies que tenim emmagatzemades en el navegador, es pot comprovar el seu valor en Dev Tools --&gt; Application --&gt; Storage\nEl temps de vida de les cookies pot ser tan llarg com el lloc web en el qual resideixen. Elles seguiran ací, fins i tot si el navegador està tancat o obert.\nPer a esborrar una cookie es pot posar que expiren en el passat:\n&lt;?php\nsetcookie(nombre, &quot;&quot;, 1) // pasado\n\nO que caduquen dins d'un període de temps deteminado:\n&lt;?php\nsetcookie(nombre, valor, time() + 3600) // Caducan dentro de una hora\n\nS'utilitzen per a:\n\nRecordar els inicis de sessió\nEmmagatzemar valors temporals d'usuari\nSi un usuari està navegant per una llista paginada d'articles, ordenats d'una certa manera, podem emmagatzemar l'ajust de la classificació.\n\nL'alternativa en el client per a emmagatzemar informació en el navegador és l'objecte LocalStorage.\nSessió\nLa sessió afig la gestió de l'estat a HTTP, emmagatzemant en aquest cas la informació en el servidor.\nCada visitant té un ID de sessió únic, el qual per defecte s'emmagatzema en una cookie denominada PHPSESSID.\nSi el client no té les cookies actives, l'ID es propaga en cada URL dins del mateix domini.\nCada sessió té associat un magatzem de dades mitjançant el array global $_SESSION, en el qual podem emmagatzemar i recuperar informació.\nLa sessió comença en executar un script PHP. Es genera un nou ID i es carreguen les dades del magatzem:\n\nLes operacions que podem realitzar amb la sessió són:\n&lt;?php\nsession_start(); // carga la sesión\nsession_regenerate_id(true); // regenera el id\nsession_id() // devuelve el id\n$_SESSION[clave] = valor; // inserción\nsession_destroy(); // destruye la sesión\nunset($_SESSION[clave]; // borrado\n\nVeurem mitjançant un exemple com podem inserir en un pàgina dades en la sessió per a posteriorment en una altra pàgina accedir a aqueixes dades. Per exemple, en sesion.php tindríem\n&lt;?php\n// Iniciar sessió\nsession_start();\nsession_regenerate_id(true);\n\n// Establir valors de sessió\n$_SESSION['usuari'] = 'JohnDoe';\n$_SESSION['rol'] = 'admin';\n\n?&gt;\n\nI posteriorment podem accedir a la sessió en sesion1.php:\n&lt;?php\nsession_start();\n// Recuperar valors de sessió\necho 'Usuari: ' . $_SESSION['usuari'] . '&lt;br&gt;';\necho 'Rol: ' . $_SESSION['rol'] . '&lt;br&gt;';\n\n// Tancar sessió de forma segura\nsession_unset(); // Eliminar totes les variables de sessió\nsession_destroy(); // Destruir la sessió\n?&gt;\n\n[!note] &quot;Configurant la sessió en php.ini&quot;\nLes següent propietats de php.ini permeten configurar alguns aspectes de la sessió: * session.save_handler: controlador que gestiona com s'emmagatzema (files)\n* session.save_path: ruta on s'emmagatzemen els arxius amb les dades (si tenim un clúster, podríem usar /mnt/sessions en tots els servidor de manera que apunten a una carpeta compartida)\n* session.name: nom de la sessió (PHSESSID)\n* session.acte_start: Es pot fer que s'autocarregue amb cada script. Per defecte està deshabilitat\n* session.cookie_lifetime: temps de vida per defecte\n\nMés informació en la documentació oficial.\nSerialització en PHP\nLa serialització és el procés de convertir una estructura de dades o un objecte en una seqüència de caràcters que pot ser fàcilment emmagatzemada o transmesa i després reconstruïda. PHP proporciona dos funcions principals per a això: serialize() i unserialize().\n\nserialize()\nLa funció serialize() en PHP s'utilitza per a convertir una estructura de dades o un objecte en una representació de cadena.\n\n$data = array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n$serialized_data = serialize($data);\necho $serialized_data;\n\nEixida\na:3:{i:0;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;s:1:&quot;c&quot;;}\n\nunserialize()\nLa funció unserialize() en PHP s'utilitza per a convertir la representació de cadena serialitzada de nou en una estructura de dades o un objecte.\n\n$original_data = unserialize($serialized_data);\nprint_r($original_data);\n\nEixida\nArray\n(\n[0] =&gt; a\n[1] =&gt; b\n[2] =&gt; c\n)\n\nUtilitzant amb Sessions\nLes sessions en PHP permeten emmagatzemar informació d'usuari per ser utilitzada en diverses pàgines. Pot ser útil serialitzar dades per a emmagatzemar-les en una sessió:\nIniciant una sessió i emmagatzemant dades serialitzades:\nsession_start();\nsession_regenerate_id(true);\n\n$data = array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n$_SESSION['data_serialitzada'] = serialize($data);\n\nsession_start();\n\nif (isset($_SESSION['data_serialitzada'])) {\n$data = unserialize($_SESSION['data_serialitzada']);\nprint_r($data);\n}\n\nConsideracions de Seguretat:\nÉs crucial entendre que la funció unserialize() pot ser perillosa si s'usa amb dades que no són de confiança, ja que podria portar a l'execució de codi arbitrari. Per això, mai has de deserialitzar dades que vinguen d'una font desconeguda o no fiable sense validar-les prèviament.\n3.Autenticació d'usuaris\nMecanismes d'Autenticació d'Usuaris\n\nMecanisme d'Autenticació\nCaracterístiques\nAvantatges\n\nBàsica (usuari/contrasenya)\nEs requereix un nom d'usuari i una contrasenya per accedir.\nFàcil d'implementar, àmpliament utilitzada.\n\nCookies\nEmmagatzema informació d'autenticació en el navegador de l'usuari.\nPersistència d'inici de sessió, personalització d'experiència.\n\nSessions\nManté l'estat d'autenticació en el servidor amb una identificació de sessió única.\nMajor seguretat, evita la necessitat d'emmagatzemar informació sensible al client.\n\nOAuth\nPermet als usuaris accedir a recursos sense compartir les seves credencials.\nSeguretat millorada, experiència d'usuari simplificada.\n\nJWT (JSON Web Token)\nUtilitza tokens basats en JSON per a l'autenticació.\nLliure d'estat, fàcil de compartir entre diferents serveis.\n\nSAML (Security Assertion Markup Language)\nUtilitza XML per a intercanviar dades d'autenticació entre l'usuari i el servei.\nIntegració amb sistemes d'autenticació empresarial, alt nivell de seguretat.\n\nAutenticació multifactor (MFA)\nRequereix múltiples formes de verificació (per exemple, contrasenya + codi SMS).\nSeguretat augmentada, redueix el risc de compromís de comptes.\n\nExemple amb sessions\nUna sessió estableix una relació anònima amb un usuari particular, de manera que podem saber si és el mateix usuari entre dues peticions diferents. Si preparem un sistema de login, podrem saber qui utilitza la nostra aplicació.\n&lt;?php\n// Llista d'usuaris predefinits amb contrasenyes en text pla\n$users = [\n'user1@example.com' =&gt; 'password1',\n'user2@example.com' =&gt; 'password2',\n];\n\n// Convertir les contrasenyes a un format encriptat\nforeach ($users as $email =&gt; $password) {\n$users[$email] = password_hash($password, PASSWORD_BCRYPT);\n}\n\n// Formulari d'autenticació\nif (isset($_POST['login'])) {\n$email = $_POST['email'];\n$password = $_POST['password'];\n\nif (isset($users[$email]) &amp;&amp; password_verify($password, $users[$email])) {\n// L'usuari està autenticat\nsession_start();\n$_SESSION['user'] = $email;\necho &quot;Login successful. Welcome, &quot; . $email;\n} else {\n// Credencials incorrectes\necho &quot;Invalid email or password.&quot;;\n}\n}\n?&gt;\n&lt;form method=&quot;post&quot;&gt;\nEmail: &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;\nPassword: &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;\n&lt;button type=&quot;submit&quot; name=&quot;login&quot;&gt;Login&lt;/button&gt;\n&lt;/form&gt;\n\nAquest exemple mostra com mantenir l'estat de la sessió d'un usuari una vegada autenticat.\n&lt;?php\nsession_start();\n\nif (!isset($_SESSION['user'])) {\nheader(&quot;Location: login.php&quot;);\nexit();\n}\n\n// Mostra la pàgina només si l'usuari està autenticat\necho &quot;Welcome, &quot; . $_SESSION['user'];\n?&gt;\n\nFinalment, necessitem l'opció de tancar la sessió que col·loquem en logout.php:\n&lt;?php\n// Recuperamos la información de la sesión\nsession_start();\n\n// Y la destruimos\nsession_destroy();\nheader(&quot;Location: index.php&quot;);\n?&gt;\n\n!!! warning &quot;Autenticació en producció&quot;\nEn l'actualitat l'autenticació d'usuari no es realitza gestionant la sessió direcamente, sinó que es realitza mitjançant algun framekwork que abstrau tot el procés o la integració de mecanismes d'autenticació tipus OAuth, com estudiarem en l'última unitat mitjançant Laravel.\nExemple amb cookies\n&lt;?php\n// Llista d'usuaris predefinits amb contrasenyes en text pla\n$users = [\n'user1@example.com' =&gt; 'password1',\n'user2@example.com' =&gt; 'password2',\n];\n\n// Convertir les contrasenyes a un format encriptat\nforeach ($users as $email =&gt; $password) {\n$users[$email] = password_hash($password, PASSWORD_BCRYPT);\n}\n\nif (isset($_POST['login'])) {\n$email = $_POST['email'];\n$password = $_POST['password'];\n\nif (isset($users[$email]) &amp;&amp; password_verify($password, $users[$email])) {\n// Establir una cookie d'autenticació\nsetcookie(&quot;user&quot;, $email, time() + (86400 * 30), &quot;/&quot;); // 86400 = 1 dia\necho &quot;Login successful. Welcome, &quot; . $email;\n} else {\n// Credencials incorrectes\necho &quot;Invalid email or password.&quot;;\n}\n}\n\n// Llegir la cookie\nif (isset($_COOKIE['user'])) {\necho &quot;Welcome back, &quot; . $_COOKIE['user'];\n}\n?&gt;\n&lt;form method=&quot;post&quot;&gt;\nEmail: &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;\nPassword: &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;\n&lt;button type=&quot;submit&quot; name=&quot;login&quot;&gt;Login&lt;/button&gt;\n&lt;/form&gt;\n\n[!warning] &quot;Seguretat en cookies&quot;\nLes cookies són vulnerables a atacs com Cross-Site Scripting (XSS) i Cross-Site Request Forgery (CSRF). Per a protegir-les, s'ha de configurar la cookie com a segura i només accessible a través de la web.\n\nExemple amb JWT\nAquest exemple mostra com generar i verificar un JWT per a l'autenticació.\n&lt;?php\nfunction base64UrlEncode($data) {\nreturn rtrim(strtr(base64_encode($data), '+/', '-_'), '=');\n}\n\nfunction base64UrlDecode($data) {\nreturn base64_decode(strtr($data, '-_', '+/'));\n}\n\nfunction createJWT($header, $payload, $secret) {\n$headerEncoded = base64UrlEncode(json_encode($header));\n$payloadEncoded = base64UrlEncode(json_encode($payload));\n\n$signature = hash_hmac('sha256', &quot;$headerEncoded.$payloadEncoded&quot;, $secret, true);\n$signatureEncoded = base64UrlEncode($signature);\n\nreturn &quot;$headerEncoded.$payloadEncoded.$signatureEncoded&quot;;\n}\n\nfunction verifyJWT($jwt, $secret) {\nlist($headerEncoded, $payloadEncoded, $signatureEncoded) = explode('.', $jwt);\n\n$signature = base64UrlDecode($signatureEncoded);\n$expectedSignature = hash_hmac('sha256', &quot;$headerEncoded.$payloadEncoded&quot;, $secret, true);\n\nif ($signature === $expectedSignature) {\nreturn json_decode(base64UrlDecode($payloadEncoded));\n}\n\nreturn false;\n}\n\n// Exemples d'ús\n$header = ['alg' =&gt; 'HS256', 'typ' =&gt; 'JWT'];\n$payload = ['email' =&gt; 'user1@example.com', 'exp' =&gt; time() + 3600];\n$secret = 'your_secret_key';\n\n$jwt = createJWT($header, $payload, $secret);\necho &quot;JWT: &quot; . $jwt . &quot;\\n&quot;;\n\n$decoded = verifyJWT($jwt, $secret);\nif ($decoded) {\necho &quot;JWT valid: &quot; . json_encode($decoded) . &quot;\\n&quot;;\n} else {\necho &quot;Invalid JWT.\\n&quot;;\n}\n?&gt;\n\nExemple amb MFA\nAquest exemple mostra com afegir una capa addicional d'autenticació amb un codi MFA.\n&lt;?php\nsession_start();\n\nfunction sendMFACode() {\n$code = rand(100000, 999999);\n$_SESSION['mfa_code'] = $code;\n\n// Simular enviament de codi via email o SMS\necho &quot;Verification code: $code&quot;; // En un entorn real, envia el codi per email o SMS.\n}\n\nfunction verifyMFACode($inputCode) {\nreturn isset($_SESSION['mfa_code']) &amp;&amp; $inputCode == $_SESSION['mfa_code'];\n}\n\nif (isset($_POST['send_code'])) {\nsendMFACode();\n}\n\nif (isset($_POST['verify_code'])) {\nif (verifyMFACode($_POST['mfa_code'])) {\necho &quot;MFA successful.&quot;;\n} else {\necho &quot;Invalid verification code.&quot;;\n}\n}\n?&gt;\n&lt;form method=&quot;post&quot;&gt;\n&lt;button type=&quot;submit&quot; name=&quot;send_code&quot;&gt;Send MFA Code&lt;/button&gt;\n&lt;/form&gt;\n&lt;form method=&quot;post&quot;&gt;\nMFA Code: &lt;input type=&quot;text&quot; name=&quot;mfa_code&quot; required&gt;\n&lt;button type=&quot;submit&quot; name=&quot;verify_code&quot;&gt;Verify MFA Code&lt;/button&gt;\n&lt;/form&gt;\n\nExemple amb OAuth\nPer a OAuth, es pot utilitzar un proveïdor extern com Google per autenticar els usuaris. Ho vorem més avant.\n&lt;?php\nrequire_once 'vendor/autoload.php';\n\n$provider = new League\\OAuth2\\Client\\Provider\\Google([\n'clientId' =&gt; 'your-client-id',\n'clientSecret' =&gt; 'your-client-secret',\n'redirectUri' =&gt; 'your-redirect-url',\n]);\n\nif (!isset($_GET['code'])) {\n$authUrl = $provider-&gt;getAuthorizationUrl();\n$_SESSION['oauth2state'] = $provider-&gt;getState();\nheader('Location: ' . $authUrl);\nexit;\n} elseif (empty($_GET['state']) || ($_GET['state'] !== $_SESSION['oauth2state'])) {\nunset($_SESSION['oauth2state']);\nexit('Invalid state');\n} else {\n$token = $provider-&gt;getAccessToken('authorization_code', [\n'code' =&gt; $_GET['code']\n]);\n\n$user = $provider-&gt;getResourceOwner($token);\n$userData = $user-&gt;toArray();\n\n// Mostra la informació de l'usuari\necho 'Hello, ' . $userData['name'];\n}\n?&gt;\n\n4. Referències Addicionals\nA continuació es presenten diverses referències que poden ajudar-te a aprofundir en el tema de la gestió de sessions i cookies en PHP.\nDocumentació Oficial de PHP\n\nSessions a PHP: La documentació oficial de PHP proporciona informació detallada sobre l'ús de sessions, incloent-hi exemples pràctics i consells de millors pràctiques.\n\nSessions a PHP\n\nCookies a PHP: Trobaràs informació oficial sobre com treballar amb cookies en PHP, amb descripcions d'atributs com HttpOnly, Secure i SameSite.\n\nCookies a PHP\n\nArticles i Blocs Tècnics\n\nPHP Sessions: Tips &amp; Tricks: Aquest article discuteix tècniques avançades per gestionar sessions en PHP, amb exemples i millors pràctiques per a la seguretat.\n\nPHP Sessions: Tips &amp; Tricks\n\nHandling Cookies Securely in PHP: Una guia sobre com manejar cookies de manera segura, destacant estratègies per protegir les dades de l'usuari.\n\nHandling Cookies Securely in PHP\n\nLlibres sobre PHP\n\n&quot;Modern PHP: New Features and Good Practices&quot; de Josh Lockhart: Aquest llibre cobreix les novetats de PHP i les millors pràctiques, incloent la seguretat de sessions i cookies.\n\n&quot;PHP Objects, Patterns, and Practice&quot; de M. Zandstra: Proporciona una visió profunda sobre el disseny de programari amb PHP, incloent-hi aspectes de seguretat relacionats amb sessions i cookies.\n\nGuies de Seguretat en Desenvolupament Web\n\nOWASP Secure Coding Practices: Aquesta guia de OWASP ofereix una ràpida referència sobre les millors pràctiques de codificació segura, útils per a protegir les teves aplicacions web.\n\nOWASP Secure Coding Practices\n\nOWASP Cheat Sheet on Session Management: Una fitxa de referència ràpida de OWASP sobre la gestió de sessions, proporcionant consells de seguretat essencials.\n\nOWASP Cheat Sheet on Session Management\n\nConferències i Vídeos Educatius\n\nPHP Conference YouTube Channel: El canal de YouTube de PHP Conference ofereix vídeos de conferències i xerrades que cobreixen una varietat de temes, incloent sessions i seguretat.\n\nPHP Conference YouTube Channel\n\nLaracasts: Ofereix vídeos d'alta qualitat sobre desenvolupament en PHP i Laravel, amb temes rellevants per a sessions i cookies.\n\nLaracasts\n\nTutorials Online i Plataformes Educatives\n\nStack Overflow PHP Sessions Tag: Un lloc de consulta on trobar respostes a preguntes freqüents sobre la gestió de sessions en PHP.\n\nStack Overflow PHP Sessions Tag\n\nCursos a Udemy sobre PHP: Cursos que cobreixen des de conceptes bàsics fins a avançats de PHP, incloent-hi la gestió de sessions i cookies.\n\nCursos a Udemy sobre PHP\n\n5.Exercicis\nBateria d'Exercicis Solucionats per a la Unitat de Programació web\nExercici 1: Crear una sessió\n1.Crea una pàgina PHP que inicialitze una sessió i emmagatzeme el nom i el rol d'un usuari en variables de sessió. Mostra aquests valors a la pàgina web.\n\nSolució\n```php\n&lt;?php\n// Iniciar sessió\nsession_start();\n// Emmagatzemar informació de l'usuari en la sessió\n$_SESSION['nom'] = 'Joan';\n$_SESSION['rol'] = 'Administrador';\necho 'Benvingut, ' . $_SESSION['nom'] . '';\necho 'Rol: ' . $_SESSION['rol'] . '';\n?&gt;\n```\n\nExercici 2: Regenerar l'ID de sessió\n\nModifica l'exercici anterior per regenerar l'ID de sessió just després d'emmagatzemar la informació de l'usuari.\n\nSolució\n```php\n&lt;?php\n// Iniciar sessió\nsession_start();\n// Emmagatzemar informació de l'usuari en la sessió\n$_SESSION['nom'] = 'Joan';\n$_SESSION['rol'] = 'Administrador';\n// Regenerar l'ID de sessió\nsession_regenerate_id(true);\necho 'Benvingut, ' . $_SESSION['nom'] . '';\necho 'Rol: ' . $_SESSION['rol'] . '';\n?&gt;\n```\n\nExercici 3: Tancar la sessió\n\nEscriu un script PHP que elimine totes les variables de sessió i destrueixi la sessió quan l'usuari tanqui sessió.\n\nSolució\n```php\n&lt;?php\n// Iniciar sessió\nsession_start();\n// Eliminar totes les variables de sessió\nsession_unset();\n// Destruir la sessió\nsession_destroy();\n?&gt;\n```\n\nExercici 4: Crear una cookie segura\n\nEscriu un script PHP per crear una cookie que emmagatzeme el nom d'usuari amb els atributs de seguretat HttpOnly, Secure i SameSite.\n\nSolució\nphp &lt;?php // Crear una cookie segura setcookie( 'nom_usuari', 'Joan', [ 'expires' =&gt; time() + 3600, // 1 hora 'path' =&gt; '/', 'domain' =&gt; '', // Domini actual 'secure' =&gt; true, // Només HTTPS 'httponly' =&gt; true, // Només accessible via HTTP 'samesite' =&gt; 'Lax' // o 'Strict' o 'None' ] ); ?&gt;\n\nExercici 5: Llegir i modificar una cookie\n\nCrea una pàgina PHP que llegeixca el valor d'una cookie anomenada nom_usuari i la modifique afegint un prefix de salutació.\n\nSolució\n```php\n&lt;?php\n// Llegir el valor de la cookie\nif (isset($_COOKIE['nom_usuari'])) {\n$nomUsuari = $_COOKIE['nom_usuari'];\necho 'Hola, ' . $nomUsuari;\n// Modificar el valor de la cookie\n$salutacio = 'Hola, ' . $nomUsuari;\nsetcookie('nom_usuari', $salutacio, time() + 3600, '/');\n} else {\necho 'Cookie not found.';\n}\n?&gt;\n```\n\nExercici 6: Aplicació de gestió d'usuaris amb sessions\n\nDesenvolupa una aplicació PHP amb dos scripts: un per iniciar sessió i un altre per tancar sessió. L'aplicació ha de permetre que l'usuari introdueixca el seu nom d'usuari i vega un missatge de benvinguda una vegada haja iniciat sessió.\n\nSolució\n```php\n\n&lt;?php\nsession_start();\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n$nomUsuari = $_POST['nom_usuari'];\n// Emmagatzemar el nom d'usuari en la sessió\n$_SESSION['nom_usuari'] = $nomUsuari;\n// Redireccionar a la pàgina de benvinguda\nheader('Location: welcome.php');\nexit();\n}\n?&gt;\n<!DOCTYPE html>\n\nIniciar Sessió\n\nIniciar Sessió\n\nNom d'usuari:\n\nIniciar Sessió\n\n```\n```php\n\n&lt;?php\nsession_start();\n// Tancar sessió de forma segura\nsession_unset();\nsession_destroy();\n// Redireccionar a la pàgina de login\nheader('Location: login.php');\nexit();\n?&gt;\n```\n```php\n\n&lt;?php\nsession_start();\nif (!isset($_SESSION['nom_usuari'])) {\n// Redireccionar a la pàgina de login si no s'ha iniciat sessió\nheader('Location: login.php');\nexit();\n}\n$nomUsuari = $_SESSION['nom_usuari'];\n?&gt;\n<!DOCTYPE html>\n\nBenvingut\n\nBenvingut, <?php echo htmlspecialchars($nomUsuari); ?>!\nAquesta és la teva pàgina de benvinguda.\nTancar Sessió\n\n```\n\nExercici 7: Aplicació de gestió de preferències amb cookies\n\nCrea una aplicació PHP que permeta als usuaris seleccionar el seu color preferit, emmagatzemant aquesta informació en una cookie. La pàgina hauria de mostrar el color preferit de l'usuari en futures visites.\n\nSolució\n```php\n&lt;?php\n// Llegir el color preferit de la cookie\ncolorPreferit=isset(_COOKIE['color_preferit']) ? $_COOKIE['color_preferit'] : 'blau';\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n$colorPreferit = $_POST['color_preferit'];\n// Emmagatzemar el color preferit en una cookie\nsetcookie('color_preferit', $colorPreferit, time() + 3600, '/');\n}\n?&gt;\n<!DOCTYPE html>\n\nPreferències de Color\n\n\">\nPreferències de Color\n\nColor preferit:\n\n&lt;option value=&quot;blau&quot; <?php if ($colorPreferit === 'blau') echo 'selected'; ?>&gt;Blau\n&lt;option value=&quot;vermell&quot; <?php if ($colorPreferit === 'vermell') echo 'selected'; ?>&gt;Vermell\n&lt;option value=&quot;verd&quot; <?php if ($colorPreferit === 'verd') echo 'selected'; ?>&gt;Verd\n\nGuardar\n\n```\n\nExercicis proposats\nExercici 1: Sistema de Carret de Compres sense Base de Dades\n\nDescripció:\nDesenvolupa una aplicació PHP que permeta als usuaris afegir productes a un carret de compres i mostrar el contingut del carret. Utilitza sessions per a mantindre l'estat del carret entre pàgines.\n\nRequisits:\n\nCrear una pàgina on l'usuari puga seleccionar productes.\nAfegir els productes seleccionats a un carret emmagatzemat en una sessió.\nMostrar un resum del carret amb els productes afegits i les seues quantitats.\nPermetre que l'usuari elimine productes del carret.\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;ca&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;Selecció de productes&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Afegir productes al carret&lt;/h1&gt;\n&lt;form action=&quot;carret.php&quot; method=&quot;POST&quot;&gt;\n&lt;label for=&quot;producte&quot;&gt;Tria un producte:&lt;/label&gt;\n&lt;select name=&quot;producte&quot; id=&quot;producte&quot;&gt;\n&lt;option value=&quot;Poma&quot;&gt;Poma&lt;/option&gt;\n&lt;option value=&quot;Plàtan&quot;&gt;Plàtan&lt;/option&gt;\n&lt;option value=&quot;Taronja&quot;&gt;Taronja&lt;/option&gt;\n&lt;/select&gt;\n&lt;input type=&quot;submit&quot; value=&quot;Afegir al carret&quot;&gt;\n&lt;/form&gt;\n&lt;a href=&quot;carret.php&quot;&gt;Veure carret&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nExercici 2: Autenticació Bàsica d'Usuaris amb Sessions\n\nDescripció:\nCrea una aplicació PHP que permeta als usuaris iniciar sessió mitjançant un formulari. Utilitza sessions per a mantindre l'estat d'autenticació de l'usuari i mostrar missatges personalitzats basats en aquest estat.\n\nRequisits:\n\nCrear un formulari d'inici de sessió que sol·licite el nom d'usuari i la contrasenya.\nEmmagatzemar l'estat d'autenticació en una sessió després de verificar les credencials.\nMostrar una pàgina de benvinguda personalitzada per a l'usuari autenticat.\nProporcionar un enllaç per a tancar sessió i destruir la sessió.\n\nExercici 3: Recordatori d'Usuari amb Cookies\n\nDescripció:\nAfig una funcionalitat de &quot;recordar-me&quot; a l'exercici anterior que emmagatzeme el nom d'usuari en una cookie i permeta a l'usuari ser recordat en futures visites al lloc web.\n\nRequisits:\n\nAfig una opció de &quot;recordar-me&quot; al formulari d'inici de sessió.\nEmmagatzemar el nom d'usuari en una cookie quan l'opció és seleccionada.\nComprovar la cookie en futures visites i iniciar sessió automàticament si la cookie existeix.\nAssegurar que les cookies es configuren amb atributs de seguretat adequats (HttpOnly, Secure, SameSite).\n\nExercici 4: Formulari de Contacte amb Protecció CSRF\n\nDescripció:\nDesenvolupa un formulari de contacte que permeta als usuaris enviar missatges i implementa protecció CSRF per a assegurar que les sol·licituds siguen legítimes.\n\nRequisits:\n\nCrear un formulari de contacte amb camps per al nom, correu electrònic i missatge.\nGenerar i emmagatzemar un token CSRF en una sessió quan es carrega el formulari.\nIncloure el token CSRF com a camp ocult en el formulari.\nVerificar el token CSRF quan s'envia el formulari i mostrar un missatge de confirmació si és vàlid.\nMostrar un missatge d'error si el token CSRF no és vàlid o no existeix.\n\nExercici 5: Seguiment d'Activitat de l'Usuari amb Sessions\n\nDescripció:\nCrea un sistema que registre les pàgines visitades per l'usuari durant una sessió i mostre aquesta informació quan l'usuari visita una pàgina d'activitat.\n\nRequisits:\n\nEmmagatzemar una llista de pàgines visitades per l'usuari en una sessió.\nActualitzar la llista de pàgines cada vegada que l'usuari visite una nova pàgina.\nCrear una pàgina que mostre l'historial de pàgines visitades durant la sessió actual.\nAssegurar que l'historial es restableix quan l'usuari tanca la sessió.\n\nSolucions\n6. Enunciats dels projectes\nPer als dos projectes\n\nAutenticació de Jugadors:\n\nImplementa un sistema d'autenticació bàsic que permeta als jugadors iniciar sessió abans de començar el joc. Utilitza sessions per a mantindre l'estat d'autenticació.\nHa de servir per als dos jocs, &quot;Penjat&quot; i &quot;4 en Ratlla&quot;.\nFes que una vegada autenticar l'usuari puga triar a quin joc vol jugar (en la mateix pàgina).\nProtegeix els jocs per tal que no es puga jugar en cas de no estar autenticat.\n\nProjecte Penjat\n\nManteniment de l'Estat del Joc amb Sessions:\n\nUtilitza sessions per a emmagatzemar l'estat actual del joc, incloent la paraula a endevinar, lletres endevinades, i el nombre d'intents restants.\n\nGestió de la Sessió del Joc:\n\nAfegeix funcionalitats per a reiniciar el joc en qualsevol moment, reinicialitzant les variables de sessió per a començar una nova partida.\nAfegeix una opció per a tancar sessió i finalitzar la partida actual.\nAfegeix un funció per a saver si el joc ha acabat, ja siga perquè s'han endevinat totes les lletres o s'haguen arribat al màxim número d'intents permesos.\nControla el final del joc\n\nCookies per a Recordar Jugadors:\n\nImplementa cookies per a recordar els jugadors entre visites, permetent que l'usuari siga recordat si selecciona una opció de &quot;Recordar-me&quot; durant l'inici de sessió.\n\nSeguretat i Autenticació:\n\nImplementa un sistema d'autenticació bàsic per a garantir que només els jugadors autenticats puguen accedir al joc.\nUtilitza sessions per a mantenir l'estat d'autenticació i controlar l'accés a les funcionalitats del joc.\n\nConsideracions Addicionals\n\nResiliència del Joc: Implementa la lògica necessària per a manejar intents invàlids i mostrar missatges d'error adequats.\nMillores d'Interfície: Afegix un enllaç o botó per a tancar sessió i una opció per a reiniciar el joc.\n\nProjecte &quot;4 en Ratlla&quot;\n\nGestió de l'Estat de la Graella amb Sessions:\n\nUtilitza sessions per a emmagatzemar l'estat actual de la graella i el torn del jugador. Això permet mantenir la partida entre sol·licituds.\n\nManteniment de la Sessió entre Jugadors:\n\nEmmagatzema l'identificador de cada jugador en sessions per a assegurar que el torn actual siga persistent entre sol·licituds.\nAfegeix funcionalitats per a reiniciar el joc en qualsevol moment, reinicialitzant les variables de sessió per a començar una nova partida.\nAfegeix una opció per a tancar sessió i finalitzar la partida actual.\nAfegeix un funció per a saver si el joc ha acabat, ja siga perquè s'ha fet 4 en ratlla o s'haja completat el tauler.\nControla el final del joc.\n\nCookies per a la Persistència d'Usuaris:\n\nPermet l'ús de cookies per a recordar els jugadors entre visites si han seleccionat &quot;Recordar-me&quot;. Utilitza cookies per a emmagatzemar l'últim jugador autenticat.\n\nSeguretat i Autenticació:\n\nImplementa un sistema d'autenticació bàsic per a garantir que només els jugadors autenticats puguen accedir al joc.\nUtilitza sessions per a mantenir l'estat d'autenticació i controlar l'accés a les funcionalitats del joc.\n\nAddicional\n\nImplementa la lògica per tal que el segon jugador siga la màquina (pots adaptar i/o millorar l'algorisme de baix).\nControla el joc per a que no es puga seguir jugant una vegada acabat.\nImplementa un sistema de puntuació que otorgue 2 punts al guanyador i 1 a cadascú en cas d'empat.\n\nfunction jugar(&amp;$graella,$jugadorActual){\n\n$opponent = $jugadorActual === 1 ? 2 : 1;\n\n// Comprovar si pots guanyar\nfor ($col = 1; $col &lt;= COLUMNES; $col++) {\nif (isValidMove($graella, $col)) {\n$tempBoard = $graella;\n$coord = ferMoviment($tempBoard, $col, $jugadorActual);\n\nif (fi_joc($tempBoard, $coord)) {\nreturn ferMoviment($graella,$col,$jugadorActual); // Guanyar immediatament\n}\n}\n}\n\n// Comprovar si l'oponent pot guanyar i bloquejar\nfor ($col = 1; $col &lt;= COLUMNES; $col++) {\nif (isValidMove($graella, $col)) {\n$tempBoard = $graella;\n$coord = ferMoviment($tempBoard, $col, $opponent);\nif (fi_joc($tempBoard, $coord )) {\nreturn ferMoviment($graella,$col,$jugadorActual); // Bloquejar\n}\n}\n}\n\n// Estratègia: buscar el millor moviment\n// Podem afegir més lògica aquí per seleccionar el millor moviment\n$possibles = array();\nfor ($col = 1; $col &lt;= COLUMNES; $col++) {\nif (isValidMove($graella, $col)) {\n$possibles[] = $col;\n}\n}\nif (count($possibles)&gt;2) {\n$random = rand(-1,1);\n}\n$middle = (int) (count($possibles) / 2)+$random;\n$inthemiddle = $possibles[$middle];\nreturn ferMoviment($graella, $inthemiddle, $jugadorActual);\n\nreturn -1; // Totes les columnes estan plenes\n}\n\nConsideracions Addicionals\n\nLògica de Torn de Jugadors: Implementa la lògica necessària per a canviar de torn entre els jugadors utilitzant sessions.\nReinici de Partida: Afegeix una opció per a reiniciar el joc, que ha de restablir les sessions i permetre començar de nou.\nInterfície d'Usuari Amigable: Assegura't que la interfície d'usuari és clara i proporciona indicacions visuals dels moviments i torns dels jugadors.\n\nRúbrica d'Avaluació\n\nCriteri\nExcel·lent (4)\nBé (3)\nAdequat (2)\nInsuficient (1)\n\nFuncionalitat del Joc\nEl joc està completament funcional i sense errors.\nEl joc està majoritàriament funcional amb errors mínims.\nEl joc és funcional, però conté errors significatius.\nEl joc no és funcional o està incomplet.\n\nÚs de Sessions\nSessions ben implementades per a mantenir l'estat del joc.\nSessions utilitzades correctament amb alguns problemes menors.\nSessions utilitzades, però amb deficiències importants.\nNo s'han utilitzat sessions o són incorrectes.\n\nÚs de Cookies\nCookies ben utilitzades per a recordar els jugadors.\nCookies utilitzades adequadament amb algunes millores possibles.\nCookies utilitzades amb limitacions evidents.\nNo s'han utilitzat cookies o són incorrectes.\n\nAutenticació d'Usuaris\nAutenticació segura i efectiva implementada.\nAutenticació implementada amb alguns problemes.\nAutenticació present però amb deficiències notables.\nNo s'ha implementat autenticació o és incorrecta.\n\nInterfície d'Usuari\nInterfície atractiva i fàcil d'utilitzar.\nInterfície clara amb algunes millores possibles.\nInterfície funcional però poc intuïtiva.\nInterfície confusa i difícil d'utilitzar.\n\nSeguretat\nTotes les mesures de seguretat implementades correctament.\nSeguretat adequada amb algunes millores possibles.\nMesures de seguretat bàsiques implementades.\nNo s'han tingut en compte mesures de seguretat.\n\nComentaris i Codi\nCodi ben comentat i fàcilment llegible.\nCodi clar amb comentaris adequats.\nCodi llegible però amb pocs comentaris.\nCodi desordenat i sense comentaris.\n\nInnovació i Creativitat\nEl projecte mostra innovació significativa.\nAlgunes idees creatives han estat implementades.\nAlguna creativitat present, però limitada.\nCap creativitat o innovació en el projecte.\n\nPunts addicionals\n1 punt per cadascúna aconseguida.\n\nExplicació dels Criteris\nFuncionalitat del Joc\n\nExcel·lent (4): El joc funciona completament segons les especificacions, amb totes les funcionalitats implementades i sense errors. Els jugadors poden interaccionar amb el joc tal com s'esperava i totes les accions es realitzen correctament.\n\nInsuficient (1): El joc no és funcional, falten parts importants del codi o el joc no es pot jugar correctament.\n\nÚs de Sessions\n\nExcel·lent (4): Les sessions s'utilitzen eficaçment per a mantenir l'estat del joc i de l'usuari entre sol·licituds. Les dades de la sessió es gestionen de manera adequada per a preservar l'experiència de l'usuari.\n\nInsuficient (1): No s'han utilitzat sessions o la seva implementació és incorrecta, la qual cosa afecta negativament l'experiència de l'usuari.\n\nÚs de Cookies\n\nExcel·lent (4): Les cookies s'utilitzen de manera efectiva per a recordar els jugadors entre sessions, amb la configuració adequada d'atributs de seguretat (HttpOnly, Secure, SameSite).\n\nInsuficient (1): No s'han utilitzat cookies o la seva implementació és incorrecta, amb una configuració de seguretat deficient.\n\nAutenticació d'Usuaris\n\nExcel·lent (4): L'autenticació dels usuaris és segura i eficient, amb mecanismes adequats per a validar les credencials i protegir la informació dels usuaris.\n\nInsuficient (1): No s'ha implementat un sistema d'autenticació o el sistema present és insegur i defectuós.\n\nInterfície d'Usuari\n\nExcel·lent (4): La interfície d'usuari és atractiva, clara i fàcil de navegar, proporcionant una experiència d'usuari òptima.\n\nInsuficient (1): La interfície és confusa, difícil d'utilitzar o inacabada.\n\nSeguretat\n\nExcel·lent (4): Totes les mesures de seguretat necessàries han estat implementades, incloent-hi la validació de dades d'entrada, protecció CSRF i altres pràctiques de seguretat recomanades.\n\nInsuficient (1): No s'han tingut en compte mesures de seguretat, deixant el projecte vulnerable a possibles atacs.\n\nComentaris i Codi\n\nExcel·lent (4): El codi està ben comentat, és llegible i segueix bones pràctiques de programació.\n\nInsuficient (1): El codi està desordenat, difícil de llegir i manca de comentaris explicatius.\n\nInnovació i Creativitat\n\nExcel·lent (4): El projecte mostra un alt grau d'innovació i creativitat, oferint característiques o enfocaments únics que milloren el joc.\n\nInsuficient (1): El projecte manca de creativitat o innovació, seguint únicament les instruccions bàsiques sense cap valor afegit.\n\nNotes Addicionals\n\nConsistència del Codi: S'espera que el codi sigui consistent, utilitzant convencions de noms adequades i estructures de codi clares.\nAdaptació de les Necessitats: Els criteris poden ser adaptats segons les necessitats específiques del curs o dels projectes individuals.\n\n7. Autoavaluació: Gestió de Sessions i Cookies\nExercici 1: Funcions de les Cookies\nPregunta:\nQuina és la funció principal de les cookies en el context del desenvolupament web?\nOpcions:\n\na) Guardar els fitxers de l'usuari al servidor.\n\nb) Emmagatzemar informació del client per personalitzar l'experiència d'usuari.\n\nc) Executar codi al servidor.\n\nd) Controlar la velocitat de la connexió a Internet.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Emmagatzemar informació del client per personalitzar l'experiència d'usuari.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Seguretat de les Cookies\nPregunta:\nQuins atributs de seguretat haurien de tindre les cookies per protegir-les contra atacs?\nOpcions:\n\na) Secure\n\nb) HttpOnly\n\nc) SameSite\n\nd) CrossSite\n\nfunction checkAnswer2() {\nvar correctAnswers = [\"a\", \"b\", \"c\"];\nvar checkboxes = document.getElementsByName('question2');\nvar userAnswers = [];\nfor (var i = 0; i < checkboxes.length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nuserAnswers.sort();\nvar resultText = (JSON.stringify(userAnswers) === JSON.stringify(correctAnswers))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Secure, b) HttpOnly, c) SameSite.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Creació de Sessions en PHP\nPregunta:\nQuin dels següents passos és necessari per iniciar una sessió en PHP?\nOpcions:\n\na) Cridar a la funció session_start().\n\nb) Utilitzar la funció session_open().\n\nc) Assignar un valor a la variable $_SESSION.\n\nd) No es necessita cap funció especial.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Cridar a la funció session_start().\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Manteniment d'Informació en Sessions\nPregunta:\nCom es pot mantindre la informació d'un usuari durant la sessió d'una aplicació web?\nOpcions:\n\na) Utilitzant la variable global $GLOBALS.\n\nb) Utilitzant la variable $_SESSION.\n\nc) Utilitzant la variable $_COOKIE.\n\nd) Utilitzant arxius temporals al servidor.\n\nfunction checkAnswer4() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question4');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Utilitzant la variable $_SESSION.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Funcions de PHP per a Sessions\nPregunta:\nQuina funció de PHP es fa servir per destruir una sessió?\nOpcions:\n\na) session_destroy()\n\nb) session_unset()\n\nc) session_delete()\n\nd) session_end()\n\nfunction checkAnswer5() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question5');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) session_destroy().\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Avantatges de les Sessions\nPregunta:\nQuins són els avantatges d'utilitzar sessions en lloc de cookies per a mantenir l'estat de l'usuari?\nOpcions:\n\na) Les sessions poden emmagatzemar més informació perquè es guarden al servidor.\n\nb) Les sessions són més segures perquè no s'envien al client.\n\nc) Les sessions redueixen la càrrega del servidor.\n\nd) Les sessions no necessiten ser configurades amb atributs de seguretat.\n\nfunction checkAnswer6() {\nvar correctAnswers = [\"a\", \"b\"];\nvar checkboxes = document.getElementsByName('question6');\nvar userAnswers = [];\nfor (var i = 0; i < checkboxes.length; i++) {\nif (checkboxes[i].checked) {\nuserAnswers.push(checkboxes[i].value);\n}\n}\nuserAnswers.sort();\nvar resultText = (JSON.stringify(userAnswers) === JSON.stringify(correctAnswers))\n? \"Correcte!\"\n: \"Incorrecte. Les respostes correctes són a) Les sessions poden emmagatzemar més informació perquè es guarden al servidor, b) Les sessions són més segures perquè no s'envien al client.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Autenticació d'Usuaris\nPregunta:\nQuina és la pràctica recomanada per assegurar la identitat d'un usuari en una aplicació web?\nOpcions:\n\na) Utilitzar noms d'usuari i contrasenyes emmagatzemades com a cookies.\n\nb) Utilitzar sessions per mantenir l'estat d'autenticació després d'iniciar sessió.\n\nc) Emmagatzemar la contrasenya de l'usuari a la URL.\n\nd) No utilitzar cap forma d'autenticació.\n\nfunction checkAnswer7() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question7');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Utilitzar sessions per mantenir l'estat d'autenticació després d'iniciar sessió.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": [ "note"]
},

{
		"title": "1. Concepte de classes i Objectes",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/1. Concepte de classes i Objectes/",
		"content": "PHP segueix un paradigma de programació orientada a objectes (POO) basada en classes.\nUn classe és un plantilla que defineix les propietats i mètodes per a poder crear objectes. D'aquest manera, un objecte és una instància d'una classe.\nTant les propietats com els mètodes es defineixen amb una visibilitat (qui pot accedir)\n\nPrivat - private: Només pot accedir la pròpia classe.\nProtegit - protected: Només pot accedir la pròpia classe o els seus descendents.\nPúblico - public: Pot accedir qualsevol altra classe.\n\nPer a declarar una classe, s'utilitza la paraula clau class seguit del nom de la classe. Per a instanciar un objecte a partir de la classe, s'utilitza new:\n&lt;?php\nclass NomClase {\n// propiedades\n// y métodos\n}\n\n$ob = new NomClase();\n\n[!important] &quot;Classes amb majúscula&quot;\nTotes les classes comencen per lletra majúscula.\n\nQuan un projecte creix, és normal modelar les classes mitjançant UML (recordeu Entorns de Desenvolupament?). La classes es representen mitjançant un quadrat, separant el nom, de les propietats i els mètodes:\n![UML|500](/img/user/01 Apuntes/PHP Teoria Batoi/imagenes/03/uml.png)\nUna vegada que hem creat un objecte, s'utilitza l'operador -&gt; per a accedir a una propietat o un mètode:\n$objeto-&gt;propiedad;\n$objeto-&gt;método(parámetros);\n\nSi des de dins de la classe, volem accedir a una propietat o mètode de la mateixa classe, utilitzarem la referència $this;\n$this-&gt;propiedad;\n$this-&gt;método(parámetros);\n\nAixí doncs, com a exemple, codificaríem una persona en el fitxer Persona.php com:\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function setNombre(string $nom) {\n$this-&gt;nombre=$nom;\n}\n\npublic function imprimir(){\necho $this-&gt;nombre;\necho '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(); // creamos un objeto\n$bruno-&gt;setNombre(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nEncara que es poden declarar diverses classes en el mateix arxiu, és una mala pràctica. Així doncs, cada fitxer contedrá una sola classe, i es nomenarà amb el nom de la classe.",
		"tags": [ "note"]
},

{
		"title": "10. Documentación con phpDocumentor",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/10. Documentación con phpDocumentor/",
		"content": "phpDocumentor és l'eina per a documentar el codi PHP. És similar en propòsit i funcionament a Javadoc.\nAixí doncs, és un eina que facilita la documentació del codi PHP, creant un lloc web amb l'API de l'aplicació.\nEs basa en l'ús d'anotacions sobre els docblocks. Per a posar-ho en marxa, en el nostre cas ens decantarem per utilitzar la imatge que ja existeix de Docker.\nInstal·lació\nPas 1: Instal·lació amb Docker\nPrimer, cal assegurar-se tenir Docker instal·lat i funcionant al sistema. Després, s'ha de descarregar i executar el contenidor de phpDocumentor utilitzant la següent comanda:\ndocker pull phpdoc/phpdoc\n\nPas 2: Generació de Documentació\nUn cop tinguem la imatge, podem utilitzar-la per generar la documentació. El procés bàsic implica muntar els fitxers de codi dins del contenidor Docker i executar phpDocumentor sobre aquests fitxers.\nAcí hi ha un exemple de com fer-ho:\nEn el cas d'usar Docker, usarem el següent comando per a executar-lo (crea el contenidor, executa el comando que li demanem, i automàticament l'esborra):\ndocker run --rm -v $(pwd):/data phpdoc/phpdoc:latest run -d /data/src -t /data/docs\n\nAquesta comanda fa el següent:\n--rm: Això elimina el contenidor després d'executar-lo, així no es queden contenidors inactius.\n-v (pwd):/data:Muntaeldirectoriactualdelteusistema((pwd)) al directori /data dins del contenidor. Hauràs de reemplaçar $(pwd) amb el camí on està el teu codi font si no estàs executant aquesta comanda des del directori del teu projecte.\n-d /data/src: Especifica el directori dins del contenidor on es troba el teu codi font. Reemplaça /data/src amb el camí corresponent dins del contenidor si és diferent.\n-t /data/docs: Especifica on vols que es generi la documentació dins del contenidor. En aquest cas, es generarà dins de /data/docs.\nPas 3: Accés a la Documentació Generada\nUna vegada generada, la documentació estarà dins del directori que especificat (en aquest cas, docs dins del directori docs de projecte). Pots obrir els fitxers HTML amb qualsevol navegador per veure la documentació.\nDocBlock\nUn docblock és el bloc de codi que es col·loca damunt d'un recurs. El seu format és:\n&lt;?php\n/**\n* Sumari*, una sola línia\n\n* Descripció* que pot utilitzar diverses línies\n* i que ofereix detalls de l'element o referències\n* per a ampliar la informació\n\n* @param string $miArgumento amb una descripció* de l'argument\n* que pot usar diverses línies.\n\n* @return void\n*/\nfunction miFuncion(tipo $miArgumento)\n{\n}\n\nDocumentant el codi\nEn tots els elements, ademas del sumari i/o descripció, posarem:\n\nEn les classes:\n\n@author nom &lt;email&gt;\n@package ruta del namespace\n\nEn les propietats:\n\n@var tipus descripció\n\nEn els mètodes:\n\n@param tipus $nomene descripció\n@throws ClaseException descripció\n@return tipus descripció\n\nVegem-ho amb un exemple. Suposem que tenim una classe que representa un client:\n&lt;?php\n/**\n* Classe que representa un client\n*\n* El client s'encarrega d'emmagatzemar els suports que té llogat,\n* de manera que podem llogar i retornar productes mitjançant les operacions\n* homònimes.\n*\n* @package Dwes\\Videoclub\\Model\n* @author Aitor Medrano &lt;a.medrano@edu.gva.es&gt;\n*/\nclass Cliente {\n\npublic string $nombre;\nprivate string $numero;\n\n/**\n* Colecció de soports alquilats\n* @var array&lt;Soporte&gt;\n*/\nprivate $soportesAlquilados[];\n\n/*\n* Comprova si el suport rebut ja el té llogat el client\n* @param Suport $suporte Suport a comprovar\n* @return bool true si ho té llogat\n/\npublic function tieneAlquilado(Soporte $soporte) : bool {\n// ...\n}\n\nSi generem la documentació i obrim amb un navegador l'arxiu docs/api/index.html podrem navegar fins a la classe `Client:",
		"tags": [ "note"]
},

{
		"title": "11. Proves amb PHPUNIT",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/11. Proves amb PHPUNIT/",
		"content": "El curs passat, dins del mòdul de Entorns de Desenvolupament*, estudiarieu la importància de la realització de proves, així com les proves unitàries mitjançant JUnit.\n\nHui dia és de gran importància seguir una bona metodologia de proves, sent el desenvolupament dirigit per les proves (Test Driven Development / TDD) un dels enfocaments més emprats, el qual consisteix en:\n\nEscriure el test, i com no hi ha codi implementat, la prova falle (roig).\nEscriure el codi d'aplicació perquè la prova funcione (verda).\nrefactoritzar el codi de l'aplicació amb l'ajuda de la prova per a comprovar que no trenquem res (refactor).\n\nEn el cas de PHP, l'eina que s'utilitza és PHPUnit (https://phpunit.de/), que com el seu nom indica, està basada en JUnit. La versió actual és la 9.0.\nIntroducció a PHPUnit\nPHPUnit és un framework de proves popular per a PHP que suporta tant proves unitàries com proves d'integració. És àmpliament utilitzat en la comunitat PHP per la seua simplicitat i eficàcia. Les proves unitàries es centren en provar components o mètodes individuals, mentre que les proves d'integració asseguren que les diferents parts del sistema funcionen conjuntament com s'espera.\nInstal·lació\nPer començar a utilitzar PHPUnit, cal instal·lar-lo. La manera recomanada és a través de Composer. Executa la següent comanda en el terminal:\ncomposer require --dev phpunit/phpunit\n\nAquesta comanda afegirà PHPUnit com a dependència de desenvolupament en el teu projecte.\n\n[!tip] &quot;Llibreries de desenvolupament&quot;\nLes llibreries que es col·loquen en require-dev són les de desenvolupament i testing, de manera que no s'instal·laran en un entorn de producció.\n\nUna vegada instal·lat, podem configurar PHPUnit creant un fitxer phpunit.xml en l'arrel del projecte per especificar la configuració de les proves:\n&lt;phpunit bootstrap=&quot;vendor/autoload.php&quot;&gt;\n&lt;testsuites&gt;\n&lt;testsuite name=&quot;Application Test Suite&quot;&gt;\n&lt;directory&gt;./tests&lt;/directory&gt;\n&lt;/testsuite&gt;\n&lt;/testsuites&gt;\n&lt;/phpunit&gt;\n\nEstructura d’un test\nEls tests en PHPUnit són classes PHP que hereten de PHPUnit\\Framework\\TestCase. Cada mètode dins d'aquestes classes que comence amb test serà executat com una prova.\n&lt;?php\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass CalculadoraTest extends TestCase {\npublic function testSuma() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;suma(2, 3);\n$this-&gt;assertEquals(5, $resultat);\n}\n}\n\nExecució de Proves\nPer executar les proves, podem utilitzar la següent comanda:\nvendor/bin/phpunit\nAquesta comanda cercarà els arxius de prova en el directori especificat (per defecte tests) i executarà totes les proves.\nTipus de proves\nAmb PHPUnit, podem realitzar diversos tipus de proves, entre elles:\nProves Unitàries: Verifiquen el funcionament d'una unitat de codi individual, com una funció o mètode.\nExemple de prova unitària:\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n\nProves Funcionals: Verifiquen que un conjunt de mòduls funciona correctament conjuntament. Aquestes proves poden simular interaccions de l'usuari en un sistema web, encara que això es fa millor amb frameworks especialitzats per a proves funcionals.\nProves d'Integració: Comproven que diferents mòduls o serveis funcionen correctament quan es combinen.\nAssercions\nLes assercions permeten comprovar el resultat dels mètodes que volem provar. Les assercions esperen que el predicat sempre siga vertader.\nPHPUnit ofereix les següent assercions:\n\nassertTrue / assertFalse: Comprova que la condició donada siga avaluada com true / false\nassertEquals / assertSame: Comprova que dues variables siguen iguals\nassertNotEquals / assertNotSame: Comprova que dues variables NO siguen iguals\nassertNull: Comprova que un valor és null.\nSame → comprova els tipus. Si no coincideixen els tipus i els valors, l'asserció fallarà\nEquals → sense comprovació estricta\nassertArrayHasKey / assertArrayNotHasKey: Comprova que un array posseïsca un key determinat / o NO ho posseïsca\nassertArraySubset: Comprova que un array posseïsca un altre array com subset del mateix\nassertAttributeContains / assertAttributeNotContains: Comprova que un atribut d'una classe continga una variable determinada / o NO continga una variable determinada\nassertAttributeEquals: Comprova que un atribut d'una classe siga igual a una variable determinada.\n\nProves amb dades\nLes proves en PHPUnit poden utilitzar data providers per executar el mateix test amb diferents dades:\n/**\n* @dataProvider proveidorDeDades\n*/\npublic function testMultiplica($a, $b, $esperat) {\n$calculadora = new Calculadora();\n$this-&gt;assertEquals($esperat, $calculadora-&gt;multiplica($a, $b));\n}\n\npublic function proveidorDeDades() {\nreturn [\n[2, 3, 6],\n[0, 5, 0],\n[-1, 5, -5],\n];\n}\n\nMocks\nEls mocks són objectes simulats que ens permeten aïllar la unitat de codi que estem provant. PHPUnit facilita la creació de mocks per a classes o interfícies.\n$mock = $this-&gt;createMock(ServeiExtern::class);\n$mock-&gt;method('obtenirDades')-&gt;willReturn('Dades simulades');\n\n$calculadora = new Calculadora($mock);\n$resultat = $calculadora-&gt;processaDades();\n$this-&gt;assertEquals('Resultat esperat', $resultat);\n\nProvant excepcions\nLes proves a més de comprovar que les classes funcionen com s'espera, han de cobrir tots els casos possibles. Així doncs, hem de poder fer proves que esperen que es llance una excepció (i que el missatge continga una certa informació):\nPer a això, s'utilitzen les següent expectatives:\n\nexpectException(Excepcion::class)\nexpectExceptionCode(codigoExcepcion)\nexpectExceptionMessage(missatge)\n\nDe la mateixa manera que abans, primer es posa l'expectativa, i després es provoca que es llance l'excepció:\n&lt;?php\npublic function testExcepcio() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n\nConclusió\nLes proves són crucials per a assegurar que el nostre codi PHP és fiable i manté la seua funcionalitat al llarg del temps. Utilitzar PHPUnit ens proporciona les eines necessàries per a escriure proves eficaces i mantenir el nostre projecte en un estat saludable.",
		"tags": [ "note"]
},

{
		"title": "12. Referències Bibliogràfiques",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/12. Referències Bibliogràfiques/",
		"content": "Programació Orientada a Objectes en PHP\n\n&quot;PHP Objects, Patterns, and Practice&quot;\nper M. Zandstra. Apress, 2017. ISBN: 978-1-4842-1361-3. Aquest llibre és un recurs essencial per entendre els fonaments de la programació orientada a objectes en PHP, així com patrons de disseny.\n\n&quot;Learning PHP, MySQL &amp; JavaScript: With jQuery, CSS &amp; HTML5&quot;\nper Robin Nixon. O'Reilly Media, 2018. ISBN: 978-1-4919-2070-2. Ofereix una introducció completa a la programació amb PHP, incloent-hi el model d'objectes de PHP.\n\nConstructors i Destructors\n\nPHP Manual: Constructors and Destructors\nDocumentació oficial de PHP sobre constructors i destructors en la programació orientada a objectes. Disponible a https://www.php.net/manual/en/language.oop5.decon.php.\n\nEncapsulació i Visibilitat\n\nPHP Manual: Visibility\nSecció del manual oficial de PHP que explica les paraules clau public, protected, i private, així com el concepte d'encapsulació. Accessible a https://www.php.net/manual/en/language.oop5.visibility.php.\n\nHerència i Polimorfisme\n\n&quot;Programming PHP&quot;\nper Kevin Tatroe, Peter MacIntyre, i Rasmus Lerdorf. O'Reilly Media, 2013. ISBN: 978-1-4493-5053-6. Aquest llibre cobreix àmpliament els conceptes d'herència i polimorfisme en PHP, proporcionant exemples pràctics.\n\nPHP Manual: Inheritance\nDocumentació oficial de PHP que tracta sobre l'herència en classes, incloent el polimorfisme. Disponible a https://www.php.net/manual/en/language.oop5.inheritance.php.\n\nClasses Abstractes i Interfícies\n\nPHP Manual: Interfaces and Abstract Classes\nExplicació oficial de les classes abstractes i les interfícies en PHP. Disponible a https://www.php.net/manual/en/language.oop5.interfaces.php.\n\nNombres màgics i Metodes màgics\n\nPHP Manual: Magic Methods\nGuia completa sobre els mètodes màgics en PHP, com __construct(), __destruct(), __get(), __set(), entre altres. Disponible a https://www.php.net/manual/en/language.oop5.magic.php.\n\nTrait en PHP\n\nPHP Manual: Traits\nDocumentació sobre traits en PHP, que permeten reutilitzar codi entre diferents classes. Disponible a https://www.php.net/manual/en/language.oop5.traits.php.\n\nExcepcions en PHP\n\n&quot;The Pragmatic Programmer: Your Journey to Mastery&quot;\nper David Thomas i Andrew Hunt. Addison-Wesley Professional, 2019. ISBN: 978-0-1359-5202-8. Inclou bones pràctiques per a la gestió d'excepcions, aplicables també a PHP.\n\nPHP Manual: Exceptions\nSecció del manual de PHP dedicada a les excepcions, explicant com llençar i capturar excepcions en PHP. Accessible a https://www.php.net/manual/en/language.exceptions.php.\n\nProves amb PHPUnit\n\n&quot;Modern PHP: New Features and Good Practices&quot;\nper Josh Lockhart. O'Reilly Media, 2015. ISBN: 978-1-4919-2904-0. Aquest llibre inclou una secció sobre proves amb PHPUnit.\n\nPHPUnit Documentation\nDocumentació oficial de PHPUnit, que cobreix com escriure i executar proves unitàries en PHP. Accessible a https://phpunit.de/documentation.html.\n\nEines de Desenvolupament i Autocàrrega\n\nComposer Documentation\nAccessible des de https://getcomposer.org/doc/. Composer és l'eina estàndard per a la gestió de dependències en PHP, i inclou suport per a l'autocàrrega de classes.\n\nPHP Manual: Autoloading Classes\nGuia sobre el mecanisme d'autocàrrega en PHP, que facilita la inclusió automàtica de classes en els teus projectes. Disponible a https://www.php.net/manual/en/language.oop5.autoload.php.\n\nPOO Avançada: Patrons de Disseny\n\n&quot;Head First Design Patterns&quot;\nper Eric Freeman i Elisabeth Robson. O'Reilly Media, 2020. ISBN: 978-1-4919-7175-9. Un recurs excel·lent per aprendre patrons de disseny aplicables a PHP.\n\n&quot;PHP Design Patterns&quot;\nper Stephan Schmidt. Publicat per Packt Publishing, 2008. ISBN: 978-1-84719-255-3. Aquest llibre explora com aplicar patrons de disseny en projectes PHP.\n\nWebs de Referència Addicionals\n\nPHP: The Right Way\nhttps://phptherightway.com/. Una guia per a desenvolupar aplicacions PHP seguint les millors pràctiques de la indústria.\n\nStack Overflow\nhttps://stackoverflow.com/questions/tagged/php. Una font d'informació valuosa per resoldre problemes específics de PHP i discutir amb altres desenvolupadors.",
		"tags": [ "note"]
},

{
		"title": "13. Exercicis",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/13. Exercicis/",
		"content": "Bateria d'Exercicis Solucionats per a la Unitat de Programació Orientada a Objectes\nExercici 1: Crear una Classe Bàsica\n\nCrea una classe Cotxe que tinga les propietats marca i model. Afegeix un mètode mostraInformacio que retorne un string amb la marca i el model del cotxe.\nCrea una instància de la classe Cotxe, assigna-li una marca i un model, i mostra la informació utilitzant el mètode mostraInformacio.\n\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\n$cotxe = new Cotxe();\n$cotxe-&gt;marca = &quot;Toyota&quot;;\n$cotxe-&gt;model = &quot;Corolla&quot;;\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Toyota, Model: Corolla\n\nExercici 2. Afegir un Constructor i destructor\n\nModifica la classe Cotxe per afegir un constructor que prenga com a paràmetres la marca i el model, i que establisca aquestes propietats automàticament.\nAfegeix un destructor a la classe Cotxe que mostre un missatge quan l'objecte és destruït. Crea un objecte i permet que es destruïsca al final del programa.\n\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\npublic function __destruct() {\necho &quot;L'objecte Cotxe ha estat destruït.\\n&quot;;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nExercici 3. Encapsulació de Propietats\n\nModifica la classe Cotxe per a que les propietats marca i model siguen privades. Afegeix mètodes públics getMarca, setMarca, getModel, i setModel per accedir i modificar aquestes propietats.\n\n&lt;?php\nclass Cotxe {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function setMarca($marca) {\n$this-&gt;marca = $marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n\npublic function setModel($model) {\n$this-&gt;model = $model;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;getMarca() . &quot;, Model: &quot; . $this-&gt;getModel();\n}\n}\n\n$cotxe = new Cotxe(&quot;Ford&quot;, &quot;Fiesta&quot;);\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Ford, Model: Fiesta\n\nExercici 4. Herència i Polimorfisme\n\nCrea una classe Vehicle amb una propietat tipus. A continuació, crea una classe Motocicleta que herete de Vehicle i tinga una propietat cilindrada. Afegeix un mètode a Motocicleta que retorne el tipus i la cilindrada.\nCrea una funció mostraDetallsVehicle que accepte un objecte de tipus Vehicle i mostre les seues propietats. Prova aquesta funció amb objectes de Cotxe i Motocicleta.\n\n&lt;?php\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function mostraDetalls() {\nreturn &quot;Tipus: &quot; . $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Cilindrada: &quot; . $this-&gt;cilindrada;\n}\n}\n\nfunction mostraDetallsVehicle(Vehicle $vehicle) {\necho $vehicle-&gt;mostraDetalls() . &quot;\\n&quot;;\n}\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\nmostraDetallsVehicle($cotxe); // Output: Tipus: Cotxe, Marca: Toyota, Model: Corolla\nmostraDetallsVehicle($moto); // Output: Tipus: Motocicleta, Cilindrada: 600\n\nExercici 5. Implementació del Patró MVC amb Vehicles\nContinuant amb l'exercici anterior on has creat les classes Vehicle, Cotxe, i Motocicleta, ara refactoritzaràs el codi per seguir el patró Model-Vista-Controlador (MVC). El teu objectiu és separar la lògica de negoci (models) de la presentació (vistes) i gestionar la interacció entre aquestes capes mitjançant un controlador.\n\nCrear el Model:\n\nRefactoritza les classes Vehicle, Cotxe, i Motocicleta perquè representen el model de negoci i només contenen la lògica relacionada amb la gestió de vehicles.\nAssegura't que els models no contenen cap codi de presentació.\n\nCrear les Vistes:\n\nCrea vistes separades per mostrar els detalls dels vehicles:\n\nUna vista HTML que mostre la informació dels vehicles en format HTML.\nUna vista en text simple que mostre els detalls dels vehicles en un format de text senzill.\n\nCrear el Controlador:\n\nImplementa un controlador que gestione la interacció entre els models i les vistes.\nEl controlador ha de ser capaç de rebre una sol·licitud per mostrar un vehicle i triar la vista adequada per mostrar-ne els detalls.\n\n&lt;?php\n// Models\n\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function getTipus() {\nreturn $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function getCilindrada() {\nreturn $this-&gt;cilindrada;\n}\n}\n\n// Vistes\n\nclass VehicleView {\npublic function renderHtml(Vehicle $vehicle) {\n$output = &quot;&lt;p&gt;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;&lt;/p&gt;&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;&lt;p&gt;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;&lt;/p&gt;&quot;;\n$output .= &quot;&lt;p&gt;Model: &quot; . $vehicle-&gt;getModel() . &quot;&lt;/p&gt;&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;&lt;p&gt;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc&lt;/p&gt;&quot;;\n}\nreturn $output;\n}\n\npublic function renderText(Vehicle $vehicle) {\n$output = &quot;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;\\n&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;\\n&quot;;\n$output .= &quot;Model: &quot; . $vehicle-&gt;getModel() . &quot;\\n&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc\\n&quot;;\n}\nreturn $output;\n}\n}\n\n// Controlador\n\nclass VehicleController {\nprivate $view;\n\npublic function __construct(VehicleView $view) {\n$this-&gt;view = $view;\n}\n\npublic function mostrarVehicle(Vehicle $vehicle, $format = 'html') {\nif ($format === 'html') {\necho $this-&gt;view-&gt;renderHtml($vehicle);\n} else {\necho $this-&gt;view-&gt;renderText($vehicle);\n}\n}\n}\n\n// Exemple d'ús\n\n$view = new VehicleView();\n$controller = new VehicleController($view);\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\n// Mostrar en HTML\n$controller-&gt;mostrarVehicle($cotxe, 'html');\n$controller-&gt;mostrarVehicle($moto, 'html');\n\n// Mostrar en Text\n$controller-&gt;mostrarVehicle($cotxe, 'text');\n$controller-&gt;mostrarVehicle($moto, 'text');\n\nExercici 5. Classes Abstractes i Interfícies\n\nCrea una classe abstracta Figura amb un mètode abstracte calculaArea. Després, crea classes Cercle i Rectangle que estiguen basades en Figura i implementen el mètode calculaArea.\nDefineix una interfície OperacionsBàsiques amb els mètodes suma i resta. Implementa aquesta interfície en una classe CalculadoraSimple.\n\n&lt;?php\nabstract class Figura {\nabstract public function calculaArea();\n}\n\nclass Cercle extends Figura {\nprivate $radi;\n\npublic function __construct($radi) {\n$this-&gt;radi = $radi;\n}\n\npublic function calculaArea() {\nreturn pi() * $this-&gt;radi * $this-&gt;radi;\n}\n}\n\nclass Rectangle extends Figura {\nprivate $ample;\nprivate $llarg;\n\npublic function __construct($ample, $llarg) {\n$this-&gt;ample = $ample;\n$this-&gt;llarg = $llarg;\n}\n\npublic function calculaArea() {\nreturn $this-&gt;ample * $this-&gt;llarg;\n}\n}\n\n$cercle = new Cercle(5);\n$rectangle = new Rectangle(4, 6);\n\necho &quot;Àrea del cercle: &quot; . $cercle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del cercle: 78.5398\necho &quot;Àrea del rectangle: &quot; . $rectangle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del rectangle: 24\n\n&lt;?php\ninterface OperacionsBàsiques {\npublic function suma($a, $b);\npublic function resta($a, $b);\n}\n\nclass CalculadoraSimple implements OperacionsBàsiques {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\n$calculadora = new CalculadoraSimple();\necho &quot;Suma: &quot; . $calculadora-&gt;suma(5, 3) . &quot;\\n&quot;; // Output: Suma: 8\necho &quot;Resta: &quot; . $calculadora-&gt;resta(5, 3) . &quot;\\n&quot;; // Output: Resta: 2\n\nExercici 6. Utilitzar Traits\n\nCrea un trait Informacio amb un mètode mostraInformacio. Inclou aquest trait en les classes Cotxe i Motocicleta, i utilitza'l per mostrar informació addicional.\n\n&lt;?php\ntrait Informacio {\npublic function mostraInformacio() {\nreturn &quot;Aquest és un objecte de tipus &quot; . get_class($this);\n}\n}\n\nclass Cotxe {\nuse Informacio;\n}\n\nclass Motocicleta {\nuse Informacio;\n}\n\n$cotxe = new Cotxe();\n$moto = new Motocicleta();\n\necho $cotxe-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Cotxe\necho $moto-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Motocicleta\n\nExercici 7. Gestionar Excepcions\n\nEscriu una funció divideix que prenga dos nombres com a paràmetres i retorne el resultat de la divisió. Si el segon nombre és zero, llença una excepció amb un missatge adequat. Captura aquesta excepció quan crides a la funció i mostra un missatge d'error.\n\nSolucio\n&lt;?php\nfunction divideix($a, $b) {\nif ($b == 0) {\nthrow new Exception(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n\ntry {\necho divideix(10, 2) . &quot;\\n&quot;; // Output: 5\necho divideix(10, 0) . &quot;\\n&quot;; // Aquesta línia llançarà una excepció\n} catch (Exception $e) {\necho &quot;Error: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;; // Output: Error: No es pot dividir per zero.\n}\n\nExercici 8. Proves amb PHPUnit\n\nCrea una classe Calculadora amb els mètodes suma i resta. Escriu una prova unitària amb PHPUnit per verificar que aquests mètodes funcionen correctament.\nAfegeix un mètode divideix a la classe Calculadora que llance una excepció quan es divideix per zero. Escriu una prova unitària que assegure que aquesta excepció es llança correctament.\n\nSolucio\n&lt;?php\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testSuma() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;suma(2, 3);\n$this-&gt;assertEquals(5, $resultat);\n}\n\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n}\n\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function divideix($a, $b) {\nif ($b == 0) {\nthrow new InvalidArgumentException(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testDivideix() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n}\n\nExercici 9. Espais de Noms (Namespaces)\n\nCrea un espai de noms App\\Models i defineix una classe Usuari dins d'aquest espai de noms. Afegeix un mètode getNomComplet que retorne el nom complet de l'usuari.\nEn un fitxer separat, importa la classe Usuari de l'espai de noms App\\Models i crea una instància d'aquesta classe. Utilitza el mètode getNomComplet per mostrar el nom complet d'un usuari.\n\nSolucio\n&lt;?php\n// Arxiu: src/Models/Usuari.php\nnamespace App\\Models;\n\nclass Usuari {\nprivate $nom;\nprivate $cognom;\n\npublic function __construct($nom, $cognom) {\n$this-&gt;nom = $nom;\n$this-&gt;cognom = $cognom;\n}\n\npublic function getNomComplet() {\nreturn $this-&gt;nom . &quot; &quot; . $this-&gt;cognom;\n}\n}\n\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Usuari;\n\n$usuari = new Usuari(&quot;Joan&quot;, &quot;Garcia&quot;);\necho $usuari-&gt;getNomComplet(); // Output: Joan Garcia\n\nExercici 10. Autoloading i Composer\n\nConfigura un projecte PHP amb Composer que utilitze l'autoloading PSR-4. Crea l'estructura de directoris src/Models i col·loca una classe Producte dins de src/Models. Verifica que l'autoloading funcione correctament instanciant la classe Producte en un fitxer separat.\nAfegeix la llibreria monolog/monolog al projecte utilitzant Composer. Crea una instància de Logger i afegeix una entrada al registre de logs.\n\nSolucio\n\nCrea l'estructura de directoris src/Models i col·loca el següent codi a src/Models/Producte.php:\n\n&lt;?php\nnamespace App\\Models;\n\nclass Producte {\nprivate $nom;\n\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nConfigura l'autoloading en composer.json:\n\n{\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {\n&quot;App\\\\&quot;: &quot;src/&quot;\n}\n}\n}\n\nExecuta composer dump-autoload per generar els fitxers d'autoload.\nUtilitza la classe producte:\n\n&lt;?php\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Producte;\n\n$producte = new Producte(&quot;Ordinador&quot;);\necho $producte-&gt;getNom(); // Output: Ordinador\n\nAfegeix Monolog a composer.json:\n\ncomposer require monolog/monolog\n\nUtilitza Monolog per crear un logger:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n\n// Afegeix una entrada al log\n$log-&gt;warning('Aquesta és una entrada d'advertència');\n$log-&gt;error('Aquesta és una entrada d'error');\n\nExercici 11. Logger\n\nUtilitzant la llibreria Monolog, crea un logger que escriga missatges a un fitxer app.log. Configura el logger per registrar missatges d'informació i d'error.\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error.\n\nSolucio\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::INFO));\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::ERROR));\n\n// Registra missatges d'informació i d'error\n$log-&gt;info('Aquesta és una entrada d’informació');\n$log-&gt;error('Aquesta és una entrada d’error');\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Handler\\ErrorLogHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n$log-&gt;pushHandler(new ErrorLogHandler());\n\n// Registra missatges d’error al fitxer i a la consola\n$log-&gt;error('Aquesta és una entrada d’error');\n\nExercici 12. Documentació\n\nDocumenta la classe Producte creada en l'exercici anterior utilitzant comentaris PHPDoc. Assegura't d'incloure la descripció de la classe, les propietats, i els mètodes.\nUtilitza una eina com phpDocumentor per generar la documentació automàtica del codi PHP del projecte, incloent-hi la classe Producte.\n\nSolucio\n&lt;?php\nnamespace App\\Models;\n\n/**\n* Classe Producte\n*\n* Representa un producte amb un nom.\n*/\nclass Producte {\n/**\n* @var string El nom del producte\n*/\nprivate $nom;\n\n/**\n* Constructor de la classe Producte\n*\n* @param string $nom El nom del producte\n*/\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\n/**\n* Obté el nom del producte\n*\n* @return string El nom del producte\n*/\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nInstal·la phpDocumentor globalment o com a dependència de desenvolupament:\n\ncomposer require --dev phpdocumentor/phpdocumentor\n\nGenera la documentació:\n\nvendor/bin/phpdoc -d src -t docs\n\nAquest comandament generarà la documentació a la carpeta docs.\nExercici 13. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nSolucio\n\nInstal·la DomPDF amb Composer:\n\ncomposer require dompdf/dompdf\n\nCrea un script PHP que generi un PDF senzill:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '&lt;h1&gt;Informe de Vendes&lt;/h1&gt;&lt;p&gt;Aquest és un informe de les vendes.&lt;/p&gt;';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'landscape');\n$dompdf-&gt;render();\n$dompdf-&gt;stream('informe.pdf');\n\nCrea un PDF amb una taula i una imatge:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '\n&lt;h1&gt;Informe de Productes&lt;/h1&gt;\n&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Producte&lt;/th&gt;\n&lt;th&gt;Preu&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Ordinador&lt;/td&gt;\n&lt;td&gt;500€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Teclat&lt;/td&gt;\n&lt;td&gt;20€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;img src=&quot;https://example.com/imatge.png&quot; alt=&quot;Imatge de Producte&quot; /&gt;\n';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'portrait');\n$dompdf-&gt;render();\n$dompdf-&gt;stream(&quot;informe_productes.pdf&quot;);",
		"tags": [ "note"]
},

{
		"title": "14. Enunciat dels projectes",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/14. Enunciat dels projectes/",
		"content": "Projecte &quot;Ofegat&quot;\n1. Refactorització amb Programació Orientada a Objectes (POO)\n\nCrear una Classe JocOfegat: Refactoritza la lògica principal del joc en una classe JocOfegat que gestione l'estat del joc, la paraula a endevinar, les lletres endevinades, i el nombre d'intents restants.\nMètodes Principals:\n\niniciarJoc($paraula): void – Inicia una nova partida amb la paraula donada.\nendevinaLletra($lletra): bool – Comprova si la lletra és part de la paraula i actualitza l'estat del joc.\nestaAcabat(): bool – Retorna true si el joc ha acabat, ja siga per guanyar o per perdre.\nobteEstat(): array – Retorna l'estat actual del joc, incloent les lletres encertades, intents restants, etc.\n\n2. Separació del Model de Negoci de la Presentació\n\nModel-Vista-Controlador (MVC):\n\nModel: La classe JocOfegat actua com a model, gestionant la lògica del joc i mantenint l'estat. Aquest model ha d'estar completament separat de qualsevol codi que gestione la presentació (HTML, CSS).\nVista: Crea vistes que s'encarreguen exclusivament de mostrar la informació a l'usuari. Aquestes vistes poden utilitzar plantilles HTML i accedir al model a través de controladors.\nControlador: El controlador serà responsable de rebre les entrades de l'usuari (com l'endevinació d'una lletra), interactuar amb el model (JocOfegat) per actualitzar l'estat del joc, i seleccionar la vista adequada per a mostrar els resultats a l'usuari.\n\n3. Integració de Composer i Autoloading\n\nConfiguració de Composer: Utilitza Composer per gestionar les dependències del projecte. Defineix l'autoloading per carregar automàticament les classes de JocOfegat.\nEstructura del Projecte:\n\nOrganitza el codi en directoris com src/Models per a les classes del joc, i src/Services per a la gestió de sessions i autenticació.\nDefineix un composer.json per configurar l'autoloading PSR-4.\n\n4. Proves amb PHPUnit\n\nEscriu Proves Unitàries: Crea proves unitàries per a la classe JocOfegat utilitzant PHPUnit. Les proves poden incloure:\n\nProva per assegurar que una paraula es configura correctament.\nProva per verificar que una lletra encertada actualitza l'estat correctament.\nProva per assegurar que el joc detecta correctament quan s'ha guanyat o perdut.\n\nProva de Gestió de Sessions: Afig proves per a la gestió de sessions, comprovant que l'estat del joc es guarda i es recupera correctament.\n\n5. Logger amb Monolog\n\nConfiguració de Logger: Utilitza Monolog per registrar esdeveniments importants, com quan s'inicia un nou joc, quan un jugador endevina una lletra o quan es produeixen errors.\nDiversos Handlers:\n\nRegistra missatges a un fitxer game.log per a esdeveniments generals.\nAfig un handler per registrar errors greus, com intents invàlids o problemes de sessió, en un fitxer d'errors separat.\n\nProjecte &quot;4 en Ratlla&quot;\n1. Refactorització amb Programació Orientada a Objectes (POO)\n\nClasse Joc4enRatlla: Refactoritza la lògica del joc en una classe Joc4enRatlla que gestione la graella, el torn del jugador, i la lògica per determinar el guanyador.\nMètodes Principals:\n\niniciarPartida(): void – Inicia una nova partida.\nferMoviment($columna): bool – Permet que un jugador faça un moviment en una columna determinada.\ncomprovaGuanyador(): ?int – Comprova si hi ha un guanyador després d'un moviment.\nobteEstatGraella(): array – Retorna l'estat actual de la graella.\n\n2. Separació del Model de Negoci de la Presentació\n\nModel-Vista-Controlador (MVC):\n\nModel: La classe Joc4enRatlla representa el model, que s'encarrega de tota la lògica del joc, incloent la gestió de la graella i la determinació del guanyador.\nVista: Les vistes presenten la graella del joc, el torn actual del jugador, i els resultats finals (guanyador o empat). Aquestes vistes han d'estar separades del model i només han de mostrar la informació proporcionada pel controlador.\nControlador: El controlador gestiona les interaccions de l'usuari, com els moviments en la graella. Aquest component comunica el model amb les vistes, assegurant-se que els canvis en l'estat del joc es reflectisquen correctament en la presentació.\n\n3. Integració de Composer i Autoloading\n\nConfiguració de Composer: Defineix un composer.json per al projecte, configurant l'autoloading PSR-4 per carregar automàticament les classes de Joc4enRatlla.\nEstructura del Projecte:\n\nOrganitza el codi en directoris com src/Models per a les classes del joc i src/Controllers per a la gestió del flux del joc.\nConfigura Composer per gestionar les dependències del projecte.\n\n4. Proves amb PHPUnit\n\nEscriu Proves Unitàries: Crea proves unitàries per a la classe Joc4enRatlla utilitzant PHPUnit. Les proves poden incloure:\n\nVerificació de la configuració inicial de la graella.\nProves per assegurar que un moviment s'aplica correctament a la graella.\nProves per assegurar que el joc detecta correctament un guanyador o un empat.\n\nProves de Gestió de Sessions: Afig proves per assegurar que l'estat del joc i el torn del jugador es mantenen correctament a través de les sessions.\n\n5. Logger amb Monolog\n\nConfiguració de Logger: Utilitza Monolog per registrar esdeveniments importants del joc, com quan un jugador fa un moviment, quan s'inicia una nova partida, o quan es produeixen errors.\nDiversos Handlers:\n\nRegistra els moviments dels jugadors i els resultats del joc en un fitxer game.log.\nRegistra errors greus o problemes amb les sessions en un fitxer d'errors separat.\n\nConsideracions Addicionals per a Ambdós Projectes\n1. Documentació amb PHPDoc\n\nDocumentació Completa: Documenta totes les classes i mètodes amb comentaris PHPDoc. Això inclou les descripcions dels paràmetres i els valors de retorn per a cada mètode.\nGeneració Automàtica: Utilitza phpDocumentor o una eina similar per generar la documentació automàticament. Afig la documentació generada al projecte per facilitar el manteniment i la comprensió del codi.\n\n2. Implementació d'Interfícies\n\nInterfície JocInterface: Crea una interfície que definisca els mètodes bàsics que qualsevol joc (com Ofegat o 4 en Ratlla) ha de tindre (iniciarJoc, ferMoviment, comprovaGuanyador, etc.). Assegura't que les classes JocOfegat i Joc4enRatlla implementen aquesta interfície.\n\n3. Serialització i Persistència\n\nSerialització de l'Estat del Joc: Implementa funcionalitats per serialitzar l'estat del joc (usant JSON o serialize()) i deserialitzar-lo per mantenir la persistència entre sessions o guardar l'estat per a reprendre la partida posteriorment.\n\nRúbrica d'Avaluació per als Projectes &quot;Ofegat&quot; i &quot;4 en Ratlla&quot;\n\nCriteri\n** Insuficient (1 punt)**\n** Adequat (2 punts)**\n** Bé (3 punts)**\n** Excel·lent (4 punts)**\n\nImplementació de Programació Orientada a Objectes (POO)\nLes classes no estan ben dissenyades, falta encapsulació, ús incorrecte d'herència, o mètodes no funcional.\nLes classes estan creades però poden tindre errors o una estructura confusa. S'aplica la POO de manera bàsica, però hi ha problemes de disseny.\nClasses correctament estructurades i funcionalment completes. Ús adequat d'encapsulació, herència i polimorfisme.\nDisseny de classes ben organitzat, reutilitzable i amb una implementació clara dels principis de POO.\n\nSeparació del Model de Negoci de la Presentació (MVC)\nNo s'ha implementat la separació de model i presentació; el codi de lògica i presentació està mesclat.\nHi ha una separació parcial, però algunes parts de la lògica del negoci es barregen amb la presentació o a l'inrevés.\nLa separació entre model, vista i controlador està ben implementada, però podria millorar en alguns aspectes.\nExcel·lent separació entre el model, vista i controlador, seguint els principis del patró MVC i mantenint un codi net.\n\nIntegració de Composer i Autoloading\nNo s'ha configurat Composer o l'autoloading, o està mal configurat i no funciona correctament.\nComposer s'ha utilitzat, però amb una estructura de projectes i autoloading bàsics o incorrectes.\nComposer i l'autoloading estan configurats correctament amb una estructura de projectes ben definida.\nÚs excel·lent de Composer amb una configuració avançada d'autoloading i una estructura de projecte organitzada i modular.\n\nImplementació de Proves amb PHPUnit\nNo s'han creat proves, o les proves creades són mínimes i no adequades per a verificar la funcionalitat.\nEs presenten proves bàsiques amb PHPUnit, però cobreixen parcialment les funcionalitats requerides.\nProves unitàries completes que cobreixen la majoria dels casos, incloent proves de gestió de sessions i lògica de joc.\nProves exhaustives que cobreixen totes les funcionalitats i consideren casos límit, amb ús de mocks quan necessari.\n\nÚs de Logger amb Monolog\nNo s'ha implementat el logger o no s'utilitza de manera efectiva per registrar esdeveniments importants.\nLogger implementat, però amb ús limitat o incorrecte en la registració d'esdeveniments i errors.\nLogger ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nÚs avançat de logger amb diferents handlers per registrar informació, errors, i seguiment detallat del flux del joc.\n\nDocumentació amb PHPDoc\nFalta documentació o és insuficient per comprendre les classes i mètodes del projecte.\nDocumentació bàsica amb PHPDoc, però amb omisions o descripcions poc clares.\nDocumentació completa amb PHPDoc per a totes les classes i mètodes, amb descripcions clares i detallades.\nDocumentació excel·lent amb PHPDoc, ben estructurada i completa, facilitant la comprensió i manteniment del projecte.\n\nQualitat del Codi i Bones Pràctiques\nCodi desorganitzat, amb molts errors de sintaxi, mala nomenclatura, o sense bones pràctiques de codi.\nCodi funcional però amb problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\nCodi ben escrit, seguint les convencions de nomenclatura i bones pràctiques de desenvolupament.\nCodi de qualitat professional, net, ben organitzat, i seguint rigorosament les millors pràctiques de programació.\n\nExplicació dels Criteris\n1 punt: Insuficient\n\nPOO: Les classes no segueixen els principis bàsics de la programació orientada a objectes. Hi ha problemes greus com la falta d'encapsulació, l'ús inadequat de l'herència o mètodes que no funcionen correctament.\nMVC: No s'ha implementat la separació del model de negoci i la presentació. El codi de la lògica del negoci està mesclat amb la presentació (HTML, CSS), cosa que dificulta el manteniment i l'escalabilitat del projecte.\nComposer i Autoloading: No s'ha configurat Composer o l'autoloading. Si estan configurats, no funcionen correctament.\nProves amb PHPUnit: Les proves estan absents o són mínimes, i no verifiquen adequadament la funcionalitat del projecte.\nLogger amb Monolog: El logger no s'ha implementat, o si està present, no s'utilitza de manera efectiva per registrar esdeveniments importants.\nDocumentació amb PHPDoc: Falta documentació essencial, o la que existeix és insuficient per a entendre el codi.\nQualitat del Codi: El codi és desorganitzat, amb molts errors de sintaxi i no segueix les bones pràctiques de programació.\n\n2 punts: Adequat\n\nPOO: Les classes estan creades, però poden contindre errors o una estructura confusa. L'aplicació de la POO és bàsica, amb alguns problemes de disseny.\nMVC: Hi ha una separació parcial entre el model de negoci i la presentació. No obstant això, encara hi ha parts del codi on la lògica del negoci està barrejada amb la presentació o a l'inrevés, cosa que indica una comprensió bàsica però incompleta del patró MVC.\nComposer i Autoloading: Composer s'ha utilitzat, però l'estructura de projectes o l'autoloading no són òptims, presentant configuracions bàsiques o incorrectes.\nProves amb PHPUnit: Es presenten proves bàsiques que cobreixen parcialment les funcionalitats requerides.\nLogger amb Monolog: El logger està implementat, però l'ús és limitat o incorrecte en la registració d'esdeveniments i errors.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és bàsica, amb algunes omisions o descripcions poc clares.\nQualitat del Codi: El codi és funcional però presenta problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\n\n3 punts: Bé\n\nPOO: Les classes estan correctament estructurades i són funcionalment completes. Es fa un ús adequat de l'encapsulació, l'herència i el polimorfisme.\nMVC: La separació entre el model, vista i controlador està ben implementada, seguint majoritàriament els principis del patró MVC. El codi és clar i estructurat, amb algunes àrees que podrien millorar-se per aconseguir una millor modularitat i mantenibilitat.\nComposer i Autoloading: Composer i l'autoloading estan configurats correctament, amb una estructura de projectes ben definida.\nProves amb PHPUnit: Les proves unitàries estan completes i cobreixen la majoria dels casos, incloent-hi la gestió de sessions i la lògica del joc.\nLogger amb Monolog: El logger està ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és completa per a totes les classes i mètodes, amb descripcions clares i detallades.\nQualitat del Codi: El codi està ben escrit, seguint les convencions de nomenclatura i les bones pràctiques de desenvolupament.\n\n4 punts: Excel·lent\n\nPOO: El disseny de classes està ben organitzat, és reutilitzable i implementa clarament els principis de la programació orientada a objectes. El codi és elegant i eficient.\nMVC: Excel·lent separació entre el model, vista i controlador, seguint rigorosament els principis del patró MVC. El codi està ben organitzat, modular i fàcil de mantenir, cosa que facilita l'escalabilitat del projecte. Hi ha una clara distinció de responsabilitats entre les diferents capes.\nComposer i Autoloading: S'utilitza Composer de manera excel·lent, amb una configuració avançada de l'autoloading i una estructura de projecte organitzada i modular.\nProves amb PHPUnit: Les proves són exhaustives, cobrint totes les funcionalitats i considerant casos límit, amb ús de mocks quan necessari.\nLogger amb Monolog: S'utilitza el logger de manera avançada, amb diferents handlers per registrar informació, errors, i fer un seguiment detallat del flux del joc.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és excel·lent, ben estructurada i completa, facilitant la comprensió i el manteniment del projecte.\nQualitat del Codi: El codi és de qualitat professional, net, ben organitzat, i segueix rigorosament les millors pràctiques de programació.",
		"tags": [ "note"]
},

{
		"title": "15. Autoavaluació Programació Orientada a Objectes en PHP",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/15. Autoavaluació Programació Orientada a Objectes en PHP/",
		"content": "Exercici 1: Constructors en PHP\nPregunta:\nQuina és la funció principal d'un constructor en una classe PHP?\nOpcions:\n\na) Destruir els objectes de la classe quan ja no són necessaris.\n\nb) Inicialitzar les propietats de l'objecte quan es crea.\n\nc) Executar una funció arbitrària abans de cada mètode.\n\nd) Crear mètodes màgics automàticament.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Inicialitzar les propietats de l'objecte quan es crea.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Herència en PHP\nPregunta:\nQuina és l'avantatge principal de l'herència en la programació orientada a objectes?\nOpcions:\n\na) Permet reutilitzar codi definint classes noves basades en classes existents.\n\nb) Permet ocultar totes les propietats i mètodes de la classe.\n\nc) Permet definir funcions globals sense necessitat de classes.\n\nd) Permet cridar a funcions de JavaScript des de PHP.\n\nfunction checkAnswer2() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question2');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet reutilitzar codi definint classes noves basades en classes existents.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Polimorfisme\nPregunta:\nQuè permet el polimorfisme en el context de la POO?\nOpcions:\n\na) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\n\nb) Permet la creació d'objectes a partir de funcions anònimes.\n\nc) Permet la connexió entre PHP i bases de dades relacionals.\n\nd) Permet executar múltiples scripts PHP alhora.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Espais de Noms\nPregunta:\nPer a què s'utilitzen els espais de noms (namespaces) en PHP?\nOpcions:\n\na) Per executar codi PHP de forma asincrònica.\n\nb) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\n\nc) Per definir variables globals accessibles des de qualsevol punt del codi.\n\nd) Per importar codi d'altres llenguatges de programació com JavaScript.\n\nfunction checkAnswer4() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question4');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Traits en PHP\nPregunta:\nQuin avantatge ofereixen els traits en PHP?\nOpcions:\n\na) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\n\nb) Permet la creació de funcions globals en PHP.\n\nc) Permet la comunicació entre diferents servidors web.\n\nd) Permet executar codi PHP dins de plantilles HTML.\n\nfunction checkAnswer5() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question5');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Excepcions en PHP\nPregunta:\nQuina és la finalitat d'utilitzar excepcions en PHP?\nOpcions:\n\na) Evitar l'execució de codi mal format.\n\nb) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\n\nc) Declarar funcions dins d'una classe.\n\nd) Garantir que totes les variables estiguen inicialitzades abans del seu ús.\n\nfunction checkAnswer6() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question6');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Autoloading en PHP\nPregunta:\nQuin avantatge ofereix l'autoloading en PHP?\nOpcions:\n\na) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\n\nb) Permet l'execució de múltiples scripts alhora.\n\nc) Permet la manipulació de fitxers en el servidor.\n\nd) Permet la connexió amb bases de dades.\n\nfunction checkAnswer7() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question7');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": [ "note"]
},

{
		"title": "2. Principis de la POO",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/2. Principis de la POO/",
		"content": "Encapsulació\nLes propietats es defineixen privades o protegides (si volem que les classes heretades puguen accedir).\nPer a cada propietat, s'afigen mètodes públics (getter/setter):\npublic setPropiedad(tipo $param)\npublic getPropiedad() : tipo\n\nLes constants es defineixen públiques perquè siguen accessibles per tots els recursos.\n&lt;?php\nclass MayorMenor {\nprivate int $mayor;\nprivate int $menor;\n\npublic function setMayor(int $may) {\n$this-&gt;mayor = $may;\n}\n\npublic function setMenor(int $men) {\n$this-&gt;menor = $men;\n}\n\npublic function getMayor() : int {\nreturn $this-&gt;mayor;\n}\n\npublic function getMenor() : int {\nreturn $this-&gt;menor;\n}\n}\n\nRebent i enviant objectes\nÉs recomanable indicar-ho en la mena de paràmetres. Si l'objecte pot retornar nuls es posa ? davant del nom de la classe.\n\n[!important] &quot;Objectes per referència&quot;\nEls objectes que s'envien i reben com a paràmetres sempre es passen per referència.\n\n&lt;?php\nfunction maymen(array $numeros) : ?MayorMenor {\n$a = max($numeros);\n$b = min($numeros);\n\n$result = new MayorMenor();\n$result-&gt;setMayor($a);\n$result-&gt;setMenor($b);\n\nreturn $result;\n}\n\n$resultado =  maymen([1,76,9,388,41,39,25,97,22]);\necho &quot;&lt;br&gt;Mayor: &quot;.$resultado-&gt;getMayor();\necho &quot;&lt;br&gt;Menor: &quot;.$resultado-&gt;getMenor();\n\nConstructor\nEl constructor dels objectes es defineix mitjançant el mètode màgic __construct.\nPot o no tindre paràmetres, però només pot haver-hi un únic constructor.\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function __construct(string $nom) {\n$this-&gt;nombre = $nom;\n}\n\npublic function imprimir(){\n  echo $this-&gt;nombre;\n  echo '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nConstructors en PHP 8\nUna de les grans novetats que ofereix PHP 8 és la simplificació dels constructors amb paràmetres, la qual cosa es coneix com a promoció de les propietats del constructor*.\nPer a això, en comptes d'haver de declarar les propietats com a privades o protegides, i després dins del constructor haver d'assignar els paràmetres a estàs propietats, el propi constructor promociona les propietats.\nVegem-ho millor amb un exemple. Imaginem una classe Punt on vulguem emmagatzemar les seues coordenades:\n&lt;?php\nclass Punto {\nprotected float $x;\nprotected float $y;\nprotected float $z;\n\npublic function __construct(\nfloat $x = 0.0,\nfloat $y = 0.0,\nfloat $z = 0.0\n) {\n$this-&gt;x = $x;\n$this-&gt;y = $y;\n$this-&gt;z = $z;\n}\n}\n\nEn PHP 8, quedaria de la següent manera (molt més curt, la qual cosa facilita la seua llegibilitat):\n&lt;?php\nclass Punto {\npublic function __construct(\nprotected float $x = 0.0,\nprotected float $y = 0.0,\nprotected float $z = 0.0,\n) {}\n}\n\n[!info] &quot;L'ordre importa&quot;\nA l'hora de codificar l'ordre dels elements ha de ser:\n\n&lt;?php\ndeclare(strict_types=1);\nclass NombreClase {\n// propiedades\n// constructor\n// getters - setters\n// resto de métodos\n}\n?&gt;\n\nClasses estàtiques\nSón aquelles que tenen propietats i/o mètodes estàtics (també es coneixen com de classe, perquè el seu valor es comparteix entre totes les instàncies de la mateixa classe).\nEs declaren amb static i es referencien amb ::.\n\nSi volem accedir a un mètode estàtic, s'anteposa el nom de la classe: Producte::nuevoProducto().\nSi des d'un mètode volem accedir a una propietat estàtica de la mateixa classe, s'utilitza la referència self: self::$numProductos\n\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0;\n\npublic static function nuevoProducto() {\nself::$numProductos++;\n}\n}\n\nProducto::nuevoProducto();\n$impuesto = Producto::IVA;\n\nTambé podem tindre classes normals que tinguen alguna propietat estàtica:\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0; \nprivate $codigo;\n\npublic function __construct(string $cod) {\nself::$numProductos++;\n$this-&gt;codigo = $cod;\n}\n\npublic function mostrarResumen() : string {\nreturn &quot;El producto &quot;.$this-&gt;codigo.&quot; es el número &quot;.self::$numProductos;\n}\n}\n\n$prod1 = new Producto(&quot;PS5&quot;);\n$prod2 = new Producto(&quot;XBOX Series X&quot;);\n$prod3 = new Producto(&quot;Nintendo Switch&quot;);\necho $prod3-&gt;mostrarResumen();\n\nIntrospecció\nEn treballar amb classes i objectes, existeixen un conjunt de funcions ja definides pel llenguatge que permeten obtindre informació sobre els objectes:\n\ninstanceof: permet comprovar si un objecte és d'una determinada classe\nget_class: retorna el nom de la classe\nget_declared_class: retorna un array amb els noms de les classes definides\nclass_àlies: crea un àlies\nclass_exists / method_exists / property_exists: true si la classe / mètode / propietat està definida\nget_class_methods / get_class_vars / get_object_vars: Retorna un array amb els noms dels mètodes / propietats d'una classe / propietats d'un objecte que són accessibles des d'on es fa la crida.\n\nUn exemple d'aquestes funcions pot ser el següent:\n&lt;?php\n$p = new Producto(&quot;PS5&quot;);\nif ($p instanceof Producto) {\necho &quot;Es un producto&quot;;\necho &quot;La clase es &quot;.get_class($p);\n\nclass_alias(&quot;Producto&quot;, &quot;Articulo&quot;);\n$c = new Articulo(&quot;Nintendo Switch&quot;);\necho &quot;Un articulo es un &quot;.get_class($c);\n\nprint_r(get_class_methods(&quot;Producto&quot;));\nprint_r(get_class_vars(&quot;Producto&quot;));\nprint_r(get_object_vars($p));\n\nif (method_exists($p, &quot;mostrarResumen&quot;)) {\n$p-&gt;mostrarResumen();\n}\n}\n\n!!! caution &quot;Clonat&quot;\nEn assignar dos objectes no es copien, es crea una nova referència. Si volem una còpia, cal clonar-ho mitjançant el mètode clone(object) : object\nSi volem modificar el clonat per defecte, cal definir el mètode màgic __clone() que es dirà després de copiar totes les propietats.\nMés informació en https://www.php.net/manual/es/language.oop5.cloning.php\nHerència\nPHP suporta herència simple, de manera que una classe només pot heretar d'una altra, no de dues classes alhora. Per a això s'utilitza la paraula clau extends. Si volem que la classe A hereta de la classe B farem:\nclass A extends B\n\nEl fill hereta els atributs i mètodes públics i protegits.\n!!! warning &quot;Cada classe en un arxiu&quot;\nCom ja hem comentat, hauríem de col·locar cada classe en un arxiu diferent per a posteriorment utilitzar-lo mitjançant include. En els següent exemple els hem col·locats junt per a facilitar la seua llegibilitat.\nPer exemple, tenim una classe Producte i una Tv que hereta de Producte:\n&lt;?php\nclass Producto {\npublic $codigo;\npublic $nombre;\npublic $nombreCorto;\npublic $PVP;\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n}\n\nPodemos utilizar las siguientes funciones para averiguar si hay relación entre dos clases:\n\nget_parent_class(object): string\nis_subclass_of(object, string): bool\n\n&lt;?php\n$t = new Tv();\n$t-&gt;codigo = 33;\nif ($t instanceof Producto) {\necho $t-&gt;mostrarResumen();\n}\n\n$padre = get_parent_class($t);\necho &quot;&lt;br&gt;La clase padre es: &quot; . $padre;\n$objetoPadre = new $padre;\necho $objetoPadre-&gt;mostrarResumen();\n\nif (is_subclass_of($t, 'Producto')) {\necho &quot;&lt;br&gt;Soy un hijo de Producto&quot;;\n}\n\nPolimorfisme\nPodem crear mètodes en els fills amb el mateix nom que el pare, canviant el seu comportament.\nPer a invocar als mètodes del pare -&gt; parent::nombreMetodo()\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nConstructor en fills\nEn els fills no es crea cap constructor de manera automàtica. Pel que si no n'hi ha, s'invoca automàticament al del pare. En canvi, si el definim en el fill, hem d'invocar al del pare de manera explícita.\n=== &quot;PHP7&quot;\n&lt;?php\nclass Producto {\npublic string $codigo;\n\npublic function __construct(string $codigo) {\n$this-&gt;codigo = $codigo;\n}\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function __construct(string $codigo, int $pulgadas, string $tecnologia) {\nparent::__construct($codigo);\n$this-&gt;pulgadas = $pulgadas;\n$this-&gt;tecnologia = $tecnologia;\n}\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n```\n\n=== &quot;PHP8&quot;\n\n``` php\n&lt;?php\nclass Producto {\npublic function __construct(private string $codigo) { }\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\n\npublic function __construct(\nstring $codigo,\nprivate int $pulgadas,\nprivate string $tecnologia)\n{\nparent::__construct($codigo);\n}\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n```\n\n### Abstracció\n\nLes classes abstractes obliguen a heretar d'una classe, ja que no es permet la seua instanciación. Es defineix mitjançant `abstract class NombreClase {`.\nUna classe abstracta pot contindre propietats i mètodes no-abstractes, i/o mètodes abstractes.\n\n``` php\n&lt;?php\n// Clase abstracta\nabstract class Producto {\nprivate $codigo;\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n// Método abstracto\nabstract public function mostrarResumen();\n}\n\nQuan una classe hereta d'una classe abstracta, obligatòriament ha d'implementar els mètodes que té el pare marcats com a abstractes.\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() { //obligado a implementarlo\necho &quot;&lt;p&gt;Código &quot;.$this-&gt;getCodigo().&quot;&lt;/p&gt;&quot;;\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\n$t = new Tv();\necho $t-&gt;getCodigo();\n\nClasses finals\nSón classes oposades a abstractes, ja que eviten que es puga heretar una classe o mètode per a sobreescriure-ho.\n&lt;?php\nclass Producto {\nprivate $codigo;\n\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n\nfinal public function mostrarResumen() : string {\nreturn &quot;Producto &quot;.$this-&gt;codigo;\n}\n}\n\n// No podremos heredar de Microondas\nfinal class Microondas extends Producto {\nprivate $potencia;\n\npublic function getPotencia() : int {\nreturn $this-&gt;potencia;\n}\n\n// No podemos implementar mostrarResumen()\n}\n\nInterfícies\nPermet definir un contracte amb les signatures dels mètodes a complir. Així doncs, només conté declaracions de funcions i totes han de ser públiques.\nEs declaren amb la paraula clau interface i després les classes que complisquen el contracte el realitzen mitjançant la paraula clau implements.\n&lt;?php\ninterface Nombreable {\n// declaración de funciones\n}\nclass NombreClase implements NombreInterfaz {\n// código de la clase\n\nEs permet l'herència d'interfícies. A més, una classe pot implementar diverses interfícies (en aquest cas, sí que suporta l'herència múltiple, però només d'interfícies).\n&lt;?php\ninterface Mostrable {\npublic function mostrarResumen() : string;\n}\n\ninterface MostrableTodo extends Mostrable {\npublic function mostrarTodo() : string;\n}\n\ninterface Facturable {\npublic function generarFactura() : string;\n}\n\nclass Producto implements MostrableTodo, Facturable {\n// Implementaciones de los métodos\n// Obligatoriamente deberá implementar public function mostrarResumen, mostrarTodo y generarFactura\n}\n\nMètodes encadenats\nSegueix el plantejament de la programació funcional, i també es coneix com method chaining. Planteja que sobre un objecte es realitzen diverses crides.\n&lt;?php\n$p1 = new Libro();\n$p1-&gt;setNombre(&quot;Harry Potter&quot;);\n$p1-&gt;setAutor(&quot;JK Rowling&quot;);\necho $p1;\n\n// Method chaining\n$p2 = new Libro();\n$p2-&gt;setNombre(&quot;Patria&quot;)-&gt;setAutor(&quot;Aramburu&quot;);\necho $p2;\n\nPer a facilitar-ho, modificarem tots els seus mètodes mutants (que modifiquen dades, setters*, ...) perquè retornen una referència a $this:\n&lt;?php\nclass Libro {\nprivate string $nombre;\nprivate string $autor;\n\npublic function getNombre() : string {\nreturn $this-&gt;nombre;\n}\npublic function setNombre(string $nombre) : Libro { \n$this-&gt;nombre = $nombre;\nreturn $this;\n}\n\npublic function getAutor() : string {\nreturn $this-&gt;autor;\n}\npublic function setAutor(string $autor) : Libro {\n$this-&gt;autor = $autor;\nreturn $this;\n}\n\npublic function __toString() : string {\nreturn $this-&gt;nombre.&quot; de &quot;.$this-&gt;autor;\n}\n}\n\nMètodes màgics\nTotes les classes PHP ofereixen un conjunt de mètodes, també coneguts com magic methods que es poden sobreescriure per a substituir el seu comportament. Alguns d'ells ja els hem utilitzats.\nDavant qualsevol dubte, és convenient consultar la documentació oficial.\nEls més destacables són:\n\n__construct()\n__destruct() → s'invoca en perdre la referència. S'utilitza per a tancar una connexió a la BD, tancar un fitxer, ...\n__toString() → representació de l'objecte com a cadena. És a dir, quan fem echo $objecte s'executa automàticament aquest mètode.\n__get(propietat), __set(propietat, valor) → Permetria accedir a les propietat privades, encara que sempre és més llegible/mantenible codificar els getter/setter.\n__isset(propietat), __unset(propietat) → Permet esbrinar o llevar el valor a una propietat.\n__sleep(), __wakeup() → S'executen en recuperar (*unserialize^) o emmagatzemar un objecte que se serialitza (*serialize), i s'utilitzen per a permet definir quines propietats se serialitzen.\n__call(), __callStatic() → S'executen en cridar a un mètode que no és públic. Permeten sobrecarreguen mètodes.",
		"tags": [ "note"]
},

{
		"title": "3. Espai de noms",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/3. Espai de noms/",
		"content": "Des de PHP 5.3 i també coneguts com Namespaces, permeten organitzar les classes/interfícies, funcions i/o constants de manera similar als paquets a Java.\n\n[!tip] &quot;Recomanació&quot;\nUn només namespace per arxiu i crear una estructura de carpetes respectant els nivells/subnivells (igual que es fa a Java)\n\nEs declaren en la primera línia mitjançant la paraula clau namespace seguida del nom de l'espai de noms assignat (cada subnivell se separa amb la barra invertida \\):\nPer exemple, per a col·locar la classe Producte dins del namespace Dwes\\Exemples ho faríem així:\n&lt;?php\nnamespace Dwes\\Exemples;\n\nconst IVA = 0.21;\n\nclass Producte {\npublic $nombre;\n  \npublic function muestra() : void {\necho&quot;&lt;p&gt;Prod:&quot; . $this-&gt;nombre . &quot;&lt;/p&gt;&quot;;\n}\n}\n\nAccés\nPer a referenciar a un recurs que conté un namespace, primer hem de tindre'l disponible fent ús de include o require. Si el recurs està en el mateix namespace, es realitza un accés directe (es coneix com a accés sense qualificar).\nRealment hi ha tres tipus d'accés:\n\nsense qualificar: recurs\nqualificat: rutaRelativa\\recurs → no fa falta posar el namespace complet\ntotalment qualificat: \\rutaAbsoluta\\recurs\n\n&lt;?php\nnamespace Dwes\\Ejemplos;\n\ninclude_once(&quot;Producto.php&quot;);\n\necho IVA; // sin cualificar\necho Utilidades\\IVA; // acceso cualificado. Daría error, no existe \\Dwes\\Ejemplos\\Utilidades\\IVA\necho \\Dwes\\Ejemplos\\IVA; // totalmente cualificado\n\n$p1 = new Producto(); // lo busca en el mismo namespace y encuentra \\Dwes\\Ejemplos\\Producto\n$p2 = new Model\\Producto(); // daría error, no existe el namespace Model. Está buscando \\Dwes\\Ejemplos\\Model\\Producto\n$p3 = new \\Dwes\\Ejemplos\\Producto(); // \\Dwes\\Ejemplos\\Producto\n\nAccés\nPer a evitar la referència qualificada podem declarar l'ús mitjançant use (similar a fer import a Java). Es fa en la capçalera, després del namespace:\nEls tipus Posibles són:\n\nuse const nombreCualificadoConstante\nuse function nombreCualificadoFuncion\nuse nombreCualificadoClase\nuse nombreCualificadoClase as NuevoNombre // per a canviar de nom elements\n\nPer exemple, si volem utilitzar la classe \\Dwes\\Exemples\\Producte des d'un recurs que es troba en l'arrel, per exemple en inici.php, faríem:\n&lt;?php\ninclude_once(&quot;Dwes\\Exemples\\Producte.php&quot;);\n\nuse const Dwes\\Exemples\\IVA;\nuse \\Dwes\\Exemples\\Producte;\n\necho IVA;\n$p1 = new Producte();\n\n[!tip] &quot;To use or not to use&quot;\nEn resum, use permet accedir sense qualificar a recursos que estan en un altre namespace. Si estem en el mateix espai de nom, no necessitem use.\n\nOrganització\nTot projecte, conforme creix, necessita organitzar el seu codi font. Es planteja una organització en la qual els arxius que interactuan amb el navegador es col·loquen en l'arrel, i les classes que definim van dins d'un namespace (i dins de la seua pròpia carpeta src o app).\n\n[!tip] &quot;Organització, includes i usos&quot;\n* Col·locarem cada recurs en un fitxer a part.\n* En la primera línia indicarem la seua namespace (si no està en l'arrel).\n* Si utilitzem altres recursos, farem un include_once d'aqueixos recursos (classes, interfícies, etc...).\n* Cada recurs ha d'incloure tots els altres recursos que referencie: la classe de la qual hereta, interfícies que implementa, classes utilitzades/rebudes com a paràmetres, etc...\n* Si els recursos estan en un espai de noms diferent al que estem, emprarem use amb la ruta completa per a després utilitzar referències sense qualificar.\n\nAutoload\nNo és tediós haver de fer el include de les classes? El autoload ve al rescat.\nAixí doncs, permet carregar les classes (no les constants ni les funcions) que s'utilitzaran i evitar haver de fer el include_once de cadascuna d'elles. Per a això, s'utilitza la funció spl_autoload_register\n&lt;?php\nspl_autoload_register( function( $nombreClase ) {\ninclude_once $nombreClase.'.php';\n} );\n?&gt;\n\n[!question] &quot;Per què es diuen autoload?&quot;\nPerquè abans es realitzava mitjançant el mètode màgic __autoload(), el qual està deprecated des de PHP 7.2\n\nI com organitzem ara el nostre codi aprofitant el autoload?\n\nPer a facilitar la cerca dels recursos a incloure, és recomanable col·locar totes les classes dins d'una mateixa carpeta. Nosaltres la col·locarem dins de app (més endavant, quan estudiem Laravel veurem el motiu d'aquesta decisió). Altres carpetes que podem crear són test per a col·locar les proves PhpUnit que després realitzarem, o la carpeta vendor on s'emmagatzemaran les llibreries del projecte (aquesta carpeta és un estándard dins de PHP, ja que Composer la crea automàticament).\nCom hem col·locat tots els nostres recursos dins de app, ara nostre autoload.php (el qual col·loquem en la carpeta arrel) només buscarà dins d'aqueixa carpeta:\n&lt;?php\nspl_autoload_register( function( $nombreClase ) {\ninclude_once &quot;app/&quot;.$nombreClase.'.php';\n} );\n\n[!tip] &quot;autoload i rutes errònies&quot;\nEn Ubuntu en fer el include de la classe que rep com a paràmetre, les barres dels namespace (\\) són diferents a les de les rutes (/). Per això, és millor que utilitzem el fitxer autoload:\n\n&lt;?php\nspl_autoload_register( function( $nombreClase ) {\n$ruta = &quot;app\\\\&quot;.$nombreClase.'.php';\n$ruta = str_replace(&quot;\\\\&quot;, &quot;/&quot;, $ruta); // Sustituimos las barras\ninclude_once $_SERVER['DOCUMENT_ROOT'].'/'.$ruta;\n} );\n\n```",
		"tags": [ "note"]
},

{
		"title": "4. Separar la lògica de negoci dels aspectes de presentació de l'aplicació",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/4. Separar la lògica de negoci dels aspectes de presentació de l&#39;aplicació/",
		"content": "Lògica de Negoci\n\nRegles i procediments que defineixen el funcionament de l'aplicació.\nInclou processament de dades, càlculs, interaccions amb la base de dades, etc.\n\nAspectes de Presentació\n\nManera en què es mostra la informació a l'usuari.\nInclou la interfície d'usuari, disseny, navegació, etc.\n\nAvantatges\n\nMantenibilitat\n\nFacilita la modificació de la lògica de negoci sense afectar la presentació.\nPermet actualitzar la interfície d'usuari sense modificar la lògica subjacent.\n\nReutilització\n\nLa lògica de negoci pot ser reutilitzada en diferents aplicacions amb interfícies variades.\nEls components de presentació poden ser reutilitzats amb diferents lògiques de negoci.\n\nEscalabilitat\n\nAjuda a escalar l'aplicació separant les preocupacions, permetent millorar una part sense impactar l'altra.\n\nProva i Depuració\n\nFacilita les proves unitàries i la depuració en permetre provar la lògica de negoci per separat de la interfície.\n\nCol·laboració\n\nPermet que desenvolupadors de backend i frontend treballen de manera independent en les seues àrees respectives.",
		"tags": [ "note"]
},

{
		"title": "5. Tecnologies i Mecanismes per a la Separació",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/5. Tecnologies i Mecanismes per a la Separació/",
		"content": "A continuació es presenten diverses tecnologies i mecanismes que faciliten la separació de la lògica de negoci i la presentació en una aplicació web:\nFrameworks PHP:\n\nLaravel: Framework que segueix el patró MVC (Model-View-Controller). Laravel facilita la creació de codi net i ben organitzat, separant clarament la lògica de negoci de la presentació.\nSymfony: Altres frameworks populars que també segueixen el patró MVC i ofereixen eines per a la separació de la lògica i la presentació.\n\nPatró MVC:\n\nModel-View-Controller: Patró de disseny que divideix una aplicació en tres components interconnectats:\n\nModel: Gestiona la lògica de negoci i les dades.\nVista: Gestiona la presentació de la informació.\nControlador: Gestiona la comunicació entre el Model i la Vista.\n\nPlantilles:\n\nBlade (Laravel): Motor de plantilles que permet separar el codi HTML de la lògica de negoci.\nTwig (Symfony): Motor de plantilles similar a Blade, utilitzat per separar la lògica de negoci del codi de presentació.\n\nAPI REST:\nPermet crear serveis web que exposen funcionalitats i dades a través de punts finals d'API, mantenint la lògica de negoci separada de la presentació.\nExemple MVC\n// Model: Product.php\nclass Product {\nprivate string $name;\nprivate float $price;\n\npublic function __construct(string $name, float $price) {\n$this-&gt;name = $name;\n$this-&gt;price = $price;\n}\n\npublic function getName(): string {\nreturn $this-&gt;name;\n}\n\npublic function getPrice(): float {\nreturn $this-&gt;price;\n}\n}\n\n// Controller: ProductController.php\nclass ProductController {\npublic function showProduct() {\n$product = new Product(&quot;Laptop&quot;, 1200.00);\ninclude 'views/productView.php';\n}\n}\n\n// View: productView.php\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Product Information&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Product: &lt;?php echo htmlspecialchars($product-&gt;getName()); ?&gt;&lt;/h1&gt;\n&lt;p&gt;Price: $&lt;?php echo htmlspecialchars($product-&gt;getPrice()); ?&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nLa separació de la lògica de negoci dels aspectes de presentació és crucial per al desenvolupament d'aplicacions web eficients, mantenibles i escalables.",
		"tags": [ "note"]
},

{
		"title": "6. Gestió d'Errors",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/6. Gestió d&#39;Errors/",
		"content": "PHP classifica els errors que ocorren en diferents nivells. Cada nivell s'identifica amb una constant. Per exemple:\n\nE_ERROR: errors fatals, no recuperables. S'interromp el script.\nE_WARNING: advertiments en temps d'execució. El script no s'interromp.\nE_NOTICE: avisos en temps d'execució.\n\nPodeu comprovar el llistat complet de constants de https://www.php.net/manual/es/errorfunc.constants.php\nPer a la configuració dels errors podem fer-ho de dues formes:\n\nA nivell de php.ini:\n\nerror_reporting: indica els nivells d'errors a notificar\n\nerror_reporting = E_ALL &amp; ~E_NOTICE -&gt; Tots els errors menys els avisos en temps d'execució.\n\ndisplay_errors: indica si mostrar o no els errors per pantalla. En entorns de producció és comuna posar-ho a off\nmitjançant codi amb les següents funcions:\n\nerror_reporting(codigo) -&gt; Controla quins errors notificar\nset_error_handler(nombreManejador) -&gt; Indica que funció s'invocarà cada vegada que es trobe un error. El manejador rep com a paràmetres el nivell de l'error i el missatge\n\nA continuació tenim un exemple mitjançant codi:\n=== &quot;Funcions per a la gestió d'errors&quot;\n&lt;?php\nerror_reporting(E_ALL &amp; ~E_NOTICE &amp; ~E_WARNING);\n$resultado = $dividendo / $divisor;\n\nerror_reporting(E_ALL &amp; ~E_NOTICE);\nset_error_handler(&quot;miManejadorErrores&quot;);\n$resultado = $dividendo / $divisor;\nrestore_error_handler(); // vuelve al anterior\n\nfunction miManejadorErrores($nivel, $mensaje) {\nswitch($nivel) {\ncase E_WARNING:\necho &quot;&lt;strong&gt;Warning&lt;/strong&gt;: $mensaje.&lt;br/&gt;&quot;;\nbreak;\ndefault:\necho &quot;Error de tipo no especificado: $mensaje.&lt;br/&gt;&quot;;\n}\n}\n```\n\n=== &quot;Consola&quot;\n\nError de tipo no especificado: Undefined variable: dividendo.\nError de tipo no especificado: Undefined variable: divisor.\nError de tipo Warning: Division by zero.\n\n### Exempcions\n\nLa gestió d'excepcions forma part des de PHP 5. El seu funcionament és similar a Java*, fent ús d'un bloc `try / catch / finally`.\nSi detectem una situació anòmala i volem llançar una excepció, haurem de realitzar `throw new Exception` (adjuntant el missatge que l'ha provocat).\n\n``` php\n&lt;?php\ntry {\nif ($divisor == 0) {\nthrow new Exception(&quot;División por cero.&quot;);\n}\n$resultado = $dividendo / $divisor;\n} catch (Exception $e) {\necho &quot;Se ha producido el siguiente error: &quot;.$e-&gt;getMessage();\n}\n\nLa classe Exception és la classe pare de totes les excepcions. El seu constructor rep missatge[,codigoError][,excepcionPrevia].\nA partir d'un objecte Exception, podem accedir als mètodes getMessage()i getCode() per a obtindre el missatge i el codi d'error de l'excepció capturada.\nEl propi llenguatge ofereix un conjunt d'excepcions ja definides, les quals podem capturar (i llançar des de PHP 7). Es recomana la seua consulta en la documentació oficial.\nCreant exempcions\nPer a crear una excepció, la forma més curta és crear una classe que únicament herete de Exception.\n&lt;?php\nclass HolaExcepcion extends Exception {}\n\nSi volem, i és recomanable depenent dels requisits, podem sobrecarregar els mètodes màgics, per exemple, sobrecarregant el constructor i cridant al constructor del pare, o reescriure el mètode __toString per a canviar el seu missatge:\n&lt;?php\nclass MiExcepcion extends Exception {\n    public function __construct($msj, $codigo = 0, Exception $previa = null) {\n        // código propio\n        parent::__construct($msj, $codigo, $previa);\n    }\n    public function __toString() {\n        return __CLASS__ . &quot;: [{$this-&gt;code}]: {$this-&gt;message}\\n&quot;;\n    }\n    public function miFuncion() {\n        echo &quot;Una función personalizada para este tipo de excepción\\n&quot;;\n    }\n}\n\nSi definim una excepció d'aplicació dins d'un namespace, quan referenciem a Exception, haurem de referenciar-la mitjançant el seu nom totalment qualificat (\\Exception), o utilitzant use:\n=== &quot;Mitjançant nom totalment qualificat&quot;\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\n\nclass AppExcepcion extends \\Exception {}\n```\n=== &quot;Mitjançant `use`&quot;\n``` php\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\n\nuse Exception;\n\nclass AppExcepcion extends Exception {}\n```\n\n##### Exempcions múltiples\n\nEs poden usar excepcions múltiples per a comprovar diferents condicions. A l'hora de capturar-les, es fa de més específica a més general.\n\n``` php\n&lt;?php\n$email = &quot;ejemplo@ejemplo.com&quot;;\ntry {\n    // Comprueba si el email es válido\n    if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE) {\n        throw new MiExcepcion($email);\n    }\n    // Comprueba la palabra ejemplo en la dirección email\n    if(strpos($email, &quot;ejemplo&quot;) !== FALSE) {\n        throw new Exception(&quot;$email es un email de ejemplo no válido&quot;);\n    }\n} catch (MiExcepcion $e) {\n    echo $e-&gt;miFuncion();\n} catch(Exception $e) {\n    echo $e-&gt;getMessage();\n}\n\n[!question] &quot;Autoevaluación&quot;\n¿Qué pasaría al ejectuar el siguiente código?\n\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\n\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException $e) {\n    echo &quot;Capturada MainException &quot; . $e-&gt;getMessage();\n} catch (SubException $e) {\n    echo &quot;Capturada SubException &quot; . $e-&gt;getMessage();\n} catch (Exception $e) {\n    echo &quot;Capturada Exception &quot; . $e-&gt;getMessage();\n}\n```\n\nSi en el mateix `catch` volem capturar diverses excepcions, hem d'utilitzar l'operador `|`:\n\n``` php\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\n\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException | SubException $e ) {\n    echo &quot;Capturada Exception &quot; . $e-&gt;getMessage();\n}\n\nDes de PHP 7, existeix el tipus Throwable, el qual és una interfície que implementen tant els errors com les excepcions, i ens permet capturar els dos tipus alhora:\n&lt;?php\ntry {\n    // tu codigo\n} catch (Throwable $e) {\n    echo 'Forma de capturar errores y excepciones a la vez';\n}\n\nSi només volem capturar els errors fatals, podem fer ús de la classe Error:\n&lt;?php\ntry {\n    // Genera una notificación que no se captura\n    echo $variableNoAsignada;\n    // Error fatal que se captura\n    funcionQueNoExiste();\n} catch (Error $e) {\n    echo &quot;Error capturado: &quot; . $e-&gt;getMessage();\n}\n\nRellançar exempcions\nEn les aplicacions reals, és molt comuna capturar una excepció de sistema i llançar una d'aplicació que hem definit nostros.\nTambé podem llançar les excepcions sense necessitat d'estar dins d'un try/catch.\n&lt;?php\nclass AppException extends Exception {}\n\ntry {\n    // Código de negocio que falla\n} catch (Exception $e) {\n    throw new AppException(&quot;AppException: &quot;.$e-&gt;getMessage(), $e-&gt;getCode(), $e);\n}",
		"tags": [ "note"]
},

{
		"title": "7. Composer",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/7. Composer/",
		"content": "Eina per excel·lència en PHP per a la gestió de llibreries i dependències, de manera que instal·la i les actualitza assegurant que tot l'equip de desenvolupament té el mateix entorn i versions. A més, ofereix autoloading del nostre codi, de manera que no hàgem de fer-lo nosaltres &quot;a mà&quot;.\nEstà escrit en PHP, i podeu consultar tota la seua documentació en https://getcomposer.org/\nUtilitza Packagist com a repositori de llibreries.\nFuncionalment, és similar a Maven (Java) / npm (JS).\nInstal·lació\nSi estem usant XAMPP, hem d'instal·lar Composer en el propi sistema operatiu. Es recomana seguir les instruccions oficials segons el sistema operatiu a emprar.\nEn canvi, si usem Docker, necessitem modificar la configuració del nostre contenidor. En el nostre cas, hem decidit modificar l'arxiu Dockerfile i afegir el següent comando:\nCOPY --from=composer:2.0 /usr/bin/composer /usr/local/bin/composer\n\nÉs important que dins del contenidor comprovem que tenim la v2:\ncomposer -V\n\nPrimers passos\nQuan creem un projecte per primera vegada, hem d'inicialitzar el repositori. Per a això, executarem el comando composer init on:\n\nConfigurem el nom del paquet, descripció, autor (nom &lt;email&gt;), tipus de paquet (project), etc.\nDefinim les dependències del projecte (require) i les de desenvolupament (require-dev) de manera interactiva.\nEn les de desenvolupament s'indica aquelles que no s'instal·laran a l'entorn de producció, per exemple, les llibreries de proves.\n\nDesprés de la seua configuració, es crearà automàticament l'arxiu composer.json amb les dades introduïdes i descàrrega les llibreries en la carpeta vendor. La instal·lació de les llibreries sempre es realitza de manera local per a cada projecte.\n\t{\n&quot;name&quot;: &quot;dwes/log&quot;,\n&quot;description&quot;: &quot;Pruebas con Monolog&quot;,\n&quot;type&quot;: &quot;project&quot;,\n&quot;require&quot;: {\n&quot;monolog/monolog&quot;: &quot;^2.1&quot;\n},\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;authors&quot;: [\n{\n&quot;name&quot;: &quot;Aitor Medrano&quot;,\n&quot;email&quot;: &quot;a.medrano@edu.gva.es&quot;\n}\n]\n}\n\nA l'hora d'indicar cada llibreria introduirem:\n\nel nom de la llibreria, composta tant pel creador o &quot;vendor&quot;, com pel nom del projecte. Exemples: monolog/monolog o laravel/installer.\n\nla versió de cada llibreria. Tenim diverses opcions per a indicar-la:\n\nDirectament: 1.4.2\nAmb comodins: 1.\nA partir de: &gt;= 2.0.3\nSense trencament de canvis:\n{ #1}\n.3.2 // &gt;=1.3.2 &lt;2.0.0\n\nActualitzar llibreries\nPodem definir les dependències via l'arxiu composer.json o mitjançant comandos amb el format composer require vendor/package:version. Per exemple, si volem afegir phpUnit com a llibreria de desenvolupament, farem:\ncomposer require phpunit/phpunit –dev\n\nDesprés d'afegir noves llibreries, hem d'actualitzar el nostre projecte:\ncomposer update\n\nSi creem l'arxiu composer.json nosaltres directament sense inicialitzar el repositori, hem d'instal·lar les dependències:\ncomposer install\n\nEn fer aquest pas (tant instal·lar com actualitzar), com ja hem comentat, es descarreguen les llibreries en dins de la carpeta vendor. És molt important afegir aquesta carpeta a l'arxiu .gitignore per a no pujar-les a GitHub.\nA més es crea l'arxiu composer.lock, que emmagatzema la versió exacta que s'ha instal·lat de cada llibreria (aquest arxiu no es toca).\nautoload.php\nComposer crea de manera automàtica en vendor/autoload.php el codi per a incloure de manera automàtica totes les llibreries que tinguem configurades en composer.json.\nPer a utilitzar-ho, en la capçalera del nostre arxius posarem:\n&lt;?php\nrequire 'vendor/autoload.php';\n\nEn el nostre cas, de moment només el podrem en els arxius on provem les classes\nSi volem que Composer també s'encarregue de carregar de manera automàtica les nostres classes de domini, dins de l'arxiu composer.json, definirem la propietat autoload:\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {&quot;Dwes\\\\&quot;: &quot;app/Dwes&quot;}\n},\n\nPosteriorment, hem de tornar a generar el autoload de Composer mitjançant l'opció dump-autoload (o du):\ncomposer dump-autoload",
		"tags": ["1", "note"]
},

{
		"title": "8. Logger amb Monolog",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/8. Logger amb Monolog/",
		"content": "Provarem Composer afegint la llibreria de Monolog al nostre projecte. Es tracta d'un llibreria per a la gestió de logs de les nostres aplicacions, suportant diferents nivells (info, warning, etc...), eixides (fitxers, sockets, BBDD, Web Services, email, etc) i formats (text pla, HTML, JSON, etc...).\nPer a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require monolog/monolog\n\nMonolog 2 requereix almenys PHP 7.2, compleix amb el estandar de logging PSR-3, i és la llibreria emprada per Laravel i Symfony per a la gestió de logs.\n\n[!info] &quot;Quan utilitzar un log&quot;\n\nSeguir les acciones/moviments dels usuaris\nRegistrar les transaccions\nRastrejar els errors d'usuari\nFallades/avisos a nivell de sistema\nInterpretar i col·leccionar dades per a posterior investigació de patrons\n\nNivells\nA continuació vam mostrar els diferents nivells de menys a més restrictiu:\n\ndebug -100: Informació detallada amb propòsits de debug. No usar en entorns de producció.\ninfo - 200: Esdeveniments interessants com l'inici de sessió d'usuaris.\nnotice - 250: Esdeveniments normals però significatius.\nwarning - 300: Ocurrències excepcionals que no arriben a ser error.\nerror - 400: Errors d'execució que permeten continuar amb l'execució de l'aplicació però que han de ser monitorats.\ncritical - 500: Situacions importants on es generen excepcions no esperades o no hi ha disponible un component.\nalert - 550: S'han de prendre mesures immediatament.\nCaiguda completa de la web, base de dades no disponible, etc... A més, se solen enviar missatges per email.\nemergency - 600: És l'error més greu i indica que tot el sistema està inutilitzable.\n\nHola Monolog\nPer exemple, en l'arxiu pruebaLog.php que col·locaríem en l'arrel, primer incloem el autoload, importem els classes a utilitzar per a finalment usar els mètodes de Monolog:\n&lt;?php\ninclude __DIR__ .&quot;/vendor/autoload.php&quot;;\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger(&quot;MiLogger&quot;);\n$log-&gt;pushHandler(new StreamHandler(&quot;logs/milog.log&quot;, Logger::DEBUG));\n\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;);\n$log-&gt;error(&quot;Esto es un mensaje de ERROR&quot;);\n$log-&gt;critical(&quot;Esto es un mensaje de CRITICAL&quot;);\n$log-&gt;alert(&quot;Esto es un mensaje de ALERT&quot;);\n\nEn tots els mètodes de registre de missatges (debug, info, ...), a més del propi missatge, li podem passar informació com el contingut d'alguna variable, usuari de l'aplicació, etc.. com a segon paràmetre dins d'un array, el qual es coneix com array de contexte.\nÉs convenient fer-ho mitjançant un array associatiu per a facilitar la lectura del log.\n&lt;?php\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [$producto]);\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [&quot;datos&quot; =&gt; $producto]);\n\nFuncionament\nCada instància Logger té un nom de canal i una pila de manejadores (handler).\nCada missatge que manem al log travessa la pila de manejadores, i cadascun decideix si ha de registrar la informació, i si es dona el cas, finalitzar la propagació.\nPer exemple, un StreamHandler en el fons de la pila que ho escriga tot en disc, i en el topall afig un MailHandler que envie un mail només quan hi haja un error.\nManejadors\nCada manejador tambien té un formatejador (Formatter). Si no s'indica cap, se li assigna un per defecte. L'últim manejador inserit serà el primer a executar-se.\nDesprés es van executant conforme a la pila.\nEls manejadores més utilitzats són:\n\nStreamHandler(ruta, nivel)\nRotatingFileHandler(ruta, maxFiles, nivel)\nNativeMailerHandler(para, asunto, desde, nivel)\nFirePHPHandler(nivel)\n\nSi volem que els missatges de l'aplicació isquen pel log del servidor,\nen el nostre cas l'arxiu error.log de Apatxe* utilitzarem com a ruta l'eixida d'error:\n&lt;?php\n// error.log\n$log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Logger::DEBUG));\n\n[!tip] &quot;FirePHP&quot;\nPer exemple, mitjançant FirePHPHandler, podem utilitzar FirePHP, la qual és una eina per a fer debug en la consola de Firefox*.\nDesprés d'instal·lar l'extensió en Firefox, habilitar les opcions i configurar el Handler, podem veure els missatges acolorits amb les seues dades:\n\n&lt;?php\n$log = new Logger(&quot;MiFirePHPLogger&quot;);\n$log-&gt;pushHandler(new FirePHPHandler(Logger::INFO));\n\n$datos = [&quot;real&quot; =&gt; &quot;Bruce Wayne&quot;, &quot;personaje&quot; =&gt; &quot;Batman&quot;];\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;, $datos);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;, $datos);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;, $datos);\n// ...\n\nCanals\nSe'ls assigna en crear el Logger. En grans aplicacions, es crea un canal per cada subsistema: vendes, comptabilitat, magatzem.\nNo és una bona pràctica usar el nom de la classe com a canal, això es fa amb un processador.\nPer al seu ús, és recomane assignar el log a una propietat privada a Logger, i posteriorment, en el constructor de la classe, assignar el canal, manejadors i format.\n&lt;?php\n$this-&gt;log = new Logger(&quot;MiApp&quot;);\n$this-&gt;log-&gt;pushHandler(new StreamHandler(&quot;logs/milog.log&quot;, Logger::DEBUG));\n$this-&gt;log-&gt;pushHandler(new FirePHPHandler(Logger::DEBUG));\n\nI dins dels mètodes per a escriure en el log:\n&lt;?php\n$this-&gt;log-&gt;warning(&quot;Producto no encontrado&quot;, [$producto]);\n\nProcessadors\nEls processadors permeten afegir informació als missatges.\nPer a això, s'apilen després de cada manejador mitjançant el mètode pushProcessor($processador).\nAlguns processadors coneguts són IntrospectionProcessor (mostren la línia, fitxer, classe i metodo des del qual s'invoca el log), WebProcessor (afig la URI, mètode i IP) o GitProcessor (afig la branca i el commit).\n=== &quot;PHP&quot;\n&lt;?php\n$log = new Logger(&quot;MiLogger&quot;);\n$log-&gt;pushHandler(new RotatingFileHandler(&quot;logs/milog.log&quot;, 0, Logger::DEBUG));\n$log-&gt;pushProcessor(new IntrospectionProcessor());\n$log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Logger::WARNING));\n// no usa Introspection pq lo hemos apilado después, le asigno otro\n$log-&gt;pushProcessor(new WebProcessor());\n\n=== &quot;Consola en format text&quot;\n[2020-11-26T13:35:31.076138+01:00] MiLogger.DEBUG: Esto es un mensaje de DEBUG [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:12,&quot;class&quot;:null,&quot;function&quot;:null}\n[2020-11-26T13:35:31.078344+01:00] MiLogger.INFO: Esto es un mensaje de INFO [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:13,&quot;class&quot;:null,&quot;function&quot;:null}\n\nFormatadors\nS'associen als manejadores amb setFormatter. Els formateadores més utilitzats són LineFormatter, HtmlFormatter o JsonFormatter.\n=== &quot;PHP&quot;\n&lt;?php\n$log = new Logger(&quot;MiLogger&quot;);\n$rfh = new RotatingFileHandler(&quot;logs/milog.log&quot;, Logger::DEBUG);\n$rfh-&gt;setFormatter(new JsonFormatter());\n$log-&gt;pushHandler($rfh);\n\n=== &quot;Consola en JSON&quot;\n{&quot;message&quot;:&quot;Esto es un mensaje de DEBUG&quot;,&quot;context&quot;:{},&quot;level&quot;:100,&quot;level_name&quot;:&quot;DEBUG&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747211+01:00&quot;,&quot;extra&quot;:{}}\n{&quot;message&quot;:&quot;Esto es un mensaje de INFO&quot;,&quot;context&quot;:{},&quot;level&quot;:200,&quot;level_name&quot;:&quot;INFO&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747538+01:00&quot;,&quot;extra&quot;:{}}\n\n[!tip] &quot;Més informació&quot;\nMés informació sobre manejadores, formateadores i processadors en https://github.com/Seldaek/monolog/blob/master/doc/02-handlers-formatters-processors.md\n\nÚs de Factories\nEn comptes de instanciar un log en cada classe, és convenient crear una factoria (per exemple, seguint la idea del patró de disseny Factory Method).\nPer al següent exemple, suposarem que creguem la factoria en el namespace Dwes\\Exemples\\Util.\n&lt;?php\nnamespace Dwes\\Ejemplos\\Util\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\nclass LogFactory {\n\npublic static function getLogger(string $canal = &quot;miApp&quot;) : Logger {\n$log = new Logger($canal);\n$log-&gt;pushHandler(new StreamHandler(&quot;logs/miApp.log&quot;, Logger::DEBUG));\n\nreturn $log;\n}\n}\n\nSi en comptes de retornar un Monolog\\Logger utilitzem la interfície de PSR, si en el futur canviem la implementació del log, no haurem de modificar nostre codi. Així doncs, la factoria ara retornarà Psr\\Log\\LoggerInterface:\n&lt;?php\nnamespace Dwes\\Ejemplos\\Util\n\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Psr\\Log\\LoggerInterface;\n\nclass LogFactory {\n\npublic static function getLogger(string $canal = &quot;miApp&quot;) : LoggerInterface {\n$log = new Logger($canal);\n$log-&gt;pushHandler(new StreamHandler(&quot;log/miApp.log&quot;, Logger::DEBUG));\n\nreturn $log;\n}\n}\n\nFinalment, per a utilitzar la factoria, només canviem el codi que teníem en el constructor de les classes que usen el log, quedant alguna cosa asi:\n&lt;?php\n\nnamespace Dwes\\Ejemplos\\Model;\n\nuse Dwes\\Ejemplos\\Util\\LogFactory;\nuse Monolog\\Logger;\n\nclass Cliente {\n\nprivate $codigo;\n\nprivate Logger $log;\n\nfunction __construct($codigo){\n$this-&gt;codigo=$codigo;\n\n$this-&gt;log = LogFactory::getLogger();\n}\n\n/// ... resto del código\n}",
		"tags": [ "note"]
},

{
		"title": "9.  Generació de PDF amb DOMPDF",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/9.  Generació de PDF amb DOMPDF/",
		"content": "Amb PHP podem manejar tot tipus d'arxius com ja hem vist però, què passa si volem generar fitxers PDF amb dades tretes d'una base de dades?\n\nGràcies a una classe escrita en PHP, podem generar arxius PDF sense necessitat d'instal·lar llibreries addicionals en el nostre servidor.\nPerò anem a utilitzar una llibreria que permet transformar codi html en pdf.\nDOMPDF\nAfegirem la llibreria de DOMPDF al nostre projecte. Per a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require dompdf/dompdf\n\nUna vegada que DOMPDF està instal·lat, el procés per generar PDFs des de HTML és bastant directe. Els passos bàsics són:\nPas 1: Incloent DOMPDF\nPrimer, necessitarem incloure DOMPDF en el script PHP. Si estem utilitzant Composer, això es fa automàticament a través de l'auto-càrrega de Composer. Només cal afegir la següent línia al principi del'script:\nrequire 'vendor/autoload.php';\n\nPas 2: Creació d'una Instància de DOMPDF\nA continuació, creem una nova instància de la classe DOMPDF:\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n\nPas 3: Carregar HTML\nDesprés, carregem l'HTML en l'objecte DOMPDF. Això es pot fer directament com una cadena o carregant un fitxer HTML:\n$html = &quot;&lt;html&gt;&lt;body&gt;Hola, això és una prova.&lt;/body&gt;&lt;/html&gt;&quot;;\n$dompdf-&gt;loadHtml($html);\n\nO bé carregar un fitxer HTML:\n$dompdf-&gt;loadHtml(file_get_contents('path/to/your/file.html'));\n\nPas 4: Configuració de la Mida del Paper i l'Orientació\nPodem configurar la mida del paper i l'orientació si és necessari:\n$dompdf-&gt;setPaper('A4', 'portrait'); // o 'landscape'\n\nPas 5: Renderització del PDF\nAra, demanem a DOMPDF que renderitze el PDF:\n$dompdf-&gt;render();\n\nPas 6: Eixida del PDF\nFinalment, podem enviar el PDF al navegador, guardar-lo en un fitxer o fer amb ell el que necessitem:\nPer mostrar-lo al navegador:\n$dompdf-&gt;stream(&quot;document.pdf&quot;, array(&quot;Attachment&quot; =&gt; false));\n\nPer desar-lo en un fitxer:\n$output = $dompdf-&gt;output();\nfile_put_contents('path/to/save/document.pdf', $output);\n\nConsells Addicionals\nCal assegurar-se que l'HTML és vàlid i ben format. DOMPDF intenta ser tolerant amb l'HTML, però l'HTML mal format pot causar problemes.\nEl CSS que s'utilitze pot afectar significativament com es veu el PDF. DOMPDF suporta una bona part de CSS 2.1, però no tot.\nSi necessitem incloure imatges, cal assegurar-se que les rutes són absolutes i accessibles des del servidor on s'executa DOMPDF.\nAquesta és una guia bàsica per començar amb DOMPDF. Per a casos d'ús més avançats i opcions de configuració, cal consultar la documentació oficial de DOMPDF.",
		"tags": [ "note"]
},

{
		"title": "Exercicis proposats",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/Exercicis proposats/",
		"content": "Exercici 1. Creació de la Classe Bàsica i Gestió de Propietats\n\nCrea una classe Persona amb les propietats privades nom, cognoms, i edat. Encapsula aquestes propietats mitjançant getters i setters. Afig els següents mètodes:\n- getNomComplet(): string – Retorna el nom complet de la persona.\n- estaJubilat(): bool – Retorna true si l'edat és major o igual a 65, false en cas contrari.\n\nModifica la classe Persona afegint un constructor que assigna nom i cognoms. Si es proporciona un tercer paràmetre, assigna l'edat; en cas contrari, assigna una edat per defecte de 25 anys.\n\nModifica la classe Persona per utilitzar una constant LIMITE_EDAT amb el valor de 66 anys i utilitza-la en el mètode estaJubilat.\n\nExercici 2. Herència i Polimorfisme\n\nCrea una classe Empleado que herete de Persona. Afig les següents propietats i mètodes:\n\nprivate float $sou\nprivate array $telefons\nanyadirTelefono(int $telefon): void – Afig un número de telèfon a l'array.\nlistarTelefonos(): string – Retorna els números de telèfon separats per comes.\nvaciarTelefonos(): void – Buida l'array de telèfons.\ndebePagarImpuestos(): bool – Retorna true si el sou és superior a 3333€, false en cas contrari.\n\nAfig un mètode estàtic toHtml(Empleado $emp): string que genere un codi HTML que mostre el nom complet de l'empleat dins d'un paràgraf i els seus telèfons dins d'una llista ordenada.\n\nAfig un mètode estàtic toHtml(Persona $p) a la classe Persona que mostre el nom complet de la persona dins d'un paràgraf. Modifica el mètode toHtml de Empleado per rebre una Persona com a paràmetre i comprovar si es tracta d'un Empleado amb instanceof.\n\nTransforma Persona en una classe abstracta. Redefineix el mètode estàtic toHtml(Persona $p) en totes les seues subclasses. Afig una classe Worker que siga també abstracta i que emmagatzeme els telefonos. Crea mètodes per calcular el sou en Empleado i Gerent, segons la descripció.\n\nExercici 3. Integració d'Espais de Noms, Autoloading, i Composer\n\nCrea una classe Empresa que incloga una propietat amb un array de Workers, ja siguen Employees o Managers. Implementa:\n\npublic function addWorker(Worker $t)\npublic function listWorkersHtml(): string – Genera la llista de treballadors en format HTML.\npublic function getCosteNominas(): float – Calcula el cost total de les nòmines.\n\nConfigura un projecte PHP amb Composer que utilitze l'autoloading PSR-4. Afig un fitxer composer.json i defineix l'estructura de directoris src/Models, src/Services, etc. Crea una classe Producte dins de src/Models i verifica que l'autoloading funcione correctament instanciant la classe en un fitxer separat.\n\nExercici 4. Logger i Documentació\n\nUtilitza la llibreria Monolog per configurar un logger que escriga missatges a un fitxer app.log. Afig funcionalitat perquè el logger registre missatges d'informació i d'error en diferents arxius segons la gravetat.\n\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error i advertència.\n\nDocumenta la classe Producte creada en exercicis anteriors utilitzant comentaris PHPDoc. Inclou la descripció de la classe, les propietats, i els mètodes. Utilitza una eina com phpDocumentor per generar documentació automàtica.\n\nEscriu proves unitàries per als mètodes de les classes Persona, Empleado, i Empresa utilitzant PHPUnit. Prova els mètodes getNomComplet, estaJubilat, addWorker, i getCosteNominas. Assegura't que les proves cobreixen diferents escenaris, incloent errors potencials.\n\nEscriu una prova unitària que comprove que el logger està registrant correctament els missatges d'error a l'arxiu corresponent. Utilitza un mock per assegurar-te que el logger funciona sense necessitat d'escriure en un fitxer real durant la prova.\n\nExercici 5. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\n\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nUtilitzant la classe Empresa i Empleado, genera un informe en PDF amb la llista de treballadors i el seu sou. Utilitza DomPDF per generar aquest informe.\n\nExercici 6. Serialització i JSON\n\nCrea una interfície JSerializable que incloga els mètodes:\n\ntoJSON(): string – Converteix l'objecte a un JSON utilitzant json_encode().\ntoSerialize(): string – Serialitza l'objecte utilitzant serialize().\n\nModifica les classes Persona, Empleado, i Empresa per implementar aquesta interfície. Assegura't que les propietats privades es puguen serialitzar correctament.\n\nEscriu mètodes per deserialitzar un objecte a partir d'una cadena JSON o d'una cadena serialitzada. Prova aquests mètodes amb PHPUnit per assegurar-te que la deserialització funciona correctament.\n\nExercici 7. Separació del Model de Negoci i la Presentació (MVC)\nFins ara, has creat diverses classes que gestionen la lògica del joc i les dades (models), com Persona, Empleado, i Empresa, i has generat sortides HTML i PDFs amb DomPDF. Ara és el moment de refactoritzar la teua aplicació per assegurar una separació clara entre la lògica del negoci i la presentació, seguint el patró Model-Vista-Controlador (MVC).\n\nCrear el Model:\n\nRefactoritza les classes Persona, Empleado, i Empresa per assegurar que només gestionen la lògica de negoci (per exemple, càlcul de nòmines, gestió d'empleats, etc.).\nAssegura't que aquestes classes no contenen codi relacionat amb la presentació (HTML o PDF).\n\nCrear les Vistes:\n\nCrea vistes separades per presentar la informació als usuaris:\n\nUna vista HTML per mostrar la informació de Empleado i Empresa com a llistats.\nUna vista PDF per generar informes amb DomPDF, basant-se en les dades proporcionades pel model.\n\nCrear el Controlador:\n\nImplementa un controlador que reba les sol·licituds dels usuaris, interactue amb el model (Persona, Empleado, Empresa), i tria la vista adequada per mostrar els resultats (HTML o PDF).\nEl controlador ha d'encapsular tota la lògica necessària per a gestionar la interacció entre la vista i el model, assegurant que el model no estiga lligat a la capa de presentació.\n\nExercici 8. Creació de Proves Unitàries per al Patró MVC\nDesprés de refactoritzar l'aplicació per separar la lògica del negoci de la presentació seguint el patró Model-Vista-Controlador (MVC), és fonamental assegurar-se que tots els components funcionen correctament i que la interacció entre ells es realitza tal com s'espera. Per això, has de crear una sèrie de proves unitàries utilitzant PHPUnit per verificar el funcionament del model, les vistes i els controladors.\n\nProves del Model:\n\nEscriu proves unitàries per verificar el funcionament dels mètodes de les classes Persona, Empleado, i Empresa.\nAssegura't que els mètodes funcionen correctament, com ara:\n\ngetNomComplet()\ndebePagarImpuestos()\naddWorker() i getCosteNominas()\n\nProva que els càlculs es realitzen correctament i que les dades es gestionen segons el que s'espera.\n\nProves del Controlador:\n\nEscriu proves unitàries per assegurar-te que els controladors interactuen correctament amb els models i que seleccionen la vista adequada per a cada situació.\nProva que les dades es passen correctament del model a la vista a través del controlador.\nImplementa proves per verificar que el controlador respon correctament a diferents sol·licituds de l'usuari, per exemple:\n\nMostrar una llista d'empleats en HTML.\nGenerar un informe en PDF utilitzant DomPDF.\n\nProves de les Vistes:\n\nEscriu proves unitàries per comprovar que les vistes reben i mostren correctament la informació proporcionada pel controlador.\nProva que la generació de contingut HTML o PDF es realitza correctament a partir de les dades proporcionades pel model.",
		"tags": [ "note"]
},

{
		"title": "phpoo",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/4. Programacion Orientada a Objetos PHP/phpoo/",
		"content": "Desenvolupament d'Aplicacions Web: POO, Separació de Lògica i Presentació, Gestió d'Errors i Proves\n\n[!abstract] &quot;Duració i criteris d'avaluació&quot;\nDuració estimada: 20 hores\n\n| Resultat d'aprenentatge | Criteris d'avaluació |\n| -------- | -------- |\n| 5. Desenvolupa aplicacions Web identificant i aplicant mecanismes per a separar el codi de presentació de la lògica de negoci.| a) S'han identificat els avantatges de separar la lògica de negoci dels aspectes de presentació de l'aplicació. b) S'han analitzat tecnologies i mecanismes que permeten realitzar aquesta separació i les seues característiques principals. c) S'han utilitzat objectes i controls en el servidor per a generar l'aspecte visual de l'aplicació Web en el client. d) S’han utilitzat formularis generats de forma dinàmica per a respondre als esdeveniments de l'aplicació Web. e) S'han identificat i aplicat els paràmetres relatius a la configuració de l'aplicació Web. f) S'han escrit aplicacions Web amb manteniment d'estat i separació de la lògica de negoci. g) S'han aplicat els principis de la programació orientada a objectes. g) S'ha provat i documentat el codi. |\n\n1. Concepte de classes i Objectes\nPHP segueix un paradigma de programació orientada a objectes (POO) basada en classes.\nUn classe és un plantilla que defineix les propietats i mètodes per a poder crear objectes. D'aquest manera, un objecte és una instància d'una classe.\nTant les propietats com els mètodes es defineixen amb una visibilitat (qui pot accedir)\n\nPrivat - private: Només pot accedir la pròpia classe.\nProtegit - protected: Només pot accedir la pròpia classe o els seus descendents.\nPúblico - public: Pot accedir qualsevol altra classe.\n\nPer a declarar una classe, s'utilitza la paraula clau class seguit del nom de la classe. Per a instanciar un objecte a partir de la classe, s'utilitza new:\n&lt;?php\nclass NomClase {\n// propiedades\n// y métodos\n}\n\n$ob = new NomClase();\n\n!!! important &quot;Classes amb majúscula&quot;\nTotes les classes comencen per lletra majúscula.\nQuan un projecte creix, és normal modelar les classes mitjançant UML (recordeu Entorns de Desenvolupament?). La classes es representen mitjançant un quadrat, separant el nom, de les propietats i els mètodes:\n![UML](/img/user/01 Apuntes/PHP Teoria Batoi/imagenes/03/uml.png)\nUna vegada que hem creat un objecte, s'utilitza l'operador -&gt; per a accedir a una propietat o un mètode:\n$objeto-&gt;propiedad;\n$objeto-&gt;método(parámetros);\n\nSi des de dins de la classe, volem accedir a una propietat o mètode de la mateixa classe, utilitzarem la referència $this;\n$this-&gt;propiedad;\n$this-&gt;método(parámetros);\n\nAixí doncs, com a exemple, codificaríem una persona en el fitxer Persona.php com:\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function setNombre(string $nom) {\n$this-&gt;nombre=$nom;\n}\n\npublic function imprimir(){\necho $this-&gt;nombre;\necho '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(); // creamos un objeto\n$bruno-&gt;setNombre(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nEncara que es poden declarar diverses classes en el mateix arxiu, és una mala pràctica. Així doncs, cada fitxer contedrá una sola classe, i es nomenarà amb el nom de la classe.\n2. Principis de la POO\nEncapsulació\nLes propietats es defineixen privades o protegides (si volem que les classes heretades puguen accedir).\nPer a cada propietat, s'afigen mètodes públics (getter/setter):\npublic setPropiedad(tipo $param)\npublic getPropiedad() : tipo\n\nLes constants es defineixen públiques perquè siguen accessibles per tots els recursos.\n&lt;?php\nclass MayorMenor {\nprivate int $mayor;\nprivate int $menor;\n\npublic function setMayor(int $may) {\n$this-&gt;mayor = $may;\n}\n\npublic function setMenor(int $men) {\n$this-&gt;menor = $men;\n}\n\npublic function getMayor() : int {\nreturn $this-&gt;mayor;\n}\n\npublic function getMenor() : int {\nreturn $this-&gt;menor;\n}\n}\n\nRebent i enviant objectes\nÉs recomanable indicar-ho en la mena de paràmetres. Si l'objecte pot retornar nuls es posa ? davant del nom de la classe.\n!!! important &quot;Objectes per referència&quot;\nEls objectes que s'envien i reben com a paràmetres sempre es passen per referència.\n&lt;?php\nfunction maymen(array $numeros) : ?MayorMenor {\n$a = max($numeros);\n$b = min($numeros);\n\n$result = new MayorMenor();\n$result-&gt;setMayor($a);\n$result-&gt;setMenor($b);\n\nreturn $result;\n}\n\n$resultado =  maymen([1,76,9,388,41,39,25,97,22]);\necho &quot;&lt;br&gt;Mayor: &quot;.$resultado-&gt;getMayor();\necho &quot;&lt;br&gt;Menor: &quot;.$resultado-&gt;getMenor();\n\nConstructor\nEl constructor dels objectes es defineix mitjançant el mètode màgic __construct.\nPot o no tindre paràmetres, però només pot haver-hi un únic constructor.\n&lt;?php\nclass Persona {\nprivate string $nombre;\n\npublic function __construct(string $nom) {\n$this-&gt;nombre = $nom;\n}\n\npublic function imprimir(){\n  echo $this-&gt;nombre;\n  echo '&lt;br&gt;';\n}\n}\n\n$bruno = new Persona(&quot;Bruno Díaz&quot;);\n$bruno-&gt;imprimir();\n\nConstructors en PHP 8\nUna de les grans novetats que ofereix PHP 8 és la simplificació dels constructors amb paràmetres, la qual cosa es coneix com a promoció de les propietats del constructor*.\nPer a això, en comptes d'haver de declarar les propietats com a privades o protegides, i després dins del constructor haver d'assignar els paràmetres a estàs propietats, el propi constructor promociona les propietats.\nVegem-ho millor amb un exemple. Imaginem una classe Punt on vulguem emmagatzemar les seues coordenades:\n&lt;?php\nclass Punto {\nprotected float $x;\nprotected float $y;\nprotected float $z;\n\npublic function __construct(\nfloat $x = 0.0,\nfloat $y = 0.0,\nfloat $z = 0.0\n) {\n$this-&gt;x = $x;\n$this-&gt;y = $y;\n$this-&gt;z = $z;\n}\n}\n\nEn PHP 8, quedaria de la següent manera (molt més curt, la qual cosa facilita la seua llegibilitat):\n&lt;?php\nclass Punto {\npublic function __construct(\nprotected float $x = 0.0,\nprotected float $y = 0.0,\nprotected float $z = 0.0,\n) {}\n}\n\n!!! info &quot;L'ordre importa&quot;\nA l'hora de codificar l'ordre dels elements ha de ser:\n``` php\n&lt;?php\ndeclare(strict_types=1);\nclass NombreClase {\n// propiedades\n// constructor\n// getters - setters\n// resto de métodos\n}\n?&gt;\n```\nClasses estàtiques\nSón aquelles que tenen propietats i/o mètodes estàtics (també es coneixen com de classe, perquè el seu valor es comparteix entre totes les instàncies de la mateixa classe).\nEs declaren amb static i es referencien amb ::.\n\nSi volem accedir a un mètode estàtic, s'anteposa el nom de la classe: Producte::nuevoProducto().\nSi des d'un mètode volem accedir a una propietat estàtica de la mateixa classe, s'utilitza la referència self: self::$numProductos\n\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0;\n\npublic static function nuevoProducto() {\nself::$numProductos++;\n}\n}\n\nProducto::nuevoProducto();\n$impuesto = Producto::IVA;\n\nTambé podem tindre classes normals que tinguen alguna propietat estàtica:\n&lt;?php\nclass Producto {\nconst IVA = 0.23;\nprivate static $numProductos = 0; \nprivate $codigo;\n\npublic function __construct(string $cod) {\nself::$numProductos++;\n$this-&gt;codigo = $cod;\n}\n\npublic function mostrarResumen() : string {\nreturn &quot;El producto &quot;.$this-&gt;codigo.&quot; es el número &quot;.self::$numProductos;\n}\n}\n\n$prod1 = new Producto(&quot;PS5&quot;);\n$prod2 = new Producto(&quot;XBOX Series X&quot;);\n$prod3 = new Producto(&quot;Nintendo Switch&quot;);\necho $prod3-&gt;mostrarResumen();\n\nIntrospecció\nEn treballar amb classes i objectes, existeixen un conjunt de funcions ja definides pel llenguatge que permeten obtindre informació sobre els objectes:\n\ninstanceof: permet comprovar si un objecte és d'una determinada classe\nget_class: retorna el nom de la classe\nget_declared_class: retorna un array amb els noms de les classes definides\nclass_àlies: crea un àlies\nclass_exists / method_exists / property_exists: true si la classe / mètode / propietat està definida\nget_class_methods / get_class_vars / get_object_vars: Retorna un array amb els noms dels mètodes / propietats d'una classe / propietats d'un objecte que són accessibles des d'on es fa la crida.\n\nUn exemple d'aquestes funcions pot ser el següent:\n&lt;?php\n$p = new Producto(&quot;PS5&quot;);\nif ($p instanceof Producto) {\necho &quot;Es un producto&quot;;\necho &quot;La clase es &quot;.get_class($p);\n\nclass_alias(&quot;Producto&quot;, &quot;Articulo&quot;);\n$c = new Articulo(&quot;Nintendo Switch&quot;);\necho &quot;Un articulo es un &quot;.get_class($c);\n\nprint_r(get_class_methods(&quot;Producto&quot;));\nprint_r(get_class_vars(&quot;Producto&quot;));\nprint_r(get_object_vars($p));\n\nif (method_exists($p, &quot;mostrarResumen&quot;)) {\n$p-&gt;mostrarResumen();\n}\n}\n\n!!! caution &quot;Clonat&quot;\nEn assignar dos objectes no es copien, es crea una nova referència. Si volem una còpia, cal clonar-ho mitjançant el mètode clone(object) : object\nSi volem modificar el clonat per defecte, cal definir el mètode màgic __clone() que es dirà després de copiar totes les propietats.\nMés informació en https://www.php.net/manual/es/language.oop5.cloning.php\nHerència\nPHP suporta herència simple, de manera que una classe només pot heretar d'una altra, no de dues classes alhora. Per a això s'utilitza la paraula clau extends. Si volem que la classe A hereta de la classe B farem:\nclass A extends B\n\nEl fill hereta els atributs i mètodes públics i protegits.\n!!! warning &quot;Cada classe en un arxiu&quot;\nCom ja hem comentat, hauríem de col·locar cada classe en un arxiu diferent per a posteriorment utilitzar-lo mitjançant include. En els següent exemple els hem col·locats junt per a facilitar la seua llegibilitat.\nPer exemple, tenim una classe Producte i una Tv que hereta de Producte:\n&lt;?php\nclass Producto {\npublic $codigo;\npublic $nombre;\npublic $nombreCorto;\npublic $PVP;\n\npublic function mostrarResumen() {\necho &quot;&lt;p&gt;Prod:&quot;.$this-&gt;codigo.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n}\n\nPodemos utilizar las siguientes funciones para averiguar si hay relación entre dos clases:\n\nget_parent_class(object): string\nis_subclass_of(object, string): bool\n\n&lt;?php\n$t = new Tv();\n$t-&gt;codigo = 33;\nif ($t instanceof Producto) {\necho $t-&gt;mostrarResumen();\n}\n\n$padre = get_parent_class($t);\necho &quot;&lt;br&gt;La clase padre es: &quot; . $padre;\n$objetoPadre = new $padre;\necho $objetoPadre-&gt;mostrarResumen();\n\nif (is_subclass_of($t, 'Producto')) {\necho &quot;&lt;br&gt;Soy un hijo de Producto&quot;;\n}\n\nPolimorfisme\nPodem crear mètodes en els fills amb el mateix nom que el pare, canviant el seu comportament.\nPer a invocar als mètodes del pare -&gt; parent::nombreMetodo()\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\nConstructor en fills\nEn els fills no es crea cap constructor de manera automàtica. Pel que si no n'hi ha, s'invoca automàticament al del pare. En canvi, si el definim en el fill, hem d'invocar al del pare de manera explícita.\n=== &quot;PHP7&quot;\n``` php\n&lt;?php\nclass Producto {\npublic string $codigo;\npublic function __construct(string $codigo) {\nthis−&gt;codigo=codigo;\n}\npublic function mostrarResumen() {\necho &quot;Prod:&quot;.$this-&gt;codigo.&quot;&quot;;\n}\n}\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\npublic function __construct(string codigo,intpulgadas, string Missing open brace for subscripttecnologia) { parent::__construct(tecnologia) { parent::__construct(codigo);\nthis−&gt;pulgadas=pulgadas;\nthis−&gt;tecnologia=tecnologia;\n}\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;TV &quot;.this−&gt;tecnologia.\"de\".this-&gt;pulgadas.&quot;&quot;;\n}\n}\n```\n=== &quot;PHP8&quot;\n``` php\n&lt;?php\nclass Producto {\npublic function __construct(private string $codigo)\npublic function mostrarResumen() {\necho &quot;Prod:&quot;.$this-&gt;codigo.&quot;&quot;;\n}\n}\nclass Tv extends Producto {\npublic function __construct(\nstring codigo,privateintpulgadas,\nprivate string Missing open brace for subscripttecnologia) { parent::__construct(tecnologia) { parent::__construct(codigo);\n}\npublic function mostrarResumen() {\nparent::mostrarResumen();\necho &quot;TV &quot;.this−&gt;tecnologia.\"de\".this-&gt;pulgadas.&quot;&quot;;\n}\n}\n```\nAbstracció\nLes classes abstractes obliguen a heretar d'una classe, ja que no es permet la seua instanciación. Es defineix mitjançant abstract class NombreClase {.\nUna classe abstracta pot contindre propietats i mètodes no-abstractes, i/o mètodes abstractes.\n&lt;?php\n// Clase abstracta\nabstract class Producto {\nprivate $codigo;\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n// Método abstracto\nabstract public function mostrarResumen();\n}\n\nQuan una classe hereta d'una classe abstracta, obligatòriament ha d'implementar els mètodes que té el pare marcats com a abstractes.\n&lt;?php\nclass Tv extends Producto {\npublic $pulgadas;\npublic $tecnologia;\n\npublic function mostrarResumen() { //obligado a implementarlo\necho &quot;&lt;p&gt;Código &quot;.$this-&gt;getCodigo().&quot;&lt;/p&gt;&quot;;\necho &quot;&lt;p&gt;TV &quot;.$this-&gt;tecnologia.&quot; de &quot;.$this-&gt;pulgadas.&quot;&lt;/p&gt;&quot;;\n}\n}\n\n$t = new Tv();\necho $t-&gt;getCodigo();\n\nClasses finals\nSón classes oposades a abstractes, ja que eviten que es puga heretar una classe o mètode per a sobreescriure-ho.\n&lt;?php\nclass Producto {\nprivate $codigo;\n\npublic function getCodigo() : string {\nreturn $this-&gt;codigo;\n}\n\nfinal public function mostrarResumen() : string {\nreturn &quot;Producto &quot;.$this-&gt;codigo;\n}\n}\n\n// No podremos heredar de Microondas\nfinal class Microondas extends Producto {\nprivate $potencia;\n\npublic function getPotencia() : int {\nreturn $this-&gt;potencia;\n}\n\n// No podemos implementar mostrarResumen()\n}\n\nInterfícies\nPermet definir un contracte amb les signatures dels mètodes a complir. Així doncs, només conté declaracions de funcions i totes han de ser públiques.\nEs declaren amb la paraula clau interface i després les classes que complisquen el contracte el realitzen mitjançant la paraula clau implements.\n&lt;?php\ninterface Nombreable {\n// declaración de funciones\n}\nclass NombreClase implements NombreInterfaz {\n// código de la clase\n\nEs permet l'herència d'interfícies. A més, una classe pot implementar diverses interfícies (en aquest cas, sí que suporta l'herència múltiple, però només d'interfícies).\n&lt;?php\ninterface Mostrable {\npublic function mostrarResumen() : string;\n}\n\ninterface MostrableTodo extends Mostrable {\npublic function mostrarTodo() : string;\n}\n\ninterface Facturable {\npublic function generarFactura() : string;\n}\n\nclass Producto implements MostrableTodo, Facturable {\n// Implementaciones de los métodos\n// Obligatoriamente deberá implementar public function mostrarResumen, mostrarTodo y generarFactura\n}\n\nMètodes encadenats\nSegueix el plantejament de la programació funcional, i també es coneix com method chaining. Planteja que sobre un objecte es realitzen diverses crides.\n&lt;?php\n$p1 = new Libro();\n$p1-&gt;setNombre(&quot;Harry Potter&quot;);\n$p1-&gt;setAutor(&quot;JK Rowling&quot;);\necho $p1;\n\n// Method chaining\n$p2 = new Libro();\n$p2-&gt;setNombre(&quot;Patria&quot;)-&gt;setAutor(&quot;Aramburu&quot;);\necho $p2;\n\nPer a facilitar-ho, modificarem tots els seus mètodes mutants (que modifiquen dades, setters*, ...) perquè retornen una referència a $this:\n&lt;?php\nclass Libro {\nprivate string $nombre;\nprivate string $autor;\n\npublic function getNombre() : string {\nreturn $this-&gt;nombre;\n}\npublic function setNombre(string $nombre) : Libro { \n$this-&gt;nombre = $nombre;\nreturn $this;\n}\n\npublic function getAutor() : string {\nreturn $this-&gt;autor;\n}\npublic function setAutor(string $autor) : Libro {\n$this-&gt;autor = $autor;\nreturn $this;\n}\n\npublic function __toString() : string {\nreturn $this-&gt;nombre.&quot; de &quot;.$this-&gt;autor;\n}\n}\n\nMètodes màgics\nTotes les classes PHP ofereixen un conjunt de mètodes, també coneguts com magic methods que es poden sobreescriure per a substituir el seu comportament. Alguns d'ells ja els hem utilitzats.\nDavant qualsevol dubte, és convenient consultar la documentació oficial.\nEls més destacables són:\n\n__construct()\n__destruct() → s'invoca en perdre la referència. S'utilitza per a tancar una connexió a la BD, tancar un fitxer, ...\n__toString() → representació de l'objecte com a cadena. És a dir, quan fem echo $objecte s'executa automàticament aquest mètode.\n__get(propietat), __set(propietat, valor) → Permetria accedir a les propietat privades, encara que sempre és més llegible/mantenible codificar els getter/setter.\n__isset(propietat), __unset(propietat) → Permet esbrinar o llevar el valor a una propietat.\n__sleep(), __wakeup() → S'executen en recuperar (*unserialize^) o emmagatzemar un objecte que se serialitza (*serialize), i s'utilitzen per a permet definir quines propietats se serialitzen.\n__call(), __callStatic() → S'executen en cridar a un mètode que no és públic. Permeten sobrecarreguen mètodes.\n\n3. Espai de noms\nDes de PHP 5.3 i també coneguts com Namespaces, permeten organitzar les classes/interfícies, funcions i/o constants de manera similar als paquets a Java.\n!!! tip &quot;Recomanació&quot;\nUn només namespace per arxiu i crear una estructura de carpetes respectant els nivells/subnivells (igual que es fa a Java)\nEs declaren en la primera línia mitjançant la paraula clau namespace seguida del nom de l'espai de noms assignat (cada subnivell se separa amb la barra invertida \\):\nPer exemple, per a col·locar la classe Producte dins del namespace Dwes\\Exemples ho faríem així:\n&lt;?php\nnamespace Dwes\\Exemples;\n\nconst IVA = 0.21;\n\nclass Producte {\npublic $nombre;\n  \npublic function muestra() : void {\necho&quot;&lt;p&gt;Prod:&quot; . $this-&gt;nombre . &quot;&lt;/p&gt;&quot;;\n}\n}\n\nAccés\nPer a referenciar a un recurs que conté un namespace, primer hem de tindre'l disponible fent ús de include o require. Si el recurs està en el mateix namespace, es realitza un accés directe (es coneix com a accés sense qualificar).\nRealment hi ha tres tipus d'accés:\n\nsense qualificar: recurs\nqualificat: rutaRelativa\\recurs → no fa falta posar el namespace complet\ntotalment qualificat: \\rutaAbsoluta\\recurs\n\n&lt;?php\nnamespace Dwes\\Ejemplos;\n\ninclude_once(&quot;Producto.php&quot;);\n\necho IVA; // sin cualificar\necho Utilidades\\IVA; // acceso cualificado. Daría error, no existe \\Dwes\\Ejemplos\\Utilidades\\IVA\necho \\Dwes\\Ejemplos\\IVA; // totalmente cualificado\n\n$p1 = new Producto(); // lo busca en el mismo namespace y encuentra \\Dwes\\Ejemplos\\Producto\n$p2 = new Model\\Producto(); // daría error, no existe el namespace Model. Está buscando \\Dwes\\Ejemplos\\Model\\Producto\n$p3 = new \\Dwes\\Ejemplos\\Producto(); // \\Dwes\\Ejemplos\\Producto\n\nAccés\nPer a evitar la referència qualificada podem declarar l'ús mitjançant use (similar a fer import a Java). Es fa en la capçalera, després del namespace:\nEls tipus Posibles són:\n\nuse const nombreCualificadoConstante\nuse function nombreCualificadoFuncion\nuse nombreCualificadoClase\nuse nombreCualificadoClase as NuevoNombre // per a canviar de nom elements\n\nPer exemple, si volem utilitzar la classe \\Dwes\\Exemples\\Producte des d'un recurs que es troba en l'arrel, per exemple en inici.php, faríem:\n&lt;?php\ninclude_once(&quot;Dwes\\Exemples\\Producte.php&quot;);\n\nuse const Dwes\\Exemples\\IVA;\nuse \\Dwes\\Exemples\\Producte;\n\necho IVA;\n$p1 = new Producte();\n\n!!! tip &quot;To use or not to use&quot;\nEn resum, use permet accedir sense qualificar a recursos que estan en un altre namespace. Si estem en el mateix espai de nom, no necessitem use.\nOrganització\nTot projecte, conforme creix, necessita organitzar el seu codi font. Es planteja una organització en la qual els arxius que interactuan amb el navegador es col·loquen en l'arrel, i les classes que definim van dins d'un namespace (i dins de la seua pròpia carpeta src o app).\n\nOrganització del codi font\n\n!!! tip &quot;Organització, includes i usos&quot;\n* Col·locarem cada recurs en un fitxer a part.\n* En la primera línia indicarem la seua namespace (si no està en l'arrel).\n* Si utilitzem altres recursos, farem un include_once d'aqueixos recursos (classes, interfícies, etc...).\n* Cada recurs ha d'incloure tots els altres recursos que referencie: la classe de la qual hereta, interfícies que implementa, classes utilitzades/rebudes com a paràmetres, etc...\n* Si els recursos estan en un espai de noms diferent al que estem, emprarem use amb la ruta completa per a després utilitzar referències sense qualificar.\nAutoload\nNo és tediós haver de fer el include de les classes? El autoload ve al rescat.\nAixí doncs, permet carregar les classes (no les constants ni les funcions) que s'utilitzaran i evitar haver de fer el include_once de cadascuna d'elles. Per a això, es pot utilitzar el composer.\n4. Composer\n\nLogo Composer\n\nEina per excel·lència en PHP per a la gestió de llibreries i dependències, de manera que instal·la i les actualitza assegurant que tot l'equip de desenvolupament té el mateix entorn i versions. A més, ofereix autoloading del nostre codi, de manera que no hàgem de fer-lo nosaltres &quot;a mà&quot;.\nEstà escrit en PHP, i podeu consultar tota la seua documentació en https://getcomposer.org/.\nUtilitza Packagist com a repositori de llibreries.\nFuncionalment, és similar a Maven (Java) / npm (JS).\nInstal·lació\nSi estem usant XAMPP, hem d'instal·lar Composer en el propi sistema operatiu. Es recomana seguir les instruccions oficials segons el sistema operatiu a emprar.\nEn canvi, si usem Docker, necessitem modificar la configuració del nostre contenidor. En el nostre cas, hem decidit modificar l'arxiu Dockerfile i afegir el següent comando:\nCOPY --from=composer:2.0 /usr/bin/composer /usr/local/bin/composer\n\nÉs important que dins del contenidor comprovem que tenim la v2:\ncomposer -V\n\nPrimers passos\nQuan creem un projecte per primera vegada, hem d'inicialitzar el repositori. Per a això, executarem el comando composer init on:\n\nConfigurem el nom del paquet, descripció, autor (nom ), tipus de paquet (project), etc...\nDefinim les dependències del projecte (require) i les de desenvolupament (require-dev) de manera interactiva.\nEn les de desenvolupament s'indica aquelles que no s'instal·laran a l'entorn de producció, per exemple, les llibreries de proves.\n\nDesprés de la seua configuració, es crearà automàticament l'arxiu composer.json amb les dades introduïdes i descàrrega les llibreries en la carpeta vendor. La instal·lació de les llibreries sempre es realitza de manera local per a cada projecte.\n{\n&quot;name&quot;: &quot;dwes/log&quot;,\n&quot;description&quot;: &quot;Pruebas con Monolog&quot;,\n&quot;type&quot;: &quot;project&quot;,\n&quot;require&quot;: {\n&quot;monolog/monolog&quot;: &quot;^2.1&quot;\n},\n&quot;license&quot;: &quot;MIT&quot;,\n&quot;authors&quot;: [\n{\n&quot;name&quot;: &quot;Aitor Medrano&quot;,\n&quot;email&quot;: &quot;a.medrano@edu.gva.es&quot;\n}\n]\n}\n\nA l'hora d'indicar cada llibreria introduirem:\n\nel nom de la llibreria, composta tant pel creador o &quot;vendor&quot;, com pel nom del projecte. Exemples: monolog/monolog o laravel/installer.\n\nla versió de cada llibreria. Tenim diverses opcions per a indicar-la:\n\nDirectament: 1.4.2\nAmb comodins: 1.\nA partir de: &gt;= 2.0.3\nSense trencament de canvis:\n{ #1}\n.3.2 // &gt;=1.3.2 &lt;2.0.0\n\nActualitzar llibreries\nPodem definir les dependències via l'arxiu composer.json o mitjançant comandos amb el format composer require vendor/package:version. Per exemple, si volem afegir phpUnit com a llibreria de desenvolupament, farem:\ncomposer require phpunit/phpunit –dev\n\nDesprés d'afegir noves llibreries, hem d'actualitzar el nostre projecte:\ncomposer update\n\nSi creem l'arxiu composer.json nosaltres directament sense inicialitzar el repositori, hem d'instal·lar les dependències:\ncomposer install\n\nEn fer aquest pas (tant instal·lar com actualitzar), com ja hem comentat, es descarreguen les llibreries en dins de la carpeta vendor. És molt important afegir aquesta carpeta a l'arxiu .gitignore per a no pujar-les a GitHub.\nA més es crea l'arxiu composer.lock, que emmagatzema la versió exacta que s'ha instal·lat de cada llibreria (aquest arxiu no es toca).\nautoload.php\nComposer crea de manera automàtica en vendor/autoload.php el codi per a incloure de manera automàtica totes les llibreries que tinguem configurades en composer.json.\nPer a utilitzar-ho, en la capçalera del nostre arxius posarem:\n&lt;?php\nrequire 'vendor/autoload.php';\n\nEn el nostre cas, de moment només el podrem en els arxius on provem les classes\nSi volem que Composer també s'encarregue de carregar de manera automàtica les nostres classes de domini, dins de l'arxiu composer.json, definirem la propietat autoload:\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {&quot;Dwes\\\\&quot;: &quot;app/Dwes&quot;}\n},\n\nPosteriorment, hem de tornar a generar el autoload de Composer mitjançant l'opció dump-autoload (o du):\ncomposer dump-autoload\n\n5. Logger amb Monolog\nProvarem Composer afegint la llibreria de Monolog al nostre projecte. Es tracta d'un llibreria per a la gestió de logs de les nostres aplicacions, suportant diferents nivells (info, warning, etc...), eixides (fitxers, sockets, BBDD, Web Services, email, etc) i formats (text pla, HTML, JSON, etc...).\nPer a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require monolog/monolog\n\nMonolog 2 requereix almenys PHP 7.2, compleix amb el estandar de logging PSR-3, i és la llibreria emprada per Laravel i Symfony per a la gestió de logs.\n!!! info &quot;Quan utilitzar un log&quot;\n* Seguir les acciones/moviments dels usuaris\n* Registrar les transaccions\n* Rastrejar els errors d'usuari\n* Fallades/avisos a nivell de sistema\n* Interpretar i col·leccionar dades per a posterior investigació de patrons\nNivells\nA continuació vam mostrar els diferents nivells de menys a més restrictiu:\n* debug -100: Informació detallada amb propòsits de debug. No usar en entorns de producció.\n* info - 200: Esdeveniments interessants com l'inici de sessió d'usuaris.\n* notice - 250: Esdeveniments normals però significatius.\n* warning - 300: Ocurrències excepcionals que no arriben a ser error.\n* error - 400: Errors d'execució que permeten continuar amb l'execució de l'aplicació però que han de ser monitorats.\n* critical - 500: Situacions importants on es generen excepcions no esperades o no hi ha disponible un component.\n* alert - 550: S'han de prendre mesures immediatament.\nCaiguda completa de la web, base de dades no disponible, etc... A més, se solen enviar missatges per email.\n* emergency - 600: És l'error més greu i indica que tot el sistema està inutilitzable.\nHola Monolog\nPer exemple, en l'arxiu pruebaLog.php que col·locaríem en l'arrel, primer incloem el autoload, importem els classes a utilitzar per a finalment usar els mètodes de Monolog:\n&lt;?php\ninclude __DIR__ .&quot;/vendor/autoload.php&quot;;\n\nuse Monolog\\Level;\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger(&quot;MiLogger&quot;);\n$log-&gt;pushHandler(new StreamHandler(&quot;logs/milog.log&quot;, Level::Debug));\n\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;);\n$log-&gt;error(&quot;Esto es un mensaje de ERROR&quot;);\n$log-&gt;critical(&quot;Esto es un mensaje de CRITICAL&quot;);\n$log-&gt;alert(&quot;Esto es un mensaje de ALERT&quot;);\n\nEn tots els mètodes de registre de missatges (debug, info, ...), a més del propi missatge, li podem passar informació com el contingut d'alguna variable, usuari de l'aplicació, etc.. com a segon paràmetre dins d'un array, el qual es coneix com array de contexte.\nÉs convenient fer-ho mitjançant un array associatiu per a facilitar la lectura del log.\n&lt;?php\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [$producto]);\n$log-&gt;warning(&quot;Producto no encontrado&quot;, [&quot;datos&quot; =&gt; $producto]);\n\nFuncionament\nCada instància Logger té un nom de canal i una pila de manejadores (handler).\nCada missatge que manem al log travessa la pila de manejadores, i cadascun decideix si ha de registrar la informació, i si es dona el cas, finalitzar la propagació.\nPer exemple, un StreamHandler en el fons de la pila que ho escriga tot en disc, i en el topall afig un MailHandler que envie un mail només quan hi haja un error.\nEls manejadores més utilitzats són:\n\nStreamHandler(ruta, nivel)\nRotatingFileHandler(ruta, maxFiles, nivel)\nNativeMailerHandler(para, asunto, desde, nivel)\nFirePHPHandler(nivel)\n\nPer exemple: Si volem que els missatges de l'aplicació isquen pel log del servidor,\nen el nostre cas l'arxiu error.log de Apatxe utilitzarem com a ruta l'eixida d'error:\n&lt;?php\n// error.log\n$log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Level::Debug));\n\n!!! tip &quot;FirePHP&quot;\nPer exemple, mitjançant FirePHPHandler, podem utilitzar FirePHP, la qual és una eina per a fer debug en la consola de Firefox*.\nDesprés d'instal·lar l'extensió en Firefox, habilitar les opcions i configurar el Handler, podem veure els missatges acolorits amb les seues dades:\n``` php\n&lt;?php\n$log = new Logger(&quot;MiFirePHPLogger&quot;);\n$log-&gt;pushHandler(new FirePHPHandler(Level::INFO));\n$datos = [&quot;real&quot; =&gt; &quot;Bruce Wayne&quot;, &quot;personaje&quot; =&gt; &quot;Batman&quot;];\n$log-&gt;debug(&quot;Esto es un mensaje de DEBUG&quot;, $datos);\n$log-&gt;info(&quot;Esto es un mensaje de INFO&quot;, $datos);\n$log-&gt;warning(&quot;Esto es un mensaje de WARNING&quot;, $datos);\n// ...\n```\n\nEjemplo de uso de FirePHP\n\nManejadors\nSi no s'indica cap, se li assigna un per defecte. L'últim manejador inserit serà el primer a executar-se.\nDesprés es van executant conforme a la pila.\nProcessadors\nEls processadors permeten afegir informació als missatges.\nPer a això, s'apilen després de cada manejador mitjançant el mètode pushProcessor($processador).\nAlguns processadors coneguts són IntrospectionProcessor (mostren la línia, fitxer, classe i metodo des del qual s'invoca el log), WebProcessor (afig la URI, mètode i IP) o GitProcessor (afig la branca i el commit).\n=== &quot;PHP&quot;\nphp &lt;?php $log = new Logger(&quot;MiLogger&quot;); $log-&gt;pushHandler(new RotatingFileHandler(&quot;logs/milog.log&quot;, 0, Level::DEBUG)); $log-&gt;pushProcessor(new IntrospectionProcessor()); $log-&gt;pushHandler(new StreamHandler(&quot;php://stderr&quot;, Level::WARNING)); // no usa Introspection pq lo hemos apilado después, le asigno otro $log-&gt;pushProcessor(new WebProcessor());\n=== &quot;Consola en format text&quot;\nlog [2020-11-26T13:35:31.076138+01:00] MiLogger.DEBUG: Esto es un mensaje de DEBUG [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:12,&quot;class&quot;:null,&quot;function&quot;:null} [2020-11-26T13:35:31.078344+01:00] MiLogger.INFO: Esto es un mensaje de INFO [] {&quot;file&quot;:&quot;C:\\\\xampp\\\\htdocs\\\\log\\\\procesador.php&quot;,&quot;line&quot;:13,&quot;class&quot;:null,&quot;function&quot;:null}\nFormatadors\nS'associen als manejadores amb setFormatter. Els formateadores més utilitzats són LineFormatter, HtmlFormatter o JsonFormatter.\n=== &quot;PHP&quot;\nphp &lt;?php $log = new Logger(&quot;MiLogger&quot;); $rfh = new RotatingFileHandler(&quot;logs/milog.log&quot;, Level::Debug); $rfh-&gt;setFormatter(new JsonFormatter()); $log-&gt;pushHandler($rfh);\n=== &quot;Consola en JSON&quot;\njson {&quot;message&quot;:&quot;Esto es un mensaje de DEBUG&quot;,&quot;context&quot;:{},&quot;level&quot;:100,&quot;level_name&quot;:&quot;DEBUG&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747211+01:00&quot;,&quot;extra&quot;:{}} {&quot;message&quot;:&quot;Esto es un mensaje de INFO&quot;,&quot;context&quot;:{},&quot;level&quot;:200,&quot;level_name&quot;:&quot;INFO&quot;,&quot;channel&quot;:&quot;MiLogger&quot;,&quot;datetime&quot;:&quot;2020-11-27T15:36:52.747538+01:00&quot;,&quot;extra&quot;:{}}\n!!! tip &quot;Més informació&quot;\nMés informació sobre manejadores, formateadores i processadors en https://github.com/Seldaek/monolog/blob/master/doc/02-handlers-formatters-processors.md\n6. Generació de PDF amb DOMPDF\nAmb PHP podem manejar tot tipus d'arxius com ja hem vist però, què passa si volem generar fitxers PDF amb dades tretes d'una base de dades?\n\nGràcies a una classe escrita en PHP, podem generar arxius PDF sense necessitat d'instal·lar llibreries addicionals en el nostre servidor.\nPerò anem a utilitzar una llibreria que permet transformar codi html en pdf.\nDOMPDF\nAfegirem la llibreria de DOMPDF al nostre projecte. Per a això, inclourem la llibreria en el nostre projecte amb:\ncomposer require dompdf/dompdf\n\nUna vegada que DOMPDF està instal·lat, el procés per generar PDFs des de HTML és bastant directe. Els passos bàsics són:\nPas 1: Incloent DOMPDF\nPrimer, necessitarem incloure DOMPDF en el script PHP. Si estem utilitzant Composer, això es fa automàticament a través de l'auto-càrrega de Composer. Només cal afegir la següent línia al principi del'script:\nrequire 'vendor/autoload.php';\n\nPas 2: Creació d'una Instància de DOMPDF\nA continuació, creem una nova instància de la classe DOMPDF:\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n\nPas 3: Carregar HTML\nDesprés, carregem l'HTML en l'objecte DOMPDF. Això es pot fer directament com una cadena o carregant un fitxer HTML:\n$html = &quot;&lt;html&gt;&lt;body&gt;Hola, això és una prova.&lt;/body&gt;&lt;/html&gt;&quot;;\n$dompdf-&gt;loadHtml($html);\n\nO bé carregar un fitxer HTML:\n$dompdf-&gt;loadHtml(file_get_contents('path/to/your/file.html'));\n\nPas 4: Configuració de la Mida del Paper i l'Orientació\nPodem configurar la mida del paper i l'orientació si és necessari:\n$dompdf-&gt;setPaper('A4', 'portrait'); // o 'landscape'\n\nPas 5: Renderització del PDF\nAra, demanem a DOMPDF que renderitze el PDF:\n$dompdf-&gt;render();\n\nPas 6: Eixida del PDF\nFinalment, podem enviar el PDF al navegador, guardar-lo en un fitxer o fer amb ell el que necessitem:\nPer mostrar-lo al navegador:\n$dompdf-&gt;stream(&quot;document.pdf&quot;, array(&quot;Attachment&quot; =&gt; false));\n\nPer desar-lo en un fitxer:\n$output = $dompdf-&gt;output();\nfile_put_contents('path/to/save/document.pdf', $output);\n\nConsells Addicionals\nCal assegurar-se que l'HTML és vàlid i ben format. DOMPDF intenta ser tolerant amb l'HTML, però l'HTML mal format pot causar problemes.\nEl CSS que s'utilitze pot afectar significativament com es veu el PDF. DOMPDF suporta una bona part de CSS 2.1, però no tot.\nSi necessitem incloure imatges, cal assegurar-se que les rutes són absolutes i accessibles des del servidor on s'executa DOMPDF.\nAquesta és una guia bàsica per començar amb DOMPDF. Per a casos d'ús més avançats i opcions de configuració, cal consultar la documentació oficial de DOMPDF.\n7. Documentación con phpDocumentor\nphpDocumentor és l'eina per a documentar el codi PHP. És similar en propòsit i funcionament a Javadoc.\nAixí doncs, és un eina que facilita la documentació del codi PHP, creant un lloc web amb l'API de l'aplicació.\nEs basa en l'ús d'anotacions sobre els docblocks. Per a posar-ho en marxa, en el nostre cas ens decantarem per utilitzar la imatge que ja existeix de Docker.\nInstal·lació\nPas 1: Instal·lació amb Docker\nPrimer, cal assegurar-se tenir Docker instal·lat i funcionant al sistema. Després, s'ha de descarregar i executar el contenidor de phpDocumentor utilitzant la següent comanda:\ndocker pull phpdoc/phpdoc\n\nPas 2: Generació de Documentació\nUn cop tinguem la imatge, podem utilitzar-la per generar la documentació. El procés bàsic implica muntar els fitxers de codi dins del contenidor Docker i executar phpDocumentor sobre aquests fitxers.\nAcí hi ha un exemple de com fer-ho:\nEn el cas d'usar Docker, usarem el següent comando per a executar-lo (crea el contenidor, executa el comando que li demanem, i automàticament l'esborra):\ndocker run --rm -v $(pwd):/data phpdoc/phpdoc:latest run -d /data/src -t /data/src/docs\n\nAquesta comanda fa el següent:\n* -rm: Això elimina el contenidor després d'executar-lo, així no es queden contenidors inactius.\n* -v (pwd):/data:Muntaeldirectoriactualdelteusistema((pwd)) al directori /data dins del contenidor. Hauràs de reemplaçar $(pwd) amb el camí on està el teu codi font si no estàs executant aquesta comanda des del directori del teu projecte.\n* -d /data/src: Especifica el directori dins del contenidor on es troba el teu codi font. Reemplaça /data/src amb el camí corresponent dins del contenidor si és diferent.\n* -t /data/src/docs: Especifica on vols que es generi la documentació dins del contenidor. En aquest cas, es generarà dins de /data/docs.\nPas 3: Accés a la Documentació Generada\nUna vegada generada, la documentació estarà dins del directori que especificat (en aquest cas, docs dins del directori docs de projecte). Pots obrir els fitxers HTML amb qualsevol navegador per veure la documentació.\nDocBlock\nUn docblock és el bloc de codi que es col·loca damunt d'un recurs. El seu format és:\n&lt;?php\n/**\n* Sumari*, una sola línia\n\n* Descripció* que pot utilitzar diverses línies\n* i que ofereix detalls de l'element o referències\n* per a ampliar la informació\n\n* @param string $miArgumento amb una descripció* de l'argument\n* que pot usar diverses línies.\n\n* @return void\n*/\nfunction miFuncion(tipo $miArgumento)\n{\n}\n\n!!! tip &quot;Visual Studio Code&quot;\nPer tal que us ajude a documentar podeu utilitzar l'extensió PHP DocBlocker.\nDocumentant el codi\nEn tots els elements, ademas del sumari i/o descripció, posarem:\n\nEn les classes:\n\n@author nom\n@package ruta del namespace\n\nEn les propietats:\n\n@var tipus descripció\n\nEn els mètodes:\n\n@param tipus $nomene descripció\n@throws ClaseException descripció\n@return tipus descripció\n\nVegem-ho amb un exemple. Suposem que tenim una classe que representa un client:\n&lt;?php\n/**\n* Classe que representa un client\n*\n* El client s'encarrega d'emmagatzemar els suports que té llogat,\n* de manera que podem llogar i retornar productes mitjançant les operacions\n* homònimes.\n*\n* @package Dwes\\Videoclub\\Model\n* @author Aitor Medrano &lt;a.medrano@edu.gva.es&gt;\n*/\nclass Cliente {\n\npublic string $nombre;\nprivate string $numero;\n\n/**\n* Colecció de soports alquilats\n* @var array&lt;Soporte&gt;\n*/\nprivate $soportesAlquilados[];\n\n/*\n* Comprova si el suport rebut ja el té llogat el client\n* @param Suport $suporte Suport a comprovar\n* @return bool true si ho té llogat\n/\npublic function tieneAlquilado(Soporte $soporte) : bool {\n// ...\n}\n\nSi generem la documentació i obrim amb un navegador l'arxiu docs/api/index.html podrem navegar fins a la classe `Client:\n\nphpDocumentor de Cliente\n\n8. Separar la lògica de negoci dels aspectes de presentació de l'aplicació\nLògica de Negoci\n\nRegles i procediments que defineixen el funcionament de l'aplicació.\nInclou processament de dades, càlculs, interaccions amb la base de dades, etc.\n\nAspectes de Presentació\n\nManera en què es mostra la informació a l'usuari.\nInclou la interfície d'usuari, disseny, navegació, etc.\n\nAvantatges\n\nMantenibilitat\n\nFacilita la modificació de la lògica de negoci sense afectar la presentació.\nPermet actualitzar la interfície d'usuari sense modificar la lògica subjacent.\n\nReutilització\n\nLa lògica de negoci pot ser reutilitzada en diferents aplicacions amb interfícies variades.\nEls components de presentació poden ser reutilitzats amb diferents lògiques de negoci.\n\nEscalabilitat\n\nAjuda a escalar l'aplicació separant les preocupacions, permetent millorar una part sense impactar l'altra.\n\nProva i Depuració\n\nFacilita les proves unitàries i la depuració en permetre provar la lògica de negoci per separat de la interfície.\n\nCol·laboració\n\nPermet que desenvolupadors de backend i frontend treballen de manera independent en les seues àrees respectives.\n\nTecnologies i Mecanismes per a la Separació\nA continuació es presenten diverses tecnologies i mecanismes que faciliten la separació de la lògica de negoci i la presentació en una aplicació web:\nFrameworks PHP:\nLaravel: Framework que segueix el patró MVC (Model-View-Controller). Laravel facilita la creació de codi net i ben organitzat, separant clarament la lògica de negoci de la presentació.\nSymfony: Altres frameworks populars que també segueixen el patró MVC i ofereixen eines per a la separació de la lògica i la presentació.\nPatró MVC:\nModel-View-Controller: Patró de disseny que divideix una aplicació en tres components interconnectats:\nModel: Gestiona la lògica de negoci i les dades.\nVista: Gestiona la presentació de la informació.\nControlador: Gestiona la comunicació entre el Model i la Vista.\nPlantilles:\nBlade (Laravel): Motor de plantilles que permet separar el codi HTML de la lògica de negoci.\nTwig (Symfony): Motor de plantilles similar a Blade, utilitzat per separar la lògica de negoci del codi de presentació.\nAPI REST:\nPermet crear serveis web que exposen funcionalitats i dades a través de punts finals d'API, mantenint la lògica de negoci separada de la presentació.\nExemple MVC\n// Model: Product.php\nclass Product {\nprivate string $name;\nprivate float $price;\n\npublic function __construct(string $name, float $price) {\n$this-&gt;name = $name;\n$this-&gt;price = $price;\n}\n\npublic function getName(): string {\nreturn $this-&gt;name;\n}\n\npublic function getPrice(): float {\nreturn $this-&gt;price;\n}\n}\n\n// Controller: ProductController.php\nclass ProductController {\npublic function showProduct() {\n$product = new Product(&quot;Laptop&quot;, 1200.00);\ninclude 'views/productView.php';\n}\n}\n\n// View: productView.php\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Product Information&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Product: &lt;?php echo htmlspecialchars($product-&gt;getName()); ?&gt;&lt;/h1&gt;\n&lt;p&gt;Price: $&lt;?php echo htmlspecialchars($product-&gt;getPrice()); ?&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nLa separació de la lògica de negoci dels aspectes de presentació és crucial per al desenvolupament d'aplicacions web eficients, mantenibles i escalables.\n9. Gestió d'Exempcions\nLa gestió d'excepcions forma part des de PHP 5. El seu funcionament és similar a Java*, fent ús d'un bloc try / catch / finally.\nSi detectem una situació anòmala i volem llançar una excepció, haurem de realitzar throw new Exception (adjuntant el missatge que l'ha provocat).\n&lt;?php\ntry {\nif ($divisor == 0) {\nthrow new Exception(&quot;División por cero.&quot;);\n}\n$resultado = $dividendo / $divisor;\n} catch (Exception $e) {\necho &quot;Se ha producido el siguiente error: &quot;.$e-&gt;getMessage();\n}\n\nLa classe Exception és la classe pare de totes les excepcions. El seu constructor rep missatge[,codigoError][,excepcionPrevia].\nA partir d'un objecte Exception, podem accedir als mètodes getMessage()i getCode() per a obtindre el missatge i el codi d'error de l'excepció capturada.\nEl propi llenguatge ofereix un conjunt d'excepcions ja definides, les quals podem capturar (i llançar des de PHP 7). Es recomana la seua consulta en la documentació oficial.\nCreant exempcions\nPer a crear una excepció, la forma més curta és crear una classe que únicament herete de Exception.\n&lt;?php\nclass HolaExcepcion extends Exception {}\n\nSi volem, i és recomanable depenent dels requisits, podem sobrecarregar els mètodes màgics, per exemple, sobrecarregant el constructor i cridant al constructor del pare, o reescriure el mètode __toString per a canviar el seu missatge:\n&lt;?php\nclass MiExcepcion extends Exception {\n    public function __construct($msj, $codigo = 0, Exception $previa = null) {\n        // código propio\n        parent::__construct($msj, $codigo, $previa);\n    }\n    public function __toString() {\n        return __CLASS__ . &quot;: [{$this-&gt;code}]: {$this-&gt;message}\\n&quot;;\n    }\n    public function miFuncion() {\n        echo &quot;Una función personalizada para este tipo de excepción\\n&quot;;\n    }\n}\n\nSi definim una excepció d'aplicació dins d'un namespace, quan referenciem a Exception, haurem de referenciar-la mitjançant el seu nom totalment qualificat (\\Exception), o utilitzant use:\n=== &quot;Mitjançant nom totalment qualificat&quot;\n``` php\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\nclass AppExcepcion extends \\Exception {}\n=== &quot;Mitjançant `use`&quot; php\n&lt;?php\nnamespace \\Dwes\\Ejemplos;\nuse Exception;\nclass AppExcepcion extends Exception {}\n```\nExempcions múltiples\nEs poden usar excepcions múltiples per a comprovar diferents condicions. A l'hora de capturar-les, es fa de més específica a més general.\n&lt;?php\n$email = &quot;ejemplo@ejemplo.com&quot;;\ntry {\n    // Comprueba si el email es válido\n    if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE) {\n        throw new MiExcepcion($email);\n    }\n    // Comprueba la palabra ejemplo en la dirección email\n    if(strpos($email, &quot;ejemplo&quot;) !== FALSE) {\n        throw new Exception(&quot;$email es un email de ejemplo no válido&quot;);\n    }\n} catch (MiExcepcion $e) {\n    echo $e-&gt;miFuncion();\n} catch(Exception $e) {\n    echo $e-&gt;getMessage();\n}\n\n!!! question &quot;Autoevaluación&quot;\n¿Qué pasaría al ejectuar el siguiente código?\n``` php\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException Extra open brace or missing close bracee) {     echo \"Capturada MainException \" . e) {     echo \"Capturada MainException \" . e-&gt;getMessage();\n} catch (SubException Extra open brace or missing close bracee) {     echo \"Capturada SubException \" . e) {     echo \"Capturada SubException \" . e-&gt;getMessage();\n} catch (Exception Extra open brace or missing close bracee) {     echo \"Capturada Exception \" . e) {     echo \"Capturada Exception \" . e-&gt;getMessage();\n}\n```\nSi en el mateix catch volem capturar diverses excepcions, hem d'utilitzar l'operador |:\n&lt;?php\nclass MainException extends Exception {}\nclass SubException extends MainException {}\n\ntry {\n    throw new SubException(&quot;Lanzada SubException&quot;);\n} catch (MainException | SubException $e ) {\n    echo &quot;Capturada Exception &quot; . $e-&gt;getMessage();\n}\n\nDes de PHP 7, existeix el tipus Throwable, el qual és una interfície que implementen tant els errors com les excepcions, i ens permet capturar els dos tipus alhora:\n&lt;?php\ntry {\n    // tu codigo\n} catch (Throwable $e) {\n    echo 'Forma de capturar errores y excepciones a la vez';\n}\n\nSi només volem capturar els errors fatals, podem fer ús de la classe Error:\n&lt;?php\ntry {\n    // Genera una notificación que no se captura\n    echo $variableNoAsignada;\n    // Error fatal que se captura\n    funcionQueNoExiste();\n} catch (Error $e) {\n    echo &quot;Error capturado: &quot; . $e-&gt;getMessage();\n}\n\nRellançar exempcions\nEn les aplicacions reals, és molt comuna capturar una excepció de sistema i llançar una d'aplicació que hem definit nostros.\nTambé podem llançar les excepcions sense necessitat d'estar dins d'un try/catch.\n&lt;?php\nclass AppException extends Exception {}\n\ntry {\n    // Código de negocio que falla\n} catch (Exception $e) {\n    throw new AppException(&quot;AppException: &quot;.$e-&gt;getMessage(), $e-&gt;getCode(), $e);\n}\n\n10. Proves amb PHPUNIT\nEl curs passat, dins del mòdul de Entorns de Desenvolupament, estudiarieu la importància de la realització de proves, així com les proves unitàries mitjançant JUnit.\n\nTest Driven Development\n\nHui dia és de gran importància seguir una bona metodologia de proves, sent el desenvolupament dirigit per les proves (Test Driven Development / TDD) un dels enfocaments més emprats, el qual consisteix en:\n\nEscriure el test, i com no hi ha codi implementat, la prova falle (roig).\nEscriure el codi d'aplicació perquè la prova funcione (verda).\nrefactoritzar el codi de l'aplicació amb l'ajuda de la prova per a comprovar que no trenquem res (refactor).\n\nEn el cas de PHP, l'eina que s'utilitza és PHPUnit (https://phpunit.de/), que com el seu nom indica, està basada en JUnit. La versió actual és la 11.\nIntroducció a PHPUnit\nPHPUnit és un framework de proves popular per a PHP que suporta tant proves unitàries com proves d'integració. És àmpliament utilitzat en la comunitat PHP per la seua simplicitat i eficàcia. Les proves unitàries es centren en provar components o mètodes individuals, mentre que les proves d'integració asseguren que les diferents parts del sistema funcionen conjuntament com s'espera.\nInstal·lació\nPer començar a utilitzar PHPUnit, cal instal·lar-lo. La manera recomanada és a través de Composer. Executa la següent comanda en el terminal:\ncomposer require --dev phpunit/phpunit\n\nAquesta comanda afegirà PHPUnit com a dependència de desenvolupament en el teu projecte.\n!!! tip &quot;Llibreries de desenvolupament&quot;\nLes llibreries que es col·loquen en require-dev són les de desenvolupament i testing, de manera que no s'instal·laran en un entorn de producció.\nUna vegada instal·lat, podem configurar PHPUnit creant un fitxer phpunit.xml en l'arrel del projecte per especificar la configuració de les proves:\n&lt;phpunit bootstrap=&quot;vendor/autoload.php&quot;&gt;\n&lt;testsuites&gt;\n&lt;testsuite name=&quot;Application Test Suite&quot;&gt;\n&lt;directory&gt;tests&lt;/directory&gt;\n&lt;/testsuite&gt;\n&lt;/testsuites&gt;\n&lt;/phpunit&gt;\n\nEstructura d’un test\nEls tests en PHPUnit són classes PHP que hereten de PHPUnit\\Framework\\TestCase. Cada mètode dins d'aquestes classes que comence amb test serà executat com una prova.\nuse PHPUnit\\Framework\\TestCase;\nuse App\\Models\\Empleado;\n\nclass EmpleadoTest extends TestCase {\nprivate $empleado;\n\nprotected function setUp(): void {\n$this-&gt;empleado = new Empleado('John', 'Doe', 4000, 30);\n}\n\npublic function testGetSou() {\n$this-&gt;assertEquals(4000, $this-&gt;empleado-&gt;getSou());\n}\n\npublic function testSetSou() {\n$this-&gt;empleado-&gt;setSou(4500);\n$this-&gt;assertEquals(4500, $this-&gt;empleado-&gt;getSou());\n}\n\npublic function testGetTelefonos() {\n$this-&gt;assertIsArray($this-&gt;empleado-&gt;getTelefonos());\n$this-&gt;assertEmpty($this-&gt;empleado-&gt;getTelefonos());\n}\n\npublic function testSetTelefono() {\n$this-&gt;empleado-&gt;setTelefono('123456789');\n$this-&gt;assertCount(1, $this-&gt;empleado-&gt;getTelefonos());\n$this-&gt;assertEquals('123456789', $this-&gt;empleado-&gt;getTelefonos()[0]);\n}\n\npublic function testListarTelefonos() {\n$this-&gt;empleado-&gt;setTelefono('123456789');\n$this-&gt;empleado-&gt;setTelefono('987654321');\n$this-&gt;assertEquals('123456789, 987654321', $this-&gt;empleado-&gt;listarTelefonos());\n}\n\npublic function testVaciarTelefonos() {\n$this-&gt;empleado-&gt;setTelefono('123456789');\n$this-&gt;empleado-&gt;vaciarTelefonos();\n$this-&gt;assertEmpty($this-&gt;empleado-&gt;getTelefonos());\n}\n\npublic function testDebePagarImpuestos() {\n$this-&gt;assertTrue($this-&gt;empleado-&gt;debePagarImpuestos());\n$this-&gt;empleado-&gt;setSou(3000);\n$this-&gt;assertFalse($this-&gt;empleado-&gt;debePagarImpuestos());\n}\n}\n\nExecució de Proves\nPer executar les proves, podem utilitzar la següent comanda:\nvendor/bin/phpunit\nAquesta comanda cercarà els arxius de prova en el directori especificat (per defecte tests) i executarà totes les proves.\nTipus de proves\nAmb PHPUnit, podem realitzar diversos tipus de proves, entre elles:\n\nProves Unitàries : Verifiquen el funcionament d'una unitat de codi individual, com una funció o mètode.\nProves Funcionals: Verifiquen que un conjunt de mòduls funciona correctament conjuntament. Aquestes proves poden simular interaccions de l'usuari en un sistema web, encara que això es fa millor amb frameworks especialitzats per a proves funcionals.\nProves d'Integració*: Comproven que diferents mòduls o serveis funcionen correctament quan es combinen.\n\nExemple de prova unitària:\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n\nAssercions\nLes assercions permeten comprovar el resultat dels mètodes que volem provar. Les assercions esperen que el predicat sempre siga vertader.\nPHPUnit ofereix les següent assercions:\n\nassertTrue / assertFalse: Comprova que la condició donada siga avaluada com true / false\nassertEquals / assertSame: Comprova que dues variables siguen iguals\nassertNotEquals / assertNotSame: Comprova que dues variables NO siguen iguals\nassertNull: Comprova que un valor és null.\nSame → comprova els tipus. Si no coincideixen els tipus i els valors, l'asserció fallarà\nEquals → sense comprovació estricta\nassertArrayHasKey / assertArrayNotHasKey: Comprova que un array posseïsca un key determinat / o NO ho posseïsca\nassertArraySubset: Comprova que un array posseïsca un altre array com subset del mateix\nassertAttributeContains / assertAttributeNotContains: Comprova que un atribut d'una classe continga una variable determinada / o NO continga una variable determinada\nassertAttributeEquals: Comprova que un atribut d'una classe siga igual a una variable determinada.\n\nProves amb dades\nLes proves en PHPUnit poden utilitzar data providers per executar el mateix test amb diferents dades:\n/**\n* @dataProvider proveidorDeDades\n*/\npublic function testMultiplica($a, $b, $esperat) {\n$calculadora = new Calculadora();\n$this-&gt;assertEquals($esperat, $calculadora-&gt;multiplica($a, $b));\n}\n\npublic function proveidorDeDades() {\nreturn [\n[2, 3, 6],\n[0, 5, 0],\n[-1, 5, -5],\n];\n}\n\nMocks\nEls mocks són objectes simulats que ens permeten aïllar la unitat de codi que estem provant. PHPUnit facilita la creació de mocks per a classes o interfícies.\n$mock = $this-&gt;createMock(ServeiExtern::class);\n$mock-&gt;method('obtenirDades')-&gt;willReturn('Dades simulades');\n\n$calculadora = new Calculadora($mock);\n$resultat = $calculadora-&gt;processaDades();\n$this-&gt;assertEquals('Resultat esperat', $resultat);\n\nProvant excepcions\nLes proves a més de comprovar que les classes funcionen com s'espera, han de cobrir tots els casos possibles. Així doncs, hem de poder fer proves que esperen que es llance una exempció (i que el missatge continga una certa informació):\nPer a això, s'utilitzen les següent expectatives:\n\nexpectException(Excepcion::class)\nexpectExceptionCode(codigoExcepcion)\nexpectExceptionMessage(missatge)\n\nDe la mateixa manera que abans, primer es posa l'expectativa, i després es provoca que es llance l'exempció:\n&lt;?php\npublic function testExcepcio() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n\nConclusió\nLes proves són crucials per a assegurar que el nostre codi PHP és fiable i manté la seua funcionalitat al llarg del temps. Utilitzar PHPUnit ens proporciona les eines necessàries per a escriure proves eficaces i mantenir el nostre projecte en un estat saludable.\n12. Referències Bibliogràfiques\nProgramació Orientada a Objectes en PHP\n\n&quot;PHP Objects, Patterns, and Practice&quot;\nper M. Zandstra. Apress, 2017. ISBN: 978-1-4842-1361-3. Aquest llibre és un recurs essencial per entendre els fonaments de la programació orientada a objectes en PHP, així com patrons de disseny.\n\n&quot;Learning PHP, MySQL &amp; JavaScript: With jQuery, CSS &amp; HTML5&quot;\nper Robin Nixon. O'Reilly Media, 2018. ISBN: 978-1-4919-2070-2. Ofereix una introducció completa a la programació amb PHP, incloent-hi el model d'objectes de PHP.\n\nConstructors i Destructors\n\nPHP Manual: Constructors and Destructors\nDocumentació oficial de PHP sobre constructors i destructors en la programació orientada a objectes. Disponible a https://www.php.net/manual/en/language.oop5.decon.php.\n\nEncapsulació i Visibilitat\n\nPHP Manual: Visibility\nSecció del manual oficial de PHP que explica les paraules clau public, protected, i private, així com el concepte d'encapsulació. Accessible a https://www.php.net/manual/en/language.oop5.visibility.php.\n\nHerència i Polimorfisme\n\n&quot;Programming PHP&quot;\nper Kevin Tatroe, Peter MacIntyre, i Rasmus Lerdorf. O'Reilly Media, 2013. ISBN: 978-1-4493-5053-6. Aquest llibre cobreix àmpliament els conceptes d'herència i polimorfisme en PHP, proporcionant exemples pràctics.\n\nPHP Manual: Inheritance\nDocumentació oficial de PHP que tracta sobre l'herència en classes, incloent el polimorfisme. Disponible a https://www.php.net/manual/en/language.oop5.inheritance.php.\n\nClasses Abstractes i Interfícies\n\nPHP Manual: Interfaces and Abstract Classes\nExplicació oficial de les classes abstractes i les interfícies en PHP. Disponible a https://www.php.net/manual/en/language.oop5.interfaces.php.\n\nNombres màgics i Metodes màgics\n\nPHP Manual: Magic Methods\nGuia completa sobre els mètodes màgics en PHP, com __construct(), __destruct(), __get(), __set(), entre altres. Disponible a https://www.php.net/manual/en/language.oop5.magic.php.\n\nTrait en PHP\n\nPHP Manual: Traits\nDocumentació sobre traits en PHP, que permeten reutilitzar codi entre diferents classes. Disponible a https://www.php.net/manual/en/language.oop5.traits.php.\n\nExcepcions en PHP\n\n&quot;The Pragmatic Programmer: Your Journey to Mastery&quot;\nper David Thomas i Andrew Hunt. Addison-Wesley Professional, 2019. ISBN: 978-0-1359-5202-8. Inclou bones pràctiques per a la gestió d'excepcions, aplicables també a PHP.\n\nPHP Manual: Exceptions\nSecció del manual de PHP dedicada a les excepcions, explicant com llençar i capturar excepcions en PHP. Accessible a https://www.php.net/manual/en/language.exceptions.php.\n\nProves amb PHPUnit\n\n&quot;Modern PHP: New Features and Good Practices&quot;\nper Josh Lockhart. O'Reilly Media, 2015. ISBN: 978-1-4919-2904-0. Aquest llibre inclou una secció sobre proves amb PHPUnit.\n\nPHPUnit Documentation\nDocumentació oficial de PHPUnit, que cobreix com escriure i executar proves unitàries en PHP. Accessible a https://phpunit.de/documentation.html.\n\nEines de Desenvolupament i Autocàrrega\n\nComposer Documentation\nAccessible des de https://getcomposer.org/doc/. Composer és l'eina estàndard per a la gestió de dependències en PHP, i inclou suport per a l'autocàrrega de classes.\n\nPHP Manual: Autoloading Classes\nGuia sobre el mecanisme d'autocàrrega en PHP, que facilita la inclusió automàtica de classes en els teus projectes. Disponible a https://www.php.net/manual/en/language.oop5.autoload.php.\n\nPOO Avançada: Patrons de Disseny\n\n&quot;Head First Design Patterns&quot;\nper Eric Freeman i Elisabeth Robson. O'Reilly Media, 2020. ISBN: 978-1-4919-7175-9. Un recurs excel·lent per aprendre patrons de disseny aplicables a PHP.\n\n&quot;PHP Design Patterns&quot;\nper Stephan Schmidt. Publicat per Packt Publishing, 2008. ISBN: 978-1-84719-255-3. Aquest llibre explora com aplicar patrons de disseny en projectes PHP.\n\nWebs de Referència Addicionals\n\nPHP: The Right Way\nhttps://phptherightway.com/. Una guia per a desenvolupar aplicacions PHP seguint les millors pràctiques de la indústria.\n\nStack Overflow\nhttps://stackoverflow.com/questions/tagged/php. Una font d'informació valuosa per resoldre problemes específics de PHP i discutir amb altres desenvolupadors.\n\n13. Exercicis\nBateria d'Exercicis Solucionats per a la Unitat de Programació Orientada a Objectes\nExercici 1: Crear una Classe Bàsica\n\nCrea una classe Cotxe que tinga les propietats marca i model. Afegeix un mètode mostraInformacio que retorne un string amb la marca i el model del cotxe.\nCrea una instància de la classe Cotxe, assigna-li una marca i un model, i mostra la informació utilitzant el mètode mostraInformacio.\n\nSolució\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\n$cotxe = new Cotxe();\n$cotxe-&gt;marca = &quot;Toyota&quot;;\n$cotxe-&gt;model = &quot;Corolla&quot;;\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Toyota, Model: Corolla\n\nExercici 2. Afegir un Constructor i destructor\n\nModifica la classe Cotxe per afegir un constructor que prenga com a paràmetres la marca i el model, i que establisca aquestes propietats automàticament.\nAfegeix un destructor a la classe Cotxe que mostre un missatge quan l'objecte és destruït. Crea un objecte i permet que es destruïsca al final del programa.\n\nSolució\n&lt;?php\nclass Cotxe {\npublic $marca;\npublic $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\npublic function __destruct() {\necho &quot;L'objecte Cotxe ha estat destruït.\\n&quot;;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nExercici 3. Encapsulació de Propietats\n\nModifica la classe Cotxe per a que les propietats marca i model siguen privades. Afegeix mètodes públics getMarca, setMarca, getModel, i setModel per accedir i modificar aquestes propietats.\n\nSolució\n&lt;?php\nclass Cotxe {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function setMarca($marca) {\n$this-&gt;marca = $marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n\npublic function setModel($model) {\n$this-&gt;model = $model;\n}\n\npublic function mostraInformacio() {\nreturn &quot;Marca: &quot; . $this-&gt;getMarca() . &quot;, Model: &quot; . $this-&gt;getModel();\n}\n}\n\n$cotxe = new Cotxe(&quot;Ford&quot;, &quot;Fiesta&quot;);\necho $cotxe-&gt;mostraInformacio(); // Output: Marca: Ford, Model: Fiesta\n\nExercici 4. Herència i Polimorfisme\n\nCrea una classe Vehicle amb una propietat tipus. A continuació, crea una classe Motocicleta que herete de Vehicle i tinga una propietat cilindrada. Afegeix un mètode a Motocicleta que retorne el tipus i la cilindrada.\nCrea una funció mostraDetallsVehicle que accepte un objecte de tipus Vehicle i mostre les seues propietats. Prova aquesta funció amb objectes de Cotxe i Motocicleta.\n\nSolució\n&lt;?php\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function mostraDetalls() {\nreturn &quot;Tipus: &quot; . $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Marca: &quot; . $this-&gt;marca . &quot;, Model: &quot; . $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function mostraDetalls() {\nreturn parent::mostraDetalls() . &quot;, Cilindrada: &quot; . $this-&gt;cilindrada;\n}\n}\n\nfunction mostraDetallsVehicle(Vehicle $vehicle) {\necho $vehicle-&gt;mostraDetalls() . &quot;\\n&quot;;\n}\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\nmostraDetallsVehicle($cotxe); // Output: Tipus: Cotxe, Marca: Toyota, Model: Corolla\nmostraDetallsVehicle($moto); // Output: Tipus: Motocicleta, Cilindrada: 600\n\nExercici 5. Implementació del Patró MVC amb Vehicles\nContinuant amb l'exercici anterior on has creat les classes Vehicle, Cotxe, i Motocicleta, ara refactoritzaràs el codi per seguir el patró Model-Vista-Controlador (MVC). El teu objectiu és separar la lògica de negoci (models) de la presentació (vistes) i gestionar la interacció entre aquestes capes mitjançant un controlador.\n\nCrear el Model:\n\nRefactoritza les classes Vehicle, Cotxe, i Motocicleta perquè representen el model de negoci i només contenen la lògica relacionada amb la gestió de vehicles.\nAssegura't que els models no contenen cap codi de presentació.\n\nCrear les Vistes:\n\nCrea vistes separades per mostrar els detalls dels vehicles:\n\nUna vista HTML que mostre la informació dels vehicles en format HTML.\nUna vista en text simple que mostre els detalls dels vehicles en un format de text senzill.\n\nCrear el Controlador:\n\nImplementa un controlador que gestione la interacció entre els models i les vistes.\nEl controlador ha de ser capaç de rebre una sol·licitud per mostrar un vehicle i triar la vista adequada per mostrar-ne els detalls.\n\nSolució\n&lt;?php\n// Models\n\nclass Vehicle {\nprotected $tipus;\n\npublic function __construct($tipus) {\n$this-&gt;tipus = $tipus;\n}\n\npublic function getTipus() {\nreturn $this-&gt;tipus;\n}\n}\n\nclass Cotxe extends Vehicle {\nprivate $marca;\nprivate $model;\n\npublic function __construct($marca, $model) {\nparent::__construct(&quot;Cotxe&quot;);\n$this-&gt;marca = $marca;\n$this-&gt;model = $model;\n}\n\npublic function getMarca() {\nreturn $this-&gt;marca;\n}\n\npublic function getModel() {\nreturn $this-&gt;model;\n}\n}\n\nclass Motocicleta extends Vehicle {\nprivate $cilindrada;\n\npublic function __construct($cilindrada) {\nparent::__construct(&quot;Motocicleta&quot;);\n$this-&gt;cilindrada = $cilindrada;\n}\n\npublic function getCilindrada() {\nreturn $this-&gt;cilindrada;\n}\n}\n\n// Vistes\n\nclass VehicleView {\npublic function renderHtml(Vehicle $vehicle) {\n$output = &quot;&lt;p&gt;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;&lt;/p&gt;&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;&lt;p&gt;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;&lt;/p&gt;&quot;;\n$output .= &quot;&lt;p&gt;Model: &quot; . $vehicle-&gt;getModel() . &quot;&lt;/p&gt;&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;&lt;p&gt;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc&lt;/p&gt;&quot;;\n}\nreturn $output;\n}\n\npublic function renderText(Vehicle $vehicle) {\n$output = &quot;Tipus: &quot; . $vehicle-&gt;getTipus() . &quot;\\n&quot;;\nif ($vehicle instanceof Cotxe) {\n$output .= &quot;Marca: &quot; . $vehicle-&gt;getMarca() . &quot;\\n&quot;;\n$output .= &quot;Model: &quot; . $vehicle-&gt;getModel() . &quot;\\n&quot;;\n} elseif ($vehicle instanceof Motocicleta) {\n$output .= &quot;Cilindrada: &quot; . $vehicle-&gt;getCilindrada() . &quot; cc\\n&quot;;\n}\nreturn $output;\n}\n}\n\n// Controlador\n\nclass VehicleController {\nprivate $view;\n\npublic function __construct(VehicleView $view) {\n$this-&gt;view = $view;\n}\n\npublic function mostrarVehicle(Vehicle $vehicle, $format = 'html') {\nif ($format === 'html') {\necho $this-&gt;view-&gt;renderHtml($vehicle);\n} else {\necho $this-&gt;view-&gt;renderText($vehicle);\n}\n}\n}\n\n// Exemple d'ús\n\n$view = new VehicleView();\n$controller = new VehicleController($view);\n\n$cotxe = new Cotxe(&quot;Toyota&quot;, &quot;Corolla&quot;);\n$moto = new Motocicleta(600);\n\n// Mostrar en HTML\n$controller-&gt;mostrarVehicle($cotxe, 'html');\n$controller-&gt;mostrarVehicle($moto, 'html');\n\n// Mostrar en Text\n$controller-&gt;mostrarVehicle($cotxe, 'text');\n$controller-&gt;mostrarVehicle($moto, 'text');\n\nExercici 5. Classes Abstractes i Interfícies\n\nCrea una classe abstracta Figura amb un mètode abstracte calculaArea. Després, crea classes Cercle i Rectangle que estiguen basades en Figura i implementen el mètode calculaArea.\nDefineix una interfície OperacionsBàsiques amb els mètodes suma i resta. Implementa aquesta interfície en una classe CalculadoraSimple.\n\nSolució\n&lt;?php\nabstract class Figura {\nabstract public function calculaArea();\n}\n\nclass Cercle extends Figura {\nprivate $radi;\n\npublic function __construct($radi) {\n$this-&gt;radi = $radi;\n}\n\npublic function calculaArea() {\nreturn pi() * $this-&gt;radi * $this-&gt;radi;\n}\n}\n\nclass Rectangle extends Figura {\nprivate $ample;\nprivate $llarg;\n\npublic function __construct($ample, $llarg) {\n$this-&gt;ample = $ample;\n$this-&gt;llarg = $llarg;\n}\n\npublic function calculaArea() {\nreturn $this-&gt;ample * $this-&gt;llarg;\n}\n}\n\n$cercle = new Cercle(5);\n$rectangle = new Rectangle(4, 6);\n\necho &quot;Àrea del cercle: &quot; . $cercle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del cercle: 78.5398\necho &quot;Àrea del rectangle: &quot; . $rectangle-&gt;calculaArea() . &quot;\\n&quot;; // Output: Àrea del rectangle: 24\n\n&lt;?php\ninterface OperacionsBàsiques {\npublic function suma($a, $b);\npublic function resta($a, $b);\n}\n\nclass CalculadoraSimple implements OperacionsBàsiques {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\n$calculadora = new CalculadoraSimple();\necho &quot;Suma: &quot; . $calculadora-&gt;suma(5, 3) . &quot;\\n&quot;; // Output: Suma: 8\necho &quot;Resta: &quot; . $calculadora-&gt;resta(5, 3) . &quot;\\n&quot;; // Output: Resta: 2\n\nExercici 6. Utilitzar Traits\n\nCrea un trait Informacio amb un mètode mostraInformacio. Inclou aquest trait en les classes Cotxe i Motocicleta, i utilitza'l per mostrar informació addicional.\n\nSolució\n&lt;?php\ntrait Informacio {\npublic function mostraInformacio() {\nreturn &quot;Aquest és un objecte de tipus &quot; . get_class($this);\n}\n}\n\nclass Cotxe {\nuse Informacio;\n}\n\nclass Motocicleta {\nuse Informacio;\n}\n\n$cotxe = new Cotxe();\n$moto = new Motocicleta();\n\necho $cotxe-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Cotxe\necho $moto-&gt;mostraInformacio() . &quot;\\n&quot;; // Output: Aquest és un objecte de tipus Motocicleta\n\nExercici 7. Gestionar Excepcions\n\nEscriu una funció divideix que prenga dos nombres com a paràmetres i retorne el resultat de la divisió. Si el segon nombre és zero, llença una excepció amb un missatge adequat. Captura aquesta excepció quan crides a la funció i mostra un missatge d'error.\n\nSolució\n&lt;?php\nfunction divideix($a, $b) {\nif ($b == 0) {\nthrow new Exception(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n\ntry {\necho divideix(10, 2) . &quot;\\n&quot;; // Output: 5\necho divideix(10, 0) . &quot;\\n&quot;; // Aquesta línia llançarà una excepció\n} catch (Exception $e) {\necho &quot;Error: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;; // Output: Error: No es pot dividir per zero.\n}\n\nExercici 8. Proves amb PHPUnit\n\nCrea una classe Calculadora amb els mètodes suma i resta. Escriu una prova unitària amb PHPUnit per verificar que aquests mètodes funcionen correctament.\nAfegeix un mètode divideix a la classe Calculadora que llance una excepció quan es divideix per zero. Escriu una prova unitària que assegure que aquesta excepció es llança correctament.\n\nSolució\n&lt;?php\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function suma($a, $b) {\nreturn $a + $b;\n}\n\npublic function resta($a, $b) {\nreturn $a - $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testSuma() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;suma(2, 3);\n$this-&gt;assertEquals(5, $resultat);\n}\n\npublic function testResta() {\n$calculadora = new Calculadora();\n$resultat = $calculadora-&gt;resta(5, 3);\n$this-&gt;assertEquals(2, $resultat);\n}\n}\n\n// Arxiu: tests/CalculadoraTest.php\nuse PHPUnit\\Framework\\TestCase;\n\nclass Calculadora {\npublic function divideix($a, $b) {\nif ($b == 0) {\nthrow new InvalidArgumentException(&quot;No es pot dividir per zero.&quot;);\n}\nreturn $a / $b;\n}\n}\n\nclass CalculadoraTest extends TestCase {\npublic function testDivideix() {\n$this-&gt;expectException(InvalidArgumentException::class);\n\n$calculadora = new Calculadora();\n$calculadora-&gt;divideix(5, 0);\n}\n}\n\nExercici 9. Espais de Noms (Namespaces)\n\nCrea un espai de noms App\\Models i defineix una classe Usuari dins d'aquest espai de noms. Afegeix un mètode getNomComplet que retorne el nom complet de l'usuari.\nEn un fitxer separat, importa la classe Usuari de l'espai de noms App\\Models i crea una instància d'aquesta classe. Utilitza el mètode getNomComplet per mostrar el nom complet d'un usuari.\n\nSolució\n&lt;?php\n// Arxiu: src/Models/Usuari.php\nnamespace App\\Models;\n\nclass Usuari {\nprivate $nom;\nprivate $cognom;\n\npublic function __construct($nom, $cognom) {\n$this-&gt;nom = $nom;\n$this-&gt;cognom = $cognom;\n}\n\npublic function getNomComplet() {\nreturn $this-&gt;nom . &quot; &quot; . $this-&gt;cognom;\n}\n}\n\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Usuari;\n\n$usuari = new Usuari(&quot;Joan&quot;, &quot;Garcia&quot;);\necho $usuari-&gt;getNomComplet(); // Output: Joan Garcia\n\nExercici 10. Autoloading i Composer\n\nConfigura un projecte PHP amb Composer que utilitze l'autoloading PSR-4. Crea l'estructura de directoris src/Models i col·loca una classe Producte dins de src/Models. Verifica que l'autoloading funcione correctament instanciant la classe Producte en un fitxer separat.\nAfegeix la llibreria monolog/monolog al projecte utilitzant Composer. Crea una instància de Logger i afegeix una entrada al registre de logs.\n\nSolució\n\nCrea l'estructura de directoris src/Models i col·loca el següent codi a src/Models/Producte.php:\n\n&lt;?php\nnamespace App\\Models;\n\nclass Producte {\nprivate $nom;\n\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nConfigura l'autoloading en composer.json:\n\n{\n&quot;autoload&quot;: {\n&quot;psr-4&quot;: {\n&quot;App\\\\&quot;: &quot;src/&quot;\n}\n}\n}\n\nExecuta composer dump-autoload per generar els fitxers d'autoload.\nUtilitza la classe producte:\n\n&lt;?php\n// Arxiu: index.php\nrequire 'vendor/autoload.php';\n\nuse App\\Models\\Producte;\n\n$producte = new Producte(&quot;Ordinador&quot;);\necho $producte-&gt;getNom(); // Output: Ordinador\n\nAfegeix Monolog a composer.json:\n\ncomposer require monolog/monolog\n\nUtilitza Monolog per crear un logger:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n\n// Afegeix una entrada al log\n$log-&gt;warning('Aquesta és una entrada d'advertència');\n$log-&gt;error('Aquesta és una entrada d'error');\n\nExercici 11. Logger\n\nUtilitzant la llibreria Monolog, crea un logger que escriga missatges a un fitxer app.log. Configura el logger per registrar missatges d'informació i d'error.\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error.\n\nSolució\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::INFO));\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::ERROR));\n\n// Registra missatges d'informació i d'error\n$log-&gt;info('Aquesta és una entrada d’informació');\n$log-&gt;error('Aquesta és una entrada d’error');\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Handler\\ErrorLogHandler;\n\n$log = new Logger('nom_aplicacio');\n$log-&gt;pushHandler(new StreamHandler('app.log', Logger::WARNING));\n$log-&gt;pushHandler(new ErrorLogHandler());\n\n// Registra missatges d’error al fitxer i a la consola\n$log-&gt;error('Aquesta és una entrada d’error');\n\nExercici 12. Documentació\n\nDocumenta la classe Producte creada en l'exercici anterior utilitzant comentaris PHPDoc. Assegura't d'incloure la descripció de la classe, les propietats, i els mètodes.\nUtilitza una eina com phpDocumentor per generar la documentació automàtica del codi PHP del projecte, incloent-hi la classe Producte.\n\nSolució\n&lt;?php\nnamespace App\\Models;\n\n/**\n* Classe Producte\n*\n* Representa un producte amb un nom.\n*/\nclass Producte {\n/**\n* @var string El nom del producte\n*/\nprivate $nom;\n\n/**\n* Constructor de la classe Producte\n*\n* @param string $nom El nom del producte\n*/\npublic function __construct($nom) {\n$this-&gt;nom = $nom;\n}\n\n/**\n* Obté el nom del producte\n*\n* @return string El nom del producte\n*/\npublic function getNom() {\nreturn $this-&gt;nom;\n}\n}\n\nInstal·la phpDocumentor globalment o com a dependència de desenvolupament:\n\ncomposer require --dev phpdocumentor/phpdocumentor\n\nGenera la documentació:\n\nvendor/bin/phpdoc -d src -t docs\n\nAquest comandament generarà la documentació a la carpeta docs.\n\nExercici 13. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nSolució\n\nInstal·la DomPDF amb Composer:\n\ncomposer require dompdf/dompdf\n\nCrea un script PHP que generi un PDF senzill:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '&lt;h1&gt;Informe de Vendes&lt;/h1&gt;&lt;p&gt;Aquest és un informe de les vendes.&lt;/p&gt;';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'landscape');\n$dompdf-&gt;render();\n$dompdf-&gt;stream('informe.pdf');\n\nCrea un PDF amb una taula i una imatge:\n\n&lt;?php\nrequire 'vendor/autoload.php';\n\nuse Dompdf\\Dompdf;\n\n$dompdf = new Dompdf();\n$html = '\n&lt;h1&gt;Informe de Productes&lt;/h1&gt;\n&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Producte&lt;/th&gt;\n&lt;th&gt;Preu&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Ordinador&lt;/td&gt;\n&lt;td&gt;500€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Teclat&lt;/td&gt;\n&lt;td&gt;20€&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;img src=&quot;https://example.com/imatge.png&quot; alt=&quot;Imatge de Producte&quot; /&gt;\n';\n\n$dompdf-&gt;loadHtml($html);\n$dompdf-&gt;setPaper('A4', 'portrait');\n$dompdf-&gt;render();\n$dompdf-&gt;stream(&quot;informe_productes.pdf&quot;);\n\nExercicis proposats\nExercici 1. Creació de la Classe Bàsica i Gestió de Propietats\n\nCrea una classe Persona amb les propietats privades nom, cognoms, i edat. Encapsula aquestes propietats mitjançant getters i setters. Afig els següents mètodes:\n- getNomComplet(): string – Retorna el nom complet de la persona.\n- estaJubilat(): bool – Retorna true si l'edat és major o igual a 65, false en cas contrari.\n\nModifica la classe Persona afegint un constructor que assigna nom i cognoms. Si es proporciona un tercer paràmetre, assigna l'edat; en cas contrari, assigna una edat per defecte de 25 anys.\n\nModifica la classe Persona per utilitzar una constant LIMITE_EDAT amb el valor de 66 anys i utilitza-la en el mètode estaJubilat.\n\nExercici 2. Herència i Polimorfisme\n\nCrea una classe Empleado que herete de Persona. Afig les següents propietats i mètodes:\n\nprivate float $sou\nprivate array $telefons\nanyadirTelefono(int $telefon): void – Afig un número de telèfon a l'array.\nlistarTelefonos(): string – Retorna els números de telèfon separats per comes.\nvaciarTelefonos(): void – Buida l'array de telèfons.\ndebePagarImpuestos(): bool – Retorna true si el sou és superior a 3333€, false en cas contrari.\n\nAfig un mètode estàtic toHtml(Empleado $emp): string que genere un codi HTML que mostre el nom complet de l'empleat dins d'un paràgraf i els seus telèfons dins d'una llista ordenada.\n\nAfig un mètode estàtic toHtml(Persona $p) a la classe Persona que mostre el nom complet de la persona dins d'un paràgraf. Modifica el mètode toHtml de Empleado per rebre una Persona com a paràmetre i comprovar si es tracta d'un Empleado amb instanceof.\n\nTransforma Persona en una classe abstracta. Redefineix el mètode estàtic toHtml(Persona $p) en totes les seues subclasses.\n\nExercici 3. Integració d'Espais de Noms, Autoloading, i Composer\n\nCrea una classe Empresa que incloga una propietat amb un array de Empleados . Implementa:\n\npublic function addWorker(Empleado $t)\npublic function listWorkersHtml(): string – Genera la llista de treballadors en format HTML.\npublic function getCosteNominas(): float – Calcula el cost total de les nòmines.\n\nConfigura el projecte PHP amb Composer que utilitze l'autoloading PSR-4.\n\nExercici 4. Logger i Documentació\n\nUtilitza la llibreria Monolog per configurar un logger que escriga missatges a un fitxer app.log. Afig funcionalitat perquè el logger registre missatges d'informació i d'error en diferents arxius segons la gravetat.\n\nConfigura un logger que escriga missatges de registre tant a un fitxer com a la consola. Prova el logger registrant missatges d'error i advertència.\n\nDocumenta la classe Producte creada en exercicis anteriors utilitzant comentaris PHPDoc. Inclou la descripció de la classe, les propietats, i els mètodes. Utilitza una eina com phpDocumentor per generar documentació automàtica.\n\nEscriu proves unitàries per als mètodes de les classes Persona, Empleado, i Empresa utilitzant PHPUnit. Prova els mètodes getNomComplet, estaJubilat, addWorker, i getCosteNominas. Assegura't que les proves cobreixen diferents escenaris, incloent errors potencials.\n\nEscriu una prova unitària que comprove que el logger està registrant correctament els missatges d'error a l'arxiu corresponent. Utilitza un mock per assegurar-te que el logger funciona sense necessitat d'escriure en un fitxer real durant la prova.\n\nExercici 5. Generació de PDFs amb DomPDF\n\nInstal·la la llibreria dompdf/dompdf amb Composer. Crea un script PHP que genere un PDF senzill amb un títol i un paràgraf de text.\n\nCrea un PDF utilitzant DomPDF que incloga una taula amb dades i una imatge. Assegura't que el PDF es renderitze correctament i que la imatge s'incloga en el document.\n\nUtilitzant la classe Empresa i Empleado, genera un informe en PDF amb la llista de treballadors i el seu sou. Utilitza DomPDF per generar aquest informe.\n\nExercici 6. Serialització i JSON\n\nCrea una interfície JSerializable que incloga els mètodes:\n\ntoJSON(): string – Converteix l'objecte a un JSON utilitzant json_encode().\ntoSerialize(): string – Serialitza l'objecte utilitzant serialize().\n\nModifica les classes Persona, Empleado, i Empresa per implementar aquesta interfície. Assegura't que les propietats privades es puguen serialitzar correctament.\n\nEscriu mètodes per deserialitzar un objecte a partir d'una cadena JSON o d'una cadena serialitzada. Prova aquests mètodes amb PHPUnit per assegurar-te que la deserialització funciona correctament.\n\nExercici 7. Separació del Model de Negoci i la Presentació (MVC)\nFins ara, has creat diverses classes que gestionen la lògica del joc i les dades (models), com Persona, Empleado, i Empresa, i has generat sortides HTML i PDFs amb DomPDF. Ara és el moment de refactoritzar la teua aplicació per assegurar una separació clara entre la lògica del negoci i la presentació, seguint el patró Model-Vista-Controlador (MVC).\n\nCrear el Model:\n\nRefactoritza les classes Persona, Empleado, i Empresa per assegurar que només gestionen la lògica de negoci (per exemple, càlcul de nòmines, gestió d'empleats, etc.).\nAssegura't que aquestes classes no contenen codi relacionat amb la presentació (HTML o PDF).\n\nCrear les Vistes:\n\nCrea vistes separades per presentar la informació als usuaris:\n\nUna vista HTML per mostrar la informació de Empleado i Empresa com a llistats.\nUna vista PDF per generar informes amb DomPDF, basant-se en les dades proporcionades pel model.\n\nCrear el Controlador:\n\nImplementa un controlador que reba les sol·licituds dels usuaris, interactue amb el model (Persona, Empleado, Empresa), i tria la vista adequada per mostrar els resultats (HTML o PDF).\nEl controlador ha d'encapsular tota la lògica necessària per a gestionar la interacció entre la vista i el model, assegurant que el model no estiga lligat a la capa de presentació.\n\nEmpleadoController\n&lt;?php\nnamespace App\\Controllers;\n\nuse App\\Models\\Empleado;\n\nclass EmpleadoController {\n\npublic function listAll(){\n$persona1 = new Empleado('Ignasi','Gomis Mullor',50);\n$persona2 = new Empleado('Juan','Segura Vasco',50);\n$persona1-&gt;setSou(2500);\n$persona2-&gt;setSou(2500);\n\n$empleados = [$persona1, $persona2];\n\ninclude $_SERVER['DOCUMENT_ROOT'].'/views/empleado.view.php';\n\n}\n}\n\nempleado.view.php\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;ca&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;Empleado&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;table&gt;\n&lt;tr&gt;\n&lt;th&gt;Nom&lt;/th&gt;&lt;th&gt;Telefons&lt;/th&gt;&lt;th&gt;Sou&lt;/th&gt;\n&lt;/tr&gt;\n&lt;?php foreach ($empleados as $empleado): ?&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;?= $empleado ?&gt;&lt;/td&gt;&lt;td&gt;&lt;?= $empleado-&gt;listarTelefonos() ?&gt;&lt;/td&gt;&lt;td&gt;&lt;?= $empleado-&gt;getSou() ?&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;?php endforeach; ?&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nindex.php\n\n&lt;?php\ninclude_once __DIR__ .'/../vendor/autoload.php';\n\nuse App\\Controllers\\EmpleadoController;\n\n$controller = new EmpleadoController();\n$controller-&gt;listAll();\n\nExercici 8. Creació de Proves Unitàries per al Patró MVC\nDesprés de refactoritzar l'aplicació per separar la lògica del negoci de la presentació seguint el patró Model-Vista-Controlador (MVC), és fonamental assegurar-se que tots els components funcionen correctament i que la interacció entre ells es realitza tal com s'espera. Per això, has de crear una sèrie de proves unitàries utilitzant PHPUnit per verificar el funcionament del model, les vistes i els controladors.\n\nProves del Model:\n\nEscriu proves unitàries per verificar el funcionament dels mètodes de les classes Persona, Empleado, i Empresa.\nAssegura't que els mètodes funcionen correctament, com ara:\n\ngetNomComplet()\ndebePagarImpuestos()\naddWorker() i getCosteNominas()\n\nProva que els càlculs es realitzen correctament i que les dades es gestionen segons el que s'espera.\n\nProves del Controlador:\n\nEscriu proves unitàries per assegurar-te que els controladors interactuen correctament amb els models i que seleccionen la vista adequada per a cada situació.\nProva que les dades es passen correctament del model a la vista a través del controlador.\nImplementa proves per verificar que el controlador respon correctament a diferents sol·licituds de l'usuari, per exemple:\n\nMostrar una llista d'empleats en HTML.\nGenerar un informe en PDF utilitzant DomPDF.\n\nProves de les Vistes:\n\nEscriu proves unitàries per comprovar que les vistes reben i mostren correctament la informació proporcionada pel controlador.\nProva que la generació de contingut HTML o PDF es realitza correctament a partir de les dades proporcionades pel model.\n\n14. Enunciat dels projectes\nProjecte &quot;4 en Ratlla&quot;\n1. Crear l'entorn del 4 en ratlla\n\nDins de php crear les carpetes App,Views i Helpers.\nDins de la carpeta App crea les carpetes Models, Controllers , Services i Exceptions.\nDins de la carpeta src tindrem el index.php i el css.\n\n2. Integració de Composer i Autoloading\n\nConfiguració de Composer: Defineix un composer.json per al projecte, configurant l'autoloading PSR-4 per carregar automàticament les classes de Joc4enRatlla.\nEstructura del Projecte:\n\nOrganitza el codi en directoris com App/Models per a les classes del joc i App/Controllers per a la gestió del flux del joc.\nConfigura Composer per gestionar les dependències del projecte.\n\n3. Refactorització amb Programació Orientada a Objectes (POO) i amb MVC\nModels\n\nDins de la carpeta Models:\n\nClasse Board: Crea una classe Board per representar la graella del joc. Aquesta classe ha de gestionar la configuració inicial de la graella, els moviments dels jugadors, i la comprovació de si hi ha un guanyador.\n\nnamespace Joc4enRatlla\\Models;\n\nclass Board\n{\npublic const FILES = 6;\npublic const COLUMNS = 7;\npublic const DIRECTIONS = [\n[0, 1], // Horizontal derecha\n[1, 0], // Vertical abajo\n[1, 1], // Diagonal abajo-derecha\n[1, -1] // Diagonal abajo-izquierda\n];\n\nprivate array $slots;\n\npublic function __construct()\n\n// Getters i Setters\n\nprivate static function initializeBoard(): array //Inicialitza la graella amb valors buits\npublic function setMovementOnBoard(int $column, int $player): array //Realitza un moviment en la graella\npublic function checkWin(array $coord): bool //Comprova si hi ha un guanyador\npublic function isValidMove(int $column): bool //Comprova si el moviment és vàlid\n\n}\n\nClasse Jugador: Crea una classe Player per representar els jugadors del joc, amb propietats com el name, el color de les fitxes, forma de jugar isAutomatic.\n\nnamespace Joc4enRatlla\\Models;\n\nclass Player {\nprivate $name; // Nom del jugador\nprivate $color; // Color de les fitxes\nprivate $isAutomatic; // Forma de jugar (automàtica/manual)\n\npublic function __construct( $name, $color, $isAutomatic = false)\n\n// Getters i Setters\n\n}\n\nClasse Game: Refactoritza la lògica del joc en una classe Game que gestione la graella, el torn del jugador, i la lògica per determinar el guanyador, la puntuació.\n\nnamespace Joc4enRatlla\\Models;\n\nuse Joc4enRatlla\\Models\\Board;\nuse Joc4enRatlla\\Models\\Player;\n\nclass Game\n{\nprivate Board $board;\nprivate int $nextPlayer;\nprivate array $players;\nprivate ?Player $winner;\nprivate array $scores = [1 =&gt; 0, 2 =&gt; 0];\n\npublic function __construct( Player $jugador1, Player $jugador2)\n\n// getters i setters\n\npublic function reset(): void //Reinicia el joc\npublic function play($columna) //Realitza un moviment\npublic function playAutomatic(){\n$opponent = $this-&gt;nextPlayer === 1 ? 2 : 1;\n\nfor ($col = 1; $col &lt;= Board::COLUMNS; $col++) {\nif ($this-&gt;board-&gt;isValidMove($col)) {\n$tempBoard = clone($this-&gt;board);\n$coord = $tempBoard-&gt;setMovementOnBoard($col, $this-&gt;nextPlayer);\n\nif ($tempBoard-&gt;checkWin($coord)) {\n$this-&gt;play($col);\nreturn;\n}\n}\n}\n\nfor ($col = 1; $col &lt;= Board::COLUMNS; $col++) {\nif ($this-&gt;board-&gt;isValidMove($col)) {\n$tempBoard = clone($this-&gt;board);\n$coord = $tempBoard-&gt;setMovementOnBoard($col, $opponent);\nif ($tempBoard-&gt;checkWin($coord )) {\n$this-&gt;play($col);\nreturn;\n}\n}\n}\n\n$possibles = array();\nfor ($col = 1; $col &lt;= Board::COLUMNS; $col++) {\nif ($this-&gt;board-&gt;isValidMove($col)) {\n$possibles[] = $col;\n}\n}\nif (count($possibles)&gt;2) {\n$random = rand(-1,1);\n}\n$middle = (int) (count($possibles) / 2)+$random;\n$inthemiddle = $possibles[$middle];\n$this-&gt;play($inthemiddle);\n}\npublic function save() //Guarda l'estat del joc a les sessions\npublic static function restore() //Restaura l'estat del joc de les sessions\n\n}\n\nDocumentació:\n\nTotes les classes i mètodes han d'estar documentats amb comentaris PHPDoc.\n\nControladors\n\nDins de la carpeta Controllers:\n\nClasse JocController: Crea un controlador JocController que gestione el joc. Aquest controlador ha de permetre als jugadors realitzar moviments, comprovar l'estat del joc, i gestionar les vistes.\n\nnamespace Joc4enRatlla\\Controllers;\n\nuse Joc4enRatlla\\Models\\Player;\nuse Joc4enRatlla\\Models\\Game;\n\nclass GameController\n{\nprivate Game $game;\n\n// Request és l'array $_POST\n\npublic function __construct($request=null)\n{\n//Inicialització del joc\n$this-&gt;play($request);\n\n}\n\npublic function play(Array $request)\n{\n// Gestió del joc\n...\n\n$board = $this-&gt;game-&gt;getBoard();\n$players = $this-&gt;game-&gt;getPlayers();\n$winner = $this-&gt;game-&gt;getWinner();\n$scores = $this-&gt;game-&gt;getScores();\n\nloadView('index',compact('board','players','winner','scores'));\n}\n}\n\nServeis i funcions\n\nDins de la carpeta Services:\n\nFunció loadView: Crea una funció loadView que carregue les vistes del joc. Aquesta funció ha de rebre el nom de la vista i les dades a passar a la vista, i ha de mostrar la vista amb les dades proporcionades.\n\n&lt;?php\n\nnamespace Joc4enRatlla\\Services;\n\nclass Service\n{\npublic static function loadView($view, $data = [])\n{\n$viewPath = str_replace('.', '/', $view);\nextract($data);\n\ninclude $_SERVER['DOCUMENT_ROOT'] . &quot;/../Views/$viewPath.view.php&quot;;\n\n}\n}\n\ni la funció loadView en un fitxer de funcions\nfunction loadView($view, $data = [])\n{\nJoc4enRatlla\\Services\\Service::loadView($view, $data);\n}\n\nfunction dd(...$data )\n{\necho &quot;&lt;pre&gt;&quot;;\nforeach ($data as $d) {\nvar_dump($d);\n}\n\necho &quot;&lt;/pre&gt;&quot;;\ndie();\n}\n\nVistes\n\nDins de la carpeta Views:\n\nVista index.php: Crea una vista index.php que mostre la graella del joc, el torn actual del jugador, i els resultats finals (guanyador o empat). Aquesta vista ha de permetre als jugadors realitzar moviments en la graella.\n\n&lt;html&gt;\n&lt;head&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;4ratlla.css?v=&lt;?php echo time(); ?&gt;&quot;&gt;\n&lt;title&gt;4 en ratlla&lt;/title&gt;\n&lt;style&gt;\n.player1 {\nbackground-color: &lt;?= $players[1]-&gt;getColor() ?&gt; ; /* Color vermell per un dels jugadors */\n}\n\n.player2 {\nbackground-color: &lt;?= $players[2]-&gt;getColor() ?&gt;; /* Color groc per l'altre jugador */\n}\n\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;?php include_once $_SERVER['DOCUMENT_ROOT'].'/../Views/partials/error.view.php' ?&gt;\n&lt;form action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]); ?&gt;&quot; method=&quot;post&quot;&gt;\n&lt;?php include_once $_SERVER['DOCUMENT_ROOT'].'/../Views/partials/board.view.php' ?&gt;\n&lt;input type=&quot;submit&quot; name=&quot;reset&quot; value=&quot;Reiniciar joc&quot;&gt;\n&lt;input type=&quot;submit&quot; name=&quot;exit&quot; value=&quot;Acabar joc&quot;&gt;\n&lt;/form&gt;\n&lt;?php include_once $_SERVER['DOCUMENT_ROOT'].'/../Views/partials/panel.view.php' ?&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nSPA\nCreen la pàgina index.php que carregarà el joc 4 en ratlla.\n&lt;?php\nsession_start();\nrequire_once $_SERVER['DOCUMENT_ROOT'] . '/../vendor/autoload.php';\nrequire_once $_SERVER['DOCUMENT_ROOT'] . '/../Helpers/functions.php';\nuse Joc4enRatlla\\Controllers\\GameController;\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n$gameController = new GameController($_POST);\n} else {\nloadView('jugador');\n}\n\n4. Proves amb PHPUnit\n\nEscriu Proves Unitàries: Crea proves unitàries per a la classe Joc4enRatlla utilitzant PHPUnit. Les proves poden incloure:\n\nVerificació de la configuració inicial de la graella.\nProves per assegurar que un moviment s'aplica correctament a la graella.\nProves per assegurar que el joc detecta correctament un guanyador o un empat.\n\nProves de Gestió de Sessions: Afig proves per assegurar que l'estat del joc i el torn del jugador es mantenen correctament a través de les sessions.\n\n5. Logger amb Monolog\n\nConfiguració de Logger: Utilitza Monolog per registrar esdeveniments importants del joc, com quan un jugador fa un moviment, quan s'inicia una nova partida, o quan es produeixen errors.\nDiversos Handlers:\n\nRegistra els moviments dels jugadors i els resultats del joc en un fitxer game.log.\nRegistra errors greus o problemes amb les sessions en un fitxer d'errors separat.\n\nConsideracions Addicionals pel Projecte\n1. Documentació amb PHPDoc\n\nDocumentació Completa: Documenta totes les classes i mètodes amb comentaris PHPDoc. Això inclou les descripcions dels paràmetres i els valors de retorn per a cada mètode.\nGeneració Automàtica: Utilitza phpDocumentor o una eina similar per generar la documentació automàticament. Afig la documentació generada al projecte per facilitar el manteniment i la comprensió del codi.\n\n2. Implementació d'Interfícies\n\nInterfície JocInterface: Crea una interfície que definisca els mètodes bàsics que qualsevol joc ha de tindre (iniciarJoc, ferMoviment, comprovaGuanyador, etc.). Assegura't que la Joc4enRatlla implemente aquesta interfície.\n\n3. Serialització i Persistència\n\nSerialització de l'Estat del Joc: Implementa funcionalitats per serialitzar l'estat del joc (usant JSON o serialize()) i deserialitzar-lo per mantenir la persistència entre sessions o guardar l'estat per a reprendre la partida posteriorment.\n\n4. Exempcions\n\nGestió d'Excepcions: Utilitza excepcions per gestionar el que un jugador jugue una columna que ja estiga plena. Afig el missatge d'error al jocs.\n\n5. Fes que el jugador puga triar nom i color\n\nTriar Nom i Color: Permet als jugadors triar el seu nom i el color de les fitxes al començar una partida. Aquesta informació ha de ser guardada en les sessions i mostrada en la vista del joc.\n\nCriteri\n** Insuficient (1 punt)**\n** Adequat (2 punts)**\n** Bé (3 punts)**\n** Excel·lent (4 punts)**\n\n**Funcionalitat del programa **\nNo es funcional.\nEs funcional però falten funcionalitats.\nEs funcional però falten detalls.\nTotalment funcional.\n\nImplementació de Programació Orientada a Objectes (POO)\nLes classes no estan ben dissenyades, falta encapsulació, ús incorrecte d'herència, o mètodes no funcional.\nLes classes estan creades però poden tindre errors o una estructura confusa. S'aplica la POO de manera bàsica, però hi ha problemes de disseny.\nClasses correctament estructurades i funcionalment completes. Ús adequat d'encapsulació, herència i polimorfisme.\nDisseny de classes ben organitzat, reutilitzable i amb una implementació clara dels principis de POO.\n\nSeparació del Model de Negoci de la Presentació (MVC)\nNo s'ha implementat la separació de model i presentació; el codi de lògica i presentació està mesclat.\nHi ha una separació parcial, però algunes parts de la lògica del negoci es barregen amb la presentació o a l'inrevés.\nLa separació entre model, vista i controlador està ben implementada, però podria millorar en alguns aspectes.\nExcel·lent separació entre el model, vista i controlador, seguint els principis del patró MVC i mantenint un codi net.\n\nIntegració de Composer i Autoloading\nNo s'ha configurat Composer o l'autoloading, o està mal configurat i no funciona correctament.\nComposer s'ha utilitzat, però amb una estructura de projectes i autoloading bàsics o incorrectes.\nComposer i l'autoloading estan configurats correctament amb una estructura de projectes ben definida.\nÚs excel·lent de Composer amb una configuració avançada d'autoloading i una estructura de projecte organitzada i modular.\n\nImplementació de Proves amb PHPUnit\nNo s'han creat proves, o les proves creades són mínimes i no adequades per a verificar la funcionalitat.\nEs presenten proves bàsiques amb PHPUnit, però cobreixen parcialment les funcionalitats requerides.\nProves unitàries completes que cobreixen la majoria dels casos, incloent proves de gestió de sessions i lògica de joc.\nProves exhaustives que cobreixen totes les funcionalitats i consideren casos límit, amb ús de mocks quan necessari.\n\nÚs de Logger amb Monolog\nNo s'ha implementat el logger o no s'utilitza de manera efectiva per registrar esdeveniments importants.\nLogger implementat, però amb ús limitat o incorrecte en la registració d'esdeveniments i errors.\nLogger ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nÚs avançat de logger amb diferents handlers per registrar informació, errors, i seguiment detallat del flux del joc.\n\nDocumentació amb PHPDoc\nFalta documentació o és insuficient per comprendre les classes i mètodes del projecte.\nDocumentació bàsica amb PHPDoc, però amb omisions o descripcions poc clares.\nDocumentació completa amb PHPDoc per a totes les classes i mètodes, amb descripcions clares i detallades.\nDocumentació excel·lent amb PHPDoc, ben estructurada i completa, facilitant la comprensió i manteniment del projecte.\n\nExempcions\nNo hi ha.\nSi hi ha però no es mostra missatge d'error.\nEs tracta perfectament i hi ha missatge d'error .\n\nQualitat del Codi i Bones Pràctiques\nCodi desorganitzat, amb molts errors de sintaxi, mala nomenclatura, o sense bones pràctiques de codi.\nCodi funcional però amb problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\nCodi ben escrit, seguint les convencions de nomenclatura i bones pràctiques de desenvolupament.\nCodi de qualitat professional, net, ben organitzat, i seguint rigorosament les millors pràctiques de programació.\n\nExplicació dels Criteris\n1 punt: Insuficient\n\nPOO: Les classes no segueixen els principis bàsics de la programació orientada a objectes. Hi ha problemes greus com la falta d'encapsulació, l'ús inadequat de l'herència o mètodes que no funcionen correctament.\nMVC: No s'ha implementat la separació del model de negoci i la presentació. El codi de la lògica del negoci està mesclat amb la presentació (HTML, CSS), cosa que dificulta el manteniment i l'escalabilitat del projecte.\nComposer i Autoloading: No s'ha configurat Composer o l'autoloading. Si estan configurats, no funcionen correctament.\nProves amb PHPUnit: Les proves estan absents o són mínimes, i no verifiquen adequadament la funcionalitat del projecte.\nLogger amb Monolog: El logger no s'ha implementat, o si està present, no s'utilitza de manera efectiva per registrar esdeveniments importants.\nDocumentació amb PHPDoc: Falta documentació essencial, o la que existeix és insuficient per a entendre el codi.\nQualitat del Codi: El codi és desorganitzat, amb molts errors de sintaxi i no segueix les bones pràctiques de programació.\n\n2 punts: Adequat\n\nPOO: Les classes estan creades, però poden contindre errors o una estructura confusa. L'aplicació de la POO és bàsica, amb alguns problemes de disseny.\nMVC: Hi ha una separació parcial entre el model de negoci i la presentació. No obstant això, encara hi ha parts del codi on la lògica del negoci està barrejada amb la presentació o a l'inrevés, cosa que indica una comprensió bàsica però incompleta del patró MVC.\nComposer i Autoloading: Composer s'ha utilitzat, però l'estructura de projectes o l'autoloading no són òptims, presentant configuracions bàsiques o incorrectes.\nProves amb PHPUnit: Es presenten proves bàsiques que cobreixen parcialment les funcionalitats requerides.\nLogger amb Monolog: El logger està implementat, però l'ús és limitat o incorrecte en la registració d'esdeveniments i errors.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és bàsica, amb algunes omisions o descripcions poc clares.\nQualitat del Codi: El codi és funcional però presenta problemes d'estructura, estil inconsistent o incompliment parcial de bones pràctiques.\n\n3 punts: Bé\n\nPOO: Les classes estan correctament estructurades i són funcionalment completes. Es fa un ús adequat de l'encapsulació, l'herència i el polimorfisme.\nMVC: La separació entre el model, vista i controlador està ben implementada, seguint majoritàriament els principis del patró MVC. El codi és clar i estructurat, amb algunes àrees que podrien millorar-se per aconseguir una millor modularitat i mantenibilitat.\nComposer i Autoloading: Composer i l'autoloading estan configurats correctament, amb una estructura de projectes ben definida.\nProves amb PHPUnit: Les proves unitàries estan completes i cobreixen la majoria dels casos, incloent-hi la gestió de sessions i la lògica del joc.\nLogger amb Monolog: El logger està ben implementat, amb esdeveniments i errors registrats adequadament en diferents fitxers o canals.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és completa per a totes les classes i mètodes, amb descripcions clares i detallades.\nQualitat del Codi: El codi està ben escrit, seguint les convencions de nomenclatura i les bones pràctiques de desenvolupament.\n\n4 punts: Excel·lent\n\nPOO: El disseny de classes està ben organitzat, és reutilitzable i implementa clarament els principis de la programació orientada a objectes. El codi és elegant i eficient.\nMVC: Excel·lent separació entre el model, vista i controlador, seguint rigorosament els principis del patró MVC. El codi està ben organitzat, modular i fàcil de mantenir, cosa que facilita l'escalabilitat del projecte. Hi ha una clara distinció de responsabilitats entre les diferents capes.\nComposer i Autoloading: S'utilitza Composer de manera excel·lent, amb una configuració avançada de l'autoloading i una estructura de projecte organitzada i modular.\nProves amb PHPUnit: Les proves són exhaustives, cobrint totes les funcionalitats i considerant casos límit, amb ús de mocks quan necessari.\nLogger amb Monolog: S'utilitza el logger de manera avançada, amb diferents handlers per registrar informació, errors, i fer un seguiment detallat del flux del joc.\nDocumentació amb PHPDoc: La documentació amb PHPDoc és excel·lent, ben estructurada i completa, facilitant la comprensió i el manteniment del projecte.\nQualitat del Codi: El codi és de qualitat professional, net, ben organitzat, i segueix rigorosament les millors pràctiques de programació.\n\n15. Autoavaluació: Programació Orientada a Objectes en PHP\nExercici 1: Constructors en PHP\nPregunta:\nQuina és la funció principal d'un constructor en una classe PHP?\nOpcions:\n\na) Destruir els objectes de la classe quan ja no són necessaris.\n\nb) Inicialitzar les propietats de l'objecte quan es crea.\n\nc) Executar una funció arbitrària abans de cada mètode.\n\nd) Crear mètodes màgics automàticament.\n\nfunction checkAnswer1() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question1');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Inicialitzar les propietats de l'objecte quan es crea.\";\ndocument.getElementById('result1').innerText = resultText;\n}\n\nExercici 2: Herència en PHP\nPregunta:\nQuina és l'avantatge principal de l'herència en la programació orientada a objectes?\nOpcions:\n\na) Permet reutilitzar codi definint classes noves basades en classes existents.\n\nb) Permet ocultar totes les propietats i mètodes de la classe.\n\nc) Permet definir funcions globals sense necessitat de classes.\n\nd) Permet cridar a funcions de JavaScript des de PHP.\n\nfunction checkAnswer2() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question2');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet reutilitzar codi definint classes noves basades en classes existents.\";\ndocument.getElementById('result2').innerText = resultText;\n}\n\nExercici 3: Polimorfisme\nPregunta:\nQuè permet el polimorfisme en el context de la POO?\nOpcions:\n\na) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\n\nb) Permet la creació d'objectes a partir de funcions anònimes.\n\nc) Permet la connexió entre PHP i bases de dades relacionals.\n\nd) Permet executar múltiples scripts PHP alhora.\n\nfunction checkAnswer3() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question3');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que una funció tinga múltiples implementacions depenent de l'objecte que la cride.\";\ndocument.getElementById('result3').innerText = resultText;\n}\n\nExercici 4: Espais de Noms\nPregunta:\nPer a què s'utilitzen els espais de noms (namespaces) en PHP?\nOpcions:\n\na) Per executar codi PHP de forma asincrònica.\n\nb) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\n\nc) Per definir variables globals accessibles des de qualsevol punt del codi.\n\nd) Per importar codi d'altres llenguatges de programació com JavaScript.\n\nfunction checkAnswer4() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question4');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Per evitar conflictes entre noms de classes, funcions o constants en diferents parts del codi.\";\ndocument.getElementById('result4').innerText = resultText;\n}\n\nExercici 5: Traits en PHP\nPregunta:\nQuin avantatge ofereixen els traits en PHP?\nOpcions:\n\na) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\n\nb) Permet la creació de funcions globals en PHP.\n\nc) Permet la comunicació entre diferents servidors web.\n\nd) Permet executar codi PHP dins de plantilles HTML.\n\nfunction checkAnswer5() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question5');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet escriure codi reutilitzable que es pot incloure en múltiples classes, independentment de la jerarquia d'herència.\";\ndocument.getElementById('result5').innerText = resultText;\n}\n\nExercici 6: Excepcions en PHP\nPregunta:\nQuina és la finalitat d'utilitzar excepcions en PHP?\nOpcions:\n\na) Evitar l'execució de codi mal format.\n\nb) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\n\nc) Declarar funcions dins d'una classe.\n\nd) Garantir que totes les variables estiguen inicialitzades abans del seu ús.\n\nfunction checkAnswer6() {\nvar correctAnswer = \"b\";\nvar radios = document.getElementsByName('question6');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és b) Gestionar errors i condicions excepcionals de manera controlada dins d'una aplicació.\";\ndocument.getElementById('result6').innerText = resultText;\n}\n\nExercici 7: Autoloading en PHP\nPregunta:\nQuin avantatge ofereix l'autoloading en PHP?\nOpcions:\n\na) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\n\nb) Permet l'execució de múltiples scripts alhora.\n\nc) Permet la manipulació de fitxers en el servidor.\n\nd) Permet la connexió amb bases de dades.\n\nfunction checkAnswer7() {\nvar correctAnswer = \"a\";\nvar radios = document.getElementsByName('question7');\nvar userAnswer;\nfor (var i = 0; i < radios.length; i++) {\nif (radios[i].checked) {\nuserAnswer = radios[i].value;\nbreak;\n}\n}\nvar resultText = userAnswer === correctAnswer ? \"Correcte!\" : \"Incorrecte. La resposta correcta és a) Permet que les classes es carreguen automàticament quan s'utilitzen, sense necessitat de fer incloure manualment cada fitxer.\";\ndocument.getElementById('result7').innerText = resultText;\n}",
		"tags": ["1", "note"]
},

{
		"title": "0. Indice",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/0. Indice/",
		"content": "[!abstract] &quot;Duració i criteris d'avaluació&quot;\nDuració estimada: 10 hores\n\nResultat d'aprenentatge\nCriteris d'avaluació\n\n6. Desenvolupa aplicacions web d'accés a magatzems de dades, aplicant mesures per a mantindre la seguretat i la integritat de la informació.\na) S'han analitzat les tecnologies que permeten l'accés mitjançant programació a la informació disponible en magatzems de dades.\n\nb) S'han creat aplicacions que establisquen connexions amb bases de dades.\n\nc) S'ha recuperat informació emmagatzemada en bases de dades.\n\nd) S'ha publicat en aplicacions web la informació recuperada.\n\ne) S'han utilitzat conjunts de dades per a emmagatzemar la informació.\n\nf) S'han creat aplicacions web que permeten l'actualització i l'eliminació d'informació disponible en una base de dades.\n\ng) S'han provat i documentat les aplicacions web.\n\nEn aquesta unitat aprendrem a accedir a dades que es troben en un servidor; recuperant, editant i creant aquestes dades a través d'una base de dades.\nA través de les diferents capes o nivells, de les quals 2 d'elles ja coneixem (Nginx, PHP) i MySQL la que estudiarem en aquest tema.",
		"tags": [ "note"]
},

{
		"title": "1. Introducció a les tecnologies per accedir a dades",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/1. Introducció a les tecnologies per accedir a dades/",
		"content": "Bases de dades relacionals (SQL)\nLes bases de dades relacionals utilitzen llenguatge SQL per emmagatzemar i recuperar dades de taules relacionades. En PHP, les tecnologies més utilitzades per accedir-hi són PDO i MySQLi. PDO suporta múltiples sistemes de bases de dades (MySQL, PostgreSQL, etc.), mentre que MySQLi està dissenyat específicament per a MySQL.\nBases de dades NoSQL\nLes bases de dades NoSQL, com MongoDB o Firebase, emmagatzemen dades en formats no estructurats, com JSON. Aquestes són ideals per a aplicacions que gestionen grans volums de dades o dades no estructurades. MongoDB és un sistema orientat a documents, mentre que Firebase és conegut per les seves capacitats en temps real.\nAccés a APIs\nLes APIs REST permeten accedir a dades de serveis web externs utilitzant sol·licituds HTTP i respostes en formats com JSON o XML. GraphQL és una alternativa moderna que permet sol·licituds més específiques, només retornant les dades necessàries, en contrast amb les sol·licituds REST, que poden ser més generals.\nWeb Scraping\nEl web scraping és el procés d'extracció automàtica de dades de pàgines web. Aquesta tècnica es pot utilitzar per recuperar informació d'una pàgina web quan no hi ha una API disponible. En PHP, es poden utilitzar diverses biblioteques per descarregar i analitzar contingut HTML, com ara cURL i DOMDocument.\nConsideracions de seguretat\nÉs fonamental garantir la seguretat quan es treballa amb l'accés a dades. Això inclou protegir les aplicacions contra vulnerabilitats comunes, com les injeccions SQL, i assegurar les connexions utilitzant SSL/TLS quan es comuniqui amb bases de dades remotes o APIs externes.",
		"tags": [ "note"]
},

{
		"title": "2. Bases de dades relacionals (SQL)",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/2. Bases de dades relacionals (SQL)/",
		"content": "Instal·lació\nA través de XAMPP és molt senzill, simplement ens descarregaríem el programa i l'activaríem. Per a descarregar XAMPP prem ací.\nAmb Docker utilitzarem un altre repositori que inclou el mysql i el phpMyAdmin i llancem\ndocker-compose up -d\n\nSi tot ha eixit bé i el contenidor està en marxa, podrem visitar la pàgina de phpMyAdmin de la següent manera\nhttp://localhost:8000\n\nPer a accedir hem d'utilitzar les següents credencials que venen configurades en el arxiu docker-compose.yml\nusuario: root\ncontraseña: 1234\n\nEstructura d'una base de dades\nSabem que una base de dades té molts camps amb els seus noms i valors, però a més sabem que la base de dades ha de tindre un nom. per tant tindríem la següent estructura per a una base de dades:\nNombreBaseDeDatos\n|__Tabla-#1\n| |__DatosTabla-#1\n|\n|__Tabla-#2\n| |__DatosTabla-#2\n|\n|__Tabla-#3\n| |__DatosTabla-#3\n[...]\nVegem-ho en un exemple real\nRyanair\n|__pasajero\n| |__id[]\n| |__nombre\n| |__apellidos\n| |__edad\n| |__id_vuelo[^]\n|\n|__vuelo\n| |__id[]\n| |__n_plazas\n| |__disponible\n| |__id_pais[^]\n|\n|__pais\n|__id[*]\n|__nombre\n\n[*] Clau primària [^] Clave Forània\n\nSQL\nAquest llenguatge de consulta estructurada (Structured Query Language) és el que utilitzarem per a realitzar les consultes a les nostres bases de dades per a mostrar el contingut en les diferents interfícies web que creem al llarg de la unitat. Si vols saber més detalls visita Wiki SQL\nExemple d'una sentència SQL on seleccionem totes les files i columnes de la nostra taula anomenada 'pais'\nSELECT * FROM pais\n\nEstas sentencias pueden invocarse desde la consola de comandos mediante el intérprete mysql (previamente instalado en el sistema) o a través de la herramienta phpMyAdmin.\nLas sentencias SQL también las podemos usar dentro de nuestro código php, de tal manera que cuando se cargue nuestra interfaz web, lance una sentecia SQL para mostrar los datos que queramos.\n&lt;?php\n// Llistat de clients, adreçats per DNI de manera ASCendent\n$clientesOrdenadosPorDNI = &quot;SELECT * FROM `pasajero` ORDER BY `dni`&quot; ASC;\n?&gt;\n\nphpMyAdmin\n\nAquest programari funciona sota Ngingx i PHP i és més que res una interfície web per a gestionar les bases de dades que tinguem disponibles en el nostre servidor local. Molts *hostings ofereixen aquesta eina per defecte per a poder gestionar les BBDD que tinguem configurades sota el nostre compte.\nCreant una base de dades dins de phpMyAdmin\n\nPer a crear una nova base de dades hem d'entrar en phpMyAdmin com a usuari root i punxar en l'opció Nova del menú de l'esquerra.\n\nEn la nova finestra de creació posarem un nom a nostra bbdd.\n\nTambé establirem el cotejamiento utf8m4_unicode_ci perquè nostra bbdd suporte tot tipus de caràcters (com els asiàtics) i fins i tot emojis ;)\n\nLi donem al botó de Crear per a crear la bbdd i començar a escriure les diferents taules que anem a introduir en ella.\n\nEl sistema generarà el codi SQL per a crear tot el que li hem posat i crearà la base de dades amb les taules que li hàgem ficat.\nCREATE TABLE `persona`. ( `id` INT NOT NULL AUTO_INCREMENT , `nombre` TINYTEXT NOT NULL , `apellidos` TEXT NOT NULL , `telefono` TINYTEXT NOT NULL , PRIMARY KEY (`id`)) ENGINE = InnoDB;\n\nOpcions en phpMyAdmin\nQuan seleccionem una base de dades de la llista, el sistema ens mostra diverses pestanyes amb les quals interactuar amb la base de dades en qüestió:\n\nEstructura: Podem veure les diferents taules que consoliden la nostra base de dades\n\nSQL: Per si volem injectar codi SQL perquè el sistema l'interprete\n\nBuscar: Serveix per a buscar per termes, en la nostra base de dades, aplicant diferents filtres de cerca\n\nGenerar consulta: semblança a SQL però d'una manera més gràfica, sense haver de saber res del llenguatge\n\nExportar i importar: Com el seu nom indica, per a fer qualsevol de les 2 operacions sobre la base de dades\n\nOperacions: Diferents opcions avançades per a realitzar en la nostra base de dades, de la qual destacarem l'opció Cotejamiento on podrem canviar el cotejamiento de la nostra taula però ULL AMB ACÔ perquè podem eliminar dades sense voler, ja que en canviar el cotejamiento podem suprimir caràcters no suportats pel nou cotejamiento\n\nNo aprofundirem en la resta d'opcions però, en la pestanya Més existeix l'opció Dissenyador per a poder editar les relacions entre taules d'una manera gràfica (punxant i arrossegant) que veurem més endavant.",
		"tags": [ "note"]
},

{
		"title": "3. PHP Data Objects  PDO",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/3. PHP Data Objects  PDO/",
		"content": "La classe PDO de PHP s'utilitza per connectar-se a una base de dades i executar consultes SQL de manera segura. Quan construeixes una instància de PDO, pots passar-li diferents atributs en el constructor i opcions per configurar el comportament de la connexió. Aquí tens els atributs principals i el seu propòsit:\nConstructor de la classe PDO\nEl constructor de la classe PDO accepta tres paràmetres obligatoris i un opcional:\n&lt;?php\n$pdo = new PDO(string $dsn, string $username, string $password, array $options);\n\n$dsn (Data Source Name): És una cadena que especifica el tipus de base de dades i la informació necessària per connectar-s'hi.\n\nFormat per tipus de base de dades i configuració, per exemple:\n\nMysql:host=localhost;dbname=testdb (per a MySQL).\npgsql:host=localhost;port=5432;dbname=testdb (per a PostgreSQL).\nsqlite:/path/to/database.db (per a SQLite).\n\n$username: El nom d'usuari per a la connexió a la base de dades.\n$password: La contrasenya associada al nom d'usuari.\n$options (Opcional): Un array d'opcions per definir el comportament de la connexió. Aquests són alguns dels valors més comuns que es poden definir en aquest array:\n\nPDO::ATTR_ERRMODE: Controla com es gestionen els errors. Alguns valors comuns són:\n\nPDO::ERRMODE_SILENT: Els errors no generen cap missatge.\nPDO::ERRMODE_WARNING: Els errors generen un avís.\nPDO::ERRMODE_EXCEPTION: Els errors generen una excepció, que és el més recomanable per controlar errors.\n\nPDO::ATTR_DEFAULT_FETCH_MODE: Defineix el mode de recuperació de dades per defecte, com ara:\n\nPDO::FETCH_ASSOC: Retorna les dades com un array associatiu.\nPDO::FETCH_OBJ: Retorna les dades com un objecte.\nPDO::FETCH_BOTH: Retorna les dades com un array associatiu i numèric.\n\nPDO::ATTR_PERSISTENT: Habilita connexions persistents. Una connexió persistent pot millorar el rendiment mantenint la connexió activa per múltiples peticions en lloc de crear-ne una nova cada vegada.\nPDO::ATTR_TIMEOUT: Defineix un temps límit per a la connexió en segons.\n\nExemple de connexió amb PDO\n$dsn = &quot;mysql:host=localhost;dbname=testdb&quot;;\n$username = &quot;usuari&quot;;\n$password = &quot;contrasenya&quot;;\n$options = [\nPDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION,\nPDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC,\nPDO::ATTR_PERSISTENT =&gt; true,\nPDO::MYSQL_ATTR_INIT_COMMAND =&gt; &quot;SET NAMES utf8&quot;\n];\n\ntry {\n$pdo = new PDO($dsn, $username, $password, $options);\necho &quot;Connexió establerta amb èxit!&quot;;\n} catch (PDOException $e) {\necho &quot;Error de connexió: &quot; . $e-&gt;getMessage();\n}\n\nAquest codi estableix una connexió a una base de dades MySQL amb un joc de caràcters utf8, una connexió persistent, i llança excepcions en cas d'errors.\nQualsevol error que es llance a través de PDO, el sistema llançarà una PDOException .\nFitxer de configuració de la BD\nDe la mateixa manera que podem tenir el nostre arxiu de funcions funciones.php i alberguem totes les funcions que s'usen de manera global en l'aplicació, podem establir un arxiu de constants on definim els paràmetres de connexió amb la base de dades.\n&lt;?php\n\n// ▒▒▒▒▒▒▒▒ conexion.php ▒▒▒▒▒▒▒▒\n\nconstDSN = &quot;mysql:host=localhost;dbname=dwes&quot;;\nconstUSUARIO = &quot;dwes&quot;;\nconstPASSWORD = &quot;abc123&quot;;\n\n/* ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n▒▒▒▒▒▒▒▒ NO SUBAS ESTE ARCHIVO A git ▒▒▒▒▒\n\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ */\n\nAquest arxiu conté informació molt sensible així que no és recomanable que puges aquest arxiu a git.\nSentències preparades\nEs tracta de sentències que s'estableixen com si foren plantilles de la SQL que llançarem, acceptant paràmetres que són establits a posteriori de la declaració de la sentència preparada.\nLes sentències preparades eviten la injecció de SQL (SQL Injection) i milloren el rendiment de nostres aplicacions o pàgines web.\n&lt;?php\n$sql = &quot;INSERT INTO Clientes VALUES (?, ?, ?, ?)&quot;;\n\nCada interrogant és un paràmetre que establirem després, unes quantes línies més a baix.\nUna vegada tenim la plantilla de la nostra consulta, hem de seguir amb la preparació juntament amb 3 mètodes més de PHP per a la seua completa execució:\n\nprepare: prepara la sentencia abans de ser executada.\nbind: el tipus d'unió (*bind^) de dada que pot ser mitjançant ' ? ' o ' :parametre '\nexecute s'executa la consulta unint la plantilla amb les variables o paràmetres que hem establit.\n\nExemple paràmetros\n&lt;?php\n\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion = null;\n\ntry {\n$cantidad = $_GET[&quot;cantidad&quot;];\n\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;DELETE FROM stock WHERE unidades = ?&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n$isOk = $sentencia -&gt; execute([$cantidad]);\n$cantidadAfectada = $sentencia -&gt; rowCount();\n\necho $cantidadAfectada;\n} catch (PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null\n\nExemple bindParam\nMolt semblant a utilitzar paràmetres però aquesta vegada la variable està dins de la sentència SQL, en aquest cas l'hem anomenada :cant\n&lt;?php\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion=null;\n\ntry {\n$cantidad = $_GET[&quot;cantidad&quot;] ?? 0;\n\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;DELETE FROM stock WHERE unidades = :cant&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; bindParam(&quot;:cant&quot;, $cantidad);\n\n$isOk = $sentencia -&gt; execute();\n\n$cantidadAfectada = $sentencia -&gt; rowCount();\n\necho $cantidadAfectada;\n} catch (PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null;\n\nbindParam VS bindValue\nUtilitzarem bindValue() quan hàgem d'inserir dades només una vegada, en canvi, haurem d'usar bindParam() quan hàgem de passar dades múltiples, com per exemple, un array.\n&lt;?php\n// se asignan nombre a los parámetros\n$sql = &quot;DELETE FROM stock WHERE unidades = :cant&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n// bindParam enlaza por referencia\n$cantidad = 0;\n\n$sentencia -&gt; bindParam(&quot;:cant&quot;, $cantidad);\n$cantidad = 1;\n\n// se eliminan con cant = 1\n$isOk = $sentencia -&gt; execute();\n\n// bindValue enlaza por valor\n$cantidad = 0;\n\n$sentencia -&gt; bindValue(&quot;:cant&quot;, $cantidad);\n$cantidad = 1;\n\n// se eliminan con cant = 0\n$isOk = $sentencia-&gt;execute();\n\nPer a més informació i ús de les variables PDO consulta el manual de PHP.\nInserint registres\nA l'hora d'inserir registres en una base de dades, hem de tindre en compte que en la taula pot haver-hi valors autoincrementats. Per a salvaguardar açò, el que hem de fer és deixar aqueix camp autoincrementat buit, però a l'hora de fer la connexió, hem de recuperar-ho amb el mètode lastInsertId().\n&lt;?php\n$nombre = $_GET[&quot;nombre&quot;] ?? &quot;SUCURSAL X&quot;;\n$telefono = $_GET[&quot;telefono&quot;] ?? &quot;636123456&quot;;\n\n$sql=&quot;INSERT INTO tienda(nombre, tlf) VALUES (:nombre, :telefono)&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; bindParam(&quot;:nombre&quot;, $nombre);\n$sentencia -&gt; bindParam(&quot;:telefono&quot;, $telefono);\n\n$isOk = $sentencia -&gt; execute();\n$idGenerado = $conexion -&gt; lastInsertId();\n\necho $idGenerado;\n\nConsultant registres\nA l'hora de recuperar els resultats d'una consulta, bastarà amb invocar al mètode PDOStatement::fetch per a llistar les files generades per la consulta.\nPerò hem de triar el tipus de dada que volem rebre entre els 3 que hi ha disponibles:\n\nPDO::FETCH_ASSOC: array indexat que els seus keys són el nom de les columnes.\nPDO::FETCH_NUM: array indexat que els seus keys són números.\nPDO::FETCH_BOTH: valor per defecte. Retorna un array indexat que els seus keys són tant el nom de les columnes com números.\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con array asociativo.php ▒▒▒▒▒▒▒▒\n\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion = null;\n\ntry{\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;select * from tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_ASSOC);\n$sentencia -&gt; execute();\n\nwhile($fila = $sentencia -&gt; fetch()){\necho &quot;Codigo:&quot; . $fila[&quot;cod&quot;] . &quot;&lt;br /&gt;&quot;;\necho &quot;Nombre:&quot; . $fila[&quot;nombre&quot;] . &quot;&lt;br /&gt;&quot;;\necho &quot;Teléfono:&quot; . $fila[&quot;tlf&quot;] . &quot;&lt;br /&gt;&quot;;\n}\n\n}catch(PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null;\n\nRecuperant dades amb una matriu com a resultat de la nostra consulta\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con array asociativo ▒▒▒▒▒▒▒▒\n\n$sql=&quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_ASSOC);\n$sentencia -&gt; execute();\n\n$tiendas = $sentencia -&gt; fetchAll();\n\nforeach($tiendasas$tienda) {\necho&quot;Codigo:&quot; . $tienda[&quot;cod&quot;] . &quot;&lt;br /&gt;&quot;;\necho&quot;Nombre:&quot; . $tienda[&quot;nombre&quot;] . &quot;&lt;br /&gt;&quot;;\n}\n\nPerò si el que volem és llegir dades amb forma d'objecte utilitzant PDO::FETCH_OBJ, hem de crear un objecte amb propietats públiques amb el mateix nom que les columnes de la taula que anem a consultar.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con formato de objeto ▒▒▒▒▒▒▒▒\n\n$sql=&quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_OBJ);\n$sentencia -&gt; execute();\n\nwhile($t = $sentencia -&gt; fetch()) {\necho&quot;Codigo:&quot; . $t -&gt; cod . &quot;&lt;br /&gt;&quot;;\necho&quot;Nombre:&quot; . $t -&gt; nombre . &quot;&lt;br /&gt;&quot;;\necho&quot;Teléfono:&quot; . $t -&gt; tlf . &quot;&lt;br /&gt;&quot;;\n}\n\nConsultes amb models\nPortem temps creant classes en PHP i les consultes també admeten aquest tipus de dades mitjançant l'ús de PDO::FETCH_CLASS\nSi usem aquest mètode, hem de tindre en compte que els noms dels atributs privats han de coincidir amb els noms de les columnes de la taula que anem a manejar.\nAixí doncs, si pel que siga canviem l'estructura de la taula HEM DE CANVIAR la nostra classe perquè tot continue funcionant.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ clase Tienda ▒▒▒▒▒▒▒▒\n\nclassTienda {\nprivate int $cod;\nprivate string $nombre;\nprivate ? string $tlf;\n\npublic function getCodigo() : int {\nreturn $this -&gt; cod;\n}\n\npublic function getNombre() : string {\nreturn $this -&gt; nombre;\n}\n\npublic function getTelefono() : ?string {\nreturn $this -&gt; tlf;\n}\n}\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Consultando a través de la clase Tienda ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n// Aquí 'Tienda' es el nombre de nuestra clase\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS, Tienda::class);\n$sentencia -&gt; execute();\n\nwhile($t = $sentencia -&gt; fetch()) {\necho &quot;Codigo: &quot; . $t -&gt; getCodigo() . &quot;&lt;br /&gt;&quot;;\necho &quot;Nombre: &quot; . $t -&gt; getNombre() . &quot;&lt;br /&gt;&quot;;\necho &quot;Teléfono: &quot; . $t -&gt; getTelefono() . &quot;&lt;br /&gt;&quot;;\n\nvar_dump($t);\n}\n\nPerò què passa si les nostres classes tenen constructor? doncs que hem d'indicar-li, al mètode FECTH, que emplene les propietats després de cridar al constructor i per a això fem ús de PDO::FETCH_PROPS_LATE.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Consulta para una clase con constructor ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, Tienda::class);\n$sentencia -&gt; execute();\n\n$tiendas = $sentencia -&gt; fetchAll();\n\nConsultes amb LIKE\nPer a utilitzar el comodí LIKE o altres comodins, hem d'associar-lo a la dada i MAI en la pròpia consulta.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Utilizando comodines :: LIKE ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda where nombre like :nombre or tlf like :tlf&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, Tienda::class);\n\n$cadBuscar = &quot;%&quot; . $busqueda . &quot;%&quot;;\n\n$sentencia -&gt; execute([&quot;nombre&quot; =&gt; $cadBuscar,&quot;tlf&quot; =&gt; $cadBuscar]);\n\n$result = $sentencia -&gt; fetchAll();\n\nTeniu una llista d'exemples molt completa en la documentació oficial.",
		"tags": [ "note"]
},

{
		"title": "4. Login & Password",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/4. Login &amp; Password/",
		"content": "Per a manejar un sistema complet de login i password amb contrasenyes xifrades, necessitem un mètode que xifre aqueixos strings que l'usuari introdueix com a contrasenya; tant en el formulari de registre com en el del login, ja que en codificar una contrasenya, després hem de descodificar-la per a comprovar que totes dues *contrasenyes (la que introdueix l'usuari en el login i la que tenim en la base de dades) coincidisquen.\nNecessitem doncs:\n\npassword_hash() per a emmagatzemar la contrasenya en la base de dades a l'hora de fer el INSERT\n\nPASSWORD_DEFAULT emmagatzemem la contrasenya usant el mètode d'encriptació bcrypt\n\nPASSWORD_BCRYPT emmagatzemem la contrasenya usant l'algorisme CRYPT_BLOWFISH compatible amb crypt()\n\npassword_verify() per a verificar l'usuari i la contrasenya\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Almacenando usuario y password en BD ▒▒▒▒▒▒▒▒\n\n$usu = $_POST[&quot;usuario&quot;];\n$pas = $_POST[&quot;password&quot;];\n\n$sql = &quot;INSERT INTO usuarios(usuario, password) VALUES (:usuario, :password)&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n\n$isOk = $sentencia -&gt; execute([\n&quot;usuario&quot; =&gt; $usu,\n&quot;password&quot; =&gt; password_hash($pas,PASSWORD_DEFAULT)\n]);\n\nAra que tenim l'usuari codificat i guardat en la base de dades, el recuperarem per a poder loguejar-lo correctament.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Recuperando usuario y password en BD ▒▒▒▒▒▒▒▒\n\n$usu = $_POST[&quot;login&quot;] ?? &quot;&quot;;\n\n$sql = &quot;select * from usuarios where usuario = ?&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; execute([$usu]);\n\n$usuario = $sentencia -&gt; fetch();\n\nif($usuario &amp;&amp; password_verify($_POST['pass'], $usuario['password'])) {\necho&quot;OK!&quot;;\n} else {\necho&quot;KO&quot;;\n}",
		"tags": [ "note"]
},

{
		"title": "5. QueryBuilder",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/5. QueryBuilder/",
		"content": "Un Query Builder (Constructor de Consultes) és una eina o classe que facilita la creació, execució i manipulació de consultes SQL en un programa. L'objectiu principal és proporcionar una interfície més intuïtiva i segura per interactuar amb bases de dades, sense haver d'escriure consultes SQL en brut.\nA continuació, detallo algunes de les principals avantatges i característiques d'un Query Builder com el que has compartit anteriorment:\n\nAbstracció de la Base de Dades:\n\nEl Query Builder proporciona una capa d'abstracció que permet interactuar amb diferents tipus de bases de dades (MySQL, PostgreSQL, SQLite, etc.) sense canviar el codi de la teva aplicació. Això facilita la portabilitat i l'escalabilitat del codi.\n\nSeguretat:\n\nPrevé injeccions SQL: Gràcies a l'ús de sentències preparades i enllaçament de paràmetres, el Query Builder ajuda a prevenir atacs d'injecció SQL, una de les amenaces més comunes en desenvolupament web.\n\nSintaxi Més Neta i Més Fàcil:\n\nEls Query Builders solen proporcionar una sintaxi més neta i fàcil d'entendre que les cadenes SQL pures. Això fa que el codi sigui més llegible i fàcil de mantenir.\n\nReutilització de Codi:\n\nLes funcions del Query Builder es poden reutilitzar a tot el projecte, reduint la duplicació de codi i facilitant el manteniment.\n\nFlexibilitat:\n\nPermet realitzar consultes complexes amb una sintaxi simplificada, facilitant l'adaptació del codi a canvis en els requeriments de l'aplicació.\n\nDesenvolupament Més Ràpid:\n\nAjuda a accelerar el procés de desenvolupament, ja que els desenvolupadors no necessiten recordar la sintaxi SQL exacta per a cada tipus de base de dades.\n\nFàcil de Depurar:\n\nEl codi generat pel Query Builder és més fàcil de depurar en comparació amb les llargues cadenes SQL.\n\nSuport per a Operacions CRUD:\n\nEls Query Builders solen incloure suport integrat per a operacions CRUD (Crear, Llegir, Actualitzar, Esborrar), fent més fàcil la manipulació de dades.\n\nEn resum, un Query Builder serveix per simplificar la interacció amb bases de dades, proporcionant una interfície més segura, neta i fàcil d'utilitzar que les cadenes SQL pures. Ajuda a accelerar el desenvolupament, facilita el manteniment i millora la seguretat de l'aplicació.\nAcí en tenim un exemple de construcció casera:\n&lt;?php\n\nnamespace BatBook;\n\nuse PDO;\n\nclass QueryBuilder\n{\n// Aquesta funció serveix per a construir i executar consultes SQL de tipus SELECT.\n// Es pot filtrar per valors, limitar la quantitat de resultats i establir un offset.\npublic static function sql($class, $values=null, $limit = null, $offset = null)\n{\n// Obté el nom de la taula a partir de la propietat estàtica $nameTable de la classe passada com argument.\n$table = $class::$nameTable;\n\n// Obté una connexió a la base de dades.\n$conn = Connection::get();\n\n// Construeix la consulta SQL bàsica.\n$sql = &quot;SELECT * FROM $table&quot;;\n\n// Afegeix condicions WHERE si es proporcionen valors per a filtrar.\nif ($values) {\n$sql .= &quot; WHERE &quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= &quot; AND $id=:$id&quot;;\n} else {\n$sql .= &quot;$id=:$id&quot;;\n}\n}\n}\n\n// Afegeix les clàusules LIMIT i OFFSET si són necessàries.\nif (isset($limit) &amp;&amp; isset($offset)) {\n$sql .= &quot; LIMIT $limit OFFSET $offset&quot;;\n}\n\n// Prepara la sentència SQL.\n$sentence = $conn-&gt;prepare($sql);\n\n// Enllaça els valors a la sentència.\nforeach ($values??[] as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n\n// Estableix el mode de recuperació a objectes de la classe especificada.\n$sentence -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE , $class);\n\n// Executa la consulta.\n$sentence -&gt; execute();\n\n// Retorna tots els resultats obtinguts.\nreturn $sentence-&gt;fetchAll();\n}\n\n// Aquesta funció serveix per a trobar una fila en una taula basant-se en el seu ID.\npublic static function find($class, $id)\n{\n//TODO\n}\n\n// Aquesta funció serveix per a insertar una fila en una taula.\npublic static function insert($class, $values)\n{\n$table = $class::$nameTable;\n$conn = Connection::get();\n$sql = &quot;INSERT INTO $table (&quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= ','.$id;\n} else {\n$sql .= $id;\n}\n}\n$sql .= &quot;) VALUES (&quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= ',:'.$id;\n} else {\n$sql .= ':'.$id;\n}\n}\n$sql .= &quot;)&quot;;\n$sentence = $conn-&gt;prepare($sql);\nforeach ($values as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n$sentence -&gt; execute();\nreturn $conn-&gt;lastInsertId();\n}\n\n// Aquesta funció serveix per a actualitzar una fila en una taula.\npublic static function update($class, $values, $id)\n{\n$table = $class::$nameTable;\n$conn = Connection::get();\n$sql = &quot;UPDATE $table SET &quot;;\nforeach (array_keys($values) as $key =&gt; $value) {\nif ($key != 0) {\n$sql .= ','.$value.'=:'.$value;\n} else {\n$sql .= $value.'=:'.$value;\n}\n}\n$sql .= &quot; WHERE id=:id&quot;;\n$sentence = $conn-&gt;prepare($sql);\nforeach ($values as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n$sentence-&gt;bindValue(&quot;:id&quot;, $id);\n$sentence -&gt; execute();\nreturn $id;\n}\n\n// Aquesta funció serveix per a eliminar una fila en una taula basant-se en el seu ID.\npublic static function delete($class, $id)\n{\n//TODO\n}\n}\n\nEn resum, aquesta classe proporciona funcions estàtiques per a la construcció i execució de consultes SQL bàsiques com SELECT, INSERT, UPDATE, i DELETE. Utilitza l'extensió PDO per a la connexió a bases de dades i la preparació de sentències SQL, la qual cosa ajuda a prevenir injeccions SQL. També permet la manipulació fàcil de files en bases de dades, tot retornant objectes de la classe especificada.\nRespotes d'error\nQuan no trebem un recurs en al nostra web, podem mostrar a l'usuari una pàgina específica d'error utilitzant la funció header. Una típica seria:\n&lt;!-- not-found.php --&gt;\n&lt;?php http_response_code(404); ?&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;No trobat&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;404 - Pàgina no trobada&lt;/h1&gt;\n&lt;p&gt;Ho sentim, la pàgina que estàs buscant no s'ha pogut trobar.&lt;/p&gt;\n&lt;a href=&quot;index.php&quot;&gt;Torna a l'inici&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nI per a utilitzar-la:\n&lt;?php\nheader(&quot;Location: not-found.php&quot;);\nexit;\n?&gt;",
		"tags": [ "note"]
},

{
		"title": "6. Accès a fitxers",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/6. Accès a fitxers/",
		"content": "Gràcies a la funció fopen() des de PHP podem obrir arxius que es troben en els nostres servidor o una URL.\nA aquesta funció cal passar-li 2 paràmetres; el nom de l'arxiu que volem obrir i la manera en què s'obrirà\n$fp = fopen(&quot;miarchivo.txt&quot;, &quot;r&quot;);\n\nMoltes vegades no podem obrir l'arxiu perquè aquest no es troba o no tenim accés a ell, per això és recomanable comprovar que podem fer-ho\nif (!$fp = fopen(&quot;miarchivo.txt&quot;, &quot;r&quot;)){\necho &quot;No se ha podido abrir el archivo&quot;;\n}\n\nManeres d'obertura de fitxers\n\nr: Manera lectura. Punter al principi de l'arxiu.\nr+: Obertura per a lectura i escriptura. Punter al principi de l'arxiu\nw: Obertura per a escriptura. Punter al principi de l'arxiu i el sobreescriu. Si no existeix s'intenta crear.\nw+: Obertura per a lectura i escriptura. Punter al principi de l'arxiu i el sobreescriu. Si no existeix s'intenta crear.\na: Obertura per a escriptura. Punter al final de l'arxiu. Si no existeix s'intenta crear.\na+: Obertura per a lectura i escriptura. Punter al final de l'arxiu. Si no existeix s'intenta crear.\nx: Creació i obertura per a només escriptura. Punter al principi de l'arxiu. Si l'arxiu ja existeix donarà error E_*WARNING. Si no existeix s'intenta crear.\nx+: Creació i obertura per a lectura i escriptura. Mateix comportament que x.\nc: Obertura per a escriptura. Si no existeix es crea. Si existeix no se sobreescriu ni dona cap error. Punter al principi de l'arxiu.\nc+: Obertura per a lectura i escriptura. Mateix comportament que C.\nb: Quan es treballa amb arxius binaris com *jpg, pdf, *png i altres. Se sol col·locar al final de la manera, és a dir *rb, r+b, x+b, *wb...\n\nOperacions amb arxius\nPer a poder llegir un arxiu necessitem usar la funció fread() de PHP\n// ▒▒▒▒▒▒▒▒ Abriendo un archivo y leyendo su contenido ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$fp = fopen($file, &quot;r&quot;);\n\n// filesize() nos devuelve el tamaño del archivo en cuestión\n$contents = fread($fp, filesize($file));\n\n// Cerramos la conexión con el archivo\nfclose();\n\nSi el que volem és escriure en un arxiu, haurem de fer ús de la funció fwrite()\n// ▒▒▒▒▒▒▒▒ Escribiendo en un archivo ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$texto = &quot;Hola que tal&quot;;\n\n$fp = fopen($file, &quot;w&quot;);\n\nfwrite($fp, $texto);\nfclose($fp);\n\nInformació d'un fitxer\nAmb PHP i el seu mètode stat() podem obtindre informació sobre els arxius que li indiquem. Aquest mètode retorna fins a un total de 12 elements amb informació sobre el nostre arxiu.\n\ndev\t número de dispositiu\nino\t número d'i-node\nmode\t manera de protecció de l'i-node\nnlink\t nombre d'enllaços\nuid\t ID d'usuari del propietari\ngid\t ID de grup del propietari\nrdev\t tipus de dispositiu, si és un dispositiu i-node\nsize\t grandària en bytes\natime\t moment de l'últim accés (temps Unix)\nmtime\t moment de l'última modificació (temps Unix)\nctime\t moment de l'última modificació de l'i-node (temps Unix)\nblksize\t grandària del bloc E/S del sistema de fitxers\nblocks\t nombre de blocs de 512 bytes assignats\n\nUns exemples...\n&lt;?php\n\n// ▒▒▒▒▒▒▒▒ Información del archivo ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$texto = &quot;Todos somos muy ignorantes, lo que ocurre es que no todos ignoramos las mismas cosas.&quot;;\n\n$fp = fopen($file, &quot;w&quot;);\nfwrite($fp, $texto);\n\n$datos = stat($file);\n\necho $datos[3] . &quot;&lt;br&gt;&quot;; // Número de enlaces, 1\necho $datos[7] . &quot;&lt;br&gt;&quot;; // Tamaño en bytes, 85\necho $datos[8] . &quot;&lt;br&gt;&quot;; // Momento de último acceso, 1444138104\necho $datos[9] . &quot;&lt;br&gt;&quot;; // Momento de última modificación, 1444138251\n\n?&gt;\n\nDona una ullada a les funcions de directoris que té PHP, és molt interessant.",
		"tags": [ "note"]
},

{
		"title": "7. Web Scraping",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/5. Acceso a datos/7. Web Scraping/",
		"content": "Consisteix a navegar a una pàgina web i extraure informació automàticament, a partir del codi HTML generat, i organitzar la informació pública disponible en Internet.\nAquesta pràctica requereix l'ús d'una llibreria que facilite la descàrrega de la informació desitjada imitant la interacció d'un navegador web. Aquest &quot;robot&quot; pot accedir a diverses pàgines simultàniament.\n\n[!question] &quot;¿És legal?&quot;\nSi el lloc web indica que té el contingut protegit per drets d'autor o en les normes d'accés via usuari/contrasenya ens avisa de la seua prohibició, estaríem incorrent en un delicte.\nÉs recomanable estudiar l'arxiu robots.txt que es troba en l'arrel de cada lloc web.\nMés informació en l'article El manual complet per al web scraping legal i ètic en 2021\n\nGoutte\nGoutte és un senzill client HTTP per a PHP creat específicament per a fer web scraping. Ho va desenvolupar el mateix autor del framework Symfony i ofereix un API senzilla per a extraure dades de les respostes HTML/XML dels llocs web.\nEls components principals que abstrau Goutte sobre Symfony són:\n\nBrowserKit: simula el comportament d'un navegador web.\nCssSelector: tradueix consultes CSS en consultes XPath.\nDomCrawler: facilita l'ús del DOM i XPath.\n\nPer a poder utilitzar Goutte en el nostre projecte, executarem el següent comando en el terminal:\ncomposer require fabpot/goutte\n\nGoutte con selectores CSS\nA continuació farem un exemple molt senzill utilitzant els selectors CSS, extraient informació de la web https://books.toscrape.com/, la qual és una pàgina per a proves que no rebutjarà les nostres peticions.\nDesprés de crear un client amb Goutte, hem de realitzar un petició a una URL. Amb la resposta obtinguda, podem utilitzar el mètode filter per a indicar-li la ruta CSS que volem recórrer i iterar sobre els resultats mitjançant una funció anònima. Una vegada estem dins d'un determinat node, el mètode text() ens retornarà el contingut del propi node.\nEn concret, ficarem en un array associatiu el títol i el preu de tots els llibres de la categoria Classics.\n&lt;?php\nrequire '../vendor/autoload.php';\n\n$httpClient = new \\Goutte\\Client();\n$response = $httpClient-&gt;request('GET', 'https://books.toscrape.com/catalogue/category/books/classics_6/index.html');\n// colocamos los precios en un array\n$precios = [];\n$response-&gt;filter('.row li article div.product_price p.price_color')-&gt;each(\n// le pasamos $precios por referencia para poder editarla dentro del closure\nfunction ($node) use (&amp;$precios) {\n$precios[] = $node-&gt;text();\n}\n);\n\n// colocamos el nombre y el precio en un array asociativo\n$contadorPrecios = 0;\n$libros = [];\n$response-&gt;filter('.row li article h3 a')-&gt;each(\nfunction ($node) use ($precios, &amp;$contadorPrecios, &amp;$libros) {\n$libros[$node-&gt;text()] = $precios[$contadorPrecios];\n$contadorPrecios++;\n}\n);\n\nCrawler\nUn cas molt comú és obtindre la informació d'una pàgina que té els resultats paginados, de manera que anem recorrent els enllaços i accedint a cadascun dels resultats.\nEn aquest cas agafarem tots els preus dels llibres de fantasia, i els sumarem:\n&lt;?php\nrequire '../vendor/autoload.php';\n\nuse Goutte\\Client;\nuse Symfony\\Component\\HttpClient\\HttpClient;\n\n$client = new Client(HttpClient::create(['timeout' =&gt; 60]));\n$crawler = $client-&gt;request('GET', 'https://books.toscrape.com/catalogue/category/books/fantasy_19/index.html');\n\n$salir = false;\n\n$precios = [];\nwhile (!$salir) {\n$crawler-&gt;filter('.row li article div.product_price p.price_color')-&gt;each(\nfunction ($node) use (&amp;$precios) {\n$texto = $node-&gt;text();\n$cantidad = substr($texto, 2); // Le quitamos las libras ¿2 posiciones?\n$precios[] = floatval($cantidad);\n}\n);\n\n$enlace = $crawler-&gt;selectLink('next');\nif ($enlace-&gt;count() != 0) {\n// el enlace next existe\n$sigPag = $crawler-&gt;selectLink('next')-&gt;link();\n$crawler = $client-&gt;click($sigPag); // hacemos click\n} else {\n// ya no hay enlace next\n$salir = true;\n}\n}\n\n$precioTotal = array_sum($precios);\necho $precioTotal;",
		"tags": [ "note"]
},

{
		"title": "1. Introducció",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/1. Introducció/",
		"content": "Laravel és un framework PHP modern que simplifica el desenvolupament d'aplicacions web, incloent-hi la gestió de bases de dades. La integració amb Eloquent, el seu ORM (Object-Relational Mapping), permet treballar amb bases de dades de forma intuïtiva i eficient.",
		"tags": [ "note"]
},

{
		"title": "2. Configuració inicial",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/2. Configuració inicial/",
		"content": "Laravel suporta diversos motors de bases de dades com MySQL, PostgreSQL, SQLite i SQL Server. La configuració principal es fa al fitxer .env i config/database.php.\nExemple de configuració al fitxer .env:\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=nom_base_de_dades\nDB_USERNAME=usuari\nDB_PASSWORD=contrasenya\n\nComprovació de connexió:\nDesprés de configurar el .env, utilitza el comandament:\nphp artisan migrate:status\n\nAquest comandament confirma si Laravel pot connectar-se a la base de dades configurada.\nDetecció de problemes comuns\n\nComprovar que l'extensió del driver de la base de dades (com pdo_mysql o pdo_pgsql) estigui habilitada al php.ini.\nUtilitzar php artisan config:clear per esborrar la memòria cau de configuracions si els canvis al .env no es reflecteixen.",
		"tags": [ "note"]
},

{
		"title": "3. Migracions en Laravel",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/3. Migracions en Laravel/",
		"content": "Introducció\nLes migracions són un sistema de control de versions per a bases de dades que permet treballar de manera col·laborativa, mantenint un històric dels canvis realitzats en l'esquema. Amb migracions, pots:\n\nCrear, modificar i esborrar taules.\nGestionar l'esquema de manera programàtica utilitzant Artisan i el Schema Builder.\nRevertir canvis mitjançant rollback o tornar a aplicar tots els canvis amb refresh.\n\nLaravel proporciona un conjunt d'eines intuïtives per gestionar migracions, com Artisan i la classe Schema.\nEstructura de les migracions\nTotes les migracions es guarden a la carpeta database/migrations i segueixen una estructura predefinida amb dos mètodes principals:\n\nup: Defineix les operacions que s'han d'aplicar a la base de dades (crear taules, afegir columnes, etc.).\ndown: Defineix les operacions inverses per revertir els canvis aplicats per up.\n\nExemple bàsic:\npublic function up()\n{\nSchema::create('usuarios', function (Blueprint $tabla) {\n$tabla-&gt;id();\n$tabla-&gt;string('nombre');\n$tabla-&gt;string('email')-&gt;unique();\n$tabla-&gt;timestamps();\n});\n}\n\npublic function down()\n{\nSchema::dropIfExists('usuarios');\n}\n\nPer defecte, Laravel afegeix un camp autonumèric id i dues columnes timestamps (created_at i updated_at) gestionades automàticament.\nCrear una migració\nUtilitza Artisan per crear una nova migració:\nphp artisan make:migration nom_migracio\n\nAquest comando genera un fitxer amb un nom que inclou un timestamp per assegurar l'ordre cronològic.\nExemples\n\nCrear una taula:\n\nphp artisan make:migration crear_tabla_usuarios --create=usuarios\n\nModificar una taula existent:\n\nphp artisan make:migration afegir_camp_a_usuarios --table=usuarios\n\nLaravel pot inferir accions del nom de la migració gràcies a la classe TableGuesser. Per exemple, si el nom conté create o to, Artisan deduirà si és per crear o modificar taules.\nSchema Builder\nLa classe Schema és el nucli per definir i modificar l'esquema de les bases de dades. Inclou constructors per crear, modificar i eliminar taules i columnes.\nCrear una taula\nSchema::create('users', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('username', 32);\n$table-&gt;timestamps();\n});\n\nEliminar una taula\nSchema::dropIfExists('users');\n\nAfegir columnes\nSchema::table('usuarios', function (Blueprint $table) {\n$table-&gt;string('telefono')-&gt;after('email')-&gt;nullable();\n});\n\nEliminar columnes\nSchema::table('usuarios', function (Blueprint $table) {\n$table-&gt;dropColumn('telefono');\n});\n\nTipus de columnes disponibles\nLaravel ofereix una àmplia varietat de tipus de columnes per satisfer diferents necessitats\nÍndexs i claus forànies\nCrear índexs\n$table-&gt;unique('email');\n$table-&gt;index('state');\n$table-&gt;primary(['first_name', 'last_name']);\n\nDefinir claus forànies\n$table-&gt;foreignId('user_id')-&gt;constrained()-&gt;onDelete('cascade');\n\nExecutar i revertir migracions\n\nExecutar migracions pendents:\n\nphp artisan migrate\n\nRevertir l'última migració:\n\nphp artisan migrate:rollback\n\nRevertir totes les migracions:\n\nphp artisan migrate:reset\n\nRefrescar totes les migracions:\n\nphp artisan migrate:refresh\n\nComprovar l'estat de les migracions:\n\nphp artisan migrate:status\n\nAquest conjunt de comandes permet un control complet sobre l'estat de les migracions durant el desenvolupament.",
		"tags": [ "note"]
},

{
		"title": "4. Laravel Query Builder",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/4. Laravel Query Builder/",
		"content": "El Query Builder de Laravel proporciona una interfície fluida per construir i executar consultes de bases de dades. Permet treballar amb diverses bases de dades de manera senzilla sense escriure SQL brut.\n\nExemples d'ús\nObtenir tots els registres:\n$users = DB::table('users')-&gt;get();\n\nFiltrar registres:\n$users = DB::table('users')\n-&gt;where('active', 1)\n-&gt;get();\n\nSeleccionar columnes específiques:\n$users = DB::table('users')\n-&gt;select('name', 'email')\n-&gt;get();\n\nOrdenar resultats:\n$users = DB::table('users')\n-&gt;orderBy('name', 'asc')\n-&gt;get();\n\nComptar registres:\n$count = DB::table('users')-&gt;count();\n\nConsultes amb agregats:\n$maxSalary = DB::table('employees')-&gt;max('salary');\n\nConsultes amb subconsultes:\n$users = DB::table('users')\n-&gt;whereExists(function ($query) {\n$query-&gt;select(DB::raw(1))\n-&gt;from('orders')\n-&gt;whereColumn('orders.user_id', 'users.id');\n})\n-&gt;get();\n\nUnions:\n$first = DB::table('users')-&gt;where('type', 'admin');\n$second = DB::table('users')-&gt;where('type', 'customer');\n\n$users = $first-&gt;union($second)-&gt;get();\n\nInserir un registre:\nDB::table('users')-&gt;insert([\n'name' =&gt; 'John Doe',\n'email' =&gt; 'john@example.com',\n]);\n\nActualitzar un registre:\nDB::table('users')\n-&gt;where('id', 1)\n-&gt;update(['name' =&gt; 'Updated Name']);\n\nEsborrar un registre:\nDB::table('users')\n-&gt;where('id', 1)\n-&gt;delete();\n\nEsborrar tots els registres:\nDB::table('users')-&gt;truncate();\n\nAvantatges\nEl Query Builder és ideal per a:\n\nConsultes personalitzades on el rendiment és una prioritat.\nConsultes complexes que no es poden expressar fàcilment amb Eloquent.",
		"tags": [ "note"]
},

{
		"title": "5. Laravel Eloquent",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/5. Laravel Eloquent/",
		"content": "Eloquent és l'ORM (Object-Relational Mapping) de Laravel. Proporciona una interfície senzilla i elegant per treballar amb bases de dades relacionals mitjançant models.\nDefinició de Models\nEls models es defineixen dins de la carpeta app/Models i es poden crear mitjançant Artisan:\nphp artisan make:model Movie\n\nExemple bàsic:\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Movie extends Model\n{\n// Taula associada al model\nprotected $table = 'movies';\n}\n\nPer defecte:\n\nEl model s'associa a una taula plural (movies per al model Movie).\nUtilitza id com a clau primària.\nAssumeix l'ús de camps created_at i updated_at gestionats automàticament.\n\nÚs bàsic d'un model\nRecuperar dades:\n\nTots els registres:\n\n$movies = Movie::all();\n\nRegistres filtrats:\n\n$movies = Movie::where('rating', '&gt;', 4)-&gt;get();\n\nRegistre únic:\n\n$movie = Movie::findOrFail($id);\n\nInserir dades:\n$movie = new Movie();\n$movie-&gt;title = &quot;Inception&quot;;\n$movie-&gt;director = &quot;Christopher Nolan&quot;;\n$movie-&gt;save();\n\nActualitzar dades:\n$movie = Movie::find($id);\n$movie-&gt;title = &quot;Updated Title&quot;;\n$movie-&gt;save();\n\nEsborrar dades:\n$movie = Movie::find($id);\n$movie-&gt;delete();\n\nPropietats comuns dels Models Eloquent\nEls models d'Eloquent ofereixen diverses propietats que permeten configurar el comportament de la interacció amb la base de dades. A continuació es detallen les més importants:\n&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Example extends Model\n{\n// Especifica el nom de la taula si no segueix la convenció per defecte\nprotected $table = 'custom_table_name';\n\n// Defineix la clau primària de la taula\nprotected $primaryKey = 'custom_id';\n\n// Indica si la clau primària és autoincremental\npublic $incrementing = false;\n\n// Especifica el tipus de la clau primària (per exemple, string si no és integer)\nprotected $keyType = 'string';\n\n// Defineix quins camps poden ser assignats massivament\nprotected $fillable = ['name', 'email', 'password'];\n\n// Defineix quins camps no poden ser assignats massivament\nprotected $guarded = ['is_admin'];\n\n// Oculta camps quan es converteix a JSON o arrays\nprotected $hidden = ['password', 'remember_token'];\n\n// Defineix quins camps són visibles quan es converteix a JSON o arrays\nprotected $visible = ['name', 'email'];\n\n// Transformació automàtica de camps a un tipus específic\nprotected $casts = [\n'is_admin' =&gt; 'boolean',\n'settings' =&gt; 'array',\n];\n\n// Indica si la taula té els camps `created_at` i `updated_at`\npublic $timestamps = true;\n\n// Defineix la connexió a la base de dades\nprotected $connection = 'mysql';\n}\n\nRelacions en Eloquent\n1. Un a un (One-to-One):\nUn usuari té un perfil:\nclass User extends Model\n{\npublic function profile()\n{\nreturn $this-&gt;hasOne(Profile::class);\n}\n}\n\n$user = User::find(1);\n$profile = $user-&gt;profile;\n\n2. Un a molts (One-to-Many):\nUn autor té molts llibres:\nclass Author extends Model\n{\npublic function books()\n{\nreturn $this-&gt;hasMany(Book::class);\n}\n}\n\n$author = Author::find(1);\n$books = $author-&gt;books;\n\n3. Molts a molts (Many-to-Many):\nUn usuari té molts rols:\nclass User extends Model\n{\npublic function roles()\n{\nreturn $this-&gt;belongsToMany(Role::class);\n}\n}\n\n$user = User::find(1);\n$roles = $user-&gt;roles;\n\n4. Has Many Through (Relacions transitives):\nPermet accedir a dades relacionades a través d'un altre model.\nclass Country extends Model\n{\npublic function posts()\n{\nreturn $this-&gt;hasManyThrough(Post::class, User::class);\n}\n}\n\nEager Loading (Càrrega eficient de relacions)\nPer evitar múltiples consultes a la base de dades, pots carregar relacions amb with:\n$authors = Author::with('books')-&gt;get();\n\nCol·leccions i Agrupacions\nEloquent retorna col·leccions per defecte, que permeten treballar amb mètodes\nMutators i Accessors\nEls mutators permeten transformar dades abans de guardar-les, i els accessors les transformen en recuperar-les.\nExemple:\nclass User extends Model\n{\n// Accessor\npublic function getFullNameAttribute()\n{\nreturn &quot;{$this-&gt;first_name} {$this-&gt;last_name}&quot;;\n}\n\n// Mutator\npublic function setPasswordAttribute($value)\n{\n$this-&gt;attributes['password'] = bcrypt($value);\n}\n}\n\nÚs:\n$user = User::find(1);\n$fullName = $user-&gt;full_name;\n\n$user-&gt;password = 'new_password';\n$user-&gt;save();\n\nPaginació\nLaravel facilita la paginació:\n$movies = Movie::paginate(10);\n\nEn la vista:\n{{ $movies-&gt;links() }}",
		"tags": [ "note"]
},

{
		"title": "6. Seeders i Factories en Laravel",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/6. Seeders i Factories en Laravel/",
		"content": "Els seeders i factories permeten generar dades de prova de manera fàcil i ràpida, útils durant el desenvolupament per simular dades inicials en una aplicació.\n\nSeeders\nEls seeders són classes especials que permeten &quot;sembrar&quot; dades a la base de dades.\nCrear un Seeder\nphp artisan make:seeder NomSeeder\n\nAixò crea un fitxer a la carpeta database/seeders. Per exemple:\nclass BooksSeeder extends Seeder\n{\npublic function run()\n{\n// Exemple: Crear un llibre\n$book = new Book();\n$book-&gt;title = &quot;Laravel for Beginners&quot;;\n$book-&gt;author = &quot;John Doe&quot;;\n$book-&gt;save();\n}\n}\n\nAfegir Seeders al Seeder General\nInclou els seeders al fitxer DatabaseSeeder:\nclass DatabaseSeeder extends Seeder\n{\npublic function run()\n{\n$this-&gt;call([\nBooksSeeder::class,\nAuthorsSeeder::class,\n]);\n}\n}\n\nExecutar Seeders\nExecutar tots els seeders:\nExecutar un seeder específic:\nReiniciar les migracions i executar els seeders:\nphp artisan db:seed\nphp artisan db:seed --class=BooksSeeder\nphp artisan migrate:fresh --seed\n\nFactories\nEls factories permeten crear grans quantitats de dades de manera ràpida i dinàmica mitjançant Faker.\nCrear un Factory\nphp artisan make:factory NomFactory -m Model\n\nPer exemple, per al model Author:\nnamespace Database\\Factories;\n\nuse App\\Models\\Author;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\n\nclass AuthorFactory extends Factory\n{\nprotected $model = Author::class;\n\npublic function definition()\n{\nreturn [\n'name' =&gt; $this-&gt;faker-&gt;name,\n'birth_year' =&gt; $this-&gt;faker-&gt;year,\n];\n}\n}\n\nUtilitzar un Factory\nPer generar dades amb un factory:\nuse App\\Models\\Author;\n\n// Crear un únic autor\nAuthor::factory()-&gt;create();\n\n// Crear diversos autors\nAuthor::factory()-&gt;count(10)-&gt;create();\n\nIntegració amb Seeders\nCombina factories amb seeders per generar dades dinàmiques:\nclass AuthorsSeeder extends Seeder\n{\npublic function run()\n{\nAuthor::factory()-&gt;count(10)-&gt;create();\n}\n}\n\nDades Relacionades\nEls factories permeten generar dades relacionades. Per exemple, llibres amb els seus autors:\nclass BooksSeeder extends Seeder\n{\npublic function run()\n{\n$authors = Author::factory()-&gt;count(5)-&gt;create();\n\n$authors-&gt;each(function ($author) {\nBook::factory()-&gt;count(2)-&gt;create(['author_id' =&gt; $author-&gt;id]);\n});\n}\n}\n\nExemples Avançats\nPodem cercar com construir factories més complexes a la documentació oficial.\nUtilitzar Factories per Relacions\nDefinir relacions dins d’un factory:\nclass BookFactory extends Factory\n{\npublic function definition()\n{\nreturn [\n'title' =&gt; $this-&gt;faker-&gt;sentence,\n'author_id' =&gt; Author::factory(),\n];\n}\n}\n\nLlançar el factory:\nBook::factory()-&gt;count(10)-&gt;create();\n\nFactories amb Estats\nEls estats permeten definir configuracions personalitzades per un model:\nclass BookFactory extends Factory\n{\npublic function withDiscount()\n{\nreturn $this-&gt;state([\n'price' =&gt; $this-&gt;faker-&gt;numberBetween(5, 10),\n]);\n}\n}\n\nÚs d'un estat:\nBook::factory()-&gt;withDiscount()-&gt;create();\n\nAvantatges dels Factories\n\nFaciliten la generació massiva de dades.\nSimplifiquen les proves i el desenvolupament amb dades fictícies realistes.\nRedueixen el temps d'inicialització de les aplicacions.",
		"tags": [ "note"]
},

{
		"title": "7. Requests, Responses i Validació en Laravel",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/7. Requests, Responses i Validació en Laravel/",
		"content": "1. Requests\nIntroducció\nUn Request en Laravel és un objecte que encapsula la informació sobre la petició HTTP, incloent dades, capçaleres, paràmetres i fitxers.\nAccés a dades del Request\n$input = $request-&gt;all(); //Accedir a tots els inputs.\n$name = $request-&gt;input('name'); //Obtenir un input específic.\n$age = $request-&gt;input('age', 18); //Especificar valors per defecte.\n$id = $request-&gt;route('id'); //Accedir a paràmetres de ruta.\n\nValidació de presència\nif ($request-&gt;has('email')) {\n// Input 'email' present\n}\nif ($request-&gt;filled('name')) {\n// Input 'name' no està buit\n}\n$filtered = $request-&gt;only(['name', 'email']); //Filtrar inputs específics.\n$excluded = $request-&gt;except(['password']); //Excloure certs inputs.\n\nTractament de fitxers\nif ($request-&gt;hasFile('photo')) { //Comprovar si hi ha un fitxer.\n$file = $request-&gt;file('photo');\n}\n$path = $request-&gt;file('photo')-&gt;store('photos'); //Emmagatzemar un fitxer.\n\n2. Responses\nCreació de respostes\nreturn response('Hello World', 200); //Crear una resposta bàsica.\nreturn response()-&gt;json([\n'name' =&gt; 'John',\n'status' =&gt; 'success'\n]); //Crear una resposta JSON.\nreturn redirect('dashboard'); //Redirecció .\nreturn redirect('login')-&gt;with('status', 'Sessió iniciada'); //Redirecció amb dades de sessió.\n\nManipular capçaleres\n//Afegeix una o múltiples capçaleres.\nreturn response('Hello')-&gt;header('Content-Type', 'text/plain');\nreturn response('Hello')\n-&gt;header('Content-Type', 'application/json')\n-&gt;header('Cache-Control', 'no-cache');\n\nRespostes de fitxers\n\nreturn response()-&gt;download($pathToFile); //Descàrrega de fitxers.\nreturn response()-&gt;file($pathToFile); //Mostrar fitxers.\n\n3. Validació\nIntroducció\nLaravel ofereix un sistema potent i senzill per validar dades d'inputs.\nValidació bàsica\n// Validar dades amb un Request.\n$request-&gt;validate([\n'name' =&gt; 'required|string|max:255',\n'email' =&gt; 'required|email',\n'password' =&gt; 'required|min:8',\n]);\n\n// Validar manualment.\n$validator = Validator::make($request-&gt;all(), [\n'title' =&gt; 'required|max:255',\n'body' =&gt; 'required',\n]);\n\nif ($validator-&gt;fails()) {\nreturn redirect('/form')-&gt;withErrors($validator);\n}\n\nRegles comunes\n\nrequired: Camp obligatori.\nemail: Validació d'un correu electrònic.\nmin:value: Mínim de caràcters o valor numèric.\nmax:value: Màxim de caràcters o valor numèric.\nunique:table,column: Ha de ser únic en una taula/columna.\nLlista sencera de regles\n\nMissatges personalitzats\n// Es poden definir missatges personalitzats per a les regles de validació.\n\n$request-&gt;validate([\n'name' =&gt; 'required',\n], [\n'name.required' =&gt; 'El nom és obligatori.',\n]);\n\nValidació condicional\n// Validació basada en altres camps o condicions.\n$request-&gt;validate([\n'password' =&gt; 'required_if:is_admin,true',\n]);\n\nValidació personalitzada\n// Es poden afegir regles personalitzades mitjançant extensions del Validator.\n\nValidator::extend('uppercase', function ($attribute, $value, $parameters, $validator) {\nreturn strtoupper($value) === $value;\n});\n\nErrors de validació\n// Obtenir tots els errors en la vista\n@if ($errors-&gt;any())\n&lt;ul&gt;\n@foreach ($errors-&gt;all() as $error)\n&lt;li&gt;{{ $error }}&lt;/li&gt;\n@endforeach\n&lt;/ul&gt;\n@endif\n\n// Mostrar errors per camp específic\n@error('name')\n&lt;div&gt;{{ $message }}&lt;/div&gt;\n@enderror",
		"tags": [ "note"]
},

{
		"title": "8. Exercici Pràctic, Guia d'Equips de Futbol Femení amb Base de Dades",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notes/01 Apuntes/PHP Teoria Batoi/8. Gestió de Dades amb Laravel/8. Exercici Pràctic, Guia d&#39;Equips de Futbol Femení amb Base de Dades/",
		"content": "L'objectiu d'aquest exercici és estendre la Guia d'Equips de Futbol Femení per utilitzar una base de dades relacional. Aprendràs a crear taules amb migracions, models per gestionar les dades, i a integrar-los amb controladors i vistes.\n\n1. Crear la Migració per a la Taula equips\nMigració\n\nGenera una migració per a la taula equips amb la següent estructura:\n\nid: Clau primària, autoincremental.\nnom: Nom de l'equip (cadena, únic, obligatori).\nestadi: Nom de l'estadi de l'equip (cadena, obligatori).\ntitols: Nombre de títols guanyats (entero, predeterminat 0).\ncreated_at i updated_at: Camps de timestamps generats automàticament.\n\nphp artisan make:migration create_equips_table --create=equips\n\nModifica el fitxer de migració per incloure l'estructura de la taula:\n\npublic function up()\n{\nSchema::create('equips', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('nom')-&gt;unique();\n$table-&gt;string('estadi');\n$table-&gt;integer('titols')-&gt;default(0);\n$table-&gt;timestamps();\n});\n}\n\nExecuta la migració per crear la taula:\n\nphp artisan migrate\n\nModels i Seeders\n\nGenera un model anomenat Equip per gestionar la taula:\n\nphp artisan make:model Equip\n\nModifica el model Equip a app/Models/Equip.php per definir els camps que es poden emplenar mitjançant assignació massiva:\n\nprotected $fillable = ['nom', 'estadi', 'titols'];\n\nCrea un seeder per a la taula equips:\n\nphp artisan make:seeder EquipsSeeder\n\nModifica el seeder EquipsSeeder per generar dades d'exemple:\n\npublic function run()\n{\nDB::table('equips')-&gt;insert([\n['nom' =&gt; 'Barça Femení', 'estadi' =&gt; 'Camp Nou', 'titols' =&gt; 30],\n['nom' =&gt; 'Atlètic de Madrid', 'estadi' =&gt; 'Cívitas Metropolitano', 'titols' =&gt; 10],\n['nom' =&gt; 'Real Madrid Femení', 'estadi' =&gt; 'Alfredo Di Stéfano', 'titols' =&gt; 5],\n]);\n}\n\nAfegeix el seeder EquipsSeeder al fitxer DatabaseSeeder:\n\npublic function run()\n{\n$this-&gt;call([\nEquipsSeeder::class,\n]);\n}\n\nExecuta els seeders per omplir la taula equips amb dades d'exemple:\n\nphp artisan db:seed\n\nControladors i CRUD\n\nModifica el mètode index,show,create,edit i destroy del controlador per obtenir els equips des de la base de dades:\npublic function index() {\n$equips = Equip::all();\nreturn view('equips.index', compact('equips'));\n}\n\npublic function show(Equip $equip) {\nreturn view('equips.show', compact('equip'));\n}\n\npublic function create() {\nreturn view('equips.create');\n}\n\npublic function edit(Equip $equip) {\nreturn view('equips.edit', compact('equip'));\n}\n\npublic function destroy(Equip $equip) {\n$equip-&gt;delete();\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip esborrat correctament!');\n}\n\nRelacions entre Taules\n\nAnem a crear la migració, model i seeder per la taula estadis i vincular-la amb la taula equips.\n\nphp artisan make:migration create_estadis_table\nphp artisan make:migration add_estadi_id_to_equips_table\nphp artisan make:model Estadi\nphp artisan make:seeder EstadisSeeder\n\nModifica la migració create_estadis_table per incloure l'estructura de la taula estadis:\n\npublic function up()\n{\nSchema::create('estadis', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('nom')-&gt;unique();\n$table-&gt;integer('capacitat');\n$table-&gt;timestamps();\n});\n}\n\nModifica la migració add_estadi_id_to_equips_table per afegir la clau forana estadi_id a la taula equips:\n\npublic function up()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;dropColumn('estadi'); // Esborra el camp estadi\n$table-&gt;foreignId('estadi_id')-&gt;constrained(); // Afegir la clau forana\n});\n}\n\npublic function down()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;string('estadi');\n$table-&gt;dropForeign(['estadi_id']);\n$table-&gt;dropColumn('estadi_id');\n});\n}\n\nModifica el model Equip per definir la relació amb l'estadi:\n\npublic function estadi()\n{\nreturn $this-&gt;belongsTo(Estadi::class);\n}\n\nModifica el model Estadi per definir la relació amb els equips:\n\npublic function equips()\n{\nreturn $this-&gt;hasMany(Equip::class);\n}\n\nModifica el seeder EstadisSeeder per generar dades d'exemple per a la taula estadis:\n\npublic function run()\n{\nDB::table('estadis')-&gt;insert([\n['nom' =&gt; 'Camp Nou', 'capacitat' =&gt; 99000],\n['nom' =&gt; 'Wanda Metropolitano', 'capacitat' =&gt; 68000],\n['nom' =&gt; 'Santiago Bernabéu', 'capacitat' =&gt; 81000],\n]);\n}\n\nAfegeix el seeder EstadisSeeder al fitxer DatabaseSeeder:\n\npublic function run()\n{\n$this-&gt;call([\nEstadisSeeder::class,\nEquipsSeeder::class,\n\n]);\n}\n\nModifica el seeder EquipsSeeder per assignar equips a estadis existents:\n\npublic function run()\n{\n$estadi = Estadi::where('nom', 'Camp Nou')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Barça Femení',\n'titols' =&gt; 30,\n]);\n$estadi = Estadi::where('nom', 'Wanda Metropolitano')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Atlètic de Madrid',\n'titols' =&gt; 10,\n]);\n$estadi = Estadi::where('nom', 'Santiago Bernabéu')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Real Madrid Femení',\n'titols' =&gt; 5,\n]);\n}\n\nExecuta els seeders per omplir les taules equips i estadis amb dades d'exemple:\n\nphp artisan migrate:fresh --seed\n\nModifica la vista equips.index per mostrar l'estadi de cada equip:\n\n@foreach ($equips as $equip)\n&lt;tr class=&quot;hover:bg-gray-100&quot;&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;\n&lt;a href=&quot;{{ route('equips.show', $equip-&gt;id) }}&quot; class=&quot;text-blue-700 hover:underline&quot;&gt;{{ $equip-&gt;nom }}&lt;/a&gt;\n&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;{{ $equip-&gt;estadi-&gt;nom }}&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;{{ $equip-&gt;titols }}&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2 flex space-x-2&quot;&gt;\n&lt;a href=&quot;{{ route('equips.show', $equip-&gt;id) }}&quot; class=&quot;text-green-600 hover:underline&quot;&gt;Mostrar&lt;/a&gt;\n&lt;a href=&quot;{{ route('equips.edit', $equip-&gt;id) }}&quot; class=&quot;text-yellow-600 hover:underline&quot;&gt;Editar&lt;/a&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n@endforeach\n\nCrea la vista equips.create per incloure un desplegable amb els estadis disponibles:\n\n&lt;form action=&quot;{{ route('equips.store') }}&quot; method=&quot;POST&quot; class=&quot;bg-white p-6 rounded-lg shadow-md max-w-md mx-auto&quot;&gt;\n@csrf\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;nom&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Nom:&lt;/label&gt;\n&lt;input type=&quot;text&quot; name=&quot;nom&quot; id=&quot;nom&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;titols&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Títols:&lt;/label&gt;\n&lt;input type=&quot;number&quot; name=&quot;titols&quot; id=&quot;titols&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;estadi_id&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Estadi:&lt;/label&gt;\n&lt;select name=&quot;estadi_id&quot; id=&quot;estadi_id&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n@foreach ($estadis as $estadi)\n&lt;option value=&quot;{{ $estadi-&gt;id }}&quot;&gt;{{ $estadi-&gt;nom }}&lt;/option&gt;\n@endforeach\n&lt;/select&gt;\n&lt;/div&gt;\n\n&lt;button type=&quot;submit&quot;\nclass=&quot;w-full bg-blue-500 text-white font-medium py-2 px-4 rounded-lg shadow hover:bg-blue-600 focus:ring focus:ring-blue-300&quot;&gt;\nCrear Equip\n&lt;/button&gt;\n&lt;/form&gt;\n\nCal modificar el controlador EquipController per obtenir els estadis disponibles.\n\nCrea el mètode store en el controlador EquipController per emmagatzemar un nou equip:\n\npublic function store(Request $request) {\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'titols' =&gt; 'integer|min:0',\n]);\nEquip::create($validated);\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip creat correctament!');\n}\n\nCal modificat el model Equip per permetre l'assignació massiva de l'estadi.\n\nModifica la vista equips.edit per incloure un desplegable amb els estadis disponibles:\n\n&lt;form action=&quot;{{ route('equips.update', $equip-&gt;id) }}&quot; method=&quot;POST&quot; class=&quot;bg-white p-6 rounded-lg shadow-md max-w-md mx-auto&quot;&gt;\n@csrf\n@method('PUT')\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;nom&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Nom:&lt;/label&gt;\n&lt;input type=&quot;text&quot; name=&quot;nom&quot; id=&quot;nom&quot; value=&quot;{{ old('nom', $equip-&gt;nom) }}&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('nom') border-red-500 @enderror&quot;&gt;\n@error('nom')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;titols&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Títols:&lt;/label&gt;\n&lt;input type=&quot;number&quot; name=&quot;titols&quot; id=&quot;titols&quot; value=&quot;{{ old('titols', $equip-&gt;titols) }}&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('titols') border-red-500 @enderror&quot;&gt;\n@error('titols')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;estadi_id&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Estadi:&lt;/label&gt;\n&lt;select name=&quot;estadi_id&quot; id=&quot;estadi_id&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('estadi_id') border-red-500 @enderror&quot;&gt;\n@foreach ($estadis as $estadi)\n&lt;option value=&quot;{{ $estadi-&gt;id }}&quot; {{ $estadi-&gt;id == $equip-&gt;estadi_id ? 'selected' : '' }}&gt;\n{{ $estadi-&gt;nom }}\n&lt;/option&gt;\n@endforeach\n&lt;/select&gt;\n@error('estadi_id')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;button type=&quot;submit&quot;\nclass=&quot;w-full bg-blue-500 text-white font-medium py-2 px-4 rounded-lg shadow hover:bg-blue-600 focus:ring focus:ring-blue-300&quot;&gt;\nActualitzar Equip\n&lt;/button&gt;\n&lt;/form&gt;\n\nCrea el mètode update en el controlador EquipController per actualitzar un equip existent:\n\npublic function update(Request $request, $id) {\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips,nom,'.$id,\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'titols' =&gt; 'integer|min:0',\n]);\n$equip = Equip::findOrFail($id);\n$equip-&gt;update($validated);\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip actualitzat correctament!');\n}\n\nAfegir un escut a l'equip\n\nCrea una migració per afegir un camp escut a la taula equips:\n\nphp artisan make:migration add_escut_to_equips_table\n\nModifica la migració add_escut_to_equips_table per incloure el camp escut:\n\npublic function up()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;string('escut')-&gt;nullable();\n});\n}\npublic function down()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;dropColumn('escut');\n});\n}\n\nAplicar la migració\n\nphp artisan migrate\n\nModifica el model Equip per incloure el camp escut:\n\nprotected $fillable = ['nom', 'estadi_id', 'titols', 'escut'];\n\nModifica la vista equips.create per incloure un camp d'arxiu per pujar l'escut de l'equip:\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;escut&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Escut:&lt;/label&gt;\n&lt;input type=&quot;file&quot; name=&quot;escut&quot; id=&quot;escut&quot;\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\nModifica la vista equips.edit per incloure un camp d'arxiu per actualitzar l'escut de l'equip:\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;escut&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Escut:&lt;/label&gt;\n&lt;input type=&quot;file&quot; name=&quot;escut&quot; id=&quot;escut&quot;\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n@if ($equip-&gt;escut)\n&lt;p class=&quot;mt-2 text-sm text-gray-500&quot;&gt;Escut actual:&lt;/p&gt;\n&lt;img src=&quot;{{ asset('storage/' . $equip-&gt;escut) }}&quot; alt=&quot;Escut de {{ $equip-&gt;nom }}&quot; class=&quot;h-16 mt-2&quot;&gt;\n@endif\n&lt;/div&gt;\n\nAfegeix enctype=&quot;multipart/form-data&quot; al dos formularis:\n\n&lt;form action=&quot;{{ route('equips.store') }}&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;\n\nCrea un enllaç simbòlic a la carpeta storage\n\nphp artisan storage:link\n\nActualitza el mètode store del controlador\n\npublic function store(Request $request)\n{\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips',\n'titols' =&gt; 'integer|min:0',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'escut' =&gt; 'nullable|image|mimes:jpeg,png,jpg|max:2048', // Validació del fitxer\n]);\n\nif ($request-&gt;hasFile('escut')) {\n$path = $request-&gt;file('escut')-&gt;store('escuts', 'public');\n$validated['escut'] = $path;\n}\n\nEquip::create($validated);\n\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip creat correctament!');\n}\n\nActualitza el mètode update del controlador\n\npublic function update(Request $request, $id)\n{\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips,nom,' . $id,\n'titols' =&gt; 'integer|min:0',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'escut' =&gt; 'nullable|image|mimes:jpeg,png,jpg|max:2048',\n]);\n\n$equip = Equip::findOrFail($id);\n\nif ($request-&gt;hasFile('escut')) {\nif ($equip-&gt;escut) {\nStorage::disk('public')-&gt;delete($equip-&gt;escut); // Esborra l'escut antic\n}\n$path = $request-&gt;file('escut')-&gt;store('escuts', 'public');\n$validated['escut'] = $path;\n}\n\n$equip-&gt;update($validated);\n\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip actualitzat correctament!');\n}\n\nCrea el mètode delete per esborrar l'escut de l'equip:\n\npublic function delete(Equip $equip)\n{\nif ($equip-&gt;escut) {\nStorage::disk('public')-&gt;delete($equip-&gt;escut);\n}\n$equip-&gt;delete();\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip esborrat correctament!');\n}\n\nModificat el component de la vista equips.show per mostrar l'escut de l'equip:\n\n&lt;div class=&quot;equip border rounded-lg shadow-md p-4 bg-white&quot;&gt;\n@if ($escut)\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;\n&lt;img src=&quot;{{ asset('storage/' . $escut) }}&quot; alt=&quot;Escut de {{ $nom }}&quot; class=&quot;h-8 w-8 object-cover rounded-full&quot;&gt;\n&lt;/td&gt;\n@endif\n&lt;h2 class=&quot;text-xl font-bold text-blue-800&quot;&gt;{{ $nom }}&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Estadi:&lt;/strong&gt; {{ $estadi }}&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Títols:&lt;/strong&gt; {{ $titols }}&lt;/p&gt;\n&lt;/div&gt;\n\nUtilitzar Factories per a Dades d'Exemple\n\nCrea un factory per a la taula equips:\n\nphp artisan make:factory EquipFactory --model=Equip\n\nModifica el factory EquipFactory per generar dades aleatòries:\n\npublic function definition()\n{\nreturn [\n'nom' =&gt; $this-&gt;faker-&gt;unique()-&gt;company,\n'titols' =&gt; $this-&gt;faker-&gt;numberBetween(0, 50),\n'estadi_id' =&gt; \\App\\Models\\Estadi::factory(),\n'escut' =&gt; 'escuts/dummy.png', // Imatge de prova predefinida\n];\n}\n}\n\nActualitza el seeder EquipsSeeder per utilitzar el factory:\n\npublic function run()\n{\n...\nEquip::factory()-&gt;count(10)-&gt;create();\n}\n\nModifica el model Equip per permetre els factories:\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Estadi extends Model\n{\nuse HasFactory;\n...\n}\n\nCrea el factory per a la taula estadis:\n\nphp artisan make:factory EstadiFactory --model=Estadi\n\nModifica el factory EstadiFactory per generar dades aleatòries:\n\npublic function definition()\n{\nreturn [\n'nom' =&gt; $this-&gt;faker-&gt;unique()-&gt;city.' Stadium',\n'capacitat' =&gt; $this-&gt;faker-&gt;numberBetween(10000, 100000),\n];\n}\n\nExecuta els seeders per omplir la taula equips amb dades generades pel factory:\n\nphp artisan migrate:fresh --seed",
		"tags": [ "note"]
},

{
		"title": "3. PHP Data Objects  PDO",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/5-acceso-a-datos/3-php-data-objects-pdo/",
		"content": "La classe PDO de PHP s'utilitza per connectar-se a una base de dades i executar consultes SQL de manera segura. Quan construeixes una instància de PDO, pots passar-li diferents atributs en el constructor i opcions per configurar el comportament de la connexió. Aquí tens els atributs principals i el seu propòsit:\nConstructor de la classe PDO\nEl constructor de la classe PDO accepta tres paràmetres obligatoris i un opcional:\n&lt;?php\n$pdo = new PDO(string $dsn, string $username, string $password, array $options);\n\n$dsn (Data Source Name): És una cadena que especifica el tipus de base de dades i la informació necessària per connectar-s'hi.\n\nFormat per tipus de base de dades i configuració, per exemple:\n\nMysql:host=localhost;dbname=testdb (per a MySQL).\npgsql:host=localhost;port=5432;dbname=testdb (per a PostgreSQL).\nsqlite:/path/to/database.db (per a SQLite).\n\n$username: El nom d'usuari per a la connexió a la base de dades.\n$password: La contrasenya associada al nom d'usuari.\n$options (Opcional): Un array d'opcions per definir el comportament de la connexió. Aquests són alguns dels valors més comuns que es poden definir en aquest array:\n\nPDO::ATTR_ERRMODE: Controla com es gestionen els errors. Alguns valors comuns són:\n\nPDO::ERRMODE_SILENT: Els errors no generen cap missatge.\nPDO::ERRMODE_WARNING: Els errors generen un avís.\nPDO::ERRMODE_EXCEPTION: Els errors generen una excepció, que és el més recomanable per controlar errors.\n\nPDO::ATTR_DEFAULT_FETCH_MODE: Defineix el mode de recuperació de dades per defecte, com ara:\n\nPDO::FETCH_ASSOC: Retorna les dades com un array associatiu.\nPDO::FETCH_OBJ: Retorna les dades com un objecte.\nPDO::FETCH_BOTH: Retorna les dades com un array associatiu i numèric.\n\nPDO::ATTR_PERSISTENT: Habilita connexions persistents. Una connexió persistent pot millorar el rendiment mantenint la connexió activa per múltiples peticions en lloc de crear-ne una nova cada vegada.\nPDO::ATTR_TIMEOUT: Defineix un temps límit per a la connexió en segons.\n\nExemple de connexió amb PDO\n$dsn = &quot;mysql:host=localhost;dbname=testdb&quot;;\n$username = &quot;usuari&quot;;\n$password = &quot;contrasenya&quot;;\n$options = [\nPDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION,\nPDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC,\nPDO::ATTR_PERSISTENT =&gt; true,\nPDO::MYSQL_ATTR_INIT_COMMAND =&gt; &quot;SET NAMES utf8&quot;\n];\n\ntry {\n$pdo = new PDO($dsn, $username, $password, $options);\necho &quot;Connexió establerta amb èxit!&quot;;\n} catch (PDOException $e) {\necho &quot;Error de connexió: &quot; . $e-&gt;getMessage();\n}\n\nAquest codi estableix una connexió a una base de dades MySQL amb un joc de caràcters utf8, una connexió persistent, i llança excepcions en cas d'errors.\nQualsevol error que es llance a través de PDO, el sistema llançarà una PDOException .\nFitxer de configuració de la BD\nDe la mateixa manera que podem tenir el nostre arxiu de funcions funciones.php i alberguem totes les funcions que s'usen de manera global en l'aplicació, podem establir un arxiu de constants on definim els paràmetres de connexió amb la base de dades.\n&lt;?php\n\n// ▒▒▒▒▒▒▒▒ conexion.php ▒▒▒▒▒▒▒▒\n\nconstDSN = &quot;mysql:host=localhost;dbname=dwes&quot;;\nconstUSUARIO = &quot;dwes&quot;;\nconstPASSWORD = &quot;abc123&quot;;\n\n/* ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n▒▒▒▒▒▒▒▒ NO SUBAS ESTE ARCHIVO A git ▒▒▒▒▒\n\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ */\n\nAquest arxiu conté informació molt sensible així que no és recomanable que puges aquest arxiu a git.\nSentències preparades\nEs tracta de sentències que s'estableixen com si foren plantilles de la SQL que llançarem, acceptant paràmetres que són establits a posteriori de la declaració de la sentència preparada.\nLes sentències preparades eviten la injecció de SQL (SQL Injection) i milloren el rendiment de nostres aplicacions o pàgines web.\n&lt;?php\n$sql = &quot;INSERT INTO Clientes VALUES (?, ?, ?, ?)&quot;;\n\nCada interrogant és un paràmetre que establirem després, unes quantes línies més a baix.\nUna vegada tenim la plantilla de la nostra consulta, hem de seguir amb la preparació juntament amb 3 mètodes més de PHP per a la seua completa execució:\n\nprepare: prepara la sentencia abans de ser executada.\nbind: el tipus d'unió (*bind^) de dada que pot ser mitjançant ' ? ' o ' :parametre '\nexecute s'executa la consulta unint la plantilla amb les variables o paràmetres que hem establit.\n\nExemple paràmetros\n&lt;?php\n\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion = null;\n\ntry {\n$cantidad = $_GET[&quot;cantidad&quot;];\n\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;DELETE FROM stock WHERE unidades = ?&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n$isOk = $sentencia -&gt; execute([$cantidad]);\n$cantidadAfectada = $sentencia -&gt; rowCount();\n\necho $cantidadAfectada;\n} catch (PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null\n\nExemple bindParam\nMolt semblant a utilitzar paràmetres però aquesta vegada la variable està dins de la sentència SQL, en aquest cas l'hem anomenada :cant\n&lt;?php\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion=null;\n\ntry {\n$cantidad = $_GET[&quot;cantidad&quot;] ?? 0;\n\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;DELETE FROM stock WHERE unidades = :cant&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; bindParam(&quot;:cant&quot;, $cantidad);\n\n$isOk = $sentencia -&gt; execute();\n\n$cantidadAfectada = $sentencia -&gt; rowCount();\n\necho $cantidadAfectada;\n} catch (PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null;\n\nbindParam VS bindValue\nUtilitzarem bindValue() quan hàgem d'inserir dades només una vegada, en canvi, haurem d'usar bindParam() quan hàgem de passar dades múltiples, com per exemple, un array.\n&lt;?php\n// se asignan nombre a los parámetros\n$sql = &quot;DELETE FROM stock WHERE unidades = :cant&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n// bindParam enlaza por referencia\n$cantidad = 0;\n\n$sentencia -&gt; bindParam(&quot;:cant&quot;, $cantidad);\n$cantidad = 1;\n\n// se eliminan con cant = 1\n$isOk = $sentencia -&gt; execute();\n\n// bindValue enlaza por valor\n$cantidad = 0;\n\n$sentencia -&gt; bindValue(&quot;:cant&quot;, $cantidad);\n$cantidad = 1;\n\n// se eliminan con cant = 0\n$isOk = $sentencia-&gt;execute();\n\nPer a més informació i ús de les variables PDO consulta el manual de PHP.\nInserint registres\nA l'hora d'inserir registres en una base de dades, hem de tindre en compte que en la taula pot haver-hi valors autoincrementats. Per a salvaguardar açò, el que hem de fer és deixar aqueix camp autoincrementat buit, però a l'hora de fer la connexió, hem de recuperar-ho amb el mètode lastInsertId().\n&lt;?php\n$nombre = $_GET[&quot;nombre&quot;] ?? &quot;SUCURSAL X&quot;;\n$telefono = $_GET[&quot;telefono&quot;] ?? &quot;636123456&quot;;\n\n$sql=&quot;INSERT INTO tienda(nombre, tlf) VALUES (:nombre, :telefono)&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; bindParam(&quot;:nombre&quot;, $nombre);\n$sentencia -&gt; bindParam(&quot;:telefono&quot;, $telefono);\n\n$isOk = $sentencia -&gt; execute();\n$idGenerado = $conexion -&gt; lastInsertId();\n\necho $idGenerado;\n\nConsultant registres\nA l'hora de recuperar els resultats d'una consulta, bastarà amb invocar al mètode PDOStatement::fetch per a llistar les files generades per la consulta.\nPerò hem de triar el tipus de dada que volem rebre entre els 3 que hi ha disponibles:\n\nPDO::FETCH_ASSOC: array indexat que els seus keys són el nom de les columnes.\nPDO::FETCH_NUM: array indexat que els seus keys són números.\nPDO::FETCH_BOTH: valor per defecte. Retorna un array indexat que els seus keys són tant el nom de les columnes com números.\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con array asociativo.php ▒▒▒▒▒▒▒▒\n\ninclude &quot;config/database.inc.php&quot;;\n\n$conexion = null;\n\ntry{\n$conexion = new PDO(DSN, USUARIO, PASSWORD);\n$conexion -&gt; setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n$sql = &quot;select * from tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_ASSOC);\n$sentencia -&gt; execute();\n\nwhile($fila = $sentencia -&gt; fetch()){\necho &quot;Codigo:&quot; . $fila[&quot;cod&quot;] . &quot;&lt;br /&gt;&quot;;\necho &quot;Nombre:&quot; . $fila[&quot;nombre&quot;] . &quot;&lt;br /&gt;&quot;;\necho &quot;Teléfono:&quot; . $fila[&quot;tlf&quot;] . &quot;&lt;br /&gt;&quot;;\n}\n\n}catch(PDOException $e) {\necho $e -&gt; getMessage();\n}\n\n$conexion = null;\n\nRecuperant dades amb una matriu com a resultat de la nostra consulta\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con array asociativo ▒▒▒▒▒▒▒▒\n\n$sql=&quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_ASSOC);\n$sentencia -&gt; execute();\n\n$tiendas = $sentencia -&gt; fetchAll();\n\nforeach($tiendasas$tienda) {\necho&quot;Codigo:&quot; . $tienda[&quot;cod&quot;] . &quot;&lt;br /&gt;&quot;;\necho&quot;Nombre:&quot; . $tienda[&quot;nombre&quot;] . &quot;&lt;br /&gt;&quot;;\n}\n\nPerò si el que volem és llegir dades amb forma d'objecte utilitzant PDO::FETCH_OBJ, hem de crear un objecte amb propietats públiques amb el mateix nom que les columnes de la taula que anem a consultar.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ consulta con formato de objeto ▒▒▒▒▒▒▒▒\n\n$sql=&quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_OBJ);\n$sentencia -&gt; execute();\n\nwhile($t = $sentencia -&gt; fetch()) {\necho&quot;Codigo:&quot; . $t -&gt; cod . &quot;&lt;br /&gt;&quot;;\necho&quot;Nombre:&quot; . $t -&gt; nombre . &quot;&lt;br /&gt;&quot;;\necho&quot;Teléfono:&quot; . $t -&gt; tlf . &quot;&lt;br /&gt;&quot;;\n}\n\nConsultes amb models\nPortem temps creant classes en PHP i les consultes també admeten aquest tipus de dades mitjançant l'ús de PDO::FETCH_CLASS\nSi usem aquest mètode, hem de tindre en compte que els noms dels atributs privats han de coincidir amb els noms de les columnes de la taula que anem a manejar.\nAixí doncs, si pel que siga canviem l'estructura de la taula HEM DE CANVIAR la nostra classe perquè tot continue funcionant.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ clase Tienda ▒▒▒▒▒▒▒▒\n\nclassTienda {\nprivate int $cod;\nprivate string $nombre;\nprivate ? string $tlf;\n\npublic function getCodigo() : int {\nreturn $this -&gt; cod;\n}\n\npublic function getNombre() : string {\nreturn $this -&gt; nombre;\n}\n\npublic function getTelefono() : ?string {\nreturn $this -&gt; tlf;\n}\n}\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Consultando a través de la clase Tienda ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda&quot;;\n$sentencia = $conexion -&gt; prepare($sql);\n\n// Aquí 'Tienda' es el nombre de nuestra clase\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS, Tienda::class);\n$sentencia -&gt; execute();\n\nwhile($t = $sentencia -&gt; fetch()) {\necho &quot;Codigo: &quot; . $t -&gt; getCodigo() . &quot;&lt;br /&gt;&quot;;\necho &quot;Nombre: &quot; . $t -&gt; getNombre() . &quot;&lt;br /&gt;&quot;;\necho &quot;Teléfono: &quot; . $t -&gt; getTelefono() . &quot;&lt;br /&gt;&quot;;\n\nvar_dump($t);\n}\n\nPerò què passa si les nostres classes tenen constructor? doncs que hem d'indicar-li, al mètode FECTH, que emplene les propietats després de cridar al constructor i per a això fem ús de PDO::FETCH_PROPS_LATE.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Consulta para una clase con constructor ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, Tienda::class);\n$sentencia -&gt; execute();\n\n$tiendas = $sentencia -&gt; fetchAll();\n\nConsultes amb LIKE\nPer a utilitzar el comodí LIKE o altres comodins, hem d'associar-lo a la dada i MAI en la pròpia consulta.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Utilizando comodines :: LIKE ▒▒▒▒▒▒▒▒\n\n$sql = &quot;SELECT * FROM tienda where nombre like :nombre or tlf like :tlf&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, Tienda::class);\n\n$cadBuscar = &quot;%&quot; . $busqueda . &quot;%&quot;;\n\n$sentencia -&gt; execute([&quot;nombre&quot; =&gt; $cadBuscar,&quot;tlf&quot; =&gt; $cadBuscar]);\n\n$result = $sentencia -&gt; fetchAll();\n\nTeniu una llista d'exemples molt completa en la documentació oficial.",
		"tags": [ "note"]
},

{
		"title": "4. Login & Password",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/5-acceso-a-datos/4-login-and-password/",
		"content": "Per a manejar un sistema complet de login i password amb contrasenyes xifrades, necessitem un mètode que xifre aqueixos strings que l'usuari introdueix com a contrasenya; tant en el formulari de registre com en el del login, ja que en codificar una contrasenya, després hem de descodificar-la per a comprovar que totes dues *contrasenyes (la que introdueix l'usuari en el login i la que tenim en la base de dades) coincidisquen.\nNecessitem doncs:\n\npassword_hash() per a emmagatzemar la contrasenya en la base de dades a l'hora de fer el INSERT\n\nPASSWORD_DEFAULT emmagatzemem la contrasenya usant el mètode d'encriptació bcrypt\n\nPASSWORD_BCRYPT emmagatzemem la contrasenya usant l'algorisme CRYPT_BLOWFISH compatible amb crypt()\n\npassword_verify() per a verificar l'usuari i la contrasenya\n\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Almacenando usuario y password en BD ▒▒▒▒▒▒▒▒\n\n$usu = $_POST[&quot;usuario&quot;];\n$pas = $_POST[&quot;password&quot;];\n\n$sql = &quot;INSERT INTO usuarios(usuario, password) VALUES (:usuario, :password)&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n\n$isOk = $sentencia -&gt; execute([\n&quot;usuario&quot; =&gt; $usu,\n&quot;password&quot; =&gt; password_hash($pas,PASSWORD_DEFAULT)\n]);\n\nAra que tenim l'usuari codificat i guardat en la base de dades, el recuperarem per a poder loguejar-lo correctament.\n&lt;?php\n// ▒▒▒▒▒▒▒▒ Recuperando usuario y password en BD ▒▒▒▒▒▒▒▒\n\n$usu = $_POST[&quot;login&quot;] ?? &quot;&quot;;\n\n$sql = &quot;select * from usuarios where usuario = ?&quot;;\n\n$sentencia = $conexion -&gt; prepare($sql);\n$sentencia -&gt; execute([$usu]);\n\n$usuario = $sentencia -&gt; fetch();\n\nif($usuario &amp;&amp; password_verify($_POST['pass'], $usuario['password'])) {\necho&quot;OK!&quot;;\n} else {\necho&quot;KO&quot;;\n}",
		"tags": [ "note"]
},

{
		"title": "5. QueryBuilder",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/5-acceso-a-datos/5-query-builder/",
		"content": "Un Query Builder (Constructor de Consultes) és una eina o classe que facilita la creació, execució i manipulació de consultes SQL en un programa. L'objectiu principal és proporcionar una interfície més intuïtiva i segura per interactuar amb bases de dades, sense haver d'escriure consultes SQL en brut.\nA continuació, detallo algunes de les principals avantatges i característiques d'un Query Builder com el que has compartit anteriorment:\n\nAbstracció de la Base de Dades:\n\nEl Query Builder proporciona una capa d'abstracció que permet interactuar amb diferents tipus de bases de dades (MySQL, PostgreSQL, SQLite, etc.) sense canviar el codi de la teva aplicació. Això facilita la portabilitat i l'escalabilitat del codi.\n\nSeguretat:\n\nPrevé injeccions SQL: Gràcies a l'ús de sentències preparades i enllaçament de paràmetres, el Query Builder ajuda a prevenir atacs d'injecció SQL, una de les amenaces més comunes en desenvolupament web.\n\nSintaxi Més Neta i Més Fàcil:\n\nEls Query Builders solen proporcionar una sintaxi més neta i fàcil d'entendre que les cadenes SQL pures. Això fa que el codi sigui més llegible i fàcil de mantenir.\n\nReutilització de Codi:\n\nLes funcions del Query Builder es poden reutilitzar a tot el projecte, reduint la duplicació de codi i facilitant el manteniment.\n\nFlexibilitat:\n\nPermet realitzar consultes complexes amb una sintaxi simplificada, facilitant l'adaptació del codi a canvis en els requeriments de l'aplicació.\n\nDesenvolupament Més Ràpid:\n\nAjuda a accelerar el procés de desenvolupament, ja que els desenvolupadors no necessiten recordar la sintaxi SQL exacta per a cada tipus de base de dades.\n\nFàcil de Depurar:\n\nEl codi generat pel Query Builder és més fàcil de depurar en comparació amb les llargues cadenes SQL.\n\nSuport per a Operacions CRUD:\n\nEls Query Builders solen incloure suport integrat per a operacions CRUD (Crear, Llegir, Actualitzar, Esborrar), fent més fàcil la manipulació de dades.\n\nEn resum, un Query Builder serveix per simplificar la interacció amb bases de dades, proporcionant una interfície més segura, neta i fàcil d'utilitzar que les cadenes SQL pures. Ajuda a accelerar el desenvolupament, facilita el manteniment i millora la seguretat de l'aplicació.\nAcí en tenim un exemple de construcció casera:\n&lt;?php\n\nnamespace BatBook;\n\nuse PDO;\n\nclass QueryBuilder\n{\n// Aquesta funció serveix per a construir i executar consultes SQL de tipus SELECT.\n// Es pot filtrar per valors, limitar la quantitat de resultats i establir un offset.\npublic static function sql($class, $values=null, $limit = null, $offset = null)\n{\n// Obté el nom de la taula a partir de la propietat estàtica $nameTable de la classe passada com argument.\n$table = $class::$nameTable;\n\n// Obté una connexió a la base de dades.\n$conn = Connection::get();\n\n// Construeix la consulta SQL bàsica.\n$sql = &quot;SELECT * FROM $table&quot;;\n\n// Afegeix condicions WHERE si es proporcionen valors per a filtrar.\nif ($values) {\n$sql .= &quot; WHERE &quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= &quot; AND $id=:$id&quot;;\n} else {\n$sql .= &quot;$id=:$id&quot;;\n}\n}\n}\n\n// Afegeix les clàusules LIMIT i OFFSET si són necessàries.\nif (isset($limit) &amp;&amp; isset($offset)) {\n$sql .= &quot; LIMIT $limit OFFSET $offset&quot;;\n}\n\n// Prepara la sentència SQL.\n$sentence = $conn-&gt;prepare($sql);\n\n// Enllaça els valors a la sentència.\nforeach ($values??[] as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n\n// Estableix el mode de recuperació a objectes de la classe especificada.\n$sentence -&gt; setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE , $class);\n\n// Executa la consulta.\n$sentence -&gt; execute();\n\n// Retorna tots els resultats obtinguts.\nreturn $sentence-&gt;fetchAll();\n}\n\n// Aquesta funció serveix per a trobar una fila en una taula basant-se en el seu ID.\npublic static function find($class, $id)\n{\n//TODO\n}\n\n// Aquesta funció serveix per a insertar una fila en una taula.\npublic static function insert($class, $values)\n{\n$table = $class::$nameTable;\n$conn = Connection::get();\n$sql = &quot;INSERT INTO $table (&quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= ','.$id;\n} else {\n$sql .= $id;\n}\n}\n$sql .= &quot;) VALUES (&quot;;\nforeach (array_keys($values) as $key =&gt; $id) {\nif ($key != 0) {\n$sql .= ',:'.$id;\n} else {\n$sql .= ':'.$id;\n}\n}\n$sql .= &quot;)&quot;;\n$sentence = $conn-&gt;prepare($sql);\nforeach ($values as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n$sentence -&gt; execute();\nreturn $conn-&gt;lastInsertId();\n}\n\n// Aquesta funció serveix per a actualitzar una fila en una taula.\npublic static function update($class, $values, $id)\n{\n$table = $class::$nameTable;\n$conn = Connection::get();\n$sql = &quot;UPDATE $table SET &quot;;\nforeach (array_keys($values) as $key =&gt; $value) {\nif ($key != 0) {\n$sql .= ','.$value.'=:'.$value;\n} else {\n$sql .= $value.'=:'.$value;\n}\n}\n$sql .= &quot; WHERE id=:id&quot;;\n$sentence = $conn-&gt;prepare($sql);\nforeach ($values as $key =&gt; $value) {\n$sentence-&gt;bindValue(&quot;:$key&quot;, $value);\n}\n$sentence-&gt;bindValue(&quot;:id&quot;, $id);\n$sentence -&gt; execute();\nreturn $id;\n}\n\n// Aquesta funció serveix per a eliminar una fila en una taula basant-se en el seu ID.\npublic static function delete($class, $id)\n{\n//TODO\n}\n}\n\nEn resum, aquesta classe proporciona funcions estàtiques per a la construcció i execució de consultes SQL bàsiques com SELECT, INSERT, UPDATE, i DELETE. Utilitza l'extensió PDO per a la connexió a bases de dades i la preparació de sentències SQL, la qual cosa ajuda a prevenir injeccions SQL. També permet la manipulació fàcil de files en bases de dades, tot retornant objectes de la classe especificada.\nRespotes d'error\nQuan no trebem un recurs en al nostra web, podem mostrar a l'usuari una pàgina específica d'error utilitzant la funció header. Una típica seria:\n&lt;!-- not-found.php --&gt;\n&lt;?php http_response_code(404); ?&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n&lt;title&gt;No trobat&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;404 - Pàgina no trobada&lt;/h1&gt;\n&lt;p&gt;Ho sentim, la pàgina que estàs buscant no s'ha pogut trobar.&lt;/p&gt;\n&lt;a href=&quot;index.php&quot;&gt;Torna a l'inici&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nI per a utilitzar-la:\n&lt;?php\nheader(&quot;Location: not-found.php&quot;);\nexit;\n?&gt;",
		"tags": [ "note"]
},

{
		"title": "6. Accès a fitxers",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/5-acceso-a-datos/6-acces-a-fitxers/",
		"content": "Gràcies a la funció fopen() des de PHP podem obrir arxius que es troben en els nostres servidor o una URL.\nA aquesta funció cal passar-li 2 paràmetres; el nom de l'arxiu que volem obrir i la manera en què s'obrirà\n$fp = fopen(&quot;miarchivo.txt&quot;, &quot;r&quot;);\n\nMoltes vegades no podem obrir l'arxiu perquè aquest no es troba o no tenim accés a ell, per això és recomanable comprovar que podem fer-ho\nif (!$fp = fopen(&quot;miarchivo.txt&quot;, &quot;r&quot;)){\necho &quot;No se ha podido abrir el archivo&quot;;\n}\n\nManeres d'obertura de fitxers\n\nr: Manera lectura. Punter al principi de l'arxiu.\nr+: Obertura per a lectura i escriptura. Punter al principi de l'arxiu\nw: Obertura per a escriptura. Punter al principi de l'arxiu i el sobreescriu. Si no existeix s'intenta crear.\nw+: Obertura per a lectura i escriptura. Punter al principi de l'arxiu i el sobreescriu. Si no existeix s'intenta crear.\na: Obertura per a escriptura. Punter al final de l'arxiu. Si no existeix s'intenta crear.\na+: Obertura per a lectura i escriptura. Punter al final de l'arxiu. Si no existeix s'intenta crear.\nx: Creació i obertura per a només escriptura. Punter al principi de l'arxiu. Si l'arxiu ja existeix donarà error E_*WARNING. Si no existeix s'intenta crear.\nx+: Creació i obertura per a lectura i escriptura. Mateix comportament que x.\nc: Obertura per a escriptura. Si no existeix es crea. Si existeix no se sobreescriu ni dona cap error. Punter al principi de l'arxiu.\nc+: Obertura per a lectura i escriptura. Mateix comportament que C.\nb: Quan es treballa amb arxius binaris com *jpg, pdf, *png i altres. Se sol col·locar al final de la manera, és a dir *rb, r+b, x+b, *wb...\n\nOperacions amb arxius\nPer a poder llegir un arxiu necessitem usar la funció fread() de PHP\n// ▒▒▒▒▒▒▒▒ Abriendo un archivo y leyendo su contenido ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$fp = fopen($file, &quot;r&quot;);\n\n// filesize() nos devuelve el tamaño del archivo en cuestión\n$contents = fread($fp, filesize($file));\n\n// Cerramos la conexión con el archivo\nfclose();\n\nSi el que volem és escriure en un arxiu, haurem de fer ús de la funció fwrite()\n// ▒▒▒▒▒▒▒▒ Escribiendo en un archivo ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$texto = &quot;Hola que tal&quot;;\n\n$fp = fopen($file, &quot;w&quot;);\n\nfwrite($fp, $texto);\nfclose($fp);\n\nInformació d'un fitxer\nAmb PHP i el seu mètode stat() podem obtindre informació sobre els arxius que li indiquem. Aquest mètode retorna fins a un total de 12 elements amb informació sobre el nostre arxiu.\n\ndev\t número de dispositiu\nino\t número d'i-node\nmode\t manera de protecció de l'i-node\nnlink\t nombre d'enllaços\nuid\t ID d'usuari del propietari\ngid\t ID de grup del propietari\nrdev\t tipus de dispositiu, si és un dispositiu i-node\nsize\t grandària en bytes\natime\t moment de l'últim accés (temps Unix)\nmtime\t moment de l'última modificació (temps Unix)\nctime\t moment de l'última modificació de l'i-node (temps Unix)\nblksize\t grandària del bloc E/S del sistema de fitxers\nblocks\t nombre de blocs de 512 bytes assignats\n\nUns exemples...\n&lt;?php\n\n// ▒▒▒▒▒▒▒▒ Información del archivo ▒▒▒▒▒▒▒▒\n\n$file = &quot;miarchivo.txt&quot;;\n$texto = &quot;Todos somos muy ignorantes, lo que ocurre es que no todos ignoramos las mismas cosas.&quot;;\n\n$fp = fopen($file, &quot;w&quot;);\nfwrite($fp, $texto);\n\n$datos = stat($file);\n\necho $datos[3] . &quot;&lt;br&gt;&quot;; // Número de enlaces, 1\necho $datos[7] . &quot;&lt;br&gt;&quot;; // Tamaño en bytes, 85\necho $datos[8] . &quot;&lt;br&gt;&quot;; // Momento de último acceso, 1444138104\necho $datos[9] . &quot;&lt;br&gt;&quot;; // Momento de última modificación, 1444138251\n\n?&gt;\n\nDona una ullada a les funcions de directoris que té PHP, és molt interessant.",
		"tags": [ "note"]
},

{
		"title": "7. Web Scraping",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/5-acceso-a-datos/7-web-scraping/",
		"content": "Consisteix a navegar a una pàgina web i extraure informació automàticament, a partir del codi HTML generat, i organitzar la informació pública disponible en Internet.\nAquesta pràctica requereix l'ús d'una llibreria que facilite la descàrrega de la informació desitjada imitant la interacció d'un navegador web. Aquest &quot;robot&quot; pot accedir a diverses pàgines simultàniament.\n\n[!question] &quot;¿És legal?&quot;\nSi el lloc web indica que té el contingut protegit per drets d'autor o en les normes d'accés via usuari/contrasenya ens avisa de la seua prohibició, estaríem incorrent en un delicte.\nÉs recomanable estudiar l'arxiu robots.txt que es troba en l'arrel de cada lloc web.\nMés informació en l'article El manual complet per al web scraping legal i ètic en 2021\n\nGoutte\nGoutte és un senzill client HTTP per a PHP creat específicament per a fer web scraping. Ho va desenvolupar el mateix autor del framework Symfony i ofereix un API senzilla per a extraure dades de les respostes HTML/XML dels llocs web.\nEls components principals que abstrau Goutte sobre Symfony són:\n\nBrowserKit: simula el comportament d'un navegador web.\nCssSelector: tradueix consultes CSS en consultes XPath.\nDomCrawler: facilita l'ús del DOM i XPath.\n\nPer a poder utilitzar Goutte en el nostre projecte, executarem el següent comando en el terminal:\ncomposer require fabpot/goutte\n\nGoutte con selectores CSS\nA continuació farem un exemple molt senzill utilitzant els selectors CSS, extraient informació de la web https://books.toscrape.com/, la qual és una pàgina per a proves que no rebutjarà les nostres peticions.\nDesprés de crear un client amb Goutte, hem de realitzar un petició a una URL. Amb la resposta obtinguda, podem utilitzar el mètode filter per a indicar-li la ruta CSS que volem recórrer i iterar sobre els resultats mitjançant una funció anònima. Una vegada estem dins d'un determinat node, el mètode text() ens retornarà el contingut del propi node.\nEn concret, ficarem en un array associatiu el títol i el preu de tots els llibres de la categoria Classics.\n&lt;?php\nrequire '../vendor/autoload.php';\n\n$httpClient = new \\Goutte\\Client();\n$response = $httpClient-&gt;request('GET', 'https://books.toscrape.com/catalogue/category/books/classics_6/index.html');\n// colocamos los precios en un array\n$precios = [];\n$response-&gt;filter('.row li article div.product_price p.price_color')-&gt;each(\n// le pasamos $precios por referencia para poder editarla dentro del closure\nfunction ($node) use (&amp;$precios) {\n$precios[] = $node-&gt;text();\n}\n);\n\n// colocamos el nombre y el precio en un array asociativo\n$contadorPrecios = 0;\n$libros = [];\n$response-&gt;filter('.row li article h3 a')-&gt;each(\nfunction ($node) use ($precios, &amp;$contadorPrecios, &amp;$libros) {\n$libros[$node-&gt;text()] = $precios[$contadorPrecios];\n$contadorPrecios++;\n}\n);\n\nCrawler\nUn cas molt comú és obtindre la informació d'una pàgina que té els resultats paginados, de manera que anem recorrent els enllaços i accedint a cadascun dels resultats.\nEn aquest cas agafarem tots els preus dels llibres de fantasia, i els sumarem:\n&lt;?php\nrequire '../vendor/autoload.php';\n\nuse Goutte\\Client;\nuse Symfony\\Component\\HttpClient\\HttpClient;\n\n$client = new Client(HttpClient::create(['timeout' =&gt; 60]));\n$crawler = $client-&gt;request('GET', 'https://books.toscrape.com/catalogue/category/books/fantasy_19/index.html');\n\n$salir = false;\n\n$precios = [];\nwhile (!$salir) {\n$crawler-&gt;filter('.row li article div.product_price p.price_color')-&gt;each(\nfunction ($node) use (&amp;$precios) {\n$texto = $node-&gt;text();\n$cantidad = substr($texto, 2); // Le quitamos las libras ¿2 posiciones?\n$precios[] = floatval($cantidad);\n}\n);\n\n$enlace = $crawler-&gt;selectLink('next');\nif ($enlace-&gt;count() != 0) {\n// el enlace next existe\n$sigPag = $crawler-&gt;selectLink('next')-&gt;link();\n$crawler = $client-&gt;click($sigPag); // hacemos click\n} else {\n// ya no hay enlace next\n$salir = true;\n}\n}\n\n$precioTotal = array_sum($precios);\necho $precioTotal;",
		"tags": [ "note"]
},

{
		"title": "1. Introducció",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/1-introduccio/",
		"content": "Laravel és un framework PHP modern que simplifica el desenvolupament d'aplicacions web, incloent-hi la gestió de bases de dades. La integració amb Eloquent, el seu ORM (Object-Relational Mapping), permet treballar amb bases de dades de forma intuïtiva i eficient.",
		"tags": [ "note"]
},

{
		"title": "2. Configuració inicial",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/2-configuracio-inicial/",
		"content": "Laravel suporta diversos motors de bases de dades com MySQL, PostgreSQL, SQLite i SQL Server. La configuració principal es fa al fitxer .env i config/database.php.\nExemple de configuració al fitxer .env:\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=nom_base_de_dades\nDB_USERNAME=usuari\nDB_PASSWORD=contrasenya\n\nComprovació de connexió:\nDesprés de configurar el .env, utilitza el comandament:\nphp artisan migrate:status\n\nAquest comandament confirma si Laravel pot connectar-se a la base de dades configurada.\nDetecció de problemes comuns\n\nComprovar que l'extensió del driver de la base de dades (com pdo_mysql o pdo_pgsql) estigui habilitada al php.ini.\nUtilitzar php artisan config:clear per esborrar la memòria cau de configuracions si els canvis al .env no es reflecteixen.",
		"tags": [ "note"]
},

{
		"title": "3. Migracions en Laravel",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/3-migracions-en-laravel/",
		"content": "Introducció\nLes migracions són un sistema de control de versions per a bases de dades que permet treballar de manera col·laborativa, mantenint un històric dels canvis realitzats en l'esquema. Amb migracions, pots:\n\nCrear, modificar i esborrar taules.\nGestionar l'esquema de manera programàtica utilitzant Artisan i el Schema Builder.\nRevertir canvis mitjançant rollback o tornar a aplicar tots els canvis amb refresh.\n\nLaravel proporciona un conjunt d'eines intuïtives per gestionar migracions, com Artisan i la classe Schema.\nEstructura de les migracions\nTotes les migracions es guarden a la carpeta database/migrations i segueixen una estructura predefinida amb dos mètodes principals:\n\nup: Defineix les operacions que s'han d'aplicar a la base de dades (crear taules, afegir columnes, etc.).\ndown: Defineix les operacions inverses per revertir els canvis aplicats per up.\n\nExemple bàsic:\npublic function up()\n{\nSchema::create('usuarios', function (Blueprint $tabla) {\n$tabla-&gt;id();\n$tabla-&gt;string('nombre');\n$tabla-&gt;string('email')-&gt;unique();\n$tabla-&gt;timestamps();\n});\n}\n\npublic function down()\n{\nSchema::dropIfExists('usuarios');\n}\n\nPer defecte, Laravel afegeix un camp autonumèric id i dues columnes timestamps (created_at i updated_at) gestionades automàticament.\nCrear una migració\nUtilitza Artisan per crear una nova migració:\nphp artisan make:migration nom_migracio\n\nAquest comando genera un fitxer amb un nom que inclou un timestamp per assegurar l'ordre cronològic.\nExemples\n\nCrear una taula:\n\nphp artisan make:migration crear_tabla_usuarios --create=usuarios\n\nModificar una taula existent:\n\nphp artisan make:migration afegir_camp_a_usuarios --table=usuarios\n\nLaravel pot inferir accions del nom de la migració gràcies a la classe TableGuesser. Per exemple, si el nom conté create o to, Artisan deduirà si és per crear o modificar taules.\nSchema Builder\nLa classe Schema és el nucli per definir i modificar l'esquema de les bases de dades. Inclou constructors per crear, modificar i eliminar taules i columnes.\nCrear una taula\nSchema::create('users', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('username', 32);\n$table-&gt;timestamps();\n});\n\nEliminar una taula\nSchema::dropIfExists('users');\n\nAfegir columnes\nSchema::table('usuarios', function (Blueprint $table) {\n$table-&gt;string('telefono')-&gt;after('email')-&gt;nullable();\n});\n\nEliminar columnes\nSchema::table('usuarios', function (Blueprint $table) {\n$table-&gt;dropColumn('telefono');\n});\n\nTipus de columnes disponibles\nLaravel ofereix una àmplia varietat de tipus de columnes per satisfer diferents necessitats\nÍndexs i claus forànies\nCrear índexs\n$table-&gt;unique('email');\n$table-&gt;index('state');\n$table-&gt;primary(['first_name', 'last_name']);\n\nDefinir claus forànies\n$table-&gt;foreignId('user_id')-&gt;constrained()-&gt;onDelete('cascade');\n\nExecutar i revertir migracions\n\nExecutar migracions pendents:\n\nphp artisan migrate\n\nRevertir l'última migració:\n\nphp artisan migrate:rollback\n\nRevertir totes les migracions:\n\nphp artisan migrate:reset\n\nRefrescar totes les migracions:\n\nphp artisan migrate:refresh\n\nComprovar l'estat de les migracions:\n\nphp artisan migrate:status\n\nAquest conjunt de comandes permet un control complet sobre l'estat de les migracions durant el desenvolupament.",
		"tags": [ "note"]
},

{
		"title": "4. Laravel Query Builder",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/4-laravel-query-builder/",
		"content": "El Query Builder de Laravel proporciona una interfície fluida per construir i executar consultes de bases de dades. Permet treballar amb diverses bases de dades de manera senzilla sense escriure SQL brut.\n\nExemples d'ús\nObtenir tots els registres:\n$users = DB::table('users')-&gt;get();\n\nFiltrar registres:\n$users = DB::table('users')\n-&gt;where('active', 1)\n-&gt;get();\n\nSeleccionar columnes específiques:\n$users = DB::table('users')\n-&gt;select('name', 'email')\n-&gt;get();\n\nOrdenar resultats:\n$users = DB::table('users')\n-&gt;orderBy('name', 'asc')\n-&gt;get();\n\nComptar registres:\n$count = DB::table('users')-&gt;count();\n\nConsultes amb agregats:\n$maxSalary = DB::table('employees')-&gt;max('salary');\n\nConsultes amb subconsultes:\n$users = DB::table('users')\n-&gt;whereExists(function ($query) {\n$query-&gt;select(DB::raw(1))\n-&gt;from('orders')\n-&gt;whereColumn('orders.user_id', 'users.id');\n})\n-&gt;get();\n\nUnions:\n$first = DB::table('users')-&gt;where('type', 'admin');\n$second = DB::table('users')-&gt;where('type', 'customer');\n\n$users = $first-&gt;union($second)-&gt;get();\n\nInserir un registre:\nDB::table('users')-&gt;insert([\n'name' =&gt; 'John Doe',\n'email' =&gt; 'john@example.com',\n]);\n\nActualitzar un registre:\nDB::table('users')\n-&gt;where('id', 1)\n-&gt;update(['name' =&gt; 'Updated Name']);\n\nEsborrar un registre:\nDB::table('users')\n-&gt;where('id', 1)\n-&gt;delete();\n\nEsborrar tots els registres:\nDB::table('users')-&gt;truncate();\n\nAvantatges\nEl Query Builder és ideal per a:\n\nConsultes personalitzades on el rendiment és una prioritat.\nConsultes complexes que no es poden expressar fàcilment amb Eloquent.",
		"tags": [ "note"]
},

{
		"title": "5. Laravel Eloquent",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/5-laravel-eloquent/",
		"content": "Eloquent és l'ORM (Object-Relational Mapping) de Laravel. Proporciona una interfície senzilla i elegant per treballar amb bases de dades relacionals mitjançant models.\nDefinició de Models\nEls models es defineixen dins de la carpeta app/Models i es poden crear mitjançant Artisan:\nphp artisan make:model Movie\n\nExemple bàsic:\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Movie extends Model\n{\n// Taula associada al model\nprotected $table = 'movies';\n}\n\nPer defecte:\n\nEl model s'associa a una taula plural (movies per al model Movie).\nUtilitza id com a clau primària.\nAssumeix l'ús de camps created_at i updated_at gestionats automàticament.\n\nÚs bàsic d'un model\nRecuperar dades:\n\nTots els registres:\n\n$movies = Movie::all();\n\nRegistres filtrats:\n\n$movies = Movie::where('rating', '&gt;', 4)-&gt;get();\n\nRegistre únic:\n\n$movie = Movie::findOrFail($id);\n\nInserir dades:\n$movie = new Movie();\n$movie-&gt;title = &quot;Inception&quot;;\n$movie-&gt;director = &quot;Christopher Nolan&quot;;\n$movie-&gt;save();\n\nActualitzar dades:\n$movie = Movie::find($id);\n$movie-&gt;title = &quot;Updated Title&quot;;\n$movie-&gt;save();\n\nEsborrar dades:\n$movie = Movie::find($id);\n$movie-&gt;delete();\n\nPropietats comuns dels Models Eloquent\nEls models d'Eloquent ofereixen diverses propietats que permeten configurar el comportament de la interacció amb la base de dades. A continuació es detallen les més importants:\n&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Example extends Model\n{\n// Especifica el nom de la taula si no segueix la convenció per defecte\nprotected $table = 'custom_table_name';\n\n// Defineix la clau primària de la taula\nprotected $primaryKey = 'custom_id';\n\n// Indica si la clau primària és autoincremental\npublic $incrementing = false;\n\n// Especifica el tipus de la clau primària (per exemple, string si no és integer)\nprotected $keyType = 'string';\n\n// Defineix quins camps poden ser assignats massivament\nprotected $fillable = ['name', 'email', 'password'];\n\n// Defineix quins camps no poden ser assignats massivament\nprotected $guarded = ['is_admin'];\n\n// Oculta camps quan es converteix a JSON o arrays\nprotected $hidden = ['password', 'remember_token'];\n\n// Defineix quins camps són visibles quan es converteix a JSON o arrays\nprotected $visible = ['name', 'email'];\n\n// Transformació automàtica de camps a un tipus específic\nprotected $casts = [\n'is_admin' =&gt; 'boolean',\n'settings' =&gt; 'array',\n];\n\n// Indica si la taula té els camps `created_at` i `updated_at`\npublic $timestamps = true;\n\n// Defineix la connexió a la base de dades\nprotected $connection = 'mysql';\n}\n\nRelacions en Eloquent\n1. Un a un (One-to-One):\nUn usuari té un perfil:\nclass User extends Model\n{\npublic function profile()\n{\nreturn $this-&gt;hasOne(Profile::class);\n}\n}\n\n$user = User::find(1);\n$profile = $user-&gt;profile;\n\n2. Un a molts (One-to-Many):\nUn autor té molts llibres:\nclass Author extends Model\n{\npublic function books()\n{\nreturn $this-&gt;hasMany(Book::class);\n}\n}\n\n$author = Author::find(1);\n$books = $author-&gt;books;\n\n3. Molts a molts (Many-to-Many):\nUn usuari té molts rols:\nclass User extends Model\n{\npublic function roles()\n{\nreturn $this-&gt;belongsToMany(Role::class);\n}\n}\n\n$user = User::find(1);\n$roles = $user-&gt;roles;\n\n4. Has Many Through (Relacions transitives):\nPermet accedir a dades relacionades a través d'un altre model.\nclass Country extends Model\n{\npublic function posts()\n{\nreturn $this-&gt;hasManyThrough(Post::class, User::class);\n}\n}\n\nEager Loading (Càrrega eficient de relacions)\nPer evitar múltiples consultes a la base de dades, pots carregar relacions amb with:\n$authors = Author::with('books')-&gt;get();\n\nCol·leccions i Agrupacions\nEloquent retorna col·leccions per defecte, que permeten treballar amb mètodes\nMutators i Accessors\nEls mutators permeten transformar dades abans de guardar-les, i els accessors les transformen en recuperar-les.\nExemple:\nclass User extends Model\n{\n// Accessor\npublic function getFullNameAttribute()\n{\nreturn &quot;{$this-&gt;first_name} {$this-&gt;last_name}&quot;;\n}\n\n// Mutator\npublic function setPasswordAttribute($value)\n{\n$this-&gt;attributes['password'] = bcrypt($value);\n}\n}\n\nÚs:\n$user = User::find(1);\n$fullName = $user-&gt;full_name;\n\n$user-&gt;password = 'new_password';\n$user-&gt;save();\n\nPaginació\nLaravel facilita la paginació:\n$movies = Movie::paginate(10);\n\nEn la vista:\n{{ $movies-&gt;links() }}",
		"tags": [ "note"]
},

{
		"title": "6. Seeders i Factories en Laravel",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/6-seeders-i-factories-en-laravel/",
		"content": "Els seeders i factories permeten generar dades de prova de manera fàcil i ràpida, útils durant el desenvolupament per simular dades inicials en una aplicació.\n\nSeeders\nEls seeders són classes especials que permeten &quot;sembrar&quot; dades a la base de dades.\nCrear un Seeder\nphp artisan make:seeder NomSeeder\n\nAixò crea un fitxer a la carpeta database/seeders. Per exemple:\nclass BooksSeeder extends Seeder\n{\npublic function run()\n{\n// Exemple: Crear un llibre\n$book = new Book();\n$book-&gt;title = &quot;Laravel for Beginners&quot;;\n$book-&gt;author = &quot;John Doe&quot;;\n$book-&gt;save();\n}\n}\n\nAfegir Seeders al Seeder General\nInclou els seeders al fitxer DatabaseSeeder:\nclass DatabaseSeeder extends Seeder\n{\npublic function run()\n{\n$this-&gt;call([\nBooksSeeder::class,\nAuthorsSeeder::class,\n]);\n}\n}\n\nExecutar Seeders\nExecutar tots els seeders:\nExecutar un seeder específic:\nReiniciar les migracions i executar els seeders:\nphp artisan db:seed\nphp artisan db:seed --class=BooksSeeder\nphp artisan migrate:fresh --seed\n\nFactories\nEls factories permeten crear grans quantitats de dades de manera ràpida i dinàmica mitjançant Faker.\nCrear un Factory\nphp artisan make:factory NomFactory -m Model\n\nPer exemple, per al model Author:\nnamespace Database\\Factories;\n\nuse App\\Models\\Author;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\n\nclass AuthorFactory extends Factory\n{\nprotected $model = Author::class;\n\npublic function definition()\n{\nreturn [\n'name' =&gt; $this-&gt;faker-&gt;name,\n'birth_year' =&gt; $this-&gt;faker-&gt;year,\n];\n}\n}\n\nUtilitzar un Factory\nPer generar dades amb un factory:\nuse App\\Models\\Author;\n\n// Crear un únic autor\nAuthor::factory()-&gt;create();\n\n// Crear diversos autors\nAuthor::factory()-&gt;count(10)-&gt;create();\n\nIntegració amb Seeders\nCombina factories amb seeders per generar dades dinàmiques:\nclass AuthorsSeeder extends Seeder\n{\npublic function run()\n{\nAuthor::factory()-&gt;count(10)-&gt;create();\n}\n}\n\nDades Relacionades\nEls factories permeten generar dades relacionades. Per exemple, llibres amb els seus autors:\nclass BooksSeeder extends Seeder\n{\npublic function run()\n{\n$authors = Author::factory()-&gt;count(5)-&gt;create();\n\n$authors-&gt;each(function ($author) {\nBook::factory()-&gt;count(2)-&gt;create(['author_id' =&gt; $author-&gt;id]);\n});\n}\n}\n\nExemples Avançats\nPodem cercar com construir factories més complexes a la documentació oficial.\nUtilitzar Factories per Relacions\nDefinir relacions dins d’un factory:\nclass BookFactory extends Factory\n{\npublic function definition()\n{\nreturn [\n'title' =&gt; $this-&gt;faker-&gt;sentence,\n'author_id' =&gt; Author::factory(),\n];\n}\n}\n\nLlançar el factory:\nBook::factory()-&gt;count(10)-&gt;create();\n\nFactories amb Estats\nEls estats permeten definir configuracions personalitzades per un model:\nclass BookFactory extends Factory\n{\npublic function withDiscount()\n{\nreturn $this-&gt;state([\n'price' =&gt; $this-&gt;faker-&gt;numberBetween(5, 10),\n]);\n}\n}\n\nÚs d'un estat:\nBook::factory()-&gt;withDiscount()-&gt;create();\n\nAvantatges dels Factories\n\nFaciliten la generació massiva de dades.\nSimplifiquen les proves i el desenvolupament amb dades fictícies realistes.\nRedueixen el temps d'inicialització de les aplicacions.",
		"tags": [ "note"]
},

{
		"title": "7. Requests, Responses i Validació en Laravel",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/7-requests-responses-i-validacio-en-laravel/",
		"content": "1. Requests\nIntroducció\nUn Request en Laravel és un objecte que encapsula la informació sobre la petició HTTP, incloent dades, capçaleres, paràmetres i fitxers.\nAccés a dades del Request\n$input = $request-&gt;all(); //Accedir a tots els inputs.\n$name = $request-&gt;input('name'); //Obtenir un input específic.\n$age = $request-&gt;input('age', 18); //Especificar valors per defecte.\n$id = $request-&gt;route('id'); //Accedir a paràmetres de ruta.\n\nValidació de presència\nif ($request-&gt;has('email')) {\n// Input 'email' present\n}\nif ($request-&gt;filled('name')) {\n// Input 'name' no està buit\n}\n$filtered = $request-&gt;only(['name', 'email']); //Filtrar inputs específics.\n$excluded = $request-&gt;except(['password']); //Excloure certs inputs.\n\nTractament de fitxers\nif ($request-&gt;hasFile('photo')) { //Comprovar si hi ha un fitxer.\n$file = $request-&gt;file('photo');\n}\n$path = $request-&gt;file('photo')-&gt;store('photos'); //Emmagatzemar un fitxer.\n\n2. Responses\nCreació de respostes\nreturn response('Hello World', 200); //Crear una resposta bàsica.\nreturn response()-&gt;json([\n'name' =&gt; 'John',\n'status' =&gt; 'success'\n]); //Crear una resposta JSON.\nreturn redirect('dashboard'); //Redirecció .\nreturn redirect('login')-&gt;with('status', 'Sessió iniciada'); //Redirecció amb dades de sessió.\n\nManipular capçaleres\n//Afegeix una o múltiples capçaleres.\nreturn response('Hello')-&gt;header('Content-Type', 'text/plain');\nreturn response('Hello')\n-&gt;header('Content-Type', 'application/json')\n-&gt;header('Cache-Control', 'no-cache');\n\nRespostes de fitxers\n\nreturn response()-&gt;download($pathToFile); //Descàrrega de fitxers.\nreturn response()-&gt;file($pathToFile); //Mostrar fitxers.\n\n3. Validació\nIntroducció\nLaravel ofereix un sistema potent i senzill per validar dades d'inputs.\nValidació bàsica\n// Validar dades amb un Request.\n$request-&gt;validate([\n'name' =&gt; 'required|string|max:255',\n'email' =&gt; 'required|email',\n'password' =&gt; 'required|min:8',\n]);\n\n// Validar manualment.\n$validator = Validator::make($request-&gt;all(), [\n'title' =&gt; 'required|max:255',\n'body' =&gt; 'required',\n]);\n\nif ($validator-&gt;fails()) {\nreturn redirect('/form')-&gt;withErrors($validator);\n}\n\nRegles comunes\n\nrequired: Camp obligatori.\nemail: Validació d'un correu electrònic.\nmin:value: Mínim de caràcters o valor numèric.\nmax:value: Màxim de caràcters o valor numèric.\nunique:table,column: Ha de ser únic en una taula/columna.\nLlista sencera de regles\n\nMissatges personalitzats\n// Es poden definir missatges personalitzats per a les regles de validació.\n\n$request-&gt;validate([\n'name' =&gt; 'required',\n], [\n'name.required' =&gt; 'El nom és obligatori.',\n]);\n\nValidació condicional\n// Validació basada en altres camps o condicions.\n$request-&gt;validate([\n'password' =&gt; 'required_if:is_admin,true',\n]);\n\nValidació personalitzada\n// Es poden afegir regles personalitzades mitjançant extensions del Validator.\n\nValidator::extend('uppercase', function ($attribute, $value, $parameters, $validator) {\nreturn strtoupper($value) === $value;\n});\n\nErrors de validació\n// Obtenir tots els errors en la vista\n@if ($errors-&gt;any())\n&lt;ul&gt;\n@foreach ($errors-&gt;all() as $error)\n&lt;li&gt;{{ $error }}&lt;/li&gt;\n@endforeach\n&lt;/ul&gt;\n@endif\n\n// Mostrar errors per camp específic\n@error('name')\n&lt;div&gt;{{ $message }}&lt;/div&gt;\n@enderror",
		"tags": [ "note"]
},

{
		"title": "8. Exercici Pràctic, Guia d'Equips de Futbol Femení amb Base de Dades",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/php-teoria-batoi/8-gestio-de-dades-amb-laravel/8-exercici-practic-guia-d-equips-de-futbol-femeni-amb-base-de-dades/",
		"content": "L'objectiu d'aquest exercici és estendre la Guia d'Equips de Futbol Femení per utilitzar una base de dades relacional. Aprendràs a crear taules amb migracions, models per gestionar les dades, i a integrar-los amb controladors i vistes.\n\n1. Crear la Migració per a la Taula equips\nMigració\n\nGenera una migració per a la taula equips amb la següent estructura:\n\nid: Clau primària, autoincremental.\nnom: Nom de l'equip (cadena, únic, obligatori).\nestadi: Nom de l'estadi de l'equip (cadena, obligatori).\ntitols: Nombre de títols guanyats (entero, predeterminat 0).\ncreated_at i updated_at: Camps de timestamps generats automàticament.\n\nphp artisan make:migration create_equips_table --create=equips\n\nModifica el fitxer de migració per incloure l'estructura de la taula:\n\npublic function up()\n{\nSchema::create('equips', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('nom')-&gt;unique();\n$table-&gt;string('estadi');\n$table-&gt;integer('titols')-&gt;default(0);\n$table-&gt;timestamps();\n});\n}\n\nExecuta la migració per crear la taula:\n\nphp artisan migrate\n\nModels i Seeders\n\nGenera un model anomenat Equip per gestionar la taula:\n\nphp artisan make:model Equip\n\nModifica el model Equip a app/Models/Equip.php per definir els camps que es poden emplenar mitjançant assignació massiva:\n\nprotected $fillable = ['nom', 'estadi', 'titols'];\n\nCrea un seeder per a la taula equips:\n\nphp artisan make:seeder EquipsSeeder\n\nModifica el seeder EquipsSeeder per generar dades d'exemple:\n\npublic function run()\n{\nDB::table('equips')-&gt;insert([\n['nom' =&gt; 'Barça Femení', 'estadi' =&gt; 'Camp Nou', 'titols' =&gt; 30],\n['nom' =&gt; 'Atlètic de Madrid', 'estadi' =&gt; 'Cívitas Metropolitano', 'titols' =&gt; 10],\n['nom' =&gt; 'Real Madrid Femení', 'estadi' =&gt; 'Alfredo Di Stéfano', 'titols' =&gt; 5],\n]);\n}\n\nAfegeix el seeder EquipsSeeder al fitxer DatabaseSeeder:\n\npublic function run()\n{\n$this-&gt;call([\nEquipsSeeder::class,\n]);\n}\n\nExecuta els seeders per omplir la taula equips amb dades d'exemple:\n\nphp artisan db:seed\n\nControladors i CRUD\n\nModifica el mètode index,show,create,edit i destroy del controlador per obtenir els equips des de la base de dades:\npublic function index() {\n$equips = Equip::all();\nreturn view('equips.index', compact('equips'));\n}\n\npublic function show(Equip $equip) {\nreturn view('equips.show', compact('equip'));\n}\n\npublic function create() {\nreturn view('equips.create');\n}\n\npublic function edit(Equip $equip) {\nreturn view('equips.edit', compact('equip'));\n}\n\npublic function destroy(Equip $equip) {\n$equip-&gt;delete();\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip esborrat correctament!');\n}\n\nRelacions entre Taules\n\nAnem a crear la migració, model i seeder per la taula estadis i vincular-la amb la taula equips.\n\nphp artisan make:migration create_estadis_table\nphp artisan make:migration add_estadi_id_to_equips_table\nphp artisan make:model Estadi\nphp artisan make:seeder EstadisSeeder\n\nModifica la migració create_estadis_table per incloure l'estructura de la taula estadis:\n\npublic function up()\n{\nSchema::create('estadis', function (Blueprint $table) {\n$table-&gt;id();\n$table-&gt;string('nom')-&gt;unique();\n$table-&gt;integer('capacitat');\n$table-&gt;timestamps();\n});\n}\n\nModifica la migració add_estadi_id_to_equips_table per afegir la clau forana estadi_id a la taula equips:\n\npublic function up()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;dropColumn('estadi'); // Esborra el camp estadi\n$table-&gt;foreignId('estadi_id')-&gt;constrained(); // Afegir la clau forana\n});\n}\n\npublic function down()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;string('estadi');\n$table-&gt;dropForeign(['estadi_id']);\n$table-&gt;dropColumn('estadi_id');\n});\n}\n\nModifica el model Equip per definir la relació amb l'estadi:\n\npublic function estadi()\n{\nreturn $this-&gt;belongsTo(Estadi::class);\n}\n\nModifica el model Estadi per definir la relació amb els equips:\n\npublic function equips()\n{\nreturn $this-&gt;hasMany(Equip::class);\n}\n\nModifica el seeder EstadisSeeder per generar dades d'exemple per a la taula estadis:\n\npublic function run()\n{\nDB::table('estadis')-&gt;insert([\n['nom' =&gt; 'Camp Nou', 'capacitat' =&gt; 99000],\n['nom' =&gt; 'Wanda Metropolitano', 'capacitat' =&gt; 68000],\n['nom' =&gt; 'Santiago Bernabéu', 'capacitat' =&gt; 81000],\n]);\n}\n\nAfegeix el seeder EstadisSeeder al fitxer DatabaseSeeder:\n\npublic function run()\n{\n$this-&gt;call([\nEstadisSeeder::class,\nEquipsSeeder::class,\n\n]);\n}\n\nModifica el seeder EquipsSeeder per assignar equips a estadis existents:\n\npublic function run()\n{\n$estadi = Estadi::where('nom', 'Camp Nou')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Barça Femení',\n'titols' =&gt; 30,\n]);\n$estadi = Estadi::where('nom', 'Wanda Metropolitano')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Atlètic de Madrid',\n'titols' =&gt; 10,\n]);\n$estadi = Estadi::where('nom', 'Santiago Bernabéu')-&gt;first();\n$estadi-&gt;equips()-&gt;create([\n'nom' =&gt; 'Real Madrid Femení',\n'titols' =&gt; 5,\n]);\n}\n\nExecuta els seeders per omplir les taules equips i estadis amb dades d'exemple:\n\nphp artisan migrate:fresh --seed\n\nModifica la vista equips.index per mostrar l'estadi de cada equip:\n\n@foreach ($equips as $equip)\n&lt;tr class=&quot;hover:bg-gray-100&quot;&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;\n&lt;a href=&quot;{{ route('equips.show', $equip-&gt;id) }}&quot; class=&quot;text-blue-700 hover:underline&quot;&gt;{{ $equip-&gt;nom }}&lt;/a&gt;\n&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;{{ $equip-&gt;estadi-&gt;nom }}&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;{{ $equip-&gt;titols }}&lt;/td&gt;\n&lt;td class=&quot;border border-gray-300 p-2 flex space-x-2&quot;&gt;\n&lt;a href=&quot;{{ route('equips.show', $equip-&gt;id) }}&quot; class=&quot;text-green-600 hover:underline&quot;&gt;Mostrar&lt;/a&gt;\n&lt;a href=&quot;{{ route('equips.edit', $equip-&gt;id) }}&quot; class=&quot;text-yellow-600 hover:underline&quot;&gt;Editar&lt;/a&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n@endforeach\n\nCrea la vista equips.create per incloure un desplegable amb els estadis disponibles:\n\n&lt;form action=&quot;{{ route('equips.store') }}&quot; method=&quot;POST&quot; class=&quot;bg-white p-6 rounded-lg shadow-md max-w-md mx-auto&quot;&gt;\n@csrf\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;nom&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Nom:&lt;/label&gt;\n&lt;input type=&quot;text&quot; name=&quot;nom&quot; id=&quot;nom&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;titols&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Títols:&lt;/label&gt;\n&lt;input type=&quot;number&quot; name=&quot;titols&quot; id=&quot;titols&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;estadi_id&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Estadi:&lt;/label&gt;\n&lt;select name=&quot;estadi_id&quot; id=&quot;estadi_id&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n@foreach ($estadis as $estadi)\n&lt;option value=&quot;{{ $estadi-&gt;id }}&quot;&gt;{{ $estadi-&gt;nom }}&lt;/option&gt;\n@endforeach\n&lt;/select&gt;\n&lt;/div&gt;\n\n&lt;button type=&quot;submit&quot;\nclass=&quot;w-full bg-blue-500 text-white font-medium py-2 px-4 rounded-lg shadow hover:bg-blue-600 focus:ring focus:ring-blue-300&quot;&gt;\nCrear Equip\n&lt;/button&gt;\n&lt;/form&gt;\n\nCal modificar el controlador EquipController per obtenir els estadis disponibles.\n\nCrea el mètode store en el controlador EquipController per emmagatzemar un nou equip:\n\npublic function store(Request $request) {\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'titols' =&gt; 'integer|min:0',\n]);\nEquip::create($validated);\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip creat correctament!');\n}\n\nCal modificat el model Equip per permetre l'assignació massiva de l'estadi.\n\nModifica la vista equips.edit per incloure un desplegable amb els estadis disponibles:\n\n&lt;form action=&quot;{{ route('equips.update', $equip-&gt;id) }}&quot; method=&quot;POST&quot; class=&quot;bg-white p-6 rounded-lg shadow-md max-w-md mx-auto&quot;&gt;\n@csrf\n@method('PUT')\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;nom&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Nom:&lt;/label&gt;\n&lt;input type=&quot;text&quot; name=&quot;nom&quot; id=&quot;nom&quot; value=&quot;{{ old('nom', $equip-&gt;nom) }}&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('nom') border-red-500 @enderror&quot;&gt;\n@error('nom')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;titols&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Títols:&lt;/label&gt;\n&lt;input type=&quot;number&quot; name=&quot;titols&quot; id=&quot;titols&quot; value=&quot;{{ old('titols', $equip-&gt;titols) }}&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('titols') border-red-500 @enderror&quot;&gt;\n@error('titols')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;estadi_id&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Estadi:&lt;/label&gt;\n&lt;select name=&quot;estadi_id&quot; id=&quot;estadi_id&quot; required\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500\n@error('estadi_id') border-red-500 @enderror&quot;&gt;\n@foreach ($estadis as $estadi)\n&lt;option value=&quot;{{ $estadi-&gt;id }}&quot; {{ $estadi-&gt;id == $equip-&gt;estadi_id ? 'selected' : '' }}&gt;\n{{ $estadi-&gt;nom }}\n&lt;/option&gt;\n@endforeach\n&lt;/select&gt;\n@error('estadi_id')\n&lt;p class=&quot;text-red-500 text-sm mt-1&quot;&gt;{{ $message }}&lt;/p&gt;\n@enderror\n&lt;/div&gt;\n\n&lt;button type=&quot;submit&quot;\nclass=&quot;w-full bg-blue-500 text-white font-medium py-2 px-4 rounded-lg shadow hover:bg-blue-600 focus:ring focus:ring-blue-300&quot;&gt;\nActualitzar Equip\n&lt;/button&gt;\n&lt;/form&gt;\n\nCrea el mètode update en el controlador EquipController per actualitzar un equip existent:\n\npublic function update(Request $request, $id) {\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips,nom,'.$id,\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'titols' =&gt; 'integer|min:0',\n]);\n$equip = Equip::findOrFail($id);\n$equip-&gt;update($validated);\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip actualitzat correctament!');\n}\n\nAfegir un escut a l'equip\n\nCrea una migració per afegir un camp escut a la taula equips:\n\nphp artisan make:migration add_escut_to_equips_table\n\nModifica la migració add_escut_to_equips_table per incloure el camp escut:\n\npublic function up()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;string('escut')-&gt;nullable();\n});\n}\npublic function down()\n{\nSchema::table('equips', function (Blueprint $table) {\n$table-&gt;dropColumn('escut');\n});\n}\n\nAplicar la migració\n\nphp artisan migrate\n\nModifica el model Equip per incloure el camp escut:\n\nprotected $fillable = ['nom', 'estadi_id', 'titols', 'escut'];\n\nModifica la vista equips.create per incloure un camp d'arxiu per pujar l'escut de l'equip:\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;escut&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Escut:&lt;/label&gt;\n&lt;input type=&quot;file&quot; name=&quot;escut&quot; id=&quot;escut&quot;\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n&lt;/div&gt;\n\nModifica la vista equips.edit per incloure un camp d'arxiu per actualitzar l'escut de l'equip:\n\n&lt;div class=&quot;mb-4&quot;&gt;\n&lt;label for=&quot;escut&quot; class=&quot;block text-sm font-medium text-gray-700 mb-1&quot;&gt;Escut:&lt;/label&gt;\n&lt;input type=&quot;file&quot; name=&quot;escut&quot; id=&quot;escut&quot;\nclass=&quot;w-full border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500&quot;&gt;\n@if ($equip-&gt;escut)\n&lt;p class=&quot;mt-2 text-sm text-gray-500&quot;&gt;Escut actual:&lt;/p&gt;\n&lt;img src=&quot;{{ asset('storage/' . $equip-&gt;escut) }}&quot; alt=&quot;Escut de {{ $equip-&gt;nom }}&quot; class=&quot;h-16 mt-2&quot;&gt;\n@endif\n&lt;/div&gt;\n\nAfegeix enctype=&quot;multipart/form-data&quot; al dos formularis:\n\n&lt;form action=&quot;{{ route('equips.store') }}&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;\n\nCrea un enllaç simbòlic a la carpeta storage\n\nphp artisan storage:link\n\nActualitza el mètode store del controlador\n\npublic function store(Request $request)\n{\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips',\n'titols' =&gt; 'integer|min:0',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'escut' =&gt; 'nullable|image|mimes:jpeg,png,jpg|max:2048', // Validació del fitxer\n]);\n\nif ($request-&gt;hasFile('escut')) {\n$path = $request-&gt;file('escut')-&gt;store('escuts', 'public');\n$validated['escut'] = $path;\n}\n\nEquip::create($validated);\n\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip creat correctament!');\n}\n\nActualitza el mètode update del controlador\n\npublic function update(Request $request, $id)\n{\n$validated = $request-&gt;validate([\n'nom' =&gt; 'required|unique:equips,nom,' . $id,\n'titols' =&gt; 'integer|min:0',\n'estadi_id' =&gt; 'required|exists:estadis,id',\n'escut' =&gt; 'nullable|image|mimes:jpeg,png,jpg|max:2048',\n]);\n\n$equip = Equip::findOrFail($id);\n\nif ($request-&gt;hasFile('escut')) {\nif ($equip-&gt;escut) {\nStorage::disk('public')-&gt;delete($equip-&gt;escut); // Esborra l'escut antic\n}\n$path = $request-&gt;file('escut')-&gt;store('escuts', 'public');\n$validated['escut'] = $path;\n}\n\n$equip-&gt;update($validated);\n\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip actualitzat correctament!');\n}\n\nCrea el mètode delete per esborrar l'escut de l'equip:\n\npublic function delete(Equip $equip)\n{\nif ($equip-&gt;escut) {\nStorage::disk('public')-&gt;delete($equip-&gt;escut);\n}\n$equip-&gt;delete();\nreturn redirect()-&gt;route('equips.index')-&gt;with('success', 'Equip esborrat correctament!');\n}\n\nModificat el component de la vista equips.show per mostrar l'escut de l'equip:\n\n&lt;div class=&quot;equip border rounded-lg shadow-md p-4 bg-white&quot;&gt;\n@if ($escut)\n&lt;td class=&quot;border border-gray-300 p-2&quot;&gt;\n&lt;img src=&quot;{{ asset('storage/' . $escut) }}&quot; alt=&quot;Escut de {{ $nom }}&quot; class=&quot;h-8 w-8 object-cover rounded-full&quot;&gt;\n&lt;/td&gt;\n@endif\n&lt;h2 class=&quot;text-xl font-bold text-blue-800&quot;&gt;{{ $nom }}&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Estadi:&lt;/strong&gt; {{ $estadi }}&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Títols:&lt;/strong&gt; {{ $titols }}&lt;/p&gt;\n&lt;/div&gt;\n\nUtilitzar Factories per a Dades d'Exemple\n\nCrea un factory per a la taula equips:\n\nphp artisan make:factory EquipFactory --model=Equip\n\nModifica el factory EquipFactory per generar dades aleatòries:\n\npublic function definition()\n{\nreturn [\n'nom' =&gt; $this-&gt;faker-&gt;unique()-&gt;company,\n'titols' =&gt; $this-&gt;faker-&gt;numberBetween(0, 50),\n'estadi_id' =&gt; \\App\\Models\\Estadi::factory(),\n'escut' =&gt; 'escuts/dummy.png', // Imatge de prova predefinida\n];\n}\n}\n\nActualitza el seeder EquipsSeeder per utilitzar el factory:\n\npublic function run()\n{\n...\nEquip::factory()-&gt;count(10)-&gt;create();\n}\n\nModifica el model Equip per permetre els factories:\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Estadi extends Model\n{\nuse HasFactory;\n...\n}\n\nCrea el factory per a la taula estadis:\n\nphp artisan make:factory EstadiFactory --model=Estadi\n\nModifica el factory EstadiFactory per generar dades aleatòries:\n\npublic function definition()\n{\nreturn [\n'nom' =&gt; $this-&gt;faker-&gt;unique()-&gt;city.' Stadium',\n'capacitat' =&gt; $this-&gt;faker-&gt;numberBetween(10000, 100000),\n];\n}\n\nExecuta els seeders per omplir la taula equips amb dades generades pel factory:\n\nphp artisan migrate:fresh --seed",
		"tags": [ "note"]
},

{
		"title": "Default",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/templates/default/",
		"content": "",
		"tags": [ "note"]
},

{
		"title": "Sin título",
		"date":"Sat Jan 04 2025 22:46:09 GMT+0000 (Coordinated Universal Time)",
		"url":"/templates/sin-titulo/",
		"content": "",
		"tags": [ "note"]
}
]