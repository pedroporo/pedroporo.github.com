[
{
		"title": "Asignatura de entornos a clientes",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/",
		"content": "type note(function(){return this.inputEl.value}) template\naction Sin título\ntemplater true\n```{ #button-km7s}\n\n[Pagina de github de los apuntes](https://github.com/cipfpbatoi/materials)",
		"tags": ["button-km7s", "note"]
},

{
		"title": "Desarollo Web en entorno servidor",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/",
		"content": "Pagina de github de los apuntes",
		"tags": [ "note"]
},

{
		"title": "Despliegue de aplicaciones WEB",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/",
		"content": "Hola despliege",
		"tags": [ "note"]
},

{
		"title": "Diseño de interfaces WEB",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/",
		"content": "Hola Diseño",
		"tags": [ "note"]
},

{
		"title": "Indice",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "Asignaturas\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/ingles/ingles/\">Ingles</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\nHorario:\n\nHora\nLunes\nMartes\nMiercoles\nJueves\nViernes\n\n14:55 - 15:50\nEmpresa\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\nEmpresa\n\n15:50 - 16:45\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\nEmpresa\n\n16:45 - 17:40\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/despliegue-de-aplicaciones-web/despliegue-de-aplicaciones-web/\">Despliegue de aplicaciones WEB</a>\nTutoria\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/ingles/ingles/\">Ingles</a>\n\n17:40 - 18:00\nDescanso\nDescanso\nDescanso\nDescanso\nDescanso\n\n18:00 - 18:55\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/ingles/ingles/\">Ingles</a>\n\n18:55 - 19:50\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n\n19:50 - 20:45\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-servidor/desarollo-web-en-entorno-servidor/\">Desarollo Web en entorno servidor</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/diseno-de-interfaces-web/diseno-de-interfaces-web/\">Diseño de interfaces WEB</a>\n\n20:45 - 21:40\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/notas/desarollo-web-en-entorno-cliente/desarollo-web-en-entorno-cliente/\">Desarollo Web en entorno cliente</a>",
		"tags": [ "note","gardenEntry"]
},

{
		"title": "Ingles",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/ingles/ingles/",
		"content": "Profesor:",
		"tags": [ "note"]
},

{
		"title": "01-sintaxis",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/01-sintaxis/",
		"content": "Sintaxis\n\nSintaxis\n\nVariables\nFunciones\n\nParámetros\nFunciones anónimas\nArrow functions (funciones flecha)\n\nEstructuras y bucles\n\nEstructura condicional: if\nEstructura condicional: switch\nBucle while\nBucle: for\nBucle: for con contador\n\nBucle: for...in\nBucle: for...of\n\nTipos de datos básicos\n\nCasting de variables\nNumber\nString\n\nTemplate literals\n\nBoolean\n\nManejo de errores\nBuenas prácticas\n\n'use strict'\nVariables\nOtras\n\nClean Code\n\nVariables\nJavascript es un lenguaje dinámicamente tipado. Esto significa que no se indica de qué tipo es una variable al declararla e incluso puede cambiar su tipo a lo largo de la ejecución del programa. Ejemplo:\nlet miVariable; // declaro miVariable y como no se asigno un valor valdrá undefined\nmiVariable='Hola'; // ahora su valor es 'Hola', por tanto contiene una cadena de texto\nmiVariable=34; // pero ahora contiene un número\nmiVariable=[3, 45, 2]; // y ahora un array\nmiVariable=undefined; // para volver a valer el valor especial undefined\n\nAdemás es débilmente tipado, lo que significa que permite operaciones entre tipos de datos diferentes. Ejemplo:\nmiVariable='23';\nconsole.log(miVariable * 2); // mostrará 46 ya que convierte la cadena '23' a número\n\nEJERCICIO: Ejecuta en la consola del navegador las instrucciones anteriores y comprueba el valor de miVariable tras cada instrucción (para ver el valor de una variable simplemente ponemos en la consola su nombre: miVariable\n\nNi siquiera estamos obligados a declarar una variable antes de usarla, aunque es recomendable para evitar errores que nos costará depurar. Podemos hacer que se produzca un error si no declaramos una variable incluyendo al principio de nuestro código la instrucción\n'use strict'\n\nLas variables de declaran con let (lo recomendado desde ES2015), aunque también pueden declararse con var (nosotros NUNCA lo haremos). La diferencia es que con let el ámbito de la variable es sólo el bloque en que se declara mientras que con var su ámbito es global (o global a la función en que se declara):\nif (edad &lt; 18) {\nlet textoLet = 'Eres mayor de edad';\nvar textoVar = 'Eres mayor de edad';\n} else {\nlet textoLet = 'Eres menor de edad';\nvar textoVar = 'Eres menor de edad';\n}\nconsole.log(textoLet); // mostrará undefined porque fuera del if no existe la variable\nconsole.log(textoVar); // mostrará la cadena\n\nCualquier variable que no se declara dentro de una función (o si se usa sin declarar) es global. Debemos siempre intentar NO usar variables globales.\nSe recomienda que Los nombres de las variables sigan la sintaxis camelCase (ej.: miPrimeraVariable).\nDesde ES2015 también podemos declarar constantes con const. Se les debe dar un valor al declararlas y si intentamos modificarlo posteriorment se produce un error. Sin embargo si la variable es un objeto o array sí podemos modificar su contenido, aunque no vlarla a asignar. Se recomienda usarla siempre que sea posible. Ejemplo:\nconst PI=3.1416;\nPI=3.14; // dará un error\n\nconst miArray=[3, 4, 5];\nmiArray[0]=6; // esto sí se puede hacer\nmiArray=[6, 4, 5]; // esto dará un error\n\nNOTA: en la página de Babel podemos teclear código en ES2015 y ver cómo quedaría una vez transpilado a ES5.\nFunciones\nSe declaran con function y se les pasan los parámetros entre paréntesis. La función puede devolver un valor usando return (si no tiene return es como si devolviera undefined).\nPuede usarse una función antes de haberla declarado por el comportamiento de Javascript llamado hoisting: el navegador primero carga todas las funciones y mueve las declaraciones de las variables al principio y luego ejecuta el código.\n\nEJERCICIO: Haz una función que te pida que escribas algo y muestre un alert diciendo 'Has escrito...' y el valor introducido. Pruébala en la consola (pegas allí la función y luego la llamas desde la consola)\n\nParámetros\nSi se llama una función con menos parámetros de los declarados el valor de los parámetros no pasados será undefined:\nfunction potencia(base, exponente) {\nconsole.log(base); // muestra 4\nconsole.log(exponente); // muestra undefined\nlet valor=1;\nfor (let i=1; i&lt;=exponente; i++) {\nvalor=valor*base;\n}\nreturn valor;\n}\n\npotencia(4); // devolverá 1 ya que no se ejecuta el for\n\nPodemos dar un valor por defecto a los parámetros por si no los pasan asignándoles el valor al definirlos:\nfunction potencia(base, exponente=2) {\nconsole.log(base); // muestra 4\nconsole.log(exponente); // muestra 2 la primera vez y 5 la segunda\nlet valor=1;\nfor (let i=1; i&lt;=exponente; i++) {\nvalor=valor*base;\n}\nreturn valor;\n}\n\nconsole.log(potencia(4)); // mostrará 16 (4^2)\nconsole.log(potencia(4,5)); // mostrará 1024 (4^5)\n\nNOTA: Hasta ES6 para dar un valor por defecto a una variable se hacía\nfunction potencia(base, exponente) {\nexponente = exponente || 2; // si exponente vale undefined se la asigna el valor 2\n...\n\nTambién es posible acceder a los parámetros desde el array arguments[] si no sabemos cuántos recibiremos:\nfunction suma () {\nvar result = 0;\nfor (var i=0; i&lt;arguments.length; i++)\nresult += arguments[i];\nreturn result;\n}\n\nconsole.log(suma(4, 2)); // mostrará 6\nconsole.log(suma(4, 2, 5, 3, 2, 1, 3)); // mostrará 20\n\nEn Javascript las funciones son un tipo de datos más por lo que podemos hacer cosas como pasarlas por argumento o asignarlas a una variable:\nconst cuadrado = function(value) {\nreturn value * value\n}\nfunction aplica_fn(dato, funcion_a_aplicar) {\nreturn funcion_a_aplicar(dato);\n}\n\naplica_fn(3, cuadrado); // devolverá 9 (3^2)\n\nAl usar paréntesis () se llama a la función. Sin paréntesis sólo se hace referencia al objeto que representa la función. La capacidad de Javascript de tratar las funciones como objetos le permite el uso de funciones de Callback y la programación funcional, que veremos más adelante.\nFunciones anónimas\nComo acabamos de ver podemos definir una función sin darle un nombre. Dicha función puede asignarse a una variable, autoejecutarse o asignasrse a un manejador de eventos. Ejemplo:\nlet holaMundo = function() {\nalert('Hola mundo!');\n}\n\nholaMundo(); // se ejecuta la función\n\nComo vemos asignamos una función a una variable de forma que podamos &quot;ejecutar&quot; dicha variable.\nArrow functions (funciones flecha)\nES2015 permite declarar una función anónima de forma más corta. Ejemplo sin arrow function:\nlet potencia = function(base, exponente) {\nlet valor=1;\nfor (let i=1; i&lt;=exponente; i++) {\nvalor=valor*base;\n}\nreturn valor;\n}\n\nAl escribirla con la sintaxis de una arrow function lo que hacemos es:\n\nEliminamos la palabra function\nSi sólo tiene 1 parámetro podemos eliminar los paréntesis de los parámetros\nPonemos el símbolo =&gt;\nSi la función sólo tiene 1 línea podemos eliminamr las { } y la palabra return\n\nEl ejemplo con arrow function:\nlet potencia = (base, exponente) =&gt; {\nlet valor=1;\nfor (let i=1; i&lt;=exponente; i++) {\nvalor=valor*base;\n}\nreturn valor;\n}\n\nOtro ejemplo, sin arrow function:\nlet cuadrado = function(base) {\nreturn base * base;\n}\n\nconn arrow function:\nlet cuadrado = base =&gt; base * base;\n\nEJERCICIO: Haz una arrow function que devuelva el cubo del número pasado como parámetro y pruébala desde la consola. Escríbela primero en la forma habitual y luego la &quot;traduces&quot; a arrow function.\n\nLas arrow function son muy útiles cuando se usan como parámetros de otras funciones (como veremos en programación funcional) pero no tienen su propio contexto this por lo que no las podremos usar como métodos de una clase u objeto).\nEstructuras y bucles\nEstructura condicional: if\nEl if es como en la mayoría de lenguajes. Puede tener asociado un else y pueden anidarse varios con else if.\nif (condicion) {\n...\n} else if (condicion2) {\n...\n} else if (condicion3) {\n...\n} else {\n...\n}\n\nEjemplo:\nif (edad &lt; 18) {\nconsole.log('Es menor de edad');\n} else if (edad &gt; 65) {\nconsole.log('Está jubilado');\n} else {\nconsole.log('Edad correcta');\n}\n\nSe puede usar el operador ? : que es como un if que devuelve un valor:\nlet esMayorDeEdad = (edad &gt; 18) ? true : false;\n\nEstructura condicional: switch\nEl switch también es como en la mayoría de lenguajes. Hay que poner break al final de cada bloque para que no continúe evaluando:\nswitch(color) {\ncase 'blanco':\ncase 'amarillo': // Ambos colores entran aquí\ncolorFondo='azul';\nbreak;\ncase 'azul':\ncolor_lambda_Fondo='amarillo';\nbreak;\ndefault: // Para cualquier otro valor\ncolorFondo='negro';\n}\n\nJavascript permite que el switch en vez de evaluar valores pueda evaluar expresiones. En este caso se pone como condición true:\nswitch(true) {\ncase age &lt; 18:\nconsole.log('Eres muy joven para entrar');\nbreak;\ncase age &lt; 65:\nconsole.log('Puedes entrar');\nbreak;\ndefault:\nconsole.log('Eres muy mayor para entrar');\n}\n\nBucle while\nPodemos usar el bucle while...do\nwhile (condicion) {\n// sentencias\n}\n\nque se ejecutará 0 o más veces. Ejemplo:\nlet nota=prompt('Introduce una nota (o cancela para finalizar)');\nwhile (nota) {\nconsole.log('La nota introducida es: '+nota);\nnota=prompt('Introduce una nota (o cancela para finalizar)');\n}\n\nO el bucle do...while:\ndo {\n// sentencias\n} while (condicion)\n\nque al menos se ejecutará 1 vez. Ejemplo:\nlet nota;\ndo {\nnota=prompt('Introduce una nota (o cancela para finalizar)');\nconsole.log('La nota introducida es: '+nota);\n} while (nota)\n\nEJERCICIO: Haz un programa para que el usuario juegue a adivinar un número. Obtén un número al azar (busca por internet cómo se hace o simplemente guarda el número que quieras en una variable) y ve pidiendo al usuario que introduzca un número. Si es el que busca le dices que lo ha encontrado y si no le mostrarás si el número que busca el mayor o menor que el introducido. El juego acaba cuando el usuario encuentra el número o cuando pulsa en 'Cancelar' (en ese caso le mostraremos un mensaje de que ha cancelado el juego).\n\nBucle: for\nTenemos muchos for que podemos usar.\nBucle: for con contador\nCreamos una variable contador que controla las veces que se ejecuta el for:\nlet datos=[5, 23, 12, 85]\nlet sumaDatos=0;\n\nfor (let i=0; i&lt;datos.length; i++) {\nsumaDatos += datos[i];\n}\n// El valor de sumaDatos será 125\n\nEJERCICIO: El factorial de un número entero n es una operación matemática que consiste en multiplicar ese número por todos los enteros menores que él: n x (n-1) x (n-2) x ... x 1. Así, el factorial de 5 (se escribe 5!) vale 5! = 5 x 4 x 3 x 2 x 1 = 120. Haz un script que calcule el factorial de un número entero.\n\nBucle: for...in\nEl bucle se ejecuta una vez para cada elemento del array (o propiedad del objeto) y se crea una variable contador que toma como valores la posición del elemento en el array:\nlet datos=[5, 23, 12, 85]\nlet sumaDatos=0;\n\nfor (let indice in datos) {\nsumaDatos += datos[indice]; // los valores que toma indice son 0, 1, 2, 3\n}\n// El valor de sumaDatos será 125\n\nTambién sirve para recorrer las propiedades de un objeto:\nlet profe={\nnom:'Juan',\nape1='Pla',\nape2='Pla'\n}\nlet nombre='';\n\nfor (var campo in profe) {\nnombre += profe.campo + ' '; // o profe[campo];\n}\n// El valor de nombre será 'Juan Pla Pla '\n\nBucle: for...of\nEs similar al for...in pero la variable contador en vez de tomar como valor cada índice toma cada elemento. Es nuevo en ES2015:\nlet datos = [5, 23, 12, 85]\nlet sumaDatos = 0;\n\nfor (let valor of datos) {\nsumaDatos += valor; // los valores que toma valor son 5, 23, 12, 85\n}\n// El valor de sumaDatos será 125\n\nTambién sirve para recorrer los caracteres de una cadena de texto:\nlet cadena = 'Hola';\n\nfor (let letra of cadena) {\nconsole.log(letra); // los valores de letra son 'H', 'o', 'l', 'a'\n}\n\nEJERCICIO: Haz 3 funciones a las que se le pasa como parámetro un array de notas y devuelve la nota media. Cada una usará un for de una de las 3 formas vistas. Pruébalas en la consola\n\nTipos de datos básicos\nPara saber de qué tipo es el valor de una variable tenemos el operador typeof. Ej.:\n\ntypeof 3 devuelve number\ntypeof 'Hola' devuelve string\n\nEn Javascript hay 2 valores especiales:\n\nundefined: es lo que vale una variable a la que no se ha asignado ningún valor\nnull: es un tipo de valor especial que podemos asignar a una variable. Es como un objeto vacío (typeof null devuelve object)\n\nTambién hay otros valores especiales relacionados con operaciones con números:\n\nNaN (Not a Number): indica que el resultado de la operación no puede ser convertido a un número (ej. 'Hola'*2, aunque '2'*2 daría 4 ya que se convierte la cadena '2' al número 2)\nInfinity y -Infinity: indica que el resultado es demasiado grande o demasiado pequeño (ej. 1/0 o -1/0)\n\nCasting de variables\nComo hemos dicho las variables pueden contener cualquier tipo de valor y, en las operaciones, Javascript realiza automáticamente las conversiones necesarias para, si es posible, realizar la operación. Por ejemplo:\n\n'4' / 2 devuelve 2 (convierte '4' en 4 y realiza la operación)\n'23' - null devuelve 0 (hace 23 - 0)\n'23' - undefined devuelve NaN (no puede convertir undefined a nada así que no puede hacer la operación)\n'23' * true devuelve 23 (23 * 1)\n'23' * 'Hello' devuelve NaN (no puede convertir 'Hello')\n23 + 'Hello' devuelve '23Hello' (+ es el operador de concatenación así que convierte 23 a '23' y los concatena)\n23 + '23' devuelve 2323 (OJO, convierte 23 a '23', no al revés)\n\nAdemás comentar que en Javascript todo son ojetos por lo que todo tiene métodos y propiedades. Veamos brevemente los tipos de datos básicos.\n\nEJERCICIO: Prueba en la consola las operaciones anteriores y alguna más con la que tengas dudas de qué devolverá\n\nNumber\nSólo hay 1 tipo de números, no existen enteros y decimales. El tipo de dato para cualquier número es number. El carácter para la coma decimal es el . (como en inglés, así que 23,12 debemos escribirlo como 23.12).\nTenemos los operadores aritméticos +, -, *, / y % y los unarios ++ y -- y existen los valores especiales Infinity y -Infinity (23 / 0 no produce un error sino que devuelve Infinity).\nPodemos usar los operadores artméticos junto al operador de asignación = (+=, -=, *=, /= y %=).\nAlgunos métodos útiles de los números son:\n\n.toFixed(num): redondea el número a los decimales indicados. Ej. 23.2376.toFixed(2) devuelve 23.24\n.toLocaleString(): devuelve el número convertido al formato local. Ej. 23.76.toLocaleString() devuelve '23,76' (convierte el punto decimal en coma)\n\nPodemos forzar la conversión a número con la función Number(valor). Ejemplo Number('23.12')devuelve 23.12\nOtras funciones útiles son:\n\nisNaN(valor): nos dice si el valor pasado es un número (false) o no (true)\nisFinite(valor): devuelve true si el valor es finito (no es Infinity ni -Infinity).\nparseInt(valor): convierte el valor pasado a un número entero. Siempre que compience por un número la conversión se podrá hacer. Ej.:\n\nparseInt(3.65) // Devuelve 3\nparseInt('3.65') // Devuelve 3\nparseInt('3 manzanas') // Devuelve 3, Number devolvería NaN\n\nparseFloat(valor): como la anterior pero conserva los decimales\n\nOJO: al sumar floats podemos tener problemas:\nconsole.log(0.1 + 0.2) // imprime 0.30000000000000004\n\nPara evitarlo redondead los resultados (o (0.1*10 + 0.2*10) / 10).\n\nEJERCICIO: Modifica la funciónque quieras de calcular la nota media para que devuelva la media con 1 decimal\n\nEJERCICIO: Modifica la función que devuelve el cubo de un número para que compruebe si el parámetro pasado es un número entero. Si no es un entero o no es un número mostrará un alert indicando cuál es el problema yndevolverá false.\n\nString\nLas cadenas de texto van entre comillas simples o dobles, es indiferente. Podemos escapar un caràcter con \\ (ej. 'Hola \\'Mundo\\'' devuelve Hola 'Mundo').\nPara forzar la conversión a cadena se usa la función String(valor) (ej. String(23) devuelve '23')\nEl operador de concatenación de cadenas es +. Ojo porque si pedimos un dato con prompt siempre devuelve una cadena así que si le pedimos la edad al usuario (por ejemplo 20) y se sumamos 10 tendremos 2010 ('20'+10).\nAlgunos métodos y propiedades de las cadenas son:\n\n.length: devuelve la longitud de una cadena. Ej.: 'Hola mundo'.length devuelve 10\n.charAt(posición): 'Hola mundo'.charAt(0) devuelve 'H'\n.indexOf(carácter): 'Hola mundo'.indexOf('o') devuelve 1. Si no se encuentra devuelve -1\n.lastIndexOf(carácter): 'Hola mundo'.lastIndexOf('o') devuelve 9\n.substring(desde, hasta): 'Hola mundo'.substring(2,4) devuelve 'la'\n.substr(desde, num caracteres): 'Hola mundo'.substr(2,4) devuelve 'la m'\n.replace(busco, reemplaza): 'Hola mundo'.replace('Hola', 'Adiós') devuelve 'Adiós mundo'\n.toLocaleLowerCase(): 'Hola mundo'.toLocaleLowerCase() devuelve 'hola mundo'\n.toLocaleUpperCase(): 'Hola mundo'.toLocaleUpperCase() devuelve 'HOLA MUNDO'\n.localeCompare(cadena): devuelve -1 si la cadena a que se aplica el método es anterior alfabéticamente a 'cadena', 1 si es posterior y 0 si ambas son iguales. Tiene en cuenta caracteres locales como acentos ñ, ç, etc\n.trim(cadena): ' Hola mundo '.trim() devuelve 'Hola mundo'\n.startsWith(cadena): 'Hola mundo'.startsWith('Hol') devuelve true\n.endsWith(cadena): 'Hola mundo'.endsWith('Hol') devuelve false\n.includes(cadena): 'Hola mundo'.includes('mun') devuelve true\n.repeat(veces): 'Hola mundo'.repeat(3) devuelve 'Hola mundoHola mundoHola mundo'\n.split(sepadaror): 'Hola mundo'.split(' ') devuelve el array ['Hola', 'mundo']. 'Hola mundo'.split('') devuelve el array ['H', 'o', 'l', 'a', ' ', 'm', 'u', 'n', 'd', 'o']\n\nPodemos probar los diferentes métodos en la página de w3schools.\n\nEJERCICIO: Haz una función a la que se le pasa un DNI (ej. 12345678w o 87654321T) y devolverá si es correcto o no. La letra que debe corresponder a un DNI correcto se obtiene dividiendo la parte numérica entre 23 y cogiendo de la cadena 'TRWAGMYFPDXBNJZSQVHLCKE' la letra correspondiente al resto de la divisón. Por ejemplo, si el resto es 0 la letra será la T y si es 4 será la G. Prueba la función en la consola con tu DNI\n\nTemplate literals\nDesde ES2015 también podemos poner una cadena entre ` (acento grave) y en ese caso podemos poner dentro variables y expresiones que serán evaluadas al ponerlas dentro de ${}. También se respetan los saltos de línea, tabuladores, etc que haya dentro. Ejemplo:\nlet edad=25;\n\nconsole.log(\\`El usuario tiene:\n${edad} años\\`)\n\nMostrará en la consola:\n\nEl usuario tiene:\n\n25 años\n\nBoolean\nLos valores booleanos son true y false. Para convertir algo a booleano se usar Boolean(valor) aunque también puede hacerse con la doble negación (!!). Cualquier valor se evaluará a true excepto 0, NaN, null, undefined o una cadena vacía ('') que se evaluarán a false.\nLos operadores lógicos son ! (negación), &amp;&amp; (and), || (or).\nPara comparar valores tenemos == y ===. La triple igualdad devuelve true si son igual valor y del mismo tipo. Como Javascript hace conversiones de tipos automáticas conviene usar la === para evitar cosas como:\n\n'3' == 3 true\n3 == 3.0 true\n0 == false true\n'' == false true\n' ' == false true\n[] == false true\nnull == false false\nundefined == false false\nundefined == null true\n\nTambién tenemos 2 operadores de diferente: != y !== que se comportan como hemos dicho antes.\nLos operadores relacionales son &gt;, &gt;=, &lt;, &lt;=. Cuando se compara un número y una cadena ésta se convierte a número y no al revés (23 &gt; '5' devuelve true, aunque '23' &gt; '5' devuelve false)\nManejo de errores\nSi sucede un error en nuestro código el programa dejará de ejecutarse por lo que el usuario tendrá la sensación de que no hace nada (el error sólo se muestra en la consola y el usuario no suele abrirla nunca). Para evitarlo es crucial capturar los posibles errores de nuestro código antes de que se produzcan.\nEn javascript (como en muchos otros lenguajes) el manejo de errores se realiza con sentencias\ntry {\n...\n}\ncatch(error) {\n...\n}\n\nDentro del bloque try ponemos el código que queremos proteger y cualquier error producido en él será pasado al bloque catch donde es tratado. Opcionalmente podemos tener al final un bloque finally que se ejecuta tanto si se produce un error como si no. El parámetro que recibe catch es un objeto de tipo Error con propiedades como name, que indica el tipo de error (SyntaxError, RangeError, ... o el genérico Error), o message, que indica el texto del error producido.\nEn ocasiones podemos querer que nuestro código genere un error. Esto evita que tengamos que comprobar si el valor devuelto por una función es el adecuado o es un código de error. Por ejemplo tenemos una función para retirar dinero de una cuenta que recibe el saldo de la misma y la cantdad de dinero a retirar y devuelve el nuevo saldo, pero si no hay suficiente saldo no debería restar nada sino mostrar un mensaje al usuario. Sin gestión de errores haríamos:\nfunction retirar(saldo, cantidad) {\nif (saldo &lt; cantidad) {\nreturn false\n}\nreturn saldo - cantidad\n}\n\n// Y donde se llama a la función_\n...\nresultado = retirar(saldo, importe)\nif (resultado === false\nalert('Saldo insuficiente')\n} else {\nsaldo = resultado\n...\n\nSe trata de un código poco claro que podemos mejorar lanzando un error en la función. Para ello se utiliza la instrucción throw:\nif (saldo &lt; cantidad) {\nthrow 'Saldo insuficiente'\n}\n\nPor defecto al lanzar un error este será de clase Error (el código anterior es equivalente a throw new Error('Saldo insuficiente')) aunque podemos lanzarlo de cualquier otra clase (throw new RangeError('Saldo insuficiente')) o personalizarlo.\nSiempre que vayamos a ejecutar código que pueda generar un error debemos ponerlo dentro de un bloque try por lo que la llamada a la función que contiene el código anterior debería estar dentro de un try. El código del ejemplo anterior quedaría:\nfunction retirar(saldo, cantidad) {\nif (saldo &lt; cantidad) {\nthrow &quot;Saldo insuficiente&quot;\n}\nreturn saldo - cantidad\n}\n\n// Siempre debemos llamar a esa función desde un bloque _try_\n...\ntry {\nsaldo = retirar(saldo, importe)\n} catch(err) {\nalert(err)\n}\n...\n\nPodemos ver en detalle cómo funcionan en la página de MDN web docs de Mozilla.\nBuenas prácticas\nJavascript nos permite hacer muchas cosas que otros lenguajes no nos dejan por lo que debemos ser cuidadosos para no cometer errores de los que no se nos va a avisar.\n'use strict'\nSi ponemos siempre esta sentencia al principio de nuestro código el intérprete nos avisará si usamos una variale sin declarar (muchas veces por equivocarnos al escrbir su nombre). En concreto fuerza al navegador a no permitir:\n\nUsar una variable sin declarar\nDefinir más de 1 vez una propiedad de un objeto\nDuplicar un parámetro en una función\nUsar números en octal\nModificar una propiedad de sólo lectura\n\nVariables\nAlgunas de las prácticas que deberíamos seguir respecto a las variables son:\n\nElegir un buen nombre es fundamental. Evitar abreviaturas o nombres sin significado (a, b, c, ...)\nEvitar en lo posible variables globales\nUsar let para declararlas\nUsar const siempre que una variable no deba cambiar su valor\nDeclarar todas las variables al principio\nInicializar las variables al declararlas\nEvitar conversiones de tipo automáticas\nUsar para nombrarlas la notación camelCase\n\nTambién es conveniente, por motivos de eficiencia no usar objetos Number, String o Boolean sino los tipos primitivos (no usar let numero = new Number(5) sino let numero = 5) y lo mismo al crear arrays, objetos o expresiones regulares (no usar let miArray = new Array() sino let miArray = []).\nOtras\nAlgunas reglas más que deberíamos seguir son:\n\nDebemos ser coherentes a la hora de escribir código: por ejemplo podemos poner (recomendado) o no espacios antes y después del = en una asignación pero debemos hacerlo siempre igual. Existen muchas guías de estilo y muy buenas: Airbnb, Google, Idiomatic, etc. Para obligarnos a seguir las reglas podemos usar alguna herramienta linter.\nTambién es conveniente para mejorar la legibilidad de nuestro código separar las líneas de más de 80 caracteres.\nUsar === en las comparaciones\nSi un parámetro puede faltar al llamar a una función darle un valor por defecto\nY para acabar comentar el código cuando sea necesario, pero mejor que sea lo suficientemente claro como para no necesitar comentarios\n\nClean Code\nEstas y otras muchas recomendaciones se recogen el el libro Clean Code de Robert C. Martin y en muchos otros libros y articulos. Aquí tenéis un pequeño resumen traducido al castellano:\n\nhttps://github.com/devictoribero/clean-code-javascript",
		"tags": [ "note"]
},

{
		"title": "02.1-objetos",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/02-1-objetos/",
		"content": "Objetos en Javascript\n\nObjetos en Javascript\n\nIntroducción\nPropiedades de un objeto\nMétodos de un objeto\nPropagación de propiedades\nDesestructuración de objetos\nComparación de objetos\nCopia de objetos\nBibliografía\n\nIntroducción\nEn Javascript podemos definir cualquier variable como un objeto declarándola con new (NO se recomienda) o creando un literal object (usando notación JSON). Ejemplo con new (no recomendado):\nconst alumno = new Object()\nalumno.nombre = 'Carlos' // se crea la propiedad 'nombre' y se le asigna un valor\nalumno['apellidos'] = 'Pérez Ortiz' // se crea la propiedad 'apellidos'\nalumno.edad = 19\n\nCreando un literal object (es la forma recomendada) el ejemplo anterior sería:\nconst alumno = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\n\nPropiedades de un objeto\nPodemos acceder a las propiedades con . (punto) o [ ]:\nconsole.log(alumno.nombre) // imprime 'Carlos'\nconsole.log(alumno['nombre']) // imprime 'Carlos'\nlet prop = 'nombre'\nconsole.log(alumno[prop]) // imprime 'Carlos'\n\nSi intentamos acceder a propiedades que no existen no se produce un error, se devuelve undefined:\nconsole.log(alumno.ciclo) // muestra undefined\n\nSin embargo se genera un error si intentamos acceder a propiedades de algo que no es un objeto:\nconsole.log(alumno.ciclo) // muestra undefined\nconsole.log(alumno.ciclo.descrip) // se genera un ERROR\n\nPara evitar ese error antes había que comprobar que existan las propiedades previas:\nconsole.log(alumno.ciclo &amp;&amp; alumno.ciclo.descrip)\n// si alumno.ciclo es un objeto muestra el valor de\n// alumno.ciclo.descrip y si no muestra undefined\n\nCon ES2020 (ES11) se ha incluido el operador de encadenamiento opcional ?. para evitar tener que comprobar esto nosotros:\nconsole.log(alumno.ciclo?.descrip)\n// si alumno.ciclo es un objeto muestra el valor de\n// alumno.ciclo.descrip y si no muestra undefined\n\nPodremos recorrer las propiedades de un objecto con for..in:\nfor (let prop in alumno) {\nconsole.log(prop + ': ' + alumno[prop])\n}\n\nSi el valor de una propiedad es el valor de una variable que se llama como la propiedad no es necesario ponerlo:\nlet nombre = 'Carlos'\n\nconst alumno = {\nnombre, // es equivalente a nombre: nombre\napellidos: 'Pérez Ortiz',\n...\n\nMétodos de un objeto\nUna propiedad de un objeto puede ser una función:\nalumno.getInfo = function() {\nreturn 'El alumno ' + this.nombre + ' ' + this.apellidos + ' tiene ' + this.edad + ' años'\n}\n\nNOTA: No podemos ponerlo con sintaxis arrow function porque no se podría acceder a las propiedades del objeto con this.\nY para llamarlo se hace como con cualquier otra propiedad:\nconsole.log(alumno.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nEJERCICIO: Crea un objeto llamado tvSamsung con las propiedades nombre (&quot;TV Samsung 42&quot;), categoria (&quot;Televisores&quot;), unidades (4), precio (345.95) y con un método llamado importe que devuelve el valor total de las unidades (nº de unidades * precio)\n\nPropagación de propiedades\nEl operador de propagación, ... (3 puntos), permite extraer las propiedades de un objeto. Ejemplo:\nconst personaCarlos = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\nconst alumnoCarlos = {\n...personaCarlos,\nciclo: 'DAW',\ncurso: 2,\n};\n\nEl objeto alumnoCarlos tendrá las propiedades de personaCarlos y las que se le añadan. Si se repiten las propiedades se sobreescriben:\nconst alumnoCarlos = {\n...personaCarlos,\nciclo: 'DAW',\ncurso: 2,\nedad: 20,\n};\n\nDesestructuración de objetos\nSimilar al anterior, permite extraer directamente a variables sólo las propiedades que necesitemos de un objeto. Ejemplo:\nconst personaCarlos = {\nnombre: 'Carlos',\napellidos: 'Pérez Ortiz',\nedad: 19,\n};\n\nfunction muestraNombre({nombre, apellidos}) {\nconsole.log('El nombre es ' + nombre + ' ' + apellidos)\n}\n\nmuestraNombre(personaCarlos)\n\nAunque a la función se le pasa un objeto esta toma como parámetros sólo 2 de sus propiedades y las asigna a las variables nombre y apellidos.\nTambién podemos asignar valores por defecto:\nfunction miProducto({nombre, apellidos = 'Desconocidos'}) {\n...\n\nComparación de objetos\nEn Javascript los objetos se comparan por referencia, no por valor. Por lo que dos objetos con los mismos valores no son iguales:\nconst a = {id:2, name: 'object 2'}\nconst b = {id:2, name: 'object 2'}\nconsole.log(a === b) // muestra false\n\nCopia de objetos\nCuando copiamos una variable de tipo boolean, string o number o se pasa como parámetro a una función se hace una copia de la misma y si se modifica la variable original no es alterada. Ej.:\nlet a = 54\nlet b = a // a = 54 b = 54\nb = 86 // a = 54 b = 86\n\nSin embargo al copiar objetos (y arrays, que son un tipo de objeto) la nueva variable apunta a la misma posición de memoria que la antigua por lo que los datos de ambas son los mismos:\nconst a = {id:2, name: 'object 2'}\nconst b = a\nb.name = 'object 3' // a = {id:2, name: 'object 3'} b = {id:2, name: 'object 3'}\n\nconst a = [54, 23, 12]\nconst b = a // a = [54, 23, 12] b = [54, 23, 12]\nb[0] = 3 // a = [3, 23, 12] b = [3, 23, 12]\n\nconst fecha1 = new Date('2018-09-23')\nconst fecha2 = fecha1 // fecha1 = '2018-09-23' fecha2 = '2018-09-23'\nfecha2.setFullYear(1999) // fecha1 = '1999-09-23' fecha2 = '1999-09-23'\n\nPara obtener una copia independiente de un array o un objeto podemos usar el operador de propagación ... o el método Object.assign. Ejemplo:\nconst a = {id:2, name: 'object 2'}\nconst b = {...a} // ahora ambos objetos contienen lo mismo pero son diferentes\nb.name = 'object 3' // a = {id:2, name: 'object 2'} b = {id:2, name: 'object 3'}\n\nCon Object.assign haremos:\nconst a = {id:2, name: 'object 2'}\nconst b = Object.assign({}, a) // ahora ambos objetos contienen lo mismo pero son diferentes\n\nSin embargo si el objeto tiene como propiedades otros objetos estos se continúan pasando por referencia. Es ese caso lo más sencillo sería hacer:\nconst a = {id: 2, name: 'object 2', address: {street: 'Rue del Percebe', num: 13} }\nconst copiaDeA = JSON.parse(JSON.stringify(a)) // ahora ambos objetos contienen lo mismo pero son diferentes\n\no bien usar la función structuredClone:\nconst a = {id: 2, name: 'object 2', address: {street: 'Rue del Percebe', num: 13} }\nconst b = structuredClone(a) // ahora ambos objetos contienen lo mismo pero son diferentes\n\nEJERCICIO: Dado el objeto a del último ejemplo copialo a un nuevo objeto b con ... y prueba a cambiar las pripiedades id y street de b. ¿Qué pasa con sus valores en a?.\n\nBibliografía\n\nCurso 'Programación con JavaScript'. CEFIRE Xest. Arturo Bernal Mayordomo",
		"tags": [ "note"]
},

{
		"title": "02.2-arrays",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/02-2-arrays/",
		"content": "Arrays\n\nArrays\n\nIntroducción\n\nArrays de objetos\n\nOperaciones con Arrays\n\nlength\nAñadir elementos\nEliminar elementos\nsplice\nslice\nArrays y Strings\nsort\nOtros métodos comunes\n\nFunctional Programming\n\nfilter\nfind\nfindIndex\nevery / some\nmap\nreduce\nforEach\nincludes\nArray.from\n\nRest y Spread\nDesestructuración de arrays\nCopia de arrays\nMap\nSet\n\nIntroducción\nSon un tipo de objeto y no tienen tamaño fijo sino que podemos añadirle elementos en cualquier momento.\nSe recomienda crearlos usando notación JSON:\nconst a = []\nconst b = [2,4,6]\n\naunque también podemos crearlos como instancias del objeto Array (NO recomendado):\nconst a = new Array() // a = []\nconst b = new Array(2,4,6) // b = [2, 4, 6]\n\nSus elementos pueden ser de cualquier tipo, incluso podemos tener elementos de tipos distintos en un mismo array. Si no está definido un elemento su valor será undefined. Ej.:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconsole.log(a[0]) // imprime 'Lunes'\nconsole.log(a[4]) // imprime 6\na[7] = 'Juan' // ahora a = ['Lunes', 'Martes', 2, 4, 6, , , 'Juan']\nconsole.log(a[7]) // imprime 'Juan'\nconsole.log(a[6]) // imprime undefined\nconsole.log(a[10]) // imprime undefined\n\nAcceder a un elemento de un array que no existe no provoca un error (devuelve undefined) pero sí lo provoca acceder a un elemento de algo que no es un array. Con ES2020 (ES11) se ha incluido el operador ?. para evitar tener que comprobar nosotros que sea un array:\nconsole.log(alumnos?.[0])\n// si alumnos es un array muestra el valor de su primer\n// elemento y si no muestra undefined pero no lanza un error\n\nArrays de objetos\nEs habitual almacenar datos en arrays en forma de objetos, por ejemplo:\nconst alumnos = [\n{\nid: 1,\nname: 'Marc Peris',\ncourse: '2nDAW',\nage: 21\n},\n{\nid: 2,\nname: 'Júlia Tortosa',\ncourse: '2nDAW',\nage: 23\n},\n]\n\nOperaciones con Arrays\nVamos a ver los principales métodos y propiedades de los arrays.\nlength\nEsta propiedad devuelve la longitud de un array:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconsole.log(a.length) // imprime 5\n\nPodemos reducir el tamaño de un array cambiando esta propiedad, aunque es una forma poco clara de hacerlo:\na.length = 3 // ahora a = ['Lunes', 'Martes', 2]\n\nAñadir elementos\nPodemos añadir elementos al final de un array con push o al principio con unshift:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\na.push('Juan') // ahora a = ['Lunes', 'Martes', 2, 4, 6, 'Juan']\na.unshift(7) // ahora a = [7, 'Lunes', 'Martes', 2, 4, 6, 'Juan']\n\nEliminar elementos\nPodemos borrar el elemento del final de un array con pop o el del principio con shift. Ambos métodos devuelven el elemento que hemos borrado:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst ultimo = a.pop() // ahora a = ['Lunes', 'Martes', 2, 4] y ultimo = 6\nconst primero = a.shift() // ahora a = ['Martes', 2, 4] y primero = 'Lunes'\n\nsplice\nPermite eliminar elementos de cualquier posición del array y/o insertar otros en su lugar. Devuelve un array con los elementos eliminados. Sintaxis:\nArray.splice(posicion, num. de elementos a eliminar, 1º elemento a insertar, 2º elemento a insertar, 3º...)\n\nEjemplo:\nlet a = ['Lunes', 'Martes', 2, 4, 6]\nlet borrado = a.splice(1, 3) // ahora a = ['Lunes', 6] y borrado = ['Martes', 2, 4]\na = ['Lunes', 'Martes', 2, 4, 6]\nborrado = a.splice(1, 0, 45, 56) // ahora a = ['Lunes', 45, 56, 'Martes', 2, 4, 6] y borrado = []\na = ['Lunes', 'Martes', 2, 4, 6]\nborrado = a.splice(1, 3, 45, 56) // ahora a = ['Lunes', 45, 56, 6] y borrado = ['Martes', 2, 4]\n\nEJERCICIO: Guarda en un array la lista de la compra con Peras, Manzanas, Kiwis, Plátanos y Mandarinas. Haz los siguiente con splice:\n\nElimina las manzanas (debe quedar Peras, Kiwis, Plátanos y Mandarinas)\nAñade detrás de los Plátanos Naranjas y Sandía (debe quedar Peras, Kiwis, Plátanos, Naranjas, Sandía y Mandarinas)\nQuita los Kiwis y pon en su lugar Cerezas y Nísperos (debe quedar Peras, Cerezas, Nísperos, Plátanos, Naranjas, Sandía y Mandarinas)\n\nslice\nDevuelve un subarray con los elementos indicados pero sin modificar el array original (sería como hacer un substr pero de un array en vez de una cadena). Sintaxis:\nArray.slice(posicion, num. de elementos a devolver)\n\nEjemplo:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst subArray = a.slice(1, 3) // ahora a = ['Lunes', 'Martes', 2, 4, 6] y subArray = ['Martes', 2, 4]\n\nEs muy útil para hacer una copia de un array:\nconst a = [2, 4, 6]\nconst copiaDeA = a.slice() // ahora ambos arrays contienen lo mismo pero son diferentes arrays\n\nArrays y Strings\nCada objeto (y los arrays son un tipo de objeto) tienen definido el método .toString() que lo convierte en una cadena. Este método es llamado automáticamente cuando, por ejemplo, queremos mostrar un array por la consola. En realidad console.log(a) ejecuta console.log(a.toString()). En el caso de los arrays esta función devuelve una cadena con los elementos del array dentro de corchetes y separados por coma.\nAdemás podemos convertir los elementos de un array a una cadena con .join() especificando el carácter separador de los elementos. Ej.:\nconst a = ['Lunes', 'Martes', 2, 4, 6]\nconst cadena = a.join('-') // cadena = 'Lunes-Martes-2-4-6'\n\nEste método es el contrario del m .split() que convierte una cadena en un array. Ej.:\nconst notas = '5-3.9-6-9.75-7.5-3'\nconst arrayNotas = notas.split('-') // arrayNotas = [5, 3.9, 6, 9.75, 7.5, 3]\nconst cadena = 'Que tal estás'\nconst arrayPalabras = cadena.split(' ') // arrayPalabras = ['Que`, 'tal', 'estás']\nconst arrayLetras = cadena.split('') // arrayLetras = ['Q','u','e`,' ','t',a',l',' ','e',s',t',á',s']\n\nsort\nOrdena alfabéticamente los elementos del array. Cambia el array además de devolverlo. Ejemplo:\nlet a = ['hola','adios','Bien','Mal',2,5,13,45]\nlet b = a.sort() // b = [13, 2, 45, 5, &quot;Bien&quot;, &quot;Mal&quot;, &quot;adios&quot;, &quot;hola&quot;], pero a también queda ordenado\n\nTambién podemos pasarle una función que le indique cómo ordenar, que devolverá un valor negativo si el primer elemento es mayor, positivo si es mayor el segundo o 0 si son iguales. Ejemplo: ordenar un array de cadenas sin tener en cuenta si son mayúsculas o minúsculas:\nlet a = ['hola','adios','Bien','Mal']\nlet b = a.sort(function(elem1, elem2) {\nif (elem1.toLocaleLowerCase &gt; elem2.toLocaleLowerCase)\nreturn -1\nif (elem1.toLocaleLowerCase &lt; elem2.toLocaleLowerCase)\nreturn 1\nreturn 0\n}) // b = [&quot;adios&quot;, &quot;Bien&quot;, &quot;hola&quot;, &quot;Mal&quot;]\n\nComo más se utiliza esta función es para ordenar arrays de objetos. Por ejemplo si tenemos un objeto alumno con los campos name y age, para ordenar un array de objetos alumno por su edad haremos:\nlet alumnosOrdenado = alumnos.sort(function(alumno1, alumno2) {\nreturn alumno1.age - alumno2.age\n})\n\nUsando arrow functions quedaría más sencillo:\nlet alumnosOrdenado = alumnos.sort((alumno1, alumno2) =&gt; alumno1.age - alumno2.age)\n\nSi que queremos ordenar por un campo de texto en vez de numérico debemos usar la función toLocaleCompare:\nlet alumnosOrdenado = alumnos.sort((alumno1, alumno2) =&gt; alumno1.name.localeCompare(alumno2.name))\n\nEJERCICIO: Haz una función que ordene las notas de un array pasado como parámetro. Si le pasamos [4,8,3,10,5] debe devolver [3,4,5,8,10]. Pruébalo en la consola\n\nOtros métodos comunes\nOtros métodos que se usan a menudo con arrays son:\n\n.concat(): concatena arrays\n\nlet a = [2, 4, 6]\nlet b = ['a', 'b', 'c']\nlet c = a.concat(b) // c = [2, 4, 6, 'a', 'b', 'c']\n\n.reverse(): invierte el orden de los elementos del array\n\nlet a = [2, 4, 6]\nlet b = a.reverse() // b = [6, 4, 2]\n\n.indexOf(): devuelve la primera posición del elemento pasado como parámetro o -1 si no se encuentra en el array\n.lastIndexOf(): devuelve la última posición del elemento pasado como parámetro o -1 si no se encuentra en el array\n\nFunctional Programming\nSe trata de un paradigma de programación (una forma de programar) donde se intenta que el código se centre más en qué debe hacer una función que en cómo debe hacerlo. El ejemplo más claro es que intenta evitar los bucles for y while sobre arrays o listas de elementos. Normalmente cuando hacemos un bucle es para recorrer la lista y realizar alguna acción con cada uno de sus elementos. Lo que hace functional programing es que a la función que debe hacer eso se le pasa como parámetro la función que debe aplicarse a cada elemento de la lista.\nDesde la versión 5.1 javascript incorpora métodos de functional programing en el lenguaje, especialmente para trabajar con arrays:\nfilter\nDevuelve un nuevo array con los elementos que cumplen determinada condición del array al que se aplica. Su parámetro es una función, habitualmente anónima, que va interactuando con los elementos del array. Esta función recibe como primer parámetro el elemento actual del array (sobre el que debe actuar). Opcionalmente puede tener como segundo parámetro su índice y como tercer parámetro el array completo. La función debe devolver true para los elementos que se incluirán en el array a devolver como resultado y false para el resto.\nEjemplo: dado un array con notas devolver un array con las notas de los aprobados. Esto usando programación imperativa (la que se centra en cómo se deben hacer las cosas) sería algo como:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = []\nfor (let i = 0 i++ i &lt; arrayNotas.length) {\nlet nota = arrayNotas[i]\nif (nota &gt; = 5) {\naprobados.push(nota)\n}\n} // aprobados = [5.2, 6, 9.75, 7.5]\n\nUsando functional programming (la que se centra en qué resultado queremos obtener) sería:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(function(nota) {\nif (nota &gt; = 5) {\nreturn true\n} else {\nreturn false\n}\n}) // aprobados = [5.2, 6, 9.75, 7.5]\n\nPodemos refactorizar esta función para que sea más compacta:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(function(nota) {\nreturn nota &gt; = 5 // nota &gt; = 5 se evalúa a 'true' si es cierto o 'false' si no lo es\n})\n\nY usando funciones lambda la sintaxis queda mucho más simple:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst aprobados = arrayNotas.filter(nota =&gt; nota &gt; = 5)\n\nLas 7 líneas del código usando programación imperativa quedan reducidas a sólo una.\n\nEJERCICIO: Dado un array con los días de la semana obtén todos los días que empiezan por 'M'\n\nfind\nComo filter pero NO devuelve un array sino el primer elemento que cumpla la condición (o undefined si no la cumple nadie). Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst primerAprobado = arrayNotas.find(nota =&gt; nota &gt; = 5) // primerAprobado = 5.2\n\nEste método tiene más sentido con objetos. Por ejemplo, si queremos encontrar la persona con DNI '21345678Z' dentro de un array llamado personas cuyos elementos son objetos con un campo 'dni' haremos:\nconst personaBuscada = personas.find(persona =&gt; persona.dni = = = '21345678Z') // devolverá el objeto completo\n\nEJERCICIO: Dado un array con los días de la semana obtén el primer día que empieza por 'M'\n\nfindIndex\nComo find pero en vez de devolver el elemento devuelve su posición (o -1 si nadie cumple la condición). En el ejemplo anterior el valor devuelto sería 0 (ya que el primer elemento cumple la condición). Al igual que el anterior tiene más sentido con arrays de objetos.\n\nEJERCICIO: Dado un array con los días de la semana obtén la posición en el array del primer día que empieza por 'M'\n\nevery / some\nLa primera devuelve true si TODOS los elementos del array cumplen la condición y false en caso contrario. La segunda devuelve true si ALGÚN elemento del array cumple la condición. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst todosAprobados = arrayNotas.every(nota =&gt; nota &gt; = 5) // false\nconst algunAprobado = arrayNotas.some(nota =&gt; nota &gt; = 5) // true\n\nEJERCICIO: Dado un array con los días de la semana indica si algún día empieza por 'S'. Dado un array con los días de la semana indica si todos los días acaban por 's'\n\nmap\nPermite modificar cada elemento de un array y devuelve un nuevo array con los elementos del original modificados. Ejemplo: queremos subir un 10% cada nota:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayNotasSubidas = arrayNotas.map(nota =&gt; nota + nota * 10%)\n\nEJERCICIO: Dado un array con los días de la semana devuelve otro array con los días en mayúsculas\n\nreduce\nDevuelve un valor calculado a partir de los elementos del array. En este caso la función recibe como primer parámetro el valor calculado hasta ahora y el método tiene como 1º parámetro la función y como 2º parámetro al valor calculado inicial (si no se indica será el primer elemento del array).\nEjemplo: queremos obtener la suma de las notas:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst sumaNotas = arrayNotas.reduce((total,nota) =&gt; total + = nota, 0) // total = 35.35\n// podríamos haber omitido el valor inicial 0 para total\nconst sumaNotas = arrayNotas.reduce((total,nota) =&gt; total + = nota) // total = 35.35\n\nEjemplo: queremos obtener la nota más alta:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst maxNota = arrayNotas.reduce((max,nota) =&gt; nota &gt; max ? nota : max) // max = 9.75\n\nEn el siguiente ejemplo gráfico tenemos un &quot;array&quot; de verduras al que le aplicamos una función map para que las corte y al resultado le aplicamos un reduce para que obtenga un valor (el sandwich) con todas ellas:\n\nEJERCICIO: Dado el array de notas anterior devuelve la nota media\n\nforEach\nEs el método más general de los que hemos visto. No devuelve nada sino que permite realizar algo con cada elemento del array.\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\narrayNotas.forEach((nota, indice) =&gt; {\nconsole.log('El elemento de la posición ' + indice + ' es: ' + nota)\n})\n\nincludes\nDevuelve true si el array incluye el elemento pasado como parámetro. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\narrayNotas.includes(7.5) // true\n\nEJERCICIO: Dado un array con los días de la semana indica si algún día es el 'Martes'\n\nArray.from\nDevuelve un array a partir de otro al que se puede aplicar una función de transformación (es similar a map). Ejemplo: queremos subir un 10% cada nota:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayNotasSubidas = Array.from(arrayNotas, nota =&gt; nota + nota * 10%)\n\nPuede usarse para hacer una copia de un array, igual que slice:\nconst arrayA = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst arrayB = Array.from(arrayA)\n\nTambién se utiliza mucho para convertir colecciones en arrays y así poder usar los métodos de arrays que hemos visto. Por ejemplo si queremos mostrar por consola cada párrafo de la página que comience por la palabra 'If' en primer lugar obtenemos todos los párrafos con:\nconst parrafos = document.getElementsByTagName('p')\n\nEsto nos devuelve una colección con todos los párrafos de la página (lo veremos más adelante al ver DOM). Podríamos hacer un for para recorrer la colección y mirar los que empiecen por lo indicado pero no podemos aplicarle los métodos vistos aquí porque son sólo para arrays así que hacemos:\nconst arrayParrafos = Array.from(parrafos)\n// y ya podemos usar los métodos que queramos:\narrayParrafos.filter(parrafo =&gt; parrafo.textContent.startsWith('If'))\n.forEach(parrafo =&gt; alert(parrafo.textContent))\n\nIMPORTANTE: desde este momento se han acabado los bucles for en nuestro código para trabajar con arrays. Usaremos siempre estas funciones!!!\n\nRest y Spread\nPermiten extraer a parámetros los elementos de un array o string (spread) o convertir en un array un grupo de parámetros (rest). El operador de ambos es ... (3 puntos).\nPara usar rest como parámetro de una función debe ser siempre el último parámetro.\nEjemplo: queremos hacer una función que calcule la media de las notas que se le pasen como parámetro y que no sabemos cuántas són. Para llamar a la función haremos:\nconsole.log(notaMedia(3.6, 6.8))\nconsole.log(notaMedia(5.2, 3.9, 6, 9.75, 7.5, 3))\n\nLa función convertirá los parámetros recibidos en un array usando rest:\nfunction notaMedia(...notas) {\nlet total = notas.reduce((total,nota) =&gt; total + = nota)\nreturn total/notas.length\n}\n\nSi lo que queremos es convertir un array en un grupo de elementos haremos spread. Por ejemplo el objeto Math proporciona métodos para trabajar con números como .max que devuelve el máximo de los números pasados como parámetro. Para saber la nota máxima en vez de .reduce como hicimos en el ejemplo anterior podemos hacer:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\n\nlet maxNota = Math.max(...arrayNotas) // maxNota = 9.75\n// si hacemos Math.max(arrayNotas) devuelve NaN porque arrayNotas es un array y no un número\n\nDesestructuración de arrays\nIgual que vimos con las propiedades de los objetos podemos extraer los elementos del array directamente a variables y viceversa. Ejemplo:\nconst arrayNotas = [5.2, 3.9, 6, 9.75, 7.5, 3]\nconst [primera, segunda, tercera] = arrayNotas // primera = 5.2, segunda = 3.9, tercera = 6\nconst [primera, , , cuarta] = arrayNotas // primera = 5.2, cuarta = 9.75\nconst [primera, ...resto] = arrayNotas // primera = 5.2, resto = [3.9, 6, 9.75, 3]\n\nTambién se pueden asignar valores por defecto:\nconst preferencias = ['Javascript', 'NodeJS']\nconst [lenguaje, backend = 'Laravel', frontend = 'VueJS'] = preferencias // lenguaje = 'Javascript', backend = 'NodeJS', frontend = 'VueJS'\n\nCopia de arrays\nComo vimos al hablar de objetos (y un array es un tipo particular de objeto) por defecto al asignarlos o pasarlos como parámetro a una función se pasan por referencia, NO se copian por lo que los datos de ambas son los mismos:\nconst a = [54, 23, 12]\nconst b = a // a = [54, 23, 12] b = [54, 23, 12]\nb[0] = 3 // a = [3, 23, 12] b = [3, 23, 12]\n\nSi queremos obtener una copia de un array que sea independiente del original podemos usar ...o Object.assign como vimos con los objetos, pero también podemos obtener una copia con slice o con Array.from:\nconst a = [2, 4, 6]\nconst copiaDeA = [...a]\nconst copiaDeA = a.slice()\nconst otraCopiaDeA = Array.fom(a)\n\nEn todos los casos los arrays contienen lo mismo pero son diferentes y al modificar uno no afectará al resto.\n\nEJERCICIO: Dado el array arr1 con los días de la semana haz un array arr2 que sea igual al arr1. Elimina de arr2 el último día y comprueba quá ha pasado con arr1. Repita la operación con un array llamado arr3 pero que crearás haciendo una copia de arr1.\n\nMap\nEs una colección de parejas de [clave,valor]. Un objeto en Javascript es un tipo particular de Map en que las claves sólo pueden ser texto o números. Se puede acceder a una propiedad con . o [propiedad]. Ejemplo:\nconst persona = {\nnombre: 'John',\napellido: 'Doe',\nedad: 39\n}\nconsole.log(persona.nombre) // John\nconsole.log(persona['nombre']) // John\n\nUn Map permite que la clave sea cualquier cosa (array, objeto, ...). No vamos a ver en profundidad estos objetos pero podéis saber más en MDN o cualquier otra página.\nSet\nEs como un Map pero que no almacena los valores sino sólo la clave. Podemos verlo como una colección que no permite duplicados. Tiene la propiedad size que devuelve su tamaño y los métodos .add (añade un elemento), .delete (lo elimina) o .has (indica si el elemento pasado se encuentra o no en la colección) y también podemos recorrerlo con .forEach.\nUna forma sencilla de eliminar los duplicados de un array es crear con él un Set:\nconst ganadores = ['Márquez', 'Rossi', 'Márquez', 'Lorenzo', 'Rossi', 'Márquez', 'Márquez']\nconst ganadoresNoDuplicados = new Set(ganadores) // {'Márquez, 'Rossi', 'Lorenzo'}\n// o si lo queremos en un array:\nconst ganadoresNoDuplicados = Array.from(new Set(ganadores)) // ['Márquez, 'Rossi', 'Lorenzo']",
		"tags": [ "note"]
},

{
		"title": "03-oop",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/03-oop/",
		"content": "Programación orientada a Objetos en Javascript\n\nProgramación orientada a Objetos en Javascript\n\nIntroducción\nHerencia\nMétodos y propiedades estáticas\nPropiedades y métodos privados y protegidos\nMétodo toString()\nMétodo valueOf()\nOrganizar el código\nEl contexto de this\nMixins\nProgramación orientada a objetos en JS5\nBibliografía\n\nIntroducción\nDesde ES2015 la POO en Javascript es similar a como se hace en otros lenguajes, con clases, herencia, ...:\nclass Alumno {\nconstructor(nombre, apellidos, edad) {\nthis.nombre = nombre\nthis.apellidos = apellidos\nthis.edad = edad\n}\ngetInfo() {\nreturn 'El alumno ' + this.nombre + ' ' + this.apellidos + ' tiene ' + this.edad + ' años'\n}\n}\n\nlet alumno1 = new Alumno('Carlos', 'Pérez Ortiz', 19)\nconsole.log(alumno1.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nNOTA: en las clases no es necesario poner 'use strict' porque por defecto todas las clases ya lo tienen.\n\nEJERCICIO: Crea una clase Productos con las propiedades name, category, units y price y los métodos total que devuelve el importe del producto y getInfo que devolverá: 'Name (category): units uds x price € = total €'. Crea 3 productos diferentes.\n\nHerencia\nUna clase puede heredar de otra utilizando la palabra reservada extends y heredará todas sus propiedades y métodos. Podemos sobrescribirlos en la clase hija (seguimos pudiendo llamar a los métodos de la clase padre utilizando la palabra reservada super -es lo que haremos si creamos un constructor en la clase hija-).\nclass AlumnInf extends Alumno{\nconstructor(nombre, apellidos, edad, ciclo) {\nsuper(nombre, apellidos, edad)\nthis.ciclo = ciclo\n}\ngetInfo() {\nreturn super.getInfo() + ' y estudia el Grado ' + (this.getGradoMedio ? 'Medio' : 'Superior') + ' de ' + this.ciclo\n}\ngetGradoMedio() {\nif (this.ciclo.toUpperCase === 'SMX')\nreturn true\nreturn false\n}\n}\n\nlet cpo = new AlumnInf('Carlos', 'Pérez Ortiz', 19, 'DAW')\nconsole.log(cpo.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años y estudia el Grado Superior de DAW'\n\nEJERCICIO: crea una clase Televisores que hereda de Productos y que tiene una nueva propiedad llamada tamaño. El método getInfo mostrará el tamaño junto al nombre\n\nMétodos y propiedades estáticas\nDesde ES2015 podemos declarar métodos estáticos. Estos métodos se llaman directamente utilizando el nombre de la clase y no tienen acceso al objeto this (ya que no hay objeto instanciado).\nclass User {\n...\nstatic getRoles() {\nreturn [&quot;user&quot;, &quot;guest&quot;, &quot;admin&quot;]\n}\n}\n\nconsole.log(User.getRoles()) // [&quot;user&quot;, &quot;guest&quot;, &quot;admin&quot;]\nlet user = new User(&quot;john&quot;)\nconsole.log(user.getRoles()) // Uncaught TypeError: user.getRoles is not a function\n\nSuelen usarse para crear funciones de la aplicación.\nRecientemente se han introducido también propiedades estáticas, que funcionan directamente desde la clase no desde un objeto, igual que los métodos estáticos. Al ser una adición reciente pueden no funcionar en algunos navegadores.\nPropiedades y métodos privados y protegidos\nA la hora de encapsular el código de las clases es importante el uso de este tipo de elementos pero Javascript sólo los incluye desde ES2019 donde introdujo la sintaxis # para declaralos:\nclass Position {\n#x = 0;\n#y = 0;\n\nconstructor(x, y) {\nthis.#x = x\nthis.#y = y\n}\ngetPosition() {\nreturn { x: this.#x, y: this.#y };\n}\nincreaseX() {\nthis.#x++;\n}\nincreaseY() {\nthis.#y++;\n}\n}\n\nconst myPosition = new Position(20, 10);\nconsole.log(Position.getPosition()); // { x: 20, y: 10 }\nconsole.log(Position.x); // undefined\nconsole.log(Position.y); // undefined\n\nAnteriormente existía una convención de que cualquier propiedad o método que comience por el carácter _ se trata de una propiedad o método protegido y no debería accederse al mismo desde el exterior (aunque en realidad el lenguaje permite hacerlo).\nEstas propiedades y métodos protegidos se heredan como cualquier otro.\nMétodo toString()\nAl convertir un objeto a string (por ejemplo al concatenarlo con un String) se llama al método .toString() del mismo, que por defecto devuelve la cadena [object Object]. Podemos sobrecargar este método para que devuelva lo que queramos:\nclass Alumno {\n...\ntoString() {\nreturn this.apellidos + ', ' + this.nombre\n}\n}\n\nlet carPerOrt = new Alumno('Carlos', 'Pérez Ortiz', 19);\nconsole.log('Alumno:' + carPerOrt) // imprime 'Alumno: Pérez Ortíz, Carlos'\n// en vez de 'Alumno: [object Object]'\n\nEste método también es el que se usará si queremos ordenar una array de objetos (recordad que .sort() ordena alfabéticamente para lo que llama al método .toString() del objeto a ordenar). Por ejemplo, tenemos el array de alumnos misAlumnos que queremos ordenar alfabéticamente. Si la clase Alumno no tiene un método toString habría que hacer como vimos en el tema de Arrays:\nmisAlumnos.sort((alum1, alum2) =&gt; (alum1.apellidos+alum1.nombre).localeCompare(alum2.apellidos+alum2.nombre));\n\nPero con el método toString que hemos definido antes podemos hacer directamente:\nmisAlumnos.sort()\n\nEJERCICIO: modifica las clases Productos y Televisores para que el método que muestra los datos del producto se llame de la manera más adecuada\n\nEJERCICIO: Crea 5 productos y guárdalos en un array. Crea las siguientes funciones (todas reciben ese array como parámetro):\n\nprodsSortByName: devuelve un array con los productos ordenados alfabéticamente\nprodsSortByPrice: devuelve un array con los productos ordenados por importe\nprodsTotalPrice: devuelve el importe total del los productos del array, con 2 decimales\nprodsWithLowUnits: además del array recibe como segundo parámetro un nº y devuelve un array con todos los productos de los que quedan menos de los unidades indicadas\nprodsList: devuelve una cadena que dice 'Listado de productos:' y en cada línea un guión y la información de un producto del array\n\nMétodo valueOf()\nAl comparar objetos (con &gt;, &lt;, ...) se usa el valor devuelto por el método .valueOf() para realizar la comparación:\nclass Alumno {\n...\nvalueOf() {\nreturn this.edad\n}\n}\n\nlet cpo = new Alumno('Carlos', 'Pérez Ortiz', 19)\nlet aat = new Alumno('Ana', 'Abad Tudela', 23)\nconsole.log(cpo &lt; aat) // imprime true ya que 19&lt;23\n\nSi este método no existiera será .toString() el que se usaría.\nOrganizar el código\nLo más conveniente es guardar cada clase en su propio fichero, que llamaremos como la clase con la extensión .class.js. Por ejemplo el fichero de la clase Users seria users.class.js.\nEn dicho fichero exportamos la clase (con export o mejor export default porque sólo hay una) y donde queramos usarla la importamos (import { Users } from 'users.class' o import Users from 'users.class', según cómo la hayamos exportado).\nEl contexto de this\nEl valor de la variable this depende del contexto e que se ejecuta el código. Al crear una instancia de una calse con new this hace referencia a la instancia creada. Pero dentro de una función se crea un nuevo contexto y la variable this pasa a hacer referencia a dicho contexto. Si en el ejemplo anterior hiciéramos algo como esto:\nclass Alumno {\n...\ngetInfo() {\nfunction nomAlum() {\nreturn this.nombre + ' ' + this.apellidos // Aquí this no es la instancia del objeto Alumno\n}\n\nreturn 'El alumno ' + nomAlum() + ' tiene ' + this.edad + ' años'\n}\n}\n\nEste código fallaría porque dentro de la función nomAlum la variable this ya no hace referencia a a instancia del objeto Alumno sino al contexto de la función. Este ejemplo no tiene mucho sentido pero a veces nos pasará en manejadores de eventos.\nSi debemos llamar a una función dentro de un método (o de un manejador de eventos) tenemos varias formas de pasarle el valor de this:\n\nUsando una arrow function que no crea un nuevo contexto por lo que this conserva su valor\n\ngetInfo() {\nconst nomAlum = () =&gt; this.nombre + ' ' + this.apellidos\n\nreturn 'El alumno ' + nomAlum() + ' tiene ' + this.edad + ' años'\n}\n\nPasándole this como parámetro a la función\n\ngetInfo() {\nfunction nomAlum(alumno) {\nreturn alumno.nombre + ' ' + alumno.apellidos\n}\n\nreturn 'El alumno ' + nomAlum(this) +' tiene ' + this.edad + ' años'\n}\n\nGuardando el valor en otra variable (como that)\n\ngetInfo() {\nfunction nomAlum() {\nreturn that.nombre + ' ' + that.apellidos // Aquí this no es el objeto Alumno\n}\n\nlet that = this;\nreturn 'El alumno ' + nomAlum() +' tiene ' + this.edad + ' años'\n}\n\nHaciendo un bind de this (lo veremos de nuevo al hablar de eventos)\n\nclass Alumno {\n...\ngetInfo() {\nfunction nomAlum() {\nreturn this.nombre + ' ' + this.apellidos // Aquí this no es el objeto Alumno\n}\n\nreturn 'El alumno ' + nomAlum.bind(this) + ' tiene ' + this.edad + ' años'\n}\n}\n\nAl llamar a la función nomAlumn le enlazamos (.bind) el valor que queremos que tenga this dentro de ella, en nuestro caso el this de donde hacemos la llamada.\nMixins\nWikipedia define un mixin como una clase que contiene métodos que pueden ser utilizados por otras clases sin necesidad de heredar de ella.\nEn Javascript se trata de un objeto que contiene métodos que podemos aplicar a una clase para datarla de ciertos comportamientos. Por ejemplo:\n// mixin\nlet saludaMixin = {\nsaluda() {\nalert(`Hola, soy ${this.nombre}`)\n}\n}\n\nclass Alumno {\nconstructor(nombre, apellidos, edad) {\n...\n}\n...\n}\n\n// asignamos el mixin a la clase\nObject.assign(Alumno.prototype, saludaMixin);\n\n// Ahora el Alumno puede decir hola\nconst alumno = new User('Carlos', 'Pérez', 25)\nalumno.saluda(); // Hola, soy Carlos\n\nProgramación orientada a objetos en JS5\n\nNOTA: este apartado está sólo para que comprendamos este código si lo vemos en algún programa pero nosotros programaremos como hemos visto antes.\n\nEn Javascript un objeto se crea a partir de otro (al que se llama prototipo). Así se crea una cadena de prototipos, el primero de los cuales es el objeto null.\nLas versiones de Javascript anteriores a ES2015 no soportan clases ni herencia. Si queremos emular en ellas el comportamiento de las clases lo que se hace es:\n\npara crear el constructor se crea una función con el nombre del objeto\npara crear los métodos se aconseja hacerlo en el prototipo del objeto para que no se cree una copia del mismo por cada instancia que creemos:\n\nfunction Alumno(nombre, apellidos, edad) {\nthis.nombre = nombre\nthis.apellidos = apellidos\nthis.edad = edad\n}\nAlumno.prototype.getInfo = function() {\nreturn `El alumno ${this.nombre} ${this.apellidos} tiene ${this.edad} años`\n}\n\nlet cpo = new Alumno('Carlos', 'Pérez Ortiz', 19)\nconsole.log(cpo.getInfo()) // imprime 'El alumno Carlos Pérez Ortíz tiene 19 años'\n\nCada objeto tiene un prototipo del que hereda sus propiedades y métodos (es el equivalente a su clase, pero en realidad es un objeto que está instanciado). Si añadimos una propiedad o método al prototipo se añade a todos los objetos creados a partir de él lo que ahorra mucha memoria.\nBibliografía\n\nCurso 'Programación con JavaScript'. CEFIRE Xest. Arturo Bernal Mayordomo",
		"tags": ["x", "y", "note"]
},

{
		"title": "03.1-vite",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/03-1-vite/",
		"content": "Vite\n\nVite\n\nIntroducción\nCrear un nuevo proyecto\nDesarrollar nuestro proyecto\n\nTrabajar con distintos ficheros de código\n\nNamed export\nDefault export\n\nImágenes\nPaso a producción\nTestear el proyecto\n\nIntroducción\nCuando crece el tamaño de un proyecto y tenemos más ficheros de código (cómo al trabajar con clases) es necesario organizarlos de forma que sea fácil encontrarlos y que no haya problemas de dependencias.\nSin embargo tener muchos ficheros hace que tengamos que importarlos todos, y en el orden adecuado, en nuestro index.html (mediante etiquetas &lt;script src=&quot;...&quot;&gt;) lo que empieza a ser engorroso y reduce el rendimiento al tener el navegador que hacer muchas peticiones HTTP.\nAdemás muchas veces incluimos en el código características del lenguaje que aún no están soportadas por todos los navegadores y cuantos más código usemos más se reduce el número de nevegadores que soportan nuestro código.\nPara evitar este problema se utilizan las herramientas de construcción de proyectos o module bundlers que unen todo el código de los distintos ficheros javascript en un único fichero que es el que se importa en el index.html y hacen los mismo con los ficheros CSS.\nAdemás proporcionan otras ventajas:\n\ntranspilan el código, de forma que podemos usar sentencias javascript que aún no soportan muchos navegadores ya que se convertirán a sentencias que hacen lo mismo pero con código legacy\nminimizan y optimizan el código para que ocupe menos y su carga sea más rápida, reduciendo el nombre de variables y funciones, eliminando espacios en blanco y comentarios, ...\ndicha minimización ofusca el código lo que dificulta que el usuario pueda ver en la consola lo que hace el programa y manipularlo\n\nNosotros usaremos el bundler Vite que, junto con webpack, son los más usados en entorno frontend. Junto a npm tendremos una forma fácil y práctica de empaquetar el código.\nAdemás Vite incorpora un servidor de desarrollo para hacer más cómoda la creación y prueba de nuestros proyectos.\nPara poder usar Vite debemos instalarlo. Como lo usaremos en muchos proyectos lo podemos instalarlo global con\nnpm install -g vite\n\nCrear un nuevo proyecto\nVite necesita Node.js versión 16 o superior aunque lo mejor es tenerlo actualizado para poder utilitzar todas sus plantillas. Para crear un nuevo proyecto haremos:\nnpm create vite@latest\n\n(si no tenemos instalado el paquete create-vite nos preguntará si lo instala)\nAl crear el proyecto nos pregunta qué framework vamos a utilizar (le diremos que Vanilla, es decir, Javascript sin framework) y si como lenguaje usaremos Javascript o Typescript.\nEsto crea el scaffolding de nuestro proyecto que consiste en una carpeta con el mismo nombre que el proyecto y una serie de ficheros en su interior:\nNos preguntará el nombre del proyecto, la plantilla (Vanilla para Javascript sin framework) y el lenguaje que queremos usar (Javascript/Typescript) y se crea una carpeta con el nombre de nuestro proyecto que contiene:\n\nindex.html: html con un div con id app que es donde se cargará la app y una etiqueta script que carga un módulo llamado main.js\nmain.js: es el punto de entrada a la aplicación .Importa los ficheros CSS, imágenes y ficheros JS con funciones o clases y establece el contenido de la página principal\ncounter.js: módulo JS que exporta una función como ejemplo que es usada en el main.js\nstyle.css: fichero donde poner nuestros estilos, con CSS de ejemplo\npublic/: carpeta donde dejar elementos estáticos que no pasarán por vite (como imágenes, ficheros CSS, ...)\nnode_modules: librerías de las dependencias (si usamos alguna)\npackage.json: fichero de configuración del proyecto. Además del nombre y la versión incluye apartados importantes:\n\ndevDependences: dependencias que se usan en desarrollo pero que no se incorporarán al código final\ndependences: dependencias que sí se incluirán en el código final (librerías que estemos usando)\nscripts: para ejecutar el servidor de desarrollo (npm run dev), generar el código final de producción (npm run build) y previsualizarlo en modo producción (npm run preview). Podemos añadir más para tests, etc\n\nSi nuestra aplicación no va a ser muy pequeña como la del ejemplo sino que tendrá diferentes ficheros Javascript, acceso a datos, interfaz de usuario, etc deberíamos organizar en código en carpetas para mejorar su legibilidad. Lo adecuando es dejar en el raíz de nuestro proyecto los ficheros index.html y main.js y crear una carpeta src donde poner el resto de código. En función del tamaño de la aplicación podríamos crear dentro subcarpetas (os propongo un nombre para ellas aunque podéis llamarlas como queráis) para:\n\nmodel: el modelo de datos, es decir, las clases\npages o views: las páginas que tendrá nuestra SPA a las que se navega desde el router (aunque en realidad sólo hay una)\napi: acceso a la API que usemos. Sólo deben conectarse al servidor y transmitir los datos recibidos al resto de la aplicación\ncomponents: web components que usemos para cosntruir las páginas\nservices: métodos síncronos que proporcionan funcionalidad\nsi nuestra aplicación es grande con muchos casos de uso convendría crear una carpeta usecases donde guardarlos. Cada uno debería tener un único método llamado run o execute\ntest: carpeta donde guardar los ficheros de test\n...\n\nNOTA: todos los ficheros javascript de un proyecto con Vite son módulos y en ellos, igual que en las clases, no es necesario poner 'use strict' porque por defecto los módulos ya funcionan así.\nDesarrollar nuestro proyecto\nPara empezar a trabajar ejecutamos desde la terminal el script\nnpm run dev\n\nEsto hace que Vite lance un servidor web en el puerto 5173 donde podemos ver la ejecución de nuestro proyecto.\nTrabajar con distintos ficheros de código\nUna de las razones de usar un bundler es que podemos repartir el código entre varios ficheros de forma que quede más organizado.\nPara que un fichero pueda tener acceso a código de otro fichero hay que hacer 2 cosas:\n\nEl fichero al que queremos acceder debe exportar el código que desea que sea accesible desde otros ficheros\nEl fichero que quiere acceder a ese código debe importarlo a una variable\n\nEsto es lo que hacíamos en el ejercicio de la frase para poder pasar los tests y lo que haremos con los ficheros donde declaremos clases.\nES6 nos proporciona 2 formas de exportar/importar código:\n\nexportar con nombre (named export): export\nexportar por defecto (default export): export default\n\nNamed export\nDe esta manera puedo exportar tantos elementos (funciones, variables, clases, ...) de un fichero como quiera. Por ejemplo, si es un fichero con una única función a exportar:\n// Fichero cuadrado.js\nexport function cuadrado (value) {\nreturn value * value\n}\n\nEn el caso de querer exportar muchas funciones lo más sencillo es exportarlas juntas en un objeto como en el fichero functions.js:\nfunction letras () {\n...\n}\n\nfunction palabras () {\n...\n}\n\nfunction maysc () {\n...\n}\n...\nexport {\n\tletras,\n\tpalabras,\n\tmaysc\n}\n\nSi es un fichero que define una clase la exportamos tal cual:\nexport class Product {\nconstructor() {\n\n}\n...\n}\n\nPara importarlo lo hacemos poniendo lo que queremos importar entre { }. Si se trata de una única función:\nimport { cuadrado } from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + cuadrado(2))\n\nTambién podríamos usar un nombre diferente para lo que importamos:\nimport { cuadrado as cuad} from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + cuad(2))\n\nSi es un fichero con muchas funciones exportadas a un objeto podemos importar sólo las que queramos o todas:\nimport { letras, maysc } from './functions.js'\n\nconsole.log('Las letras de &quot;Hola&quot; son ' + letras(&quot;Hola&quot;))\n\nTambién podemos importarlas todas a un objeto sin indicar sus nombres, con *:\nimport * as MyFunctions from './functions.js'\n\nconsole.log('Las letras de &quot;Hola&quot; son ' + MyFunctions.letras(&quot;Hola&quot;))\n\nPara importar una clase:\nimport { Product } from './product.class'\n\nconst myProd = new Product()\n\nDefault export\nDe esta manera sólo puedo exportar un elemento por fichero, y a la hora de importarlo le doy el nombre que quiera. Por ejemplo, si es un fichero con una única función a exportar:\n// Fichero cuadrado.js\nexport default function cuadrado (value) {\nreturn value * value\n}\n\nY donde vaya a usarlo:\nimport myCuadrado from './cuadrado.js'\n\nconsole.log('El cuadrado de 2 es ' + myCuadrado(2))\n\nEn el caso de una clase:\nexport default class Product {\nconstructor() {\n\n}\n...\n}\n\nY para importarla:\nimport Product from './product.class'\n\nconst myProd = new Product()\n\nEn resumen, si exporto con export importo con { } y si exporto con export default importo sin { } pero sólo puedo exportar 1 elemento.\nImágenes\nSi se trata de imágenes estáticas lo más sencillo es ponerlas dentro de la carpeta public y hacer referencia a ellas usando ruta absoluta. Todo lo que está en public se referencia como si estuviera en la raíz de nuestra aplicación:\n&lt;img src=&quot;/vite.png&quot; height=&quot;100px&quot; alt=&quot;Logo de Vite&quot;&gt;\n\nTambién podemos poner las imágenes en la carpeta assets, pero antes de usarlas deberemos imnportarlas. Ejemplo:\nimport viteLogo from './assets/vite.png'\n...\nconst logoHtml = `&lt;img src=&quot;${viteLogo}&quot; height=&quot;100px&quot; alt=&quot;Vite logo&quot;&gt;`\ndocument.body.prepend(logoHtml)\n\nCon Vite también podemos importarlas usando import.meta.url, lo que es útil si no conocemos previamente el nombre del fichero con la imagen (más información en la documentación de Vite):\nfunction getImage(fileName, height, alt) {\nimgUrl = new URL(fileName, import.meta.url).href\nconst imgHtml = `&lt;img src=&quot;${viteLogo}&quot; height=&quot;${height}&quot; alt=&quot;${alt}&quot;&gt;`\n\nreturn logoHtml\n}\n\nPaso a producción\nCuando lo hayamos acabado y queramos subirlo a producción ejecutaremos\nnpm run build\n\nque crea la carpeta /dist con los ficheros que debemos subir al servidor web de producción:\n\nindex.html\ncualquier fichero que tengamos en /public\ncarpeta assets con\n\nfichero JS con todo el código que necesita el proyecto\nfichero CSS con todos los estilos del proyecto\notros ficheros importados en el JS como imágenes, ...\n\nTestear el proyecto\nSi queremos testear el proyecto deberemos usar una herramienta de testing y crear los tests adecuados. Lo más sencillo es usar Vitest que es muy similar a Jest pero preparado para interacutar fácilmente con Vite.\nLo primero es importarlo como dependencia de producción (no lo usaremos en producción)\nnpm install --save-dev vitest\n\no abreviado\nnpm i -D vitest\n\nDebemos añadir un nuevo script en el package.json que le indique a vite que queremos usarlo para testear:\n&quot;scripts&quot;: {\n\t\t...\n&quot;test&quot;: &quot;vitest&quot;\n},\n\nCrearemos los tests en una carpeta en la raíz de nuestro proyecto llamada /test y en ella crearemos los diferentes fichero cuya extensión será .spec.js o .test.js. Cada vez que queramos pasar los tests ejecutaremos\nnpm run test\n\nPodéis obtener más información en infinidad de páginas de internet, como el Curso DWEC de Jose Castillo, y en la web oficial de vite.",
		"tags": [ "note"]
},

{
		"title": "03.1-webpack",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/03-1-webpack/",
		"content": "Webpack\nCuando trabajamos con clases la mejor forma de organizar el código es poniendo cada clase un su propio fichero javascript. Esto reduce el acoplamiento de nuestro código y nos permite reutilizar una clase en cualquier proyecto en que la necesitemos.\nSin embargo tener muchos ficheros hace que tengamos que importarlos todos, y en el orden adecuado, en nuestro index.html (mediante etiquetas &lt;script src=&quot;...&quot;&gt;) lo que empieza a ser engorroso.\nPara evitar este problema se utilizan los module bundlers o empaquetadores de código que unen todo el código de los distintos ficheros javascript en un único fichero que es el que se importa en el index.html.\nAdemás proporciona otras ventajas:\n\ntranspila el código, de forma que podemos usar sentencias javascript que aún no soportan muchos navegadores ya que se convertirán a sentencias que hacen lo mismo pero con código legacy\nminimiza y optimiza el código para que ocupe menos y su carga sea más rápida\nofusca el código al minimizarlo lo que dificulta que el usuario pueda ver en la consola lo que hace el programa y manipularlo\n\nNosotros usaremos el bundler *webpack que es el más usado en entorno frontend. Junto a npm tendremos una forma fácil y práctica de empaquetar el código.\nTrabajar con distintos ficheros\nPara que un fichero pueda tener acceso a código de otro fichero hay que hacer 2 cosas:\n\nEl fichero al que queremos acceder debe exportar el código que desea que sea accesible desde otros ficheros\nEl fichero que quiere acceder a ese código debe importarlo a una variable\n\nEsto es lo que hacíamos en el ejercicio de la frase para poder pasar los tests y lo que haremos con los ficheros donde declaramos clases.\nExportamos el código\nEn el caso de un fichero con una función a exportar será lo que exportaremos. Por ejemplo:\n// Fichero cuadrado.js\nconst cuadrado = (value) =&gt; value * value\nmodule.exports = cuadrado\n\nEn el caso de querer exportar muchas funciones lo más sencillo es exportarlas juntas en un objeto como en el fichero functions.js:\nmodule.exports = {\n\tletras,\n\tpalabras,\n\tmaysc,\n\ttitulo,\n\tletrasReves,\n\tpalabrasReves,\n\tpalindromo\n}\n\nAquí estamos exportando un objeto que contiene una serie de funciones\nSi es un fichero que define una clase la exportamos tal cual:\nclass Product {\nconstructor() {\n\n}\n...\n}\nmodule.exports = Product\n\nLo importamos donde queramos usarlo\nEn el fichero donde vayamos a usar dicho código lo importamos a una variable. Si se trata de una única función:\nconst cuadrado = require('./cuadrado.js')\nconsole.log('El cuadrado de 2 es ' + cuadrado(2))\n\nSi es un fichero con muchas funciones exportadas a un objeto podemos importar sólo las que queramos o todas:\nconst functions = require('./functions.js')\nconsole.log('Las letras de &quot;Hola&quot; son ' + functions.letras(&quot;Hola&quot;) + ' y al revés es ' + functions.letrasReves('Hola'))\n\no bien\nconst { letras, letrasReves } = require('./functions.js')\nconsole.log('Las letras de &quot;Hola&quot; son ' + letras(&quot;Hola&quot;) + ' y al revés es ' + letrasReves('Hola'))\n\nPara usar una clase la importamos:\nconst Product = require('./product.class')\nconst myProd = new Product()\n\nUsar webpack\nUna vez que tenemos nuestro código correctamente exportado e importado vamos a usar webpack para empaquetarlo.\nLo primero que habría que hacer es crear nuestro proyecto si no lo hemos hecho ya mediante npm init. Esto inicializa el proyecto y crea el fichero package.json. Recuerda escribir jest cuando nos pregunte por los tests.\nPara usar webpack simplemente lo incluímos mediante npm:\nnpm i -D webpack webpack-cli\n\nLa opción -D instala webpack como dependencia de desarrollo, lo que significa que en la versión de producción del código no se incluirá.\nPara instalar todas nuestras dependencias y que se cree la carpeta node_modules ejecutamos npm install.\nAhora ya estamos listos para usar webpack. Como hemos dicho es un module bundler, es decir, un empaquetador de código. Toma el fichero que le indiquemos como fichero principal (por defecto el ./src/index.js), lo junta con todas sus dependencias (sus require y los de sus dependencias) y los transpila a un único fichero (por defecto ./dist/main.js) que es el que se enlaza en el index.html. Además minimiza y optimiza dicho código al generarlo.\nPara generar el código empaquetado ejecutamos\nnpx webpack --mode=development\n\nEste código hay que ejecutarlo cada vez que se hagan cambios en el código. Si no quieres tener que ejecutarlo cada vez se puede lanzar con la opción --watch que deja la consola abierta y ejecuta el comando automáticamente cuando guardamos cualquiera de los ficheros del proyecto:\nnpx webpack --mode=development --watch\n\nSi nuestro fichero principal no es src/index.js lo indicaremos con la opción --entry:\nnpx webpack --entry=scripts/main.js --mode=development\n\nCuando usamos webpack le tenemos que indicar que tipo de código de salida queremos:\n\ndevelopment: webpack permite &quot;seguir&quot; la ejecución del código desde la consola ya que &quot;mapea&quot; el código generado al original de forma que en la consola vemos como si se ejecutara nuestro código (los distintos ficheros) en vez del código generado por webpack que es el que realmente se está ejecutando\nproduction: minimiza y optimiza el código para producción y ya no es posible desde la consola acceder al código original. Es lo que haremos para generar el código que subiremos al servidor de producción (NUNCA subimos el código de desarrollo).\n\nPodéis obtener más información en infinidad de páginas de internet y en la web oficial de webpack. Las diferentes opciones que podemos pasarle a este comando las podemos consultar en la página del CLI de webpack.",
		"tags": [ "note"]
},

{
		"title": "04-DOM",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/04-dom/",
		"content": "Document Object Model (DOM)\n\nDocument Object Model (DOM)\n\nIntroducción\nAcceso a los nodos\nAcceso a nodos a partir de otros\n\nPropiedades de un nodo\n\nManipular el árbol DOM\n\nAñadir nuevos nodos con innerHTML\n\nAtributos de los nodos\n\nEstilos de los nodos\nAtributos de clase\nAtributos de datos\n\nIntroducción\nLa mayoría de las veces que programamos con Javascript es para que se ejecute en una página web mostrada por el navegador. En este contexto tenemos acceso a ciertos objetos que nos permiten interactuar con la página (DOM) y con el navegador (Browser Object Model, BOM).\nEl DOM es una estructura en árbol que representa todos los elementos HTML de la página y sus atributos. Todo lo que contiene la página se representa como nodos del árbol y mediante el DOM podemos acceder a cada nodo, modificarlo, eliminarlo o añadir nuevos nodos de forma que cambiamos dinámicamente la página mostrada al usuario.\nLa raíz del árbol DOM es document y de este nodo cuelgan el resto de elementos HTML. Cada uno constituye su propio nodo y tiene subnodos con sus atributos, estilos y elementos HTML que contiene.\nPor ejemplo, la página HTML:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;title&gt;Página simple&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nse convierte en el siguiente árbol DOM:\n![Árbol DOM](/img/user/notas/Javascript Teoria Batoi/img/domSimple.png)\nCada etiqueta HTML suele originar 2 nodos:\n\nElement: correspondiente a la etiqueta\nText: correspondiente a su contenido (lo que hay entre la etiqueta y su par de cierre)\n\nCada nodo es un objeto con sus propiedades y métodos.\nEl ejemplo anterior está simplificado porque sólo aparecen los nodos de tipo elemento pero en realidad también generan nodos los saltos de línea, tabuladores, espacios, comentarios, etc. En el siguiente ejemplo podemos ver TODOS los nodos que realmente se generan. La página:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;My Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Header&lt;/h1&gt;\n&lt;p&gt;\nParagraph\n&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nse convierte en el siguiente árbol DOM:\n\nAcceso a los nodos\nLos principales métodos para acceder a los diferentes nodos son:\n\n.getElementById(id): devuelve el nodo con la id pasada. Ej.:\n\nlet nodo = document.getElementById('main'); // nodo contendrá el nodo cuya id es _main_\n\n.getElementsByClassName(clase): devuelve una colección (similar a un array) con todos los nodos de la clase indicada. Ej.:\n\nlet nodos = document.getElementsByClassName('error'); // nodos contendrá todos los nodos cuya clase es _error_\n\nNOTA: las colecciones son similares a arrays (se accede a sus elementos con [indice]) pero no se les pueden aplicar sus métodos filter, map, ... a menos que se conviertan a arrays con Array.from()\n\n.getElementsByTagName(etiqueta): devuelve una colección con todos los nodos de la etiqueta HTML indicada. Ej.:\n\nlet nodos = document.getElementsByTagName('p'); // nodos contendrá todos los nodos de tipo _&lt;p&gt;_\n\n.getElementsByName(name): devuelve una colección con todos los nodos que contengan un atributo name con el valor indicado. Ej.:\n\nlet radiosSexo = document.getElementsByName('sexo'); // radiosSexo contendrá todos los nodos con ese atributo (seguramente radiobuttons con name=&quot;sexo&quot;)\n\n.querySelector(selector): devuelve el primer nodo seleccionad por el selector CSS indicado. Ej.:\n\nlet nodo = document.querySelector('p.error'); // nodo contendrá el primer párrafo de clase _error_\n\n.querySelectorAll(selector): devuelve una colección con todos los nodos seleccionados por el selector CSS indicado. Ej.:\n\nlet nodos = document.querySelectorAll('p.error'); // nodos contendrá todos los párrafos de clase _error_\n\nNOTA: al aplicar estos métodos sobre document se seleccionará sobre la página pero podrían también aplicarse a cualquier nodo y en ese caso la búsqueda se realizaría sólo entre los descendientes de dicho nodo.\nTambién tenemos 'atajos' para obtener algunos elementos comunes:\n\ndocument.documentElement: devuelve el nodo del elemento &lt;html&gt;\ndocument.head: devuelve el nodo del elemento &lt;head&gt;\ndocument.body: devuelve el nodo del elemento &lt;body&gt;\ndocument.title: devuelve el nodo del elemento &lt;title&gt;\ndocument.link: devuelve una colección con todos los hiperenlaces del documento\ndocument.anchor: devuelve una colección con todas las anclas del documento\ndocument.forms: devuelve una colección con todos los formularios del documento\ndocument.images: devuelve una colección con todas las imágenes del documento\ndocument.scripts: devuelve una colección con todos los scripts del documento\n\nEJERCICIO: Para hacer los ejercicios de este tema descárgate esta página de ejemplo y ábrela en tu navegador. Obtén por consola, al menos de 2 formas diferentes:\n\nEl elemento con id 'input2'\n\ndocument.getElementById('input2') o document.querySelector('#input2')\n\nLa colección de párrafos\n\ndocument.getElementsByTagName('p') o document.querySelectorAll('p')\n\nLo mismo pero sólo de los párrafos que hay dentro del div 'lipsum'\n\nEl formulario (ojo, no la colección con el formulario sino sólo el formulario)\nTodos los inputs\nSólo los inputs con nombre 'sexo'\nLos items de lista de la clase 'important' (sólo los LI)\n\nAcceso a nodos a partir de otros\nEn muchas ocasiones queremos acceder a cierto nodo a partir de uno dado. Para ello tenemos los siguientes métodos que se aplican sobre un elemento del árbol DOM:\n\nelemento.parentElement: devuelve el elemento padre de elemento\nelemento.children: devuelve la colección con todos los elementos hijo de elemento (sólo elementos HTML, no comentarios ni nodos de tipo texto)\nelemento.childNodes: devuelve la colección con todos los hijos de elemento, incluyendo comentarios y nodos de tipo texto por lo que no suele utilizarse\nelemento.firstElementChild: devuelve el elemento HTML que es el primer hijo de elemento\nelemento.firstChild: devuelve el nodo que es el primer hijo de elemento (incluyendo nodos de tipo texto o comentarios)\nelemento.lastElementChild, elemento.lastChild: igual pero con el último hijo\nelemento.nextElementSibling: devuelve el elemento HTML que es el siguiente hermano de elemento\nelemento.nextSibling: devuelve el nodo que es el siguiente hermano de elemento (incluyendo nodos de tipo texto o comentarios)\nelemento.previousElementSibling, elemento.previousSibling: igual pero con el hermano anterior\nelemento.hasChildNodes: indica si elemento tiene o no nodos hijos\nelemento.childElementCount: devuelve el nº de nodos hijo de elemento\nelemento.closest(selector): devuelve el ancestro más cercano que coincide con el selector. Por ejemplo si el elemento es un &lt;td&gt; de una tabla entonces elemento.closest('table') devolverá la tabla a la que pertenece\n\nIMPORTANTE: a menos que me interesen comentarios, saltos de página, etc siempre debo usar los métodos que sólo devuelven elementos HTML, no todos los nodos.\n![Recorrer el árbol DOM](/img/user/notas/Javascript Teoria Batoi/img/domRelaciones.png)\n\nEJERCICIO: Siguiento con la página de ejemplo obtén desde la consola, al menos de 2 formas diferentes:\n\nEl primér párrafo que hay dentro del div 'lipsum'\nEl segundo párrafo de 'lipsum'\nEl último item de la lista\nLa label de 'Escoge sexo'\n\nPropiedades de un nodo\nLas principales propiedades de un nodo son:\n\nelemento.innerHTML: todo lo que hay entre la etiqueta que abre elemento y la que lo cierra, incluyendo otras etiquetas HTML. Por ejemplo si elemento es el nodo &lt;p&gt;Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;&lt;/p&gt;\n\nlet contenido = elemento.innerHTML; // contenido='Esta página es &lt;strong&gt;muy simple&lt;/strong&gt;'\n\nelemento.textContent: todo lo que hay entre la etiqueta que abre elemento y la que lo cierra, pero ignorando otras etiquetas HTML. Siguiendo con el ejemplo anterior:\n\nlet contenido = elemento.textContent; // contenido='Esta página es muy simple'\n\nelemento.value: devuelve la propiedad 'value' de un &lt;input&gt; (en el caso de un &lt;input&gt; de tipo text devuelve lo que hay escrito en él). Como los &lt;inputs&gt; no tienen etiqueta de cierre (&lt;/input&gt;) no podemos usar .innerHTML ni .textContent. Por ejemplo si elem1 es el nodo &lt;input name=&quot;nombre&quot;&gt; y elem2 es el nodo &lt;input tipe=&quot;radio&quot; value=&quot;H&quot;&gt;Hombre\n\nlet cont1 = elem1.value; // cont1 valdría lo que haya escrito en el &lt;input&gt; en ese momento\nlet cont2 = elem2.value; // cont2=&quot;H&quot;\n\nOtras propiedades:\n\nelemento.innerText: igual que textContent\nelemento.focus: da el foco a elemento (para inputs, etc). Para quitarle el foco elemento.blur\nelemento.clientHeight / elemento.clientWidth: devuelve el alto / ancho visible del elemento\nelemento.offsetHeight / elemento.offsetWidth: devuelve el alto / ancho total del elemento\nelemento.clientLeft / elemento.clientTop: devuelve la distancia de elemento al borde izquierdo / superior\nelemento.offsetLeft / elemento.offsetTop: devuelve los píxels que hemos desplazado elemento a la izquierda / abajo\n\nEJERCICIO: Obtén desde la consola, al menos de 2 formas:\n\nEl innerHTML de la etiqueta de 'Escoge sexo'\nEl textContent de esa etiqueta\nEl valor del primer input de sexo\nEl valor del sexo que esté seleccionado (difícil, búscalo por Internet)\n\nManipular el árbol DOM\nVamos a ver qué métodos nos permiten cambiar el árbol DOM, y por tanto modificar la página:\n\ndocument.createElement('etiqueta'): crea un nuevo elemento HTML con la etiqueta indicada, pero aún no se añade a la página. Ej.:\n\nlet nuevoLi = document.createElement('li');\n\nelemento.append(elementos o texto): añade al DOM los parámetros pasados como últimos hijos de elemento. Se le puede pasar tanto un nodo DOM como una cadena de texto (para la que se creará su nodo de texto correspondiente) y que se le pueden pasar varios parámetros para crear varios nodos. Ej.:\n\nnuevoLi.append('Nuevo elemento de lista'); // añade el texto pasado al elemento LI creado\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nmiPrimeraLista.append(nuevoLi); // añade LI como último hijo de UL, es decir al final de la lista\n\nelemento.prepend(elementos o texto): como el anterior pero en lugar de añadirlos como últimos hijos los añade antes del primer hijo.\n\nconst primerLi = document.createElement('li');\nprimerLi.append('Primer elemento de lista');\nlet miPrimeraLista = document.getElementsByTagName('ul')[0];\nmiPrimeraLista.prepend(nuevoLi);\n\nelemento.after(elementos o texto): como append pero en lugar de añadirlos como últimos hijos los añade como los siguientes hermanos de elemento.\n\nconst otroLi = document.createElement('li');\notroLi.append('Segundo elemento de lista');\nprimerLi.after(otroLi);\n\nelemento.before(elementos o texto): como el anterior pero los añade como los anteriores hermanos de elemento.\nelemento.remove(): borra el nodo elemento del documento.\nelemento.replaceWith(nuevoNodo): reemplaza el nodo elemento con el nuevoNodo pasado\n\nlet primerElementoDeLista = document.getElementsByTagName('ul')[0].firstChild; // selecciona el 1º LI de miPrimeraLista\nprimerElementoDeLista.replaceChild(nuevoLi); // reemplaza el 1º elemento de la lista con nuevoLi\n\nelementoAClonar.cloneNode(boolean): devuelve un clon de elementoAClonar o de elementoAClonar con todos sus descendientes según le pasemos como parámetro false o true. Luego podremos insertarlo donde queramos.\n\nOtros métodos menos usados son:\n\ndocument.createTextNode('texto'): crea un nuevo nodo de texto con el texto indicado, que luego tendremos que añadir a un nodo HTML. Normalmente no se usa porque append y el resto de métodos anteriores ya lo crean automáticamente. Ej.:\n\nlet textoLi = document.createTextNode('Nuevo elemento de lista');\n\nelemento.appendChild(nuevoNodo): añade nuevoNodo como último hijo de elemento y lo devuelve. Se diferencia con append en que sólo permite un parámetro y éste debe ser un nodo, no puede ser texto. Por eso no suele usarse. Ejemplo:\n\nnuevoLi.appendChild(textoLi); // añade el texto creado al elemento LI creado\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nmiPrimeraLista.appendChild(nuevoLi); // añade LI como último hijo de UL, es decir al final de la lista\n\nelemento.insertBefore(nuevoNodo, nodo): añade nuevoNodo como hijo de elemento antes del hijo nodo. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.insertBefore(nuevoLi, primerElementoDeLista); // añade LI al principio de la lista\n\nelemento.removeChild(nodo): borra nodo de elemento y por tanto se elimina de la página. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.removeChild(primerElementoDeLista); // borra el primer elemento de la lista\n// También podríamos haberlo borrado sin tener el padre con:\nprimerElementoDeLista.parentElement.removeChild(primerElementoDeLista);\n\nelemento.replaceChild(nuevoNodo, viejoNodo): reemplaza viejoNodo con nuevoNodo como hijo de elemento. Ej.:\n\nlet miPrimeraLista = document.getElementsByTagName('ul')[0]; // selecciona el 1º UL de la página\nlet primerElementoDeLista = miPrimeraLista.getElementsByTagName('li')[0]; // selecciona el 1º LI de miPrimeraLista\nmiPrimeraLista.replaceChild(nuevoLi, primerElementoDeLista); // reemplaza el 1º elemento de la lista con nuevoLi\n\nOJO: Si añado con el método append o appendChild un nodo que estaba en otro sitio se elimina de donde estaba para añadirse a su nueva posición. Si quiero que esté en los 2 sitios deberé clonar el nodo y luego añadir el clon y no el nodo original.\nAñadir nuevos nodos con innerHTML\nSupongamos que tenemos un DIV cuya id es myDiv al que queremos añadir al final dos párrafos, el último de ellos con un texto en negrita. El código podría ser:\nlet miDiv = document.getElementById('myDiv');\nlet nuevoParrafo = document.createElement('p');\nnuevoParrafo.textContent = 'Párrafo añadido al final';\nlet ultimoParrafo = document.createElement('p');\nconst textoNegrita = document.createElement('strong');\ntextoNegrita.textContent = 'con texto en negrita';\nultimoParrafo.append('Último párrafo ', textoNegrita);\nmiDiv.append(nuevoParrafo, ultimoParrafo);\n\nSi utilizamos la propiedad innerHTML el código a usar es mucho más simple:\nlet miDiv = document.getElementById('myDiv');\nmiDiv.innerHTML += '&lt;p&gt;Párrafo añadido al final&lt;/p&gt;&lt;p&gt;Último párrafo &lt;strong&gt;con texto en negrita&lt;/strong&gt;&lt;/p&gt;';\n\nOJO: La forma de añadir el último párrafo (línea #3: miDiv.innerHTML+='&lt;p&gt;Párrafo añadido al final&lt;/p&gt;';) aunque es válida no es muy eficiente ya que obliga al navegador a volver a pintar TODO el contenido de miDIV.\nPodemos ver más ejemplos de creación y eliminación de nodos en W3Schools.\n\nEJERCICIO: Añade a la página:\n\nUn nuevo párrafo al final del DIV 'lipsum' con el texto &quot;Nuevo párrafo añadido por javascript&quot; (fíjate que una palabra está en negrita)\nUn nuevo elemento al formulario tras el 'Dato 1' con la etiqueta 'Dato 1 bis' y el INPUT con id 'input1bis' que al cargar la página tendrá escrito &quot;Hola&quot;\n\nAtributos de los nodos\nPodemos ver y modificar los valores de los atributos de cada elemento HTML y también añadir o eliminar atributos:\n\nelemento.attributes: devuelve un array con todos los atributos de elemento\nelemento.hasAttribute('nombreAtributo'): indica si elemento tiene o no definido el atributo nombreAtributo\nelemento.getAttribute('nombreAtributo'): devuelve el valor del atributo nombreAtributo de elemento. Para muchos elementos este valor puede directamente con elemento.atributo.\nelemento.setAttribute('nombreAtributo', 'valor'): establece valor como nuevo valor del atributo nombreAtributo de elemento. También puede cambiarse el valor directamente con elemento.atributo=valor.\nelemento.removeAttribute('nombreAtributo'): elimina el atributo nombreAtributo de elemento\n\nA algunos atributos comunes como id, title o className (para el atributo class) se puede acceder y cambiar como si fueran una propiedad del elemento (elemento.atributo). Ejemplos:\nelemento.id = 'primera-lista';\n// es equivalente ha hacer:\nelemento.setAttribute('id', 'primera-lista');\n\nEstilos de los nodos\nLos estilos están accesibles como el atributo style. Cualquier estilo es una propiedad de dicho atributo pero con la sintaxis camelCase en vez de kebab-case. Por ejemplo para cambiar el color de fondo (propiedad background-color) y ponerle el color rojo al elemento miPrimeraLista haremos:\nmiPrimeraLista.style.backgroundColor = 'red';\n\nDe todas formas normalmente NO CAMBIAREMOS ESTILOS a los elementos sino que les pondremos o quitaremos clases que harán que se le apliquen o no los estilos definidos para ellas en el CSS.\nAtributos de clase\nYa sabemos que el aspecto de la página debe configurarse en el CSS por lo que no debemos aplicar atributos style al HTML. En lugar de ello les ponemos clases a los elementos que harán que se les aplique el estilo definido para dicha clase.\nComo es algo muy común en lugar de utilizar las instrucciones de elemento.setAttribute('className', 'destacado') o directamente elemento.className='destacado' podemos usar la propiedad classList que devuelve la colección de todas las clases que tiene el elemento. Por ejemplo si elemento es &lt;p class=&quot;destacado direccion&quot;&gt;...:\nlet clases=elemento.classList; // clases=['destacado', 'direccion'], OJO es una colección, no un Array\n\nAdemás dispone de los métodos:\n\n.add(clase): añade al elemento la clase pasada (si ya la tiene no hace nada). Ej.:\n\nelemento.classList.add('primero'); // ahora elemento será &lt;p class=&quot;destacado direccion primero&quot;&gt;...\n\n.remove(clase): elimina del elemento la clase pasada (si no la tiene no hace nada). Ej.:\n\nelemento.classList.remove('direccion'); // ahora elemento será &lt;p class=&quot;destacado primero&quot;&gt;...\n\n.toogle(clase): añade la clase pasada si no la tiene o la elimina si la tiene ya. Ej.:\n\nelemento.classList.toogle('destacado'); // ahora elemento será &lt;p class=&quot;primero&quot;&gt;...\nelemento.classList.toogle('direccion'); // ahora elemento será &lt;p class=&quot;primero direccion&quot;&gt;...\n\n.contains(clase): dice si el elemento tiene o no la clase pasada. Ej.:\n\nelemento.classList.contains('direccion'); // devuelve true\n\n.replace(oldClase, newClase): reemplaza del elemento una clase existente por una nueva. Ej.:\n\nelemento.classList.replace('primero', 'ultimo'); // ahora elemento será &lt;p class=&quot;ultimo direccion&quot;&gt;...\n\nTened en cuenta que NO todos los navegadores soportan classList por lo que si queremos añadir o quitar clases en navegadores que no lo soportan debemos hacerlo con los métodos estándar, por ejemplo para añadir la clase 'rojo':\nlet clases = elemento.className.split(&quot; &quot;);\nif (clases.indexOf('rojo') == -1) {\nelemento.className += ' ' + 'rojo';\n}\n\nAtributos de datos\nHTML5 permite agregar atributos personalizados no visuales a las etiquetas utilizando data-*. Estos atributos pueden ser accesibles a través de JavaScript usando dataset.\n&lt;article\nid=&quot;electriccars&quot;\ndata-columns=&quot;3&quot;\ndata-index-number=&quot;12314&quot;\ndata-parent=&quot;cars&quot;&gt;\n...\n&lt;/article&gt;\n\nlet article = document.getElementById('electriccars');\nconsole.log(article.dataset.columns); // 3\nconsole.log(article.dataset.indexNumber); // 12314\n\nFuente: Curso DWEC de José Castillo",
		"tags": ["3", "note"]
},

{
		"title": "04.1-MVC",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/04-1-mvc/",
		"content": "El patrón Modelo-Vista-Controlador\nModelo-vista-controlador (MVC) es un patrón de arquitectura de software muy utilizado en la actualidad en desarrollo web (y también en muchas aplicaciones de escritorio). Este patrón propone separar la aplicación en componentes distintos: el modelo, la vista y el controlador:\n\nEl modelo representa y gestiona los datos o información con la que trabaja la aplicación que normalmente serán variables extraidas de una base de datos. Normalmente el modelo no tiene conocimiento de las otras partes de la aplicación.\nLa vista muestra al usuario el modelo (información y lógica de negocio) en un formato adecuado para interactuar con él (usualmente la interfaz de usuario). Es la intermediaria entre la aplicación y el usuario\nEl controlador es el encargado de coordinar el funcionamiento de la aplicación. Responde a los eventos del usuario para lo que hace peticiones al modelo (para obtener o cambiar la información) y a la vista (para que muestre al usuario dicha información).\n\nAdemás de etos componentes usualmente tendremos otros como:\n\nLos servicios que controlan la comunicación con el servidor y otras fuentes externas de datos. Gestionan los accesos a la información, tanto consultas como actualizaciones, implementando también los privilegios de acceso que se hayan descrito en las especificaciones de la aplicación (lógica de negocio).\nLas rutas gestionan la navegación y las rutas de la aplicación en SPA.\n\nEste patrón de arquitectura de software se basa en las ideas de reutilización de código y la separación de conceptos, características que buscan facilitar la tarea de desarrollo de aplicaciones y su posterior mantenimiento.\nUna aplicación sin MVC\nSi una aplicación no utiliza este modelo la función que modifique los datos debe además reflejar dicha modificación en la página para que la vea el usuario. Por ejemplo vamos a hacer una aplicación para gestionar un almacén. Entre otras muchas cosas tendrá una función (podemos llamarle addProduct) que se encargue de añadir un nuevo producto al almacén y dicha función deberá realizar:\n\nañadir el nuevo producto al almacén (por ejemplo añadiéndolo a un array de productos)\npintar en la página ese nuevo producto (por ejemplo añadiendo una nueva línea a una tabla donde se muestran los productos)\n\n// La función que se ejecuta cuando el usuario envía el\n// formulario para añadir un producto debería hacer:\ndocument.getElementById('product-form').addEventListener('submit', async (event) =&gt; {\nevent.preventDefault()\n// Coge los datos del formlario\nconst name = document.getElementById('product-form-name').value\nconst price = document.getElementById('product-form-name').price\n...\n// Valida cada dato\nif (!name || name.length &lt; 5 || ...)\n...\n// Añade el producto a la BBDD\nconst prod = await addProductToDatabase(payload)\nlet newProd = new Product(prod.id, prod.name, prod.price, prod.units)\nthis.products.push(newProd)\n...\n// Pinta en la página el nuevo producto\nconst DOMproduct = document.createElement('tr')\nDOMproduct.innerHTML = `\n&lt;td&gt;${newProd.id}&lt;/td&gt;\n&lt;td&gt;${newProd.name}&lt;/td&gt;\n&lt;td&gt;${newProd.price}&lt;/td&gt;\n&lt;td&gt;${newProd.units}&lt;/td&gt;`\ndocument.getElementById('products-table').apendChild(DOMproduct)\n// Gestiona los posibles errores producidos en todo este proceso\n...\n})\n\nComo vemos, se va a convertir en una función muy grande y que se encarga de muchas cosas distintas por lo que va a ser difícil mantener ese código. Además toda la función es muy dependiente del HTML (en muchas partes se buscan elementos por su id).\nNuestro patrón MVC\nEn una aplicación muy sencilla podemos no seguir este modelo pero en cuanto la misma se complica un poco es imprescindible programar siguiendo buenas prácticas ya que si no lo hacemos nuestro código se volverá rápidamente muy difícil de mantener.\nHay muchas formas de implementar este modelo. Si estamos haciendo un proyecto con OOP podemos seguir el patrón MVC usando clases. Si sólo usamos programación estructurada será igual pero en vez de clases y métodos tendremos funciones.\nPara organizar el código crearemos subcarpetas dentro de la carpeta src:\n\nmodel: aquí incluiremos las clases que constituyen el modelo de nuestra aplicación\nview: aquí crearemos un fichero JS que será el encargado de la GUI de nuestra aplicación, el único dependiente del HTML. Nuestro fichero será una clase que representa toda la vista aunque en aplicaciones mayores lo normal es tener clases para cada página, etc\ncontroller: aquí crearemos el fichero JS que contendrá el controlador de la aplicación\nservices: aquí crearemos el fichero JS que se encargará de comunicarse con el servidor y proporcionar los datos al modelo\n\nDe este forma, si quiero cambiar la forma en que se muestra algo voy directamente a la vista y modifico la función que se ocupa de ello.\nLa vista será una clase cuyas propiedades serán elementos de la página HTML a los que accedamos frecuentemente, para no tener que buscarlos cada vez y para que estén disponibles para el controlador. Contendrá métodos para renderizar los distintos elementos de la vista.\nEl controlador será una clase cuyas propedades serán el modelo y la vista, de forma que pueda acceder a ambos elementos. Tendrá métodos para las distintas acciones que pueda hacer el usuario (y que se ejecutarán como respuesta a dichas acciones, como veremos en el tema de eventos). Cada uno de esos métodos llamará a métodos del modelo (para obtener o cambiar la información necesaria) y posteriormente de la vista (para reflejar esos cambios en lo que ve el usuario).\nPor su parte el modelo gestionará los datos de la aplicación llamando a los servicios para obtener datos del servidor o guardar en él las modificaciones pertinentes.\nEl fichero principal de la aplicación instanciará un controlador y lo inicializará.\nPor ejemplo, siguiendo con la aplicación para gestionar un almacén. El modelo constará de la clase Store que es nuestro almacén de productos (con métodos para añadir o eliminar productos, etc) y la clase Product que gestiona cada producto del almacén (con métodos para crear un nuevo producto, etc).\nEl fichero principal sería algo como:\n\nmain.js\n\nconst storeApp = new Controller()\t\t// crea el controlador\nstoreApp.init()\t\t\t\t// lo inicializa\n\n// En desarrollo podemos añadir algunas líneas que luego quitaremos para\n// imitar acciones del usuario y así ver el funcionamiento de la aplicación:\nstoreApp.addProductToStore({ name: 'Portátil Acer Travelmate E2100', price: 523.12 })\nstoreApp.changeProduct({ id: 1, price: 515.95 })\nstoreApp.deleteProduct(1)\n\ncontroller/index.js\n\nexport default class Controller {\nconstructor() {\nthis.store = new Store(1)\t\t// crea el modelo, un Store con id 1\nthis.view = new View()\t\t// crea la vista\n}\n\ninit() {\n// inicializa la vista y el modelo, si es necesario\nthis.store.init()\nthis.view.init()\t\t\t\n\n// Le indica a la vista qué funciones callback se encargarán\n// de responder a los eventos del usuario (siguiente tema)\nthis.view.setSubmitHandler(this.handleSubmitProductForm.bind(this))\n}\n\t\nhandleSubmitProductForm(payload) {\n// haría las comprobaciones necesarias sobre los datos\nif (!payload.name || payload.name.length &lt; 5 || ...) {\nthis.view.showErrorMessage('error', 'Datos incorrectos')\nreturn\n}\n...\n// y luego dice al modelo que añada el producto\ntry {\nconst newProd = this.store.addProduct(prod)\n// si lo ha hecho le dice a la vista que lo pinte\t\nthis.view.renderNewProduct(newProd)\t\n} catch(err) {\nthis.view.showErrorMessage('error', 'Error al añadir el producto')\n}\n}\n...\n}\n\nmodel/store.class.js\n\nexport default class Store {\nconstructor (id) {\nthis.id=Number(id)\nthis.products=[]\n}\n\naddProduct(payload) {\n// llama a métodos de los servicios para que añada el producto\nconst prod = await addProductToDatabase(payload)\nlet newProd = new Product(prod.id, prod.name, prod.price, prod.units)\nthis.products.push(newProd)\nreturn newProd\n}\n...\n}\n\nmodel/product.class.js\n\nexport default class Product {\nconstructor (id, name, price, units) {\nthis.id = id\nthis.name = name\nthis.price = price\nthis.units = units\n}\n...\n}\n\nview/index.js\n\nexport default class View {\nconstructor {\nthis.messageDiv = document.getElementById('messages')\nthis.productForm = document.getElementById('product-form')\nthis.productsList = document.getElementById('products-table')\n}\n\ninit() {\n...\t\t\t// inicializa la vista, si es necesario\n}\n\nsetSubmitHandler(callback) {\n// código para que el controlador llame a la función callback\n// cuando se envíe el formulario de añadir un producto\nthis.productForm.addEventListener('submit', (event) =&gt; {\nevent.preventDefault()\nconst name = document.getElementById('product-form-name').value\nconst price = document.getElementById('product-form-name').price\n...\ncallback({ name, price, ... })\n})\n}\n\nrenderNewProduct(prod) {\n// código para añadir a la tabla el producto pasado añadiendo una nueva fila\nconst DOMproduct = document.createElement('tr')\nDOMproduct.innerHTML = `\n&lt;td&gt;${newProd.id}&lt;/td&gt;\n&lt;td&gt;${newProd.name}&lt;/td&gt;\n&lt;td&gt;${newProd.price}&lt;/td&gt;\n&lt;td&gt;${newProd.units}&lt;/td&gt;`\nthis.productsList.apendChild(DOMproduct)\n}\n\nshowMessage(type, message) {\n// código para mostrar mensajes al usuario y no tener que usar los alert\nconst DOMmessage = document.createElement('div')\n...\nthis.messageDiv.apendChild(DOMmessage)\n}\n}\n\nPodéis obtener más información y ver un ejemplo más completo en https://www.natapuntes.es/patron-mvc-en-vanilla-javascript/",
		"tags": [ "note"]
},

{
		"title": "05-BOM",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/05-bom/",
		"content": "Browser Object Model (BOM)\n\nBrowser Object Model (BOM)\n\nIntroducción\nTimers\nObjetos del BOM\n\nObjeto window\n\nDiálogos\n\nObjeto location\nObjeto history\nObjeto navigator\nOtros objetos\n\nIntroducción\nEn este tema veremos cómo acceder a objetos que nos permitan interactuar con el navegador (Browser Object Model, BOM).\nUsando los objetos BOM podemos:\n\nAbrir, cambiar y cerrar ventanas\nEjecutar código en cierto tiempo (timers)\nObtener información del navegador\nVer y modificar propiedades de la pantalla\nGestionar cookies, ...\n\nTimers\nPermiten ejecutar código en el futuro (cuando transcurran los milisegundos indicados). Hay 2 tipos:\n\nsetTimeout(función, milisegundos): ejecuta la función pasada como parámetro una sóla vez, cuando transcurran los milisegundos indicados\nsetInterval(función, milisegundos): ejecuta la función cada vez que transcurran los milisegundos indicados, hasta que sea cancelado el timer. A ambas se le pueden pasar más parámetros tras los milisegundos y serán los parámetros que recibirá la función a ejecutar.\n\nAmbas funciones devuelven un identificador que nos permitirá cancelar la ejecución del código usando:\n\nclearTiemout(identificador)\nclearInterval(identificador)\n\nEjemplo:\nconst idTimeout = setTimeout(() =&gt; alert('Timeout que se ejecuta al cabo de 1 seg.'), 1000);\n\nlet i = 1;\nconst idInterval = setInterval(() =&gt; {\n\talert('Interval cada 3 seg. Ejecución nº: '+ i++);\nif (i === 5) {\nclearInterval(idInterval);\nalert('Fin de la ejecución del Interval');\n\t}\n}, 3000);\n\nEJERCICIO: Ejecuta en la consola cada una de esas funciones\n\nEn lugar de definir la función a ejecutar podemos llamar a una función que ya exista:\nfunction showMessage() {\nalert('Timeout que se ejecuta al cabo de 1 seg.')\n}\n\nconst idTimeout=setTimeout(showMessage, 1000);\n\nPero en ese caso hay que poner sólo el nombre de la función, sin () ya que si los ponemos se ejecutaría la función en ese momento y no transcurrido el tiempo indicado.\nSi necesitamos pasarle algún parámetro a la función lo añadiremos como parámetros de setTimeout o setInterval después del intervalo:\nfunction showMessage(msg) {\nalert(msg)\n}\n\nconst idTimeout = setTimeout(showMessage, 1000, 'Timeout que se ejecuta al cabo de 1 seg.');\n\nObjetos del BOM\nAl contrario que para el DOM, no existe un estándar de BOM pero es bastante parecido en los diferentes navegadores.\nObjeto window\nRepresenta la ventana del navegador y es el objeto principal. De hecho puede omitirse al llamar a sus propiedades y métodos, por ejemplo, el método setTimeout() es en realidad window.setTimeout().\nSus principales propiedades y métodos son:\n\n.name: nombre de la ventana actual\n.status: valor de la barra de estado\n.screenX/.screenY: distancia de la ventana a la esquina izquierda/superior de la pantalla\n.outerWidth/.outerHeight: ancho/alto total de la ventana, incluyendo la toolbar y la scrollbar\n.innerWidth/.innerHeight: ancho/alto útil del documento, sin la toolbar y la scrollbar\n.open(url, nombre, opciones): abre una nueva ventana. Devuelve el nuevo objeto ventana. Las principales opciones son:\n\n.toolbar: si tendrá barra de herramientas\n.location: si tendrá barra de dirección\n.directories: si tendrá botones Adelante/Atrás\n.status: si tendrá barra de estado\n.menubar: si tendrá barra de menú\n.scrollbar: si tendrá barras de desplazamiento\n.resizable: si se puede cambiar su tamaño\n.width=px/.height=px: ancho/alto\n.left=px/.top=px: posición izq/sup de la ventana\n\n.opener: referencia a la ventana desde la que se abrió esta ventana (para ventanas abiertas con open)\n.close(): la cierra (pide confirmación, a menos que la hayamos abierto con open)\n.moveTo(x,y): la mueve a las coord indicadas\n.moveBy(x,y): la desplaza los px indicados\n.resizeTo(x,y): la da el ancho y alto indicados\n.resizeBy(x,y): le añade ese ancho/alto\n.pageXoffset / pageYoffset: scroll actual de la ventana horizontal / vertical\nOtros métodos: .back(), .forward(), .home(), .stop(), .focus(), .blur(), .find(), .print(), …\nNOTA: por seguridad no se puede mover una ventana fuera de la pantalla ni darle un tamaño menor de 100x100 px ni tampoco se puede mover una ventana no abierta con .open() o si tiene varias pestañas\n\nEJERCICIO: Ejecuta desde la consola:\n\nabre una nueva ventana de dimensiones 500x200px en la posición (100,200)\nescribe en ella (con document.write) un título h1 que diga 'Hola'\nmuévela 300 px hacia abajo y 100 a la izquierda\nciérrala\n\nPuedes ver un ejemplo de cómo abrir ventanas en este vídeo.\n\nEJERCICIO: Haz que a los 2 segundos de abrir la página se abra un popup con un mensaje de bienvenida. Esta ventana tendrá en su interior un botón Cerrar que permitirá que el usuario la cierre haciendo clic en él. Tendrá el tamaño justo para visualizar el mensaje y no tendrá barras de scroll, ni de herramientas, ni de dirección... únicamente el mensaje.\n\nDiálogos\nHay 3 métodos del objeto window que ya conocemos y que nos permiten abrir ventanas de diálogo con el usuario:\n\nwindow.alert(mensaje): muestra un diálogo con el mensaje indicado y un botón de 'Aceptar'\nwindow.confirm(mensaje): muestra un diálogo con el mensaje indicado y botones de 'Aceptar' y 'Cancelar'. Devuelve true si se ha pulsado el botón de aceptar del diálogo y false si no.\nwindow.prompt(mensaje [, valor predeterminado]): muestra un diálogo con el mensaje indicado, un cuadro de texto (vacío o co el valor predeterminado indicado) y botones de 'Aceptar' y 'Cancelar'. Si se pulsa 'Aceptar' devolverá un string con el valor que haya en el cuadro de texto y si se pulsa 'Cancelar' o se cierra devolverá null.\n\nObjeto location\nContiene información sobre la URL actual del navegador y podemos modificarla. Sus principales propiedades y métodos son:\n\n.href: devuelve la URL actual completa\n.protocol, .hostname, .port: devuelve el protocolo, host y puerto respectivamente de la URL actual\n.pathname, hash, search: devuelve la ruta al recurso actual, el gragmento (#...) y la cadena de búsqueda (?...) respectivamente\n.reload(): recarga la página actual\n.assign(url): carga la página pasada como parámetro\n.replace(url): ídem pero sin guardar la actual en el historial\n\nEJERCICIO: Ejecuta en la consola\n\nmuestra la ruta completa de la página actual\nmuestra el servidor de esta página\ncarga la página de Google usando el objeto location\n\nObjeto history\nPermite acceder al historial de páginas visitadas y navegar por él:\n\n.length: muestra el número de páginas almacenadas en el historial\n.back(): vuelve a la página anterior\n.forward(): va a la siguiente página\n.go(num): se mueve num páginas hacia adelante o hacia atrás (si num es negativo) en el historial\n\nEJERCICIO: desde la consola vuelve a la página anterior\n\nObjeto navigator\nNos da información sobre el navegador y el sistema en que se ejecuta:\n\n.userAgent: muestra información sobre el navegador que usamos\n.language: muestra el idioma del navegador\n.languages: muestra los idiomas instalados en el navegador\n.appVersion: versión del navegador\n.appName: nombre del navegador\n.appCodeName: nombre en código del navegador\n.product: producto del navegador\n.platform: sistema en el que se ejecuta el navegador\n...\n\nTambién incluye objetos con sus propias API para poder interactuar con el sistema:\n\n.geolocation: devuelve un objeto con la localización del dispositivo (sólo funciona en https)\n.storage: permite acceder a los datos almacenados en el navegador (los veremos en detalle más adelante)\n.clipboard: permite copiar texto al portapapeles del usuario con .writeText() (sólo funciona en https)\n.mediaDevices: permite acceder a los dispositivos multimedia del usuario\n.serviceWorker: permite trabajar con service workers\n...\n\nEJERCICIO: desde la consola muestra la información del navegador, su lenguaje y del sistema en que se ejecuta\n\nOtros objetos\nOtros objetos que incluye BOM son:\n\nscreen: nos da información sobre la pantalla\n\n.width/.height: ancho/alto total de la pantalla (resolución)\n.availWidth/.availHeight: igual pero excluyendo la barra del S.O.\n...\n\nEJERCICIO: obtén desde la consola todas las propiedades width/height y availWidth/availHeight del objeto scrren. Compáralas con las propiedades innerWidth/innerHeight y outerWidth/outerHeight de window.",
		"tags": [ "note"]
},

{
		"title": "06-eventos",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/06-eventos/",
		"content": "Eventos\n\nEventos\n\nIntroducción\nCómo escuchar un evento\n\nEvent listeners\n\nTipos de eventos\n\nEventos de página\nEventos de ratón\nEventos de teclado\nEventos de toque\nEventos de formulario\n\nLos objetos this y event\n\nBindeo del objeto this\n\nPropagación de eventos\ninnerHTML y escuchadores de eventos\nDelegación de eventos\nEventos personalizados\n\nIntroducción\nNos permiten detectar acciones que realiza el usuario o cambios que suceden en la página y reaccionar en respuesta a ellas. Existen muchos eventos diferentes (podéis ver la lista en w3schools) aunque nosotros nos centraremos en los más comunes.\nJavascript nos permite ejecutar código cuando se produce un evento (por ejemplo el evento click del ratón) asociando al mismo una función. Hay varias formas de hacerlo.\nCómo escuchar un evento\nLa primera manera &quot;estándar&quot; de asociar código a un evento era añadiendo un atributo con el nombre del evento a escuchar (con 'on' delante) en el elemento HTML. Por ejemplo, para ejecutar código al producirse el evento 'click' sobre un botón se escribía:\n&lt;input type=&quot;button&quot; id=&quot;boton1&quot; onclick=&quot;alert('Se ha pulsado');&quot; /&gt;\n\nUna mejora era llamar a una función que contenía el código:\n&lt;input type=&quot;button&quot; id=&quot;boton1&quot; onclick=&quot;clicked()&quot; /&gt;\n\nfunction clicked() {\nalert('Se ha pulsado');\n}\n\nEsto &quot;ensuciaba&quot; con código la página HTML por lo que se creó el modelo de registro de eventos tradicional que permitía asociar a un elemento HTML una propiedad con el nombre del evento a escuchar (con 'on' delante). En el caso anterior:\ndocument.getElementById('boton1').onclick = funnction () {\nalert('Se ha pulsado');\n}\n...\n\nNOTA: hay que tener cuidado porque si se ejecuta el código antes de que se haya creado el botón estaremos asociando la función al evento click de un elemento que aún no existe así que no hará nada. Para evitarlo siempre es conveniente poner el código que atiende a los eventos dentro de una función que se ejecute al producirse el evento load de la ventana. Este evento se produce cuando se han cargado todos los elementos HTML de la página y se ha creado el árbol DOM. Lo mismo habría que hacer con cualquier código que modifique el árbol DOM. El código correcto sería:\nwindow.onload = function() {\ndocument.getElementById('boton1').onclick = function() {\nalert('Se ha pulsado');\n}\n}\n\nEvent listeners\nLa forma recomendada de hacerlo es usando el modelo avanzado de registro de eventos del W3C. Se usa el método addEventListener que recibe como primer parámetro el nombre del evento a escuchar (sin 'on') y como segundo parámetro la función a ejecutar (OJO, sin paréntesis) cuando se produzca:\ndocument.getElementById('boton1').addEventListener('click', pulsado);\n...\nfunction pulsado() {\nalert('Se ha pulsado');\n})\n\nHabitualmente se usan funciones anónimas ya que no necesitan ser llamadas desde fuera del escuchador:\ndocument.getElementById('boton1').addEventListener('click', function() {\nalert('Se ha pulsado');\n});\n\nSi queremos pasarle algún parámetro a la función escuchadora (cosa bastante poco usual) debemos usar funciones anónimas como escuchadores de eventos:\n\nNOTA: igual que antes debemos estar seguros de que se ha creado el árbol DOM antes de poner un escuchador por lo que se recomienda ponerlos siempre dentro de la función asociada al evento window.onload (o mejor window.addEventListener('load', ...) como en el ejemplo anterior).\nUna ventaja de este método es que podemos poner varios escuchadores para el mismo evento y se ejecutarán todos ellos. Para eliminar un escuchador se usa el método removeEventListener.\ndocument.getElementById('acepto').removeEventListener('click', aceptado);\n\nNOTA: no se puede quitar un escuchador si hemos usado una función anónima, para quitarlo debemos usar como escuchador una función con nombre.\nTipos de eventos\nSegún qué o dónde se produce un evento estos se clasifican en:\nEventos de página\nSe producen en el documento HTML, normalmente en el BODY:\n\nload: se produce cuando termina de cargarse la página. Es útil para hacer acciones que requieran que la página esté cargada\nDOMContentLoaded: se produce cuando se ha cargado el árbol DOM pero no se han cargado imágenes, hojas de estilo, ni subframes. Es el ideal para realizar acciones del DOM sin tener que esperar a que se carguen las imágenes y el CSS\nunload: al destruirse el documento (ej. cerrar)\nbeforeUnload: antes de destruirse (podríamos mostrar un mensaje de confirmación)\nresize: si cambia el tamaño del documento (porque se redimensiona la ventana)\n\nEventos de ratón\nLos produce el usuario con el ratón:\n\nclick / dblclick: cuando se hace click/doble click sobre un elemento\nmousedown / mouseup: al pulsar/soltar cualquier botón del ratón\nmouseenter / mouseleave: cuando el puntero del ratón entra/sale del elemento (tb. podemos usar mouseover/mouseout)\nmousemove: se produce continuamente mientras el puntero se mueva dentro del elemento\n\nNOTA: si hacemos doble click sobre un elemento la secuencia de eventos que se produciría es: mousedown -&gt; mouseup -&gt; click -&gt; mousedown -&gt; mouseup -&gt; click -&gt; dblclick\n\nEJERCICIO: Pon un escuchador desde la consola al botón 1 de la página de ejemplo de DOM para que al hacer click se muestre el un alert con 'Click sobre botón 1'. Ponle otro para que al pasar el ratón sobre él se muestre 'Entrando en botón 1'.\n\nEventos de teclado\nLos produce el usuario al usar el teclado:\n\nkeydown: se produce al presionar una tecla y se repite continuamente si la tecla se mantiene pulsada\nkeyup: cuando se deja de presionar la tecla\nkeypress: acción de pulsar y soltar (sólo se produce en las teclas alfanuméricas)\n\nNOTA: el orden de secuencia de los eventos es:\nkeyDown -&gt; keyPress -&gt; keyUp\nEventos de toque\nSe producen al usar una pantalla táctil:\n\ntouchstart: se produce cuando se detecta un toque en la pantalla táctil\ntouchend: cuando se deja de pulsar la pantalla táctil\ntouchmove: cuando un dedo es desplazado a través de la pantalla\ntouchcancel: cuando se interrumpe un evento táctil.\n\nEventos de formulario\nSe producen en los formularios:\n\nfocus / blur: al obtener/perder el foco el elemento\nchange: al perder el foco un &lt;input&gt; o &lt;textarea&gt; si ha cambiado su contenido o al cambiar de valor un &lt;select&gt; o un &lt;checkbox&gt;\ninput: al cambiar el valor de un &lt;imput&gt; o &lt;textarea&gt; (se produce cada vez que escribimos una letra es estos elementos)\nselect: al cambiar el valor de un &lt;select&gt; o al seleccionar texto de un &lt;imput&gt; o &lt;textarea&gt;\nsubmit / reset: al enviar/recargar un formulario\n\nLos objetos this y event\nAl producirse un evento se generan automáticamente en su función manejadora 2 objetos:\n\nthis: siempre hace referencia al elemento que contiene el código en donde se encuentra la variable this. En el caso de una función escuchadora será el elemento que tiene el escuchador que ha recibido el evento\nevent: es un objeto y la función escuchadora lo recibe como parámetro. Tiene propiedades y métodos que nos dan información sobre el evento, como:\n\n.type: qué evento se ha producido (click, submit, keyDown, ...)\n.target: el elemento donde se produjo el evento (puede ser this o un descendiente de this, como en el ejemplo siguiente)\n.currentTarget: el elemento que contiene el escuchador del evento lanzado (normalmente el mismo que this). Por ejemplo si tenemos un al que le ponemos un escuchador de 'click' que dentro tiene un elemento , si hacemos click sobre el event.target será el que es donde hemos hecho click (está dentro de ) pero tanto como event.currentTarget será (que es quien tiene el escuchador que se está ejecutando).\n.relatedTarget: en un evento 'mouseover' event.target es el elemento donde ha entrado el puntero del ratón y event.relatedTarget el elemento del que ha salido. En un evento 'mouseout' sería al revés.\n.cancelable: si el evento puede cancelarse. En caso afirmativo se puede llamar a event.preventDefault() para cancelarlo\n.preventDefault(): si un evento tiene un escuchador asociado se ejecuta el código de dicho escuchador y después el navegador realiza la acción que correspondería por defecto al evento si no tuviera escuchador (por ejemplo un escuchador del evento click sobre un hiperenlace hará que se ejecute su código y después saltará a la página indicada en el href del hiperenlace). Este método cancela la acción por defecto del navegador para el evento. Por ejemplo si el evento era el submit de un formulario éste no se enviará o si era un click sobre un hiperenlace no se irá a la página indicada en él.\n.stopPropagation: un evento se produce sobre un elemento y todos su padres. Por ejemplo si hacemos click en un &lt;span&gt; que está en un &lt;p&gt; que está en un &lt;div&gt; que está en el BODY el evento se va propagando por todos estos elementos y saltarían los escuchadores asociados a todos ellos (si los hubiera). Si alguno llama a este método el evento no se propagará a los demás elementos padre.\ndependiento del tipo de evento tendrá más propiedades:\n\neventos de ratón:\n\n.button: qué botón del ratón se ha pulsado (0: izq, 1: rueda; 2: dcho).\n.screenX / .screenY: las corrdenadas del ratón respecto a la pantalla\n.clientX / .clientY: las coordenadas del ratón respecto a la ventana cuando se produjo el evento\n.pageX / .pageY: las coordenadas del ratón respecto al documento (si se ha hecho un scroll será el clientX/Y más el scroll)\n.offsetX / .offsetY: las coordenadas del ratón respecto al elemento sobre el que se produce el evento\n.detail: si se ha hecho click, doble click o triple click\n\neventos de teclado: son los más incompatibles entre diferentes navegadores. En el teclado hay teclas normales y especiales (Alt, Ctrl, Shift, Enter, Tab, flechas, Supr, ...). En la información del teclado hay que distinguir entre el código del carácter pulsado (e=101, E=69, €=8364) y el código de la tecla pulsada (para los 3 caracteres es el 69 ya que se pulsa la misma tecla). Las principales propiedades de event son:\n\n.key: devuelve el nombre de la tecla pulsada\n.which: devuelve el código de la tecla pulsada\n.keyCode / .charCode: código de la tecla pulsada y del carácter pulsado (según navegadores)\n.shiftKey / .ctrlKey / .altKey / .metaKey: si está o no pulsada la tecla SHIFT / CTRL / ALT / META. Esta propiedad también la tienen los eventos de ratón\n\nNOTA: a la hora de saber qué tecla ha pulsado el usuario es conveniente tener en cuenta:\n\npara saber qué carácter se ha pulsado lo mejor usar la propiedad key o charCode de keyPress, pero varía entre navegadores\npara saber la tecla especial pulsada mejor usar el key o el keyCode de keyUp\ncaptura sólo lo que sea necesario, se producen muchos eventos de teclado\npara obtener el carácter a partir del código: String fromCharCode(codigo);\n\nLo mejor para familiarizarse con los diferentes eventos es consultar los ejemplos de w3schools.\n\nEJERCICIO: Pon desde la consola un escuchador al BODY de la página de ejemplo para que al mover el ratón en cualquier punto de la ventana del navegador, se muestre en algún sitio (añade un DIV o un P al HTML) la posición del puntero respecto del navegador y respecto de la página.\n\nEJERCICIO: Pon desde la consola un escuchador al BODY de la página de ejemplo para que al pulsar cualquier tecla nos muestre en un alert el key y el keyCode de la tecla pulsada. Pruébalo con diferentes teclas\n\nBindeo del objeto this\nEn ocasiones no queremos que this sea el elemento sobre quien se produce el evento sino que queremos conservar el valor que tenía antes de entrar a la función escuchadora. Por ejemplo la función escuchadora es un método de una clase en this tenemos el objeto de la clase sobre el que estamos actuando pero al entrar en la función perdemos esa referencia.\nEl método .bind() nos permite pasarle a una función el valor que queremos darle a la variable this dentro de dicha función. Por defecto a una función escuchadora de eventos se le bindea le valor de event.currentTarget. Si queremos que tenga otro valor se lo indicamos con .bind():\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(variable));\n\nEn este ejemplo el valor de this dentro de la función aceptado será variable. En el ejemplo que habíamos comentado de un escuchador dentro de una clase, para mantener el valor de this y que haga referencia al objeto sobre el que estamos actuando haríamos:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(this));\n\npor lo que el valor de this dentro de la función aceptado será el mismo que tenía fuera, es decir, el objeto.\nPodemos bindear, es decir, pasarle a la función escuchadora más variables declarándolas como parámetros de bind. El primer parámetro será el valor de this y los demás serán parámetros que recibirá la función antes de recibir el parámetro event que será el último. Por ejemplo:\ndocument.getElementById('acepto').removeEventListener('click', aceptado.bind(var1, var2, var3));\n...\nfunction aceptado(param1, param2, event) {\n// Aquí dentro tendremos los valores\n// this = var1\n// param1 = var2\n// param2 = var3\n// event es el objeto con la información del evento producido\n}\n\nPropagación de eventos\nNormalmente en una página web los elementos HTML se solapan unos con otros, por ejemplo, un &lt;span&gt; está en un &lt;p&gt; que está en un &lt;div&gt; que está en el &lt;body&gt;. Si ponemos un escuchador del evento click a todos ellos se ejecutarán todos ellos, pero ¿en qué orden?.\nPues el W3C establecíó un modelo en el que primero se disparan los eventos de fuera hacia dentro (primero el &lt;body&gt;) y al llegar al más interno (el &lt;span&gt;) se vuelven a disparar de nuevo pero de dentro hacia afuera. La primera fase se conoce como fase de captura y la segunda como fase de burbujeo (bubbling). Cuando ponemos un escuchador con addEventListener el tercer parámetro indica en qué fase debe dispararse:\n\ntrue: en fase de captura\nfalse (valor por defecto): en fase de burbujeo\n\nPor tanto, por defecto se disparará el escuchador más interno (el del &lt;span&gt;) y continuará el resto hasta el más externo (&lt;body&gt;) como si fuera una burbuja que sale afuera desde el interior.\nPodéis ver un ejemplo en:\n\nSin embargo si al método .addEventListener le pasamos un tercer parámetro con el valor true el comportamiento será el contrario, lo que se conoce como captura y el primer escuchador que se ejecutará es el del &lt;body&gt; y el último el del &lt;span&gt; (podéis probarlo añadiendo ese parámetro a los escuchadores del ejemplo anterior).\nEn cualquier momento podemos evitar que se siga propagando el evento ejecutando el método .stopPropagation() en el código de cualquiera de los escuchadores.\nPodéis ver las distintas fases de un evento en la página domevents.dev.\ninnerHTML y escuchadores de eventos\nSi cambiamos la propiedad innerHTML de un elemento del árbol DOM todos sus escuchadores de eventos desaparecen ya que es como si se volviera a crear ese elemento (y los escuchadores deben ponerse después de crearse).\nPor ejemplo, tenemos una tabla de datos y queremos que al hacer doble click en cada fila se muestre su id. La función que añade una nueva fila podría ser:\nfunction renderNewRow(data) {\nlet miTabla = document.getElementById('tabla-datos');\nlet nuevaFila = `&lt;tr id=&quot;${data.id}&quot;&gt;&lt;td&gt;${data.dato1}&lt;/td&gt;&lt;td&gt;${data.dato2}...&lt;/td&gt;&lt;/tr&gt;`;\nmiTabla.innerHTML += nuevaFila;\ndocument.getElementById(data.id).addEventListener('dblclick', event =&gt; alert('Id: '+ event.target.id));\n\nSin embargo esto sólo funcionaría para la última fila añadida ya que la línea miTabla.innerHTML += nuevaFila equivale a miTabla.innerHTML = miTabla.innerHTML + nuevaFila. Por tanto estamos asignando a miTabla un código HTML que ya no contiene escuchadores, excepto el de nuevaFila que lo ponemos después de hacer la asignación.\nLa forma correcta de hacerlo sería:\nfunction renderNewRow(data) {\nlet miTabla = document.getElementById('tabla-datos');\nlet nuevaFila = document.createElement('tr');\nnuevaFila.id = data.id;\nnuevaFila.innerHTML = `&lt;td&gt;${data.dato1}&lt;/td&gt;&lt;td&gt;${data.dato2}...&lt;/td&gt;`;\nnuevaFila.addEventListener('dblclick', event =&gt; alert('Id: ' + event.target.id) );\nmiTabla.appendChild(nuevaFila);\n\nDe esta forma además mejoramos el rendimiento ya que el navegador sólo tiene que renderizar el nodo correspondiente a la nuevaFila. Si lo hacemos como estaba al principio se deben volver a crear y a renderizar todas las filas de la tabla (todo lo que hay dentro de miTabla).\nDelegación de eventos\nEs un patrón de diseño que nos permite no tener que poner un escuchador a cada elemento sino uno global que haga el trabajo de todos.\nPor ejemplo si queremos escuchar cuándo hacemos click en cada celda de la tabla en lugar de poner un escuchador en cada una (que podría tener cientos) pongo sólo 1 en la tabla y mediante la propiedad event.target puede saber sobre qué celda en concreto se ha hecho click. Esto además seguirá funcionando si dinámicamente añado nuevas celdas a la tabla ya que no son ellas las que tienen el escuchador sino la propia tabla.\nNOTA: ten en cuenta que a veces el evento se produce en alguna etiqueta interna y event.target no es el elemento que buscamos. Por ejemplo si hay una imagen en la celda el event.target podría ser la &lt;img&gt; y no la &lt;td&gt;. Para asegurarnos de llegar al elemento deseado podemos usar el selector closest() que vimos en el DOM.\nPodéis ver más ejemplos de delegación de eventos en El Tutorial de JavaScript Moderno.\nEventos personalizados\nTambién podemos mediante código lanzar manualmente cualquier evento sobre un elemento con el método dispatchEvent() e incluso crear eventos personalizados, por ejemplo:\nconst event = new Event('build');\n\n// Listen for the event.\nelem.addEventListener('build', (e) =&gt; { /* ... */ });\n\n// Dispatch the event.\nelem.dispatchEvent(event);\n\nIncluso podemos añadir datos al objeto event si creamos el evento con new CustomEvent(). Podéis obtener más información en la página de MDN.",
		"tags": [ "note"]
},

{
		"title": "07-globales",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/07-globales/",
		"content": "Objetos nativos\n\nObjetos nativos\n\nIntroducción\nFunciones globales\nObjetos nativos del lenguaje\nObjeto Math\nObjeto Date\n\nIntroducción\nEn este tema vamos a ver las funciones globales de Javascript (muchas de las cuales ya hemos visto como Number() o String()) y los objetos nativos que incorpora Javascript y que nos facilitarán el trabajo proporcionándonos métodos y propiedades útiles para no tener que &quot;reinventar la rueda&quot; en nuestras aplicaciones. Dentro de ellos está el objeto RegExpr que nos permite trabajar con expresiones regulares (son iguales que en otros lenguajes) que nos serán de gran ayuda, sobre todo a la hora de validar formularios y que por eso veremos en la siguiente unidad.\nFunciones globales\n\nparseInt(valor): devuelve el valor pasado como parámetro convertido a entero o NaN si no es posible la conversión. Este método es mucho más permisivo que Number y convierte cualquier cosa que comience por un número (si encuentra un carácter no numérico detiene la conversión y devuelve lo convertido hasta el momento). Ejemplos:\n\nconsole.log( parseInt(3.84) ) // imprime 3 (ignora los decimales)\nconsole.log( parseInt('3.84') ) // imprime 3\nconsole.log( parseInt('28manzanas') ) // imprime 28\nconsole.log( parseInt('manzanas28') ) // imprime NaN\n\nparseFloat(valor): igual pero devuelve un número decimal. Ejemplos:\n\nconsole.log( parseFloat(3.84) ) // imprime 3.84\nconsole.log( parseFloat('3.84') ) // imprime 3.84\nconsole.log( parseFloat('3,84') ) // imprime 3 (la coma no es un carácter numérico)\nconsole.log( parseFloat('28manzanas') ) // imprime 28\nconsole.log( parseFloat('manzanas28') ) // imprime NaN\n\nNumber(valor): convierte el valor a un número. Es como parseFloat pero más estricto y si no puede convertir todo el valor devuelve NaN. Ejemplos:\n\nconsole.log( Number(3.84) ) // imprime 3.84\nconsole.log( Number('3.84') ) // imprime 3.84\nconsole.log( Number('3,84') ) // imprime NaN (la coma no es un carácter numérico)\nconsole.log( Number('28manzanas') ) // imprime NaN\nconsole.log( Number('manzanas28') ) // imprime NaN\n\nString(valor): convierte el valor pasado a una cadena de texto. Si le pasamos un objeto llama al método .toString() del objeto. Ejemplos:\n\nconsole.log( String(3.84) ) // imprime '3.84'\nconsole.log( String([24, 3. 12]) ) // imprime '24,3,12'\nconsole.log( {nombre: 'Marta', edad: 26} ) // imprime &quot;[object Object]&quot;\n\nBoolean(valor): convierte el valor pasado a un booleano. Sería el resultado de tenerlo como condición en un if. Muchas veces en vez de usar esto usamos la doble negación !! que da el mismo resultado. Ejemplos:\n\nconsole.log( Boolean('Hola') ) // Equivaldría a !!'Hola'. Imprime true\nconsole.log( Boolean(0) ) // Equivaldría a !!0. Imprime false\n\nisNaN(valor): devuelve true si lo pasado NO es un número o no puede convertirse en un número. Ejemplos:\n\nconsole.log( isNaN(3.84) ) // imprime false\nconsole.log( isNaN('3.84') ) // imprime false\nconsole.log( isNaN('3,84') ) // imprime true (la coma no es un carácter numérico)\nconsole.log( isNaN('28manzanas') ) // imprime true\nconsole.log( isNaN('manzanas28') ) // imprime true\n\nisFinite(valor): devuelve false si es número pasado es infinito (o demasiado grande)\n\nconsole.log( isFinite(3.84) ) // imprime true\nconsole.log( isFinite(3.84 / 0) ) // imprime false\n\nencodeURI(string) / decodeURI(string): transforma la cadena pasada a una URL codificada válida transformando los caracteres especiales que contenga, excepto , / ? : @ &amp; = + $ #. Debemos usarla siempre que vayamos a pasar una URL. Ejemplo:\n\nDecoded: “http://domain.com?val=1 2 3&amp;val2=r+y%6&quot;\nEncoded: “http://domain.com?val=1 2 3&amp;val2=r+y%256”\n\nencodeURIComponent(string) / decodeURIComponent(string): transforma también los caracteres que no transforma la anterior. Debemos usarla para codificar parámetros pero no una URL entera. Ejemplo:\n\nDecoded: “http://domain.com?val=1 2 3&amp;val2=r+y%6&quot;\nEncoded: “http%3A%2F%2Fdomain.com%3Fval%3D1%202%203%26val2%3Dr%2By%256”\n\nObjetos nativos del lenguaje\nEn Javascript casi todo son objetos. Ya hemos visto diferentes objetos:\n\nwindow\nscreen\nnavigator\nlocation\nhistory\ndocument\n\nLos 5 primeros se corresponden al modelo de objetos del navegador (BOM, Browser Object Model) y document se corresponde al modelo de objetos del documento (DOM, Document Object Model, ya lo hemos visto). Todos nos permiten interactuar con el navegador para realizar distintas acciones.\nPero además tenemos los tipos de objetos nativos, que no dependen del navegador. Son:\n\nNumber\nString\nBoolean\nArray\nFunction\nObject\nMath\nDate\nRegExp\n\nAdemás de los tipos primitivos de número, cadena, booleano, undefined y null, Javascript tiene todos los objetos indicados. Como vimos se puede crear un número usando su tipo primitivo (const num = 5) o su objeto (const num = new Number(5)) pero es mucho más eficiente usar los tipos primitivos. Pero aunque lo creemos usando el tipo de dato primitivo se considera un objeto y tenemos acceso a todas sus propiedades y métodos (num.toFixed(2)).\nYa hemos visto las principales propiedades y métodos de Number, String, Boolean y Array y aquí vamos a ver las de Math y Date y en el apartado de validar formularios las de RegExp.\nObjeto Math\nProporciona constantes y métodos para trabajar con valores numéricos:\n\nconstantes: .PI (número pi), .E (número de Euler), .LN2 (algoritmo natural en base 2), .LN10 (logaritmo natural en base 10), .LOG2E (logaritmo de E en base 2), .LOG10E (logaritmo de E en base 10), .SQRT2 (raíz cuadrada de 2), .SQRT1_2 (raíz cuadrada de 1⁄2). Ejemplos:\n\nconsole.log( Math.PI ) // imprime 3.141592653589793\nconsole.log( Math.SQRT2 ) // imprime 1.4142135623730951\n\nMath.round(x): redondea x al entero más cercano\nMath.floor(x): redondea x hacia abajo (5.99 → 5. Quita la parte decimal)\nMath.ceil(x): redondea x hacia arriba (5.01 → 6)\nMath.min(x1,x2,...): devuelve el número más bajo de los argumentos que se le pasan.\nMath.max(x1,x2,...): devuelve el número más alto de los argumentos que se le pasan.\nMath.pow(x, y): devuelve x y (x elevado a y).\nMath.abs(x): devuelve el valor absoluto de x.\nMath.random(): devuelve un número decimal aleatorio entre 0 (incluido) y 1 (no incluido). Si queremos un número entre otros rangos haremos Math.random() * (max - min) + min o si lo queremos sin decimales Math.round(Math.random() * (max - min) + min)\nMath.cos(x): devuelve el coseno de x (en radianes).\nMath.sin(x): devuelve el seno de x.\nMath.tan(x): devuelve la tangente de x.\nMath.sqrt(x): devuelve la raíz cuadrada de x\n\nEjemplos:\nconsole.log( Math.round(3.14) ) // imprime 3\nconsole.log( Math.round(3.84) ) // imprime 4\nconsole.log( Math.floor(3.84) ) // imprime 3\nconsole.log( Math.ceil(3.14) ) // imprime 4\nconsole.log( Math.sqrt(2) ) // imprime 1.4142135623730951\n\nObjeto Date\nEs la clase que usaremos siempre que vayamos a trabajar con fechas. Al crear una instancia de la clase le pasamos la fecha que queremos crear o lo dejamos en blanco para que nos cree la fecha actual. Si le pasamos la fecha podemos pasarle:\n\nmilisegundos, desde la fecha EPOCH\ncadena de fecha (en formato AAAA-MM-DD o MM-DD-AAAA)\nvalor para año, mes (entre 0 y 11), día, hora, minutos, segundos, milisegundos\n\nEjemplos:\nconst date1=new Date() // Mon Jul 30 2018 12:44:07 GMT+0200 (CEST) (es cuando he ejecutado la instrucción)\nconst date7=new Date(1532908800000) // Mon Jul 30 2018 00:00:00 GMT+0200 (CEST) (miliseg. desde 1/1/1070)\nconst date2=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST) (la fecha pasada a las 0h. GMT)\nconst date3=new Date('2018-07-30 05:30') // Mon Jul 30 2018 05:30:00 GMT+0200 (CEST) (la fecha pasada a las 05:300h. local)\nconst date6=new Date('30-07-2018') // Mon Jul 30 2018 00:00:00 GMT+0200 (CEST) (OJO: formato MM-DD-AAAA)\nconst date6=new Date('07-30-2018') // Invalid date\nconst date7=new Date('30-Jul-2018') // Mon Jul 30 2018 00:00:00 GMT+0200 (CEST) (tb. podemos poner 'July')\nconst date4=new Date(2018,7,30) // OJO: Thu Ago 30 2018 00:00:00 GMT+0200 (CEST) (OJO: 0-&gt;Ene,1-&gt;Feb... y a las 0h. local)\nconst date5=new Date(2018,7,30,5,30) // OJO: Thu Ago 30 2018 05:30:00 GMT+0200 (CEST) (OJO: 0-&gt;Ene,1-&gt;Feb,...)\n\nEJERCICIO: Crea en la consola dos variables fecNac1 y fecNac2 que contengan tu fecha de nacimiento. La primera la creas pasandole una cadena y la segunda pasándole año, mes y día\n\nCuando ponemos la fecha como texto, como separador de las fechas podemos usar -, / o espacio. Como separador de las horas debemos usar :. Cuando ponemos la fecha cono parámetros numéricos (separados por ,) podemos poner valores fuera de rango que se sumarán al valor anterior. Por ejemplo:\nconst date=new Date(2018,7,41) // Mon Sep 10 2018 00:00:00 GMT+0200 (CEST) -&gt; 41=31Ago+10\nconst date=new Date(2018,7,0) // Tue Jul 31 2018 00:00:00 GMT+0200 (CEST) -&gt; 0=0Ago=31Jul (el anterior)\nconst date=new Date(2018,7,-1) // Mon Jul 30 2018 00:00:00 GMT+0200 (CEST) -&gt; -1=0Ago-1=31Jul-1=30Jul\n\nOJO con el rango de los meses que empieza en 0-&gt;Ene, 1-&gt;Feb,...,11-&gt;Dic\nTenemos métodos getter y setter para obtener o cambiar los valores de una fecha:\n\nfullYear: permite ver (get) y cambiar (set) el año de la fecha:\n\nconst fecha=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)\nconsole.log( fecha.getFullYear() ) // imprime 2018\nfecha.setFullYear(2019) // Tue Jul 30 2019 02:00:00 GMT+0200 (CEST)\n\nmonth: devuelve/cambia el número de mes, pero recuerda que 0-&gt;Ene,...,11-&gt;Dic\n\nconst fecha=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)\nconsole.log( fecha.getMonth() ) // imprime 6\nfecha.setMonth(8) // Mon Sep 30 2019 02:00:00 GMT+0200 (CEST)\n\ndate: devuelve/cambia el número de día:\n\nconst fecha=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)\nconsole.log( fecha.getDate() ) // imprime 30\nfecha.setDate(-2) // Thu Jun 28 2018 02:00:00 GMT+0200 (CEST)\n\nday: devuelve el número de día de la semana (0-&gt;Dom, 1-&gt;Lun, ..., 6-&gt;Sáb). Este método NO tiene setter:\n\nconst fecha=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)\nconsole.log( fecha.getDay() ) // imprime 1\n\nhours, minutes, seconds, milliseconds, : devuelve/cambia el número de la hora, minuto, segundo o milisegundo, respectivamente.\ntime: devuelve/cambia el número de milisegundos desde Epoch (1/1/1970 00:00:00 GMT):\n\nconst fecha=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)\nconsole.log( fecha.getTime() ) // imprime 1532908800000\nfecha.setTime(1000*60*60*24*25) // Fri Jan 02 1970 01:00:00 GMT+0100 (CET) (le hemos añadido 25 días a Epoch)\n\nEJERCICIO: Realiza en la consola los siguientes ejercicios (usa las variables que creaste antes)\n\nmuestra el día de la semana en que naciste\nmodifica fecNac1 para que contenga la fecha de tu cumpleaños de este año (cambia sólo el año)\nmuestra el día de la semana de tu cumpleaños de este año\ncalcula el nº de días que han pasado desde que naciste hasta hoy\n\nPara mostrar la fecha tenemos varios métodos diferentes:\n\n.toString(): &quot;Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)&quot;\n.toUTCString(): &quot;Mon, 30 Jul 2018 00:00:00 GMT&quot;\n.toDateString(): &quot;Mon, 30 Jul 2018&quot;\n.toTimeString(): &quot;02:00:00 GMT+0200 (hora de verano de Europa central)&quot;\n.toISOString(): &quot;2018-07-30T00:00:00.000Z&quot;\n.toLocaleString(): &quot;30/7/2018 2:00:00&quot;\n.toLocaleDateString(): &quot;30/7/2018&quot;\n.toLocaleTimeString(): &quot;2:00:00&quot;\n\nEJERCICIO: muestra en distintos formatos la fecha y la hora de hoy\n\nNOTA: recuerda que las fechas son objetos y que se copian y se pasan como parámetro por referencia:\nconst fecha=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)\nconst otraFecha=fecha\notraFecha.setDate(28) // Thu Jul 28 2018 02:00:00 GMT+0200 (CEST)\nconsole.log( fecha.getDate() ) // imprime 28 porque fecha y otraFecha son el mismo objeto\n\nUna forma sencilla de copiar una fecha es crear una nueva pasándole la que queremos copiar:\nconst fecha=new Date('2018-07-30') // Mon Jul 30 2018 02:00:00 GMT+0200 (CEST)\nconst otraFecha=new Date(fecha)\notraFecha.setDate(28) // Thu Jul 28 2018 02:00:00 GMT+0200 (CEST)\nconsole.log( fecha.getDate() ) // imprime 30\n\nEn realidad lo que le estamos pasando es el tiempo Epoch de la fecha (es como hacer otraFecha=new Date(fecha.getTime()))\nNOTA: la comparación entre fechas funciona correctamente con los operadores &gt;, &gt;=, &lt; y &lt;= pero NO con ==, ===, != y !== ya que compara los objetos y ve que son objetos diferentes. Si queremos saber si 2 fechas son iguales (siendo diferentes objetos) el código que pondremos NO es fecha1 === fecha2 sino fecha1.getTime() === fecha2.getTime().\n\nEJERCICIO: comprueba si es mayor tu fecha de nacimiento o el 1 de enero de este año\n\nPodemos probar los distintos métodos de las fechas en la página de w3schools.",
		"tags": [ "note"]
},

{
		"title": "08-forms",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/08-forms/",
		"content": "Validación de formularios\nÍndice:\n\nValidación de formularios\n\nIntroducción\n\nValidación del navegador incorporada en HTML5\nValidación mediante la API de validación de formularios\n\nEjemplo\n\nyup\n\nExpresiones regulares\n\nPatrones\nMétodos\n\nIntroducción\nEn este tema vamos a ver cómo realizar una de las acciones principales de Javascript que es la validación de formularios en el lado cliente.\nSe trata de una verificación útil porque evita enviar datos al servidor que sabemos que no son válidos pero NUNCA puede sustituir a la validación en el lado servidor ya que en el lado cliente se puede manipular el código desde la consola para que se salte las validaciones que le pongamos.\nPodéis encontrar una guía muy completa de validación de formularios en el lado cliente el la página de MDN web docs que ha servido como base para estos apuntes.\nAdemás, al final de este tema, veremos una pequeña introducción a las expresiones regulares en Javascript.\nBásicamente tenemos 2 maneras de validar un formulario en el lado cliente:\n\nusar la validación incorporada en HTML5 y dejar que sea el navegador quien se encargue de todo\nrealizar nosotros la validación mediante Javascript\n\nLa ventaja de la primera opción es que no tenemos que escribir código sino simplemente poner unos atributos a los INPUT que indiquen qué se ha de validar. La principal desventaja es que no tenemos ningún control sobre el proceso, lo que provocará cosas como:\n\nel navegador valida campo a campo: cuando encuentra un error en un campo lo muestra y hasta que no se soluciona no valida el siguiente lo que hace que el proceso sea molesto para el usuario que no ve todo lo que hay mal de una vez\nlos mensajes son los predeterminados del navegador y en ocasiones pueden no ser muy claros para el usuario\nlos mensajes se muestran en el idioma en que está configurado el navegador, no en el de nuestra página\n\nValidación del navegador incorporada en HTML5\nFunciona añadiendo atributos a los campos del formulario que queremos validar. Los más usados son:\n\nrequired: indica que el campo es obligatorio. La valdación fallará si no hay nada escrito en el input. En el caso de un grupo de radiobuttons se pone sobre cualquiera de ellos (o sobre todos) y obliga a que haya seleccionada una opción cualquiera del grupo\npattern: obliga a que el contenido del campo cumpla la expresión regular indicada. Por ejemplo para un código postal sería pattern=&quot;^[0-9]{5}$&quot;\nminlength / maxlength: indica la longitud mínima/máxima del contenido del campo\nmin / max: indica el valor mínimo/máximo del contenido de un campo numérico\n\nTambién producen errores de validación si el contenido de un campo no se adapta al type indicado (email, number, ...) o si el valor de un campo numérico no cumple con el step indicado.\nCuando el contenido de un campo es valido dicho campo obtiene automáticamente la pseudoclase :valid y si no lo es tendrá la pseudoclase :invalid lo que nos permite poner reglas en nuestro CSS para destacar dichos campos, por ejemplo:\ninput:invalid {\nborder: 2px dashed red;\n}\n\nAdemás de las anteriores tenemos las pseudoclases :required, :optional, que nos permiten poner reglas de estilo a los campos obligatorios o no, y :focus para el campo con el foco.\nLa validación del navegador se realiza al enviar el formulario. Si encuentra un error lo muestra, se detiene la validación del resto de campos y no se envía el formulario.\nValidación mediante la API de validación de formularios\nMediante Javscript tenemos acceso a todos los campos del formulario por lo que podemos hacer la validación como queramos, pero es una tarea pesada, repetitiva y que provoca código spaguetti difícil de leer y mantener más adelante.\nPara hacerla más simple podemos usar la API de validación de formularios de HTML5 que permite que sea el navegador quien se encargue de comprobar la validez de cada campo pero las acciones (mostrar mensajes de error, no enviar el formulario, ...) las realizamos desde Javascript.\nEsto nos da la ventaja de:\n\nlos requisitos de validación de cada campo están como atributos HTML de dicho campo por lo que son fáciles de ver\nnos evitamos la mayor parte del código dedicada a comprobar si el contenido del campo es válido. Nosotros mediante la API sólo preguntamos si se cumplen o no y tomamos las medidas adecuadas\naprovechamos las pseudo-clases :valid o :invalid que el navegador pone automáticamente a los campos por lo que no tenemos que añadirles clases para desacarlos\n\nLas principales propiedades y métodos que nos proporciona esta API son:\n\ncheckValidity(): método booleano que nos dice si el campo al que se aplica es o no válido. También se puede aplicar al formulario para saber si es válido o no\nvalidationMessage: en caso de que un campo no sea válido esta propiedad contiene el texto del error de validación proporcionado por el navegador. Si es válido esta propiedad es una cadena vacía\nsetCustomValidity(mensaje): añade un error personalizado al campo (que ahora ya NO será válido para el navegador) con el mensaje pasado como parámetro. Por ejemplo podemos usarlo para indicar que el nick elegido no es válido porque ya está en uso por otro usuario. Para quitar este error se hace setCustomValidity('')\nvalidity: es un objeto que tiene propiedades booleanas para saber qué requisito del campo es el que falla:\n\nvalueMissing: indica si no se cumple el atributo required (es decir, valdrá true si el campo tiene el atributo required pero no se ha introducido nada en él)\ntypeMismatch: indica si el contenido del campo no cumple con su atributo type (ej. type=&quot;email&quot;)\npatternMismatch: indica si no se cumple con el pattern indicado en su atributo\ntooShort / tooLong: indican si no se cumple el atributo minlength o maxlength respectivamente\nrangeUnderflow / rangeOverflow: indica si no se cumple el atributo min / max\nstepMismatch: indica si no se cumple el atributo step del campo\ncustomError: indica al campo se le ha puesto un error personalizado con setCustomValidity\nvalid: indica si es campo es válido\n\n...\n\nEn la página de W3Schools podéis ver algún ejemplo básico de esto. También a continuación tenéis un ejemplo simple del valor de las diferentes propiedades involucradas en la validación de un campo de texto que es obligatorio y cuyo tamaño debe estar entre 5 y 50 caracteres:\n\nPara validar un formulario nosotros pero usando esta API debemos añadir a la etiqueta &lt;form&gt; el atributo novalidate que hace que no se encargue el navegador de mostrar los mensajes de error ni de decidir si se envía o no el formulario (aunque sí valida los campos) sino que lo haremos nosotros.\nEjemplo\nUn ejemplo sencillo de validación de un formulario podría ser:\n\nindex.html\n\n&lt;form novalidate&gt;\n&lt;label for=&quot;nombre&quot;&gt;Por favor, introduzca su nombre (entre 5 y 50 caracteres): &lt;/span&gt;\n&lt;input type=&quot;text&quot; id=&quot;nombre&quot; name=&quot;nombre&quot; required minlength=&quot;5&quot; maxlength=&quot;50&quot;&gt;\n&lt;span class=&quot;error&quot;&gt;&lt;/label&gt;\n&lt;br /&gt;\n&lt;label for=&quot;mail&quot;&gt;Por favor, introduzca una dirección de correo electrónico: &lt;/label&gt;\n&lt;input type=&quot;email&quot; id=&quot;mail&quot; name=&quot;mail&quot; required minlength=&quot;8&quot;&gt;\n&lt;span class=&quot;error&quot;&gt;&lt;/span&gt;\n&lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;\n&lt;/form&gt;\n\nmain.js\n\nconst form = document.getElementsByTagName('form')[0];\n\nconst nombre = document.getElementById('nombre');\nconst nombreError = document.querySelector('#nombre + span.error');\nconst email = document.getElementById('mail');\nconst emailError = document.querySelector('#mail + span.error');\n\nform.addEventListener('submit', (event) =&gt; {\nif(!form.checkValidity()) {\nevent.preventDefault();\n}\nnombreError.textContent = nombre.validationMessage;\nemailError.textContent = email.validationMessage;\n});\n\nstyle.css\n\n.error {\ncolor: red;\n}\n\ninput:invalid {\nborder: 2px dashed red;\n}\n\nEstamos usando\n\nvalidationMessage para mostrar el posible error de cada campo, o quitar el error cuando el campo sea válido\ncheckValidity() para no enviar/procesar el formulario si contiene errores\n\nSi no nos gusta el mensaje del navegador y queremos personalizarlo podemos hacer una función que reciba un &lt;input&gt; y usando su propiedad validity devuelva un mensaje en función del error detectado:\nfunction customErrorValidationMessage(input) {\nif (input.checkValidity()) {\nreturn ''\n}\nif (input.validity.valueMissing) {\nreturn 'Este campo es obligatorio'\n}\nif (input.validity.tooShort) {\nreturn `Debe tener al menos ${input.minLength} caracteres`\n}\n// Y seguiremos comprobando cada atributo que hayamos usado en el HTML\nreturn 'Error en el campo' // por si se nos ha olvidado comprobar algo\n}\n\nY ahora en vez de nombreError.textContent = nombre.validationMessage haremos nombreError.textContent = customErrorValidationMessage(nombre).\nSi tenemos que validar algo que no puede hacerse mediante atributos HTML (por ejemplo si el nombre de usuario ya está en uso) deberemos hacer la validación &quot;a mano&quot; y en caso de no ser válido ponerle un error con .setCustomValidity(), pero debemos recordar quitar el error si todo es correcto o el formulario siempre será inválido. Modificando el ejemplo:\nconst nombre = document.getElementById('nombre');\nconst nombreError = document.querySelector('#nombre + span.error');\n\nform.addEventListener('submit', (event) =&gt; {\nif (nombreEnUso(nombre.value)) {\nnombre.setCustomValidity('Ese nombre de usuario ya está en uso')\n} else {\nnombre.setCustomValidity('') // Se quita el error personalizado\n}\n\nif(!form.checkValidity()) {\n...\n}\n})\n\nFicheros en formularios\nHay infinidad de páginas donde poder consultar cómo validar ficheros e imágenes en un formulario. Os recomiendo:\n\nCurso DWEC de José Castillo\nw3schools\ndeveloper.mozilla.org.\n\nyup\nExisten múltiples librerías que facilitan enormenmente el tedioso trabajo de validar un formulario. Un ejemplo es yup.\nExpresiones regulares\nLas expresiones regulares permiten buscar un patrón dado en una cadena de texto. Se usan mucho a la hora de validar formularios o para buscar y reemplazar texto. En Javascript se crean poniéndolas entre caracteres / (o instanciándolas de la clase RegExp, aunque es mejor de la otra forma):\nlet cadena='Hola mundo';\nlet expr=/mundo/;\nexpr.test(cadena); // devuelve true porque en la cadena se encuentra la expresión 'mundo'\n\nPatrones\nLa potencia de las expresiones regulares es que podemos usar patrones para construir la expresión. Los más comunes son:\n\n[..] (corchetes): dentro se ponen varios caracteres o un rango y permiten comprobar si el carácter de esa posición de la cadena coincide con alguno de ellos. Ejemplos:\n\n[abc]: cualquier carácter de los indicados ('a' o 'b' o 'c')\n[^abc]: cualquiera excepto los indicados\n[a-z]: cualquier minúscula (el carácter '-' indica el rango entre 'a' y 'z', incluidas)\n[a-zA-Z]: cualquier letra\n\n( | ) (pipe): debe coincidir con una de las opciones indocadas:\n\n(x|y): la letra x o la y (sería equivalente a [xy]\n(http|https): cualquiera de las 2 palabras\n\nMetacaracteres:\n\n. (punto): un único carácter, sea el que sea\n\\d: un dígito (\\D: cualquier cosa menos dígito)\n\\s: espacio en blanco (\\S: lo opuesto)\n\\w: una palabra o carácter alfanumérico (\\W lo contrario)\n\\b: delimitador de palabra (espacio, ppio, fin)\n\\n: nueva línea\n\nCuantificadores:\n\n+: al menos 1 vez (ej. [0-9]+ al menos un dígito)\n*: 0 o más veces\n?: 0 o 1 vez\n{n}: n caracteres (ej. [0-9]{5} = 5 dígitos)\n{n,}: n o más caracteres\n{n,m}: entre n y m caracteres\n^: al ppio de la cadena (ej.: ^[a-zA-Z] = empieza por letra)\n$: al final de la cadena (ej.: [0-9]$ = que acabe en dígito)\n\nModificadores:\n\n/i: que no distinga entre Maysc y minsc (Ej. /html/i = buscará html, Html, HTML, ...)\n/g: búsqueda global, busca todas las coincidencias y no sólo la primera\n/m: busca en más de 1 línea (para cadenas con saltos de línea)\n\nEJERCICIO: contruye una expresión regular para lo que se pide a continuación y pruébala con distintas cadenas:\n\nun código postal\nun NIF formado por 8 números, un guión y una letra mayúscula o minúscula\nun número de teléfono y aceptamos 2 formatos: XXX XX XX XX o XXX XXX XXX. EL primer número debe ser un 6, un 7, un 8 o un 9\n\nMétodos\nLos usaremos para saber si la cadena coincide con determinada expresión o para buscar y reemplazar texto:\n\nexpr.test(cadena): devuelve true si la cadena coincide con la expresión. Con el modificador /g hará que cada vez que se llama busque desde la posición de la última coincidencia. Ejemplo:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/g;\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime false, hay solo dos coincidencias\n\nlet reg2 = /am/gi; // ahora no distinguirá mayúsculas y minúsculas\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true\nconsole.log(reg.test(str)); // Imprime true. Ahora tenemos 3 coincidencias con este nuevo patrón\n\nexpr.exec(cadena): igual pero en vez de true o false devuelve un objeto con la coincidencia encontrada, su posición y la cadena completa:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/gi;\nconsole.log(reg.exec(str)); // Imprime [&quot;am&quot;, index: 2, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime [&quot;am&quot;, index: 5, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime [&quot;Am&quot;, index: 15, input: &quot;I am amazed in America&quot;]\nconsole.log(reg.exec(str)); // Imprime null\n\ncadena.match(expr): igual que exec pero se aplica a la cadena y se le pasa la expresión. Si ésta tiene el modificador /g devolverá un array con todas las coincidencis:\n\nlet str = &quot;I am amazed in America&quot;;\nlet reg = /am/gi;\nconsole.log(str.match(reg)); // Imprime [&quot;am&quot;, &quot;am&quot;, &quot;Am&quot;}\n\ncadena.search(expr): devuelve la posición donde se encuentra la coincidencia buscada o -1 si no aparece\ncadena.replace(expr, cadena2): devuelve una nueva cadena xon las coincidncias de la cadena reemplazadas por la cedena pasada como 2º parámetro:\n\nlet str = &quot;I am amazed in America&quot;;\nconsole.log(str.replace(/am/gi, &quot;xx&quot;)); // Imprime &quot;I xx xxazed in xxerica&quot;\n\nconsole.log(str.replace(/am/gi, function(match) {\nreturn &quot;-&quot; + match.toUpperCase() + &quot;-&quot;;\n})); // Imprime &quot;I -AM- -AM-azed in -AM-erica&quot;\n\nNo vamos a profundizar más sobre las expresiones regulares. Es muy fácil encontrar por internet la que necesitemos en cada caso (para validar un e-mail, un NIF, un CP, ...). Podemos aprender más en:\n\nw3schools\nregular-expressions.info\nhtml5pattern atributo\ny muchas otras páginas\n\nTambién, hay páginas que nos permiten probar expresiones regulares con cualquier texto, como regexr.",
		"tags": [ "note"]
},

{
		"title": "09-ajax",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/09-ajax/",
		"content": "Ajax\n\nAjax\n\nIntroducción\n\nMétodos HTTP\nJson Server\nREST client\n\nEl objeto XMLHttpRequest\n\nEventos de XMLHttpRequest\nEjemplos de envío de datos\n\nEnviar datos al servidor en formato JSON\nEnviar datos al servidor en formato URIEncoded\nEnviar ficheros al servidor con FormData\n\nCallbakcs, Promesas y Async/Await\n\nSi Ajax fuera síncrono...\nSolución mala\nAlgo mejor: Funciones callback\nSolución buena: Promesas\nLa mejor solución: usar Async/Await\n\nfetch\n\nPropiedades y métodos de la respuesta de fetch\nGestión de errores con fetch\nOtros métodos de petición con fetch\n\nHacer varias peticiones simultáneamente. Promise.all\nOrganizar bien el código\n\nEl fichero .env\nDistintas peticiones, distintos ficheros\n\nSingle Page Application\nResumen de llamadas asíncronas\nCORS\n\nIntroducción\nAJAX es el acrónimo de Asynchronous Javascript And XML (Javascript asíncrono y XML) y es lo que usamos para hacer peticiones asíncronas al servidor desde Javascript. Cuando hacemos una petición al servidor no nos responde inmediatamente (la petición tiene que llegar al servidor, procesarse allí y enviarse la respuesta que llegará al cliente).\nLo que significa asíncrono es que la página no permanecerá bloqueada esperando esa respuesta sino que continuará ejecutando su código e interactuando con el usuario, y en el momento en que llegue la respuesta del servidor se ejecutará la función que indicamos al hacer la llamada Ajax. Respecto a XML, es el formato en que se intercambia la información entre el servidor y el cliente, aunque actualmente el formato más usado es JSON que es más simple y legible.\nBásicamente Ajax nos permite poder mostrar nuevos datos enviados por el servidor sin tener que recargar la página, que continuará disponible mientras se reciben y procesan los datos enviados por el servidor en segundo plano.\n\nSin Ajax cada vez que necesitamos nuevos datos del servidor la página deja de estar disponible para el usuario hasta que se recarga con lo que envía el servidor. Con Ajax la página está siempre disponible para el usuario y simplemente se modifica (cambiando el DOM) cuando llegan los datos del servidor:\n\nFuente Uniwebsidad\nMétodos HTTP\nLas peticiones Ajax usan el protocolo HTTP (el mismo que utiliza el navegador para cargar una página). Este protocolo envía al servidor unas cabeceras HTTP (con información como el userAgent del navegador, el idioma, etc), el tipo de petición y, opcionalmente, datos o parámetros (por ejemplo en la petición que procesa un formulario se envían los datos del mismo).\nHay diferentes tipos de petición que podemos hacer:\n\nGET: suele usarse para obtener datos sin modificar nada (equivale a un SELECT en SQL). Si enviamos datos (ej. la ID del registro a obtener) suelen ir en la url de la petición (formato URIEncoded). Ej.: locahost/users/3, https://jsonplaceholder.typicode.com/users o www.google.es?search=js\nPOST: suele usarse para añadir un dato en el servidor (equivalente a un INSERT). Los datos enviados van en el cuerpo de la petición HTTP (igual que sucede al enviar desde el navegador un formulario por POST)\nPUT: es similar al POST pero suele usarse para actualizar datos del servidor (como un UPDATE de SQL). Los datos se envían en el cuerpo de la petición (como en el POST) y la información para identificar el objeto a modificar en la url (como en el GET). El servidor hará un UPDATE sustituyendo el objeto actual por el que se le pasa como parámetro\nPATCH: es similar al PUT pero la diferencia es que en el PUT hay que pasar todos los campos del objeto a modificar (los campos no pasados se eliminan del objeto) mientras que en el PATCH sólo se pasan los campos que se quieren cambiar y en resto permanecen como están\nDELETE: se usa para eliminar un dato del servidor (como un DELETE de SQL). La información para identificar el objeto a eliminar se envía en la url (como en el GET)\nexisten otros tipos que no veremos aquí (como HEAD, PATCH, etc)\n\nEl servidor acepta la petición, la procesa y le envía una respuesta al cliente con el recurso solicitado y además unas cabeceras de respuesta (con el tipo de contenido enviado, el idioma, etc) y el código de estado. Los códigos de estado más comunes son:\n\n2xx: son peticiones procesadas correctamente. Las más usuales son 200 (ok) o 201 (created, como respuesta a una petición POST satisfactoria)\n3xx: son códigos de redirección que indican que la petición se redirecciona a otro recurso del servidor, como 301 (el recurso se ha movido permanentemente a otra URL) o 304 (el recurso no ha cambiado desde la última petición por lo que se puede recuperar desde la caché)\n4xx: indican un error por parte del cliente, como 404 (Not found, no existe el recurso solicitado) o 401 (Not authorized, el cliente no está autorizado a acceder al recurso solicitado)\n5xx: indican un error por parte del servidor, como 500 (error interno del servidor) o 504 (timeout, el servidor no responde).\n\nEn cuanto a la información enviada por el servidor al cliente normalmente serán datos en formato JSON o XML (cada vez menos usado) que el cliente procesará y mostrará en la página al usuario. También podría ser HTML, texto plano, ...\nEl formato JSON es una forma de convertir un objeto Javascript en una cadena de texto para poderla enviar, por ejemplo el objeto\nlet alumno = {\nid: 5,\nnombre: Marta,\napellidos: Pérez Rodríguez\n}\n\nse transformaría en la cadena de texto\n{ &quot;id&quot;: 5, &quot;nombre&quot;: &quot;Marta&quot;, &quot;apellidos&quot;: &quot;Pérez Rodríguez&quot; }\n\ny el array\nlet alumnos = [\n{\nid: 5,\nnombre: &quot;Marta&quot;,\napellidos: &quot;Pérez Rodríguez&quot;\n},\n{\nid: 7,\nnombre: &quot;Joan&quot;,\napellidos: &quot;Reig Peris&quot;\n},\n]\n\nen la cadena:\n[{ &quot;id&quot;: 5, &quot;nombre&quot;: Marta, &quot;apellidos&quot;: Pérez Rodríguez }, { &quot;id&quot;: 7, &quot;nombre&quot;: &quot;Joan&quot;, &quot;apellidos&quot;: &quot;Reig Peris&quot; }]\n\nPara convertir objetos en cadenas de texto JSON y viceversa Javascript proporciona 2 funciones:\n\nJSON.stringify(objeto): recibe un objeto JS y devuelve la cadena de texto correspondiente. Ej.: const cadenaAlumnos = JSON.stringify(alumnos)\nJSON.parse(cadena): realiza el proceso inverso, convirtiendo una cadena de texto en un objeto. Ej.: const alumnos = JSON.parse(cadenaAlumnos)\n\nEJERCICIO: Vamos a realizar diferentes peticions HTTP a la API https://jsonplaceholder.typicode.com, en concreto trabajaremos contra la tabla todos con tareas para hacer. Las peticiones GET podríamos hacerlas directamente desde el navegador pero para el resto debemos instalar alguna de las extensiones de cliente REST en nuestro navegador. Por tanto instalaremos dicha extensión (por ejemplo Advanced Rest Client para Chrome o Rested para Firefox y haremos todas las peticiones desde allí (incluyendo los GET) lo que nos permitirá ver los códigos de estado devueltos, las cabeceras, etc.\nLo que queremos hacer en este ejercicio es:\n\nobtener todas las tareas (devuelve un array con todas las tareas y el código devuelto será 200 - Ok)\n![GET all](/img/user/notas/Javascript Teoria Batoi/img/Ajax-GETall.png)\n\nobtener la tarea con id 55 (devuelve el objeto de la tarea 55 y el código devuelto será 200 - Ok)\n![GET one](/img/user/notas/Javascript Teoria Batoi/img/Ajax-GETone.png)\n\nobtener la tarea con id 201 (como no existe devolverá un objeto vacío y como código de error 404 - Not found)\n![GET Non Existent](/img/user/notas/Javascript Teoria Batoi/img/Ajax-GETnonExistent.png)\n\ncrear una nueva tarea. En el cuerpo de la petición le pasaremos sus datos: userID: 1, title: Prueba de POST y completed: false. No se le pasa la id (de eso se encarga la BBDD). La respuesta debe ser un código 201 (created) y el nuevo registro creado con todos sus datos incluyendo la id. Como es una API de prueba en realidad no lo está añadiendo a la BBDD por lo que si luego hacemos una petición buscando esa id nos dirá que no existe.\n![POST](/img/user/notas/Javascript Teoria Batoi/img/Ajax-POST.png)\n\nmodificar con un PATCH la tarea con id 55 para que su title sea 'Prueba de POST'. Devolverá el nuevo registro con un código 200. Como veis al hacer un PATCH los campos que no se pasan se mantienen como estaban\n![PATCH](/img/user/notas/Javascript Teoria Batoi/img/Ajax-PATCH.png)\n\nmodificar con un PUT la tarea con id 55 para que su title sea 'Prueba de POST'. Devolverá el nuevo registro con un código 200. Como veis en esta API los campos que no se pasan se eliminan; en otras los campos no pasados se mantienen como estaban\n![PUT](/img/user/notas/Javascript Teoria Batoi/img/Ajax-PUT.png)\n\neliminar la tarea con id 55. Como veis esta API devuelve un objeto vacío al eliminar; otras devuelven el objeto eliminado\n![DELETE](/img/user/notas/Javascript Teoria Batoi/img/Ajax-DELETE.png)\n\nJson Server\nLas peticiones Ajax se hacen a un servidor que proporcione una API. Como ahora no tenemos ninguno podemos utilizar Json Server que es un servidor API-REST que funciona bajo Node.js (que ya tenemos instalado para usar NPM) y que utiliza un fichero JSON como contenedor de los datos en lugar de una base de datos.\nPara instalarlo en nuestra máquina (lo instalaremos global para poderlo usar en todas nuestras prácticas) ejecutamos:\nnpm install -g json-server\n\nPara que sirva un fichero datos.json:\njson-server datos.json\n\nLe podemos poner la opción --watch ( o -w) para que actualice los datos si se modifica el fichero .json externamente (si lo editamos).\nEl fichero datos.json será un fichero que contenga un objeto JSON con una propiedad para cada &quot;tabla&quot; de nuestra BBDD. Por ejemplo, si queremos simular una BBDD con las tablas users y posts vacías el contenido del fichero será:\n{\n&quot;users&quot;: [],\n&quot;posts&quot;: []\n}\n\nLa API escucha en el puerto 3000 y servirá los diferentes objetos definidos en el fichero .json. Por ejemplo:\n\nhttp://localhost:3000/users: devuelve un array con todos los elementos de la tabla users del fichero .json\nhttp://localhost:3000/users/5: devuelve un objeto con el elemento de la tabla users cuya propiedad id valga 5\n\nTambién pueden hacerse peticiones más complejas como:\n\nhttp://localhost:3000/users?rol=3: devuelve un array con todos los elementos de users cuya propiedad rol valga 3\n\nPara más información: https://github.com/typicode/json-server.\nSi queremos acceder a la API desde otro equipo (no desde localhost) tenemos que indicar la IP de la máquina que ejecuta json-server y que se usará para acceder, por ejemplo si vamos a ejecutarlo en la máquina 192.168.0.10 pondremos:\njson-server --host 192.168.0.10 datos.json\n\nY la ruta para acceder a la API será http://192.168.0.10:3000.\n\nEJERCICIO: instalar json-server en tu máquina. Ejecútalo indicando un nombre de fichero que no existe: como verás crea un fichero json de prueba con 3 tablas: posts, comments y profiles. Ábrelo en tu navegador para ver los datos\n\nREST client\nPara probar las peticiones GET podemos poner la URL en la barra de direcciones del navegador pero para probar el resto de peticiones debemos instalar en nuestro navegador una extensión que nos permita realizar las peticiones indicando el método a usar, las cabeceras a enviar y los datos que enviaremos a servidor, además de la URL.\nExisten multitud de aplicaciones para realizar peticiones HTTP, como Advanced REST client. Cada navegador tiene sus propias extensiones para hacer esto, como Advanced Rest Client para Chrome o RestClient para Firefox.\nEl objeto XMLHttpRequest\nHasta ahora hemos hecho un repaso a lo que es el protocolo HTTP. Ahora que lo tenemos claro y hemos instalado un servidor que nos proporciona una API (json-server) vamos a realizar peticiones HTTP en nuestro código javascript usando Ajax.\nPara hacer una petición debemos crear una instancia del objeto XMLHttpRequest que es el que controlará todo el proceso. Los pasos a seguir son:\n\nCreamos la instancia del objeto: const peticion=new XMLHttpRequest()\nPara establecer la comunicación con el servidor ejecutamos el método .open() al que se le pasa como parámetro el tipo de petición (GET, POST, ...) y la URL del servidor: peticion.open('GET', 'https://jsonplaceholder.typicode.com/users')\nOPCIONAL: Si queremos añadir cabeceras a la petición HTTP llamaremos al método .setRequestHeader(). Por ejemplo si enviamos datos con POST hay que añadir la cabecera Content-type que le indica al servidor en qué formato van los datos: peticion.setRequestHeader('Content-type', 'application/x-www-form-urlencoded)\nEnviamos la petición al servidor con el método .send(). A este método se le pasa como parámetro los datos a enviar al servidor en el cuerpo de la petición (si es un POST, PUT o PATCH le pasaremos una cadena de texto con los datos a enviar: peticion.send('dato1='+encodeURIComponent(dato1)+'&amp;dato2='+encodeURIComponent(dato2))). Si es una petición GET o DELETE no le pasaremos datos (peticion.send())\nPonemos un escuchador al objeto peticion para saber cuándo está disponible la respuesta del servidor\n\nEventos de XMLHttpRequest\nTenemos diferentes eventos que el servidor envía para informarnos del estado de nuestra petición y que nosotros podemos capturar. El evento readystatechange se produce cada vez que el servidor cambia el estado de la petición. Cuando hay un cambio en el estado cambia el valor de la propiedad readyState de la petición. Sus valores posibles son:\n\n0: petición no iniciada (se ha creado el objeto XMLHttpRequest)\n1: establecida conexión con el servidor (se ha hecho el open)\n2: petición recibida por el servidor (se ha hecho el send)\n3: se está procesando la petición\n4: petición finalizada y respuesta lista (este es el evento que nos interesa porque ahora tenemos la respuesta disponible)\nA nosotros sólo nos interesa cuando su valor sea 4 que significa que ya están los datos. En ese momento la propiedad status contiene el estado de la petición HTTP (200: Ok, 404: Not found, 500: Server error, ...) que ha devuelto el servidor. Cuando readyState vale 4 y status vale 200 tenemos los datos en la propiedad responseText (o responseXML si el servidor los envía en formato XML).\n\nEl siguiente ejemplo nos enseña cómo se producen los distintos eventos en una petición asíncrona:\nconst peticion = new XMLHttpRequest();\nconsole.log(&quot;Estado inicial de la petición: &quot; + peticion.readyState);\npeticion.open('GET', 'https://jsonplaceholder.typicode.com/users');\nconsole.log(&quot;Estado de la petición tras el 'open': &quot; + peticion.readyState);\npeticion.send();\nconsole.log(&quot;Petición hecha&quot;);\npeticion.addEventListener('readystatechange', function() {\nconsole.log(&quot;Estado de la petición: &quot; + peticion.readyState);\nif (peticion.readyState === 4) {\nif (peticion.status === 200) {\nconsole.log(&quot;Datos recibidos:&quot;);\nlet usuarios = JSON.parse(peticion.responseText); // Convertirmos los datos JSON a un objeto\nconsole.log(usuarios);\n} else {\nconsole.log(&quot;Error &quot; + peticion.status + &quot; (&quot; + peticion.statusText + &quot;) en la petición&quot;);\n}\n}\n})\nconsole.log(&quot;Petición acabada&quot;);\n\nEl resultado de ejecutar ese código es el siguiente:\n![Ejemplo 1: consola](/img/user/notas/Javascript Teoria Batoi/img/ajax-ej1.png)\nFijaos cuándo cambia de estado (readyState) la petición:\n\nvale 0 al crear el objeto XMLHttpRequest\nvale 1 cuando abrimos la conexión con el servidor\nluego se envía al servidor y es éste el que va informando al cliente de cuándo cambia su estado\n\nMUY IMPORTANTE: notad que la última línea ('Petición acabada') se ejecuta antes que las de 'Estado de la petición'. Recordad que es una petición asíncrona y la ejecución del programa continúa sin esperar a que responda el servidor.\nComo normalmente no nos interesa cada cambio en el estado de la petición sino que sólo queremos saber cuándo ha terminado de procesarse tenemos otros eventos que nos pueden ser de utilidad:\n\nload: se produce cuando se recibe la respuesta del servidor. Equivale a readyState===4. En status tendremos el estado de la respuesta\nerror: se produce si sucede algún error al procesar la petición (de red, de servidor, ...)\ntimeout: si ha transcurrido el tiempo indicado y no se ha recibido respuesta del servidor. Podemos cambiar el tiempo por defecto modificando la propiedad timeout antes de enviar la petición\nabort: si se cancela la petición (se hace llamando al método .abort() de la petición)\nloadend: se produce siempre que termina la petición, independientemente de si se recibe respuesta o sucede algún error (incluyendo un timeout o un abort)\n\nEste es un ejemplo de código que sí podríamos usar para este tipo de peticiones:\nconst peticion=new XMLHttpRequest();\npeticion.open('GET', 'https://jsonplaceholder.typicode.com/users');\npeticion.send();\npeticion.addEventListener('load', function() {\nif (peticion.status===200) {\nlet usuarios=JSON.parse(peticion.responseText);\n// procesamos los datos que tenemos en usuarios\n} else {\nmuestraError(peticion);\n}\n})\npeticion.addEventListener('error', muestraError);\npeticion.addEventListener('abort', muestraError);\npeticion.addEventListener('timeout', muestraError);\n\nfunction muestraError(peticion) {\nif (peticion.status) {\nconsole.log(&quot;Error &quot;+peticion.status+&quot; (&quot;+peticion.statusText+&quot;) en la petición&quot;);\n} else {\nconsole.log(&quot;Ocurrió un error o se abortó la conexión&quot;);\n}\n}\n\nRecuerda que tratamos con peticiones asíncronas por lo que tras la línea\npeticion.addEventListener('load', function() {\n\nno se ejecuta la línea siguiente\nif (peticion.status===200) {\n\nsino la de\npeticion.addEventListener('error', muestraError);\n\nUna petición asíncrona es como pedir una pizza: tras llamar por teléfono lo siguiente no es ir a la puerta a recogerla sino que seguimos haciendo cosas por casa y cuando suena el timbre de casa entonces vamos a la puerta a por ella.\nEjemplos de envío de datos\nPodemos enviar datos al servidor en el cuerpo de la petición http. Siempre deberemos indicar en una cabecera de la petición en qué formato enviamos los datos y en función de dicho formato se hace la petición de diferente manera.\nVamos a ver algunos ejemplos de envío de datos al servidor con POST. Supondremos que tenemos una página con un formulario para dar de alta nuevos productos:\n&lt;form id=&quot;addProduct&quot;&gt;\n&lt;label for=&quot;name&quot;&gt;Nombre: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;descrip&quot;&gt;Descripción: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;descrip&quot; id=&quot;descrip&quot; required&gt;&lt;br&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Añadir&lt;/button&gt;\n&lt;/form&gt;\n\nEnviar datos al servidor en formato JSON\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst newProduct={\nname: document.getElementById(&quot;name&quot;).value,\ndescrip: document.getElementById(&quot;descrip&quot;).value,\n}\nconst peticion=new XMLHttpRequest();\npeticion.open('POST', 'https://localhost/products');\npeticion.setRequestHeader('Content-type', 'application/json'); // Siempre tiene que estar esta línea si se envían datos\npeticion.send(JSON.stringify(newProduct)); // Hay que convertir el objeto a una cadena de texto JSON para enviarlo\npeticion.addEventListener('load', function() {\n// procesamos los datos\n...\n})\n})\n\nPara enviar el objeto hay que convertirlo a una cadena JSON con la función JSON.stringify(). Siempre que enviamos datos al servidor debemos decirle el formato que tienen en la cabecera de Content-type:\npeticion.setRequestHeader('Content-type', 'application/json');\n\nEnviar datos al servidor en formato URIEncoded\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst name=document.getElementById(&quot;name&quot;).value;\nconst descrip=document.getElementById(&quot;descrip&quot;).value;\n\nconst peticion=new XMLHttpRequest();\npeticion.open('GET', 'https://localhost/products');\npeticion.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\npeticion.send('name='+encodeURIComponent(name)+'&amp;descrip='+encodeURIComponent(descrip));\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nEn este caso los datos se envían como hace el navegador por defecto en un formulario. Recordad siempre codificar lo que introduce el usuario para evitar problemas con caracteres no estándar y ataques SQL Injection u otros.\nEnviar ficheros al servidor con FormData\nFormData es una interfaz de XMLHttpRequest que permite construir fácilmente pares de clave=valor para enviar los datos de un formulario. Se envían en el mismo formato en que se enviarían directamente desde un formulario (&quot;multipart/form-data&quot;) por lo que no hay que poner encabezado de 'Content-type'.\nDe esta manera podemos enviar ficheros al servidor, no sólo valores de texto.\nVamos a añadir al formulario un campo donde el usuario pueda subir la foto del producto:\n&lt;form id=&quot;addProduct&quot;&gt;\n&lt;label for=&quot;name&quot;&gt;Nombre: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;descrip&quot;&gt;Descripción: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;descrip&quot; id=&quot;descrip&quot; required&gt;&lt;br&gt;\n&lt;label for=&quot;photo&quot;&gt;Fotografía: &lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;photo&quot; id=&quot;photo&quot; required&gt;&lt;br&gt;\n\n&lt;button type=&quot;submit&quot;&gt;Añadir&lt;/button&gt;\n&lt;/form&gt;\n\nPodemos enviar al servidor todo el contenido del formulario:\ndocument.getElementById('addProduct').addEventListener('submit', (event) =&gt; {\n...\nconst peticion=new XMLHttpRequest();\nconst datosForm = new FormData(document.getElementById('addProduct'));\n// Automáticamente ha añadido todos los inputs, incluyendo tipo 'file', blob, ...\n// Si quisiéramos añadir algún dato más haríamos:\nformData.append('otrodato', 12345);\n// Y lo enviamos\npeticion.open('POST', 'https://localhost/products');\npeticion.send(datosForm);\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nTambién podemos enviar sólo los campos que queramos:\ndocument.getElementById('addProduct').addEEventListener('submit', (event) =&gt; {\n...\nconst formData=new FormData(); // creamos un formData vacío\nformData.append('name', document.getElementById('name').value);\nformData.append('descrip', document.getElementById('descrip').value);\nformData.append('photo', document.getElementById('photo').files[0]);\n\nconst peticion=new XMLHttpRequest();\npeticion.open('POST', 'https://localhost/products');\npeticion.send(formData);\npeticion.addEventListener('load', function() {\n...\n})\n})\n\nPodéis ver más información de cómo usar formData en MDN web docs.\nCallbakcs, Promesas y Async/Await\nPara ver un ejemplo real de cómo e haría una llamada a Ajax vamos a hacer una página que muestre en una tabla los posts del usuario indicado en un input. En resumen lo que hacemos es:\n\nEl usuario de nuestra aplicación introduce el código del usuario del que queremos ver sus posts\nTenemos un escuchador para que al introducir un código de un usuario llamamos a una función getPosts() que:\n\nSe encarga de hacer la petición Ajax al servidor\nSi se produce un error se encarga de informar al usuario de nuestra aplicación\n\nCuando se reciben los datos del servidor deben pintarse en la tabla\n\nSi Ajax fuera síncrono...\nSi Ajax no fuera una petición asíncrona el código de todo esto será algo como el siguiente (ATENCIÓN, este código NO FUNCIONA):\n\nPero esto no funciona porque el valor de posts siempre es undefined. Esto es porque cuando se llama a getPosts esta función no devuelve nada (por eso posts es undefined) sino que devuelve los datos tiempo después, cuando el servidor contesta, pero entonces ya no hay nadie escuchando.\nSolución mala\nLa solución es que todo el código, no sólo de la petición Ajax sino también el de qué hacer con los datos cuando llegan, se encuentre en la función que pide los datos al servidor:\n\nEste código sí que funcionaría pero tiene una pega: tenemos que tratar los datos (en este caso pintarlos en la tabla) en la función que gestiona la petición porque es la que sabe cuándo están disponibles esos datos. Y sabemos que una función no debería tener 2 responsabilidades diferentes (obtener los datos del servidor y renderizarlos en la página).\nAlgo mejor: Funciones callback\nEsto se podría mejorar usando una función callback. La idea es que creamos una función que procese los datos (renderPosts) y se la pasamos a getPosts para que la llame cuando tenga los datos:\n\nHemos creado una función que se ocupa de renderizar los datos y se la pasamos a la función que gestiona la petición para que la llame cuando los datos están disponibles. Utilizando la función callback hemos conseguido que getPosts() se encargue sólo de obtener los datos y cuando los tenga los pasa a la encargada de pintarlos en la tabla.\nSolución buena: Promesas\nSin embargo hay una forma más limpia de resolver una función asíncrona y que el código se parezca al primero que hicimos que no funcionaba, donde la función getPosts() sólo debía ocuparse de obtener los datos y devolverlos a quien se los pidió. Ese código era:\n...\nlet idUser = document.getElementById('id-usuario').value;\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número');\n} else {\nconst posts = getPosts(idUser);\n// y aquí usamos los datos recibidos, en este caso para pintar los posts\n}\n...\n\nComo dijimos esto NO funciona, a menos que convirtamos a getPosts() en una promesa. Cuando se realiza una llamada a una promesa quien la llama puede usar unos métodos (.then() y .catch()) que NO SE EJECUTARÁN hasta que la promesa se haya resuelto (es decir, hasta que el servidor haya contestado):\n\n.then(_function(datos) { ... }_): se ejecuta cuando la promesa se haya resuelto satisfactoriamente. Su parámetro es una función que recibe como parámetro los datos que haya devuelto la promesa (que serán los datos pedidos al servidor)\n.catch(function(datos) { ... }): se ejecuta cuando se haya rechazado la promesa (si ha fallado, normalmente porque se ha recibido una respuesta errónea del servidor). Esta función recibe como parámetro la información pasada por la promesa al ser rechazada (que será información sobre el error producido).\n\nDe esta manera nuestro código quedaría:\n...\nlet idUser = document.getElementById('id-usuario').value\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número')\n} else {\ngetPosts(idUser)\n.then((posts) =&gt; { // aquí ya tenemos los datos en 'posts'\ntbody.innerHTML = ''\nposts.forEach((post) =&gt; {\nconst newPost = document.createElement('tr')\nnewPost.innerHTML = `\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;`\ntbody.appendChild(newPost)\n})\ndocument.getElementById('num-posts').textContent = posts.length\n})\n// en el .catch() está el tratamiento de errores\n.catch((error) =&gt; console.error(error))\n}\n\nPara convertir a getPosts() en una promesa sólo tenemos que &quot;envolverla&quot; en la instrucción\nreturn new Promise((resolve, reject) =&gt; {\n// Aquí el contenido de GetPosts()\n})\n\nEsto hace que devuelva un objeto de tipo Promise (return new Promise()) cuyo parámetro es una función que recibe 2 parámetros:\n\nresolve: función callback a la que se llamará cuando se resuelva la promesa satisfactoriamente\nreject: función callback a la que se llamará si se resuelve la promesa con errores\n\nEl funcionamiento es:\n\ncuando la promesa se resuelva satisfactoriamente getPosts llama a la función resolve() y le pasa los datos recibidos por el servidor. Esto hace que se ejecute el método then de la llamada a la promesa que recibirá como parámetro esos datos\nsi se produce algún error se rechaza la promesa llamando a la función reject() y pasando como parámetro la información del fallo producido y esto hará que se ejecute el .catch en la función que llamó a la promesa\n\nPor tanto nuestra función getPosts ahora quedará así:\nfunction getPosts(idUser) {\nreturn new Promise((resolve, reject) =&gt; {\nconst peticion = new XMLHttpRequest();\npeticion.open('GET', SERVER + '/posts?userId=' + idUser);\npeticion.send();\npeticion.addEventListener('load', () =&gt; {\nif (peticion.status === 200) {\nresolve(JSON.parse(peticion.responseText));\n} else {\nreject(&quot;Error &quot; + peticion.status + &quot; (&quot; + peticion.statusText + &quot;) en la petición&quot;);\n}\n})\npeticion.addEventListener('error', () =&gt; reject('Error en la petición HTTP'));\n})\n}\n\nFijaos que el único cambio es la primera línea donde convertimos nuestra función en una promesa, y que luego para &quot;devolver&quot; los datos en lugar de hacer un return, que ya hemos visto que no funciona, se hace un resolve si todo ha ido bien o un reject si ha fallado.\nDesde donde llamamos a la promesa nos suscribimos a ella usando los métodos .then() y .catch() que hemos visto anteriormente.\nBásicamente lo que nos van a proporcionar las promesas es un código más claro y mantenible ya que el código a ejecutar cuando se obtengan los datos asíncronamente estará donde se piden esos datos y no en una función escuchadora o en una función callback.\nUtilizando promesas vamos a conseguir que la función que pide los datos sea quien los obtiene y los trate o quien informa si hay un error.\nEl código del ejemplo de los posts usando promesas sería el siguiente:\n\nNOTA: Fijaos que los errores del servidor SIEMPRE llegan a la consola. En el ejemplo anterior me aparecerán 2 veces: la primera que es el error original y la segunda donde lo pinto yo con el console.error.\nPodéis consultar aprender más en MDN web docs.\nLa mejor solución: usar Async/Await\nLas promesas son una mejora respecto a los callbacks pero aún así el código puede ser difícil de leer y mantener. Para solucionar esto se introdujeron en ES2017 las palabras reservadas async y await que permiten escribir código asíncrono de una manera más clara y sencilla.\nLa palabra reservada async se pone delante de una función e indica que esa función va a devolver una promesa. La palabra reservada await se pone delante de una llamada a una promesa y le indica a Javascript que espere a que esa promesa se resuelva antes de continuar con la ejecución del código.\nUsando esto sí funcionaría el primer ejemplo que hicimos:\nlet idUser = document.getElementById('id-usuario').value;\nif (isNaN(idUser) || idUser == '') {\nalert('Debes introducir un número');\n} else {\nconst posts = await getPosts(idUser);\n// y aquí SÍ recibimos los datos porque ponemos AWAIT, en este caso para pintar los posts\n}\n\nY la función getPosts() quedaría igual que la que hicimos con promesas.\nAquí el tratamiento de errores se hace con un try/catch:\ntry {\nconst posts = await getPosts(idUser);\n} catch (error) {\nconsole.error(error);\n}\n\nUsando async/await nuestro código se asemeja a un código síncrono ya que no continuan ejecutándose las instrucciones que hay después de un await hasta que esa petición se ha resuelto. Podemos anteponer un await a cualquier llamada a una función asíncrona, como una promesa, un setTimeout, ...\nCualquier función que realice un await pasa a ser asíncrona ya que no se ejecuta al instante toda ella sino que se espera un tiempo. Para indicarlo debemos anteponer la palabra async a su declaración function. Al hacer esto automáticamente se &quot;envuelve&quot; esa función en una promesa (o sea que esa función pasa a devolver una promesa, a la que podríamos ponerle un await o un .then()).\nPodéis ver algunos ejemplos del uso de async / await en la página de MDN.\nfetch\nComo el código a escribir para hacer una petición Ajax es largo y siempre igual, la API Fetch permite realizar una petición Ajax genérica que directamente devuelve una promesa.\nBásicamente lo que hace es encapsular en una función todo el código que se repite siempre en una petición AJAX (crear la petición, hacer el open, el send, escuchar los eventos, ...). La función fetch se similar a la función getPosts que hemos creado antes pero genérica para que sirva para cualquier petición pasándole la URL. Lo que internamente hace es algo similar a:\nfunction fetch(url) {\nreturn new Promise((resolve, reject) =&gt; {\nconst peticion = new XMLHttpRequest();\npeticion.open('GET', url);\npeticion.send();\npeticion.addEventListener('load', () =&gt; {\nresolve(peticion.responseText);\n})\npeticion.addEventListener('error', () =&gt; reject('Network Error'));\n})\n}\n\nFijaos en 2 cosas que cambian respecto a nuestra función getPosts():\n\nfetch devuelve los datos &quot;en crudo&quot; por lo que si la respuesta está en formato JSON habrá con convertirlos. Para ello dispone de un método (.json()) que hace el JSON.parse. Este método devuelve una nueva promesa a la que nos suscribimos con un nuevo .then. Ejemplo.:\n\nfetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser)\n.then(response =&gt; response.json()) // los datos son una cadena JSON\n.then(myData =&gt; { // ya tenemos los datos en _myData_ como un objeto o array\n// Aquí procesamos los datos (en nuestro ejemplo los pintaríamos en la tabla)\nconsole.log(myData)\n})\n.catch(err =&gt; console.error(err));\n\nEse mismo ejemplo usando async/await sería:\ntry {\nconst response = await fetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser);\nconst myData = await response.json();\nconsole.log(myData);\n} catch (err) {\nconsole.error(err);\n}\n\nfetch llama a resolve siempre que el servidor conteste, sin comprobar si la respuesta es de éxito (200, 201, ...) o de error (4xx, 5xx). Por tanto siempre se ejecutará el then excepto si se trata de un error de red y el servidor no responde\n\nPropiedades y métodos de la respuesta de fetch\nLa respuesta devuelta por fetch() tiene las siguientes propiedades y métodos:\n\nstatus: el código de estado devuelto por el servidor (200, 404, ...)\nstatusText: el texto correspondiente a ese código (Ok, Not found, ...)\nok: booleano que vale true si el status está entre 200 y 299 y false en caso contrario\njson(): devuelve una promesa que se resolverá con los datos de la respuesta convertidos a un objeto (les hace un JSON.parse())\notros métodos para convertir los datos según el formato que tengan: text(), blob(), formData(), ... Todos devuelven una promesa con los datos de distintos formatos convertidos.\n\nEl ejemplo que hemos visto con las promesas, usando fetch quedaría:\n\nEste ejemplo fallaría si hubiéramos puesto mal la url: contestaría con un 404 pero se ejecutaría el then intentando pintar unos posts que no tenemos.\nEl ejemplo con async/await y fetch sería:\n\nGestión de errores con fetch\nSegún MDN la promesa devuelta por la API fetch sólo es rechazada en el caso de un error de red, es decir, el .catch sólo saltará si no hemos recibido respuesta del servidor; en caso contrario la promesa siempre es resuelta.\nPor tanto para saber si se ha resuelto satisfactoriamente o no debemos comprobar la propiedad .ok de la respuesta. El código correcto del ejemplo anterior gestionando los posibles errores del servidor sería:\ntry {\nconst response = await fetch('https://jsonplaceholder.typicode.com/posts?userId=' + idUser);\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst myData = await response.json();\nconsole.log(myData);\n} catch (err) {\nconsole.error(err);\n}\n\nEn este caso si la respuesta del servidor no es ok lanzamos un error que es interceptado por nuestro propio catch\nOtros métodos de petición con fetch\nLos ejemplos anteriores hacen peticiones GET al servidor. Para peticiones que no sean GET la función fetch() admite un segundo parámetro con un objeto con la información a enviar en la petición HTTP. Ej.:\nfetch(url, {\nmethod: 'POST', // o 'PUT', 'GET', 'DELETE'\nbody: JSON.stringify(data), // los datos que enviamos al servidor en el 'send'\nheaders:{\n'Content-Type': 'application/json'\n}\n}).then(...)\n\nEjemplo de una petición para añadir datos:\nfetch(url, {\nmethod: 'POST',\nbody: JSON.stringify(data), // los datos que enviamos al servidor en el 'send'\nheaders:{\n'Content-Type': 'application/json'\n}\n})\n.then(response =&gt; {\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nreturn response.json()\n})\n.then(datos =&gt; {\nalert('Datos recibidos')\nconsole.log(datos)\n})\n.catch(err =&gt; {\nalert('Error en la petición HTTP: ' + err.message);\n})\n\nPodéis ver mś ejemplos en MDN web docs y otras páginas.\nHacer varias peticiones simultáneamente. Promise.all\nEn ocasiones necesitamos hacer más de una petición al servidor. Por ejemplo para obtener los productos y sus categorías podríamos hacer:\nfunction getData() {\ngetTable('/categories')\n.then((categories) =&gt; categories.forEach((category) =&gt; renderCategory(category)))\n.catch((error) =&gt; renderErrorMessage(error))\ngetTable('/products')\n.then((products) =&gt; products.forEach((product) =&gt; renderProduct(product)))\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\nfunction getTable(table) {\nreturn new Promise((resolve, reject) =&gt; {\nfetch(SERVER + table)\n.then(response =&gt; {\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nreturn response.json()\n})\n.then((data) =&gt; resolve(data))\n.catch((error) =&gt; reject(error))\n})\n}\n\nPero si para renderizar los productos necesitamos tener las categorías este código no nos lo garantiza ya que el servidor podría devolver antes los productos aunque los pedimos después.\nUna solución sería no pedir los productos hasta tener las categorías:\nfunction getData() {\ngetTable('/categories')\n.then((categories) =&gt; {\ncategories.forEach((category) =&gt; renderCategory(category))\ngetTable('/products')\n.then((products) =&gt; products.forEach((product) =&gt; renderProduct(product)))\n.catch((error) =&gt; renderErrorMessage(error))\n})\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\npero esto hará más lento nuestro código al no hacer las 2 peticiones simultáneamente. La solución es usar el método Promise.all() al que se le pasa un array de promesas a hacer y devuelve una promesa que:\n\nse resuelve en el momento en que todas las promesas se han resuelto satisfactoriamente o\nse rechaza en el momento en que alguna de las promesas es rechazada\n\nEl código anterior de forma correcta sería:\nfunction getData() {\nPromise.all([\ngetTable('/categories')\ngetTable('/products')\n])\n.then(([categories, products]) =&gt; {\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n})\n.catch((error) =&gt; renderErrorMessage(error))\n}\n\nLo mismo pasa si en vez de promesas usamos async/await. Si hacemos:\nasync function getTable(table) {\nconst response = await fetch(SERVER + table)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync function getData() {\nconst responseCategories = await getTable('/categories');\nconst responseProducts = await getTable('/products');\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n}\n\ntenemos el problema de que no comienza la petición de los productos hasta que se reciben las categorías. La solución con Promise.all() sería:\nasync function getData() {\nconst [categories, products] = await Promise.all([\ngetTable('/categories')\ngetTable('/products')\n])\ncategories.forEach((category) =&gt; renderCategory(category))\nproducts.forEach((product) =&gt; renderProduct(product))\n}\n\nOrganizar bien el código\nEl fichero .env\nEn los ejemplos anteriores estamos guardando la URL a la que hacer la petición a la API en una constante a la que estamos llamando SERVER. Esto plantea algunos problemas:\n\nsi tenemos varios ficheros que hacen peticiones a la API deberemos declararla en todos ellos\nsi cambia hay que cambiarla en todos los ficheros y en ese caso tenemos que cambiar nuestro código\n\nPara evitarlo podemos almacenar ete tipo de cosas en el fichero .env. Se trata de un fichero donde guardar las configuraciones de la aplicación, como la URL de la API.\nPor medio de Vite podemos acceder a todas las variables de .env que comiencen por VITE_ por medio del objeto import.meta.env por lo que en nuestro código en vez de darle el valor a SERVER podríamos haber puesto:\nconst SERVER = import.meta.env.VITE_URL_API\n\nY en el fichero .env ponemos\nVITE_URL_API=http://localhost:3000\n\nEl fichero .env por defecto se sube al repositorio por lo que no debemos poner información sensible (como usuarios o contraseñas). Para ello tenemos un fichero .env.local que no se sube, o bien debemos añadir al .gitignore dicho fichero. Si el fichero con la configuración no lo subimos al repositorio es conveniente tener un fichero .env.exemple, que sí se sube, con valores predeterminados para las distintas variables, que quien quiera desplegar nuestra aplicación deberá cambiar por sus valores adecuados en producción. Además del .env y el .env.local también hay distintos ficheros que son usados en desarrollo (.env.development) y en producción (.env.production) y que pueden tener distintos datos según el entorno en que nos encontramos. Por ejemplo en el de desarrollo el valor de VITE_URL_API podría ser &quot;http://localhost:3000&quot; si usamos json-server mientras que en el de producción tendríamos la ruta del servidor de producción de la API.\nDistintas peticiones, distintos ficheros\nLas peticiones a la API deberíamos ponerlas en un fichero aparte para tener nuestro código organizado. Y peticiones a diferentes tipos de datos también deberían estar en ficheros diferentes. Por ejemplo si necesitamos obtener datos de posts y de usuarios podríamos crear una carpeta /repositories y dentro los ficheros posts.repository.js y users.repository.js.\nDentro de cada fichero haremos diferentes funciones y métodos para los diferentes tipos de petición, por ejemplo:\nconst SERVER = import.meta.env.VITE_URL_API\n\nasync getAllPosts() {\nconst response = await fetch(SERVER + '/posts')\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync getPostById(idPost) {\nconst response = await fetch(SERVER + `/posts/${idPost}`)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync insertPost(newPost) {\nconst response = await fetch(SERVER + '/posts', {\nmethod: 'POST',\nbody: JSON.stringify(newPost),\nheaders:{\n'Content-Type': 'application/json'\n}\n})\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nexport {\ngetAllPosts,\ngetPostById,\ninsertPost\n}\n\nY donde necesitemos los datos haremos:\nimport { getAllPosts } from &quot;../repositories/posts.repositories&quot;\n\nconst posts = await getAllPosts()\n\nUsando clases el ejemplo quedaría:\nconst SERVER = import.meta.env.VITE_URL_API\n\nexport default class PostsRepository {\nasync getAllPosts() {\nconst response = await fetch(SERVER + '/posts')\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync getPostById(idPost) {\nconst response = await fetch(SERVER + `/posts/${idPost}`)\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n\nasync insertPost(newPost) {\nconst response = await fetch(SERVER + '/posts', {\nmethod: 'POST',\nbody: JSON.stringify(newPost),\nheaders:{\n'Content-Type': 'application/json'\n}\n})\nif (!response.ok) {\nthrow `Error ${response.status} de la BBDD: ${response.statusText}`\n}\nconst data = await response.json()\nreturn data\n}\n}\n\nY donde necesitemos los datos haremos:\nimport PostsRepository from &quot;../repositories/posts.repositories&quot;\n\nconst repository = new PostsRepository()\nconst posts = await repository.getAllPosts()\n\nSingle Page Application\nAjax es la base para construir SPAs que permiten al usuario interactuar con una aplicación web como si se tratara de una aplicación de escritorio (sin &quot;esperas&quot; que dejen la página en blanco o no funcional mientras se recarga desde el servidor).\nEn una SPA sólo se carga la página de inicio (es la única página que existe) que se va modificando y cambiando sus datos como respuesta a la interacción del usuario. Para obtener los nuevos datos se realizan peticiones al servidor (normalmente Ajax). La respuesta son datos (JSON, XML, …) que se muestran al usuario modificando mediante DOM la página mostrada (o podrían ser trozos de HTML que se cargan en determinadas partes de la página, o ...).\nResumen de llamadas asíncronas\nUna llamada Ajax es un tipo de llamada asíncrona que podemos hacer en Javascript aunque hay muchas más, como un setTimeout() o las funciones manejadoras de eventos. Como hemos visto, para la gestión de las llamadas asíncronas tenemos varios métodos y los más comunes son:\n\nfunciones callback (no recomendado)\npromesas\nasync / await\nlibrerías, como axios\n\nCuando se produce una llamada asíncrona el orden de ejecución del código no es el que vemos en el programa ya que el código de respuesta de la llamada no se ejecutará hasta completarse esta. Podemos ver un ejemplo de esto extraído de todoJS usando funciones callback.\nAdemás, si hacemos varias llamadas tampoco sabemos el qué orden se ejecutarán sus respuestas ya que depende de cuándo el servidor finalice cada una, como podemos ver en este otro ejemplo.\nSi usamos funciones callback y necesitamos que cada función no se ejecute hasta que haya terminado la anterior debemos llamarla en la respuesta a la función anterior lo que provoca un tipo de código difícil de leer llamado callback hell.\nPara evitar esto surgieron las promesas que permiten evitar las funciones callback tan difíciles de leer. Podemos ver el primer ejemplo usando promesas. Y si necesitamos ejecutar secuencialmente las funciones evitaremos la pirámide de llamadas callback como vemos en este ejemplo.\nAún así el código no es muy claro. Para mejorarlo surgió async y await como vemos en este ejemplo. Estas funciones forman parte del estándar ES2017 por lo que no están soportadas por navegadores muy antiguos (aunque siempre podemos transpilar con Babel).\nFuente: todoJs: Controlar la ejecución asíncrona\nCORS\nCross-Origin Resource Sharing (CORS) es un mecanismo de seguridad que incluyen los navegadores y que por defecto impiden que se pueden realizar peticiones Ajax desde un navegador a un servidor con un dominio diferente al de la página cargada originalmente.\nSi necesitamos hacer este tipo de peticiones necesitamos que el servidor al que hacemos la petición añada en su respuesta la cabecera Access-Control-Allow-Origin donde indiquemos el dominio desde el que se pueden hacer peticiones (o * para permitirlas desde cualquier dominio).\nEl navegador comprobará las cabeceras de respuesta y si el dominio indicado por ella coincide con el dominio desde el que se hizo la petición, esta se permitirá.\nComo en desarrollo normalmente no estamos en el dominio de producción (para el que se permitirán las peticiones) podemos instalar en el navegador la extensión allow CORS que al activarla deshabilita la seguridad CORS en el navegador.\nPodéis ampliar la información en numerosaas páginas web como &quot;Entendiendo CORS y aplicando soluciones&quot;.",
		"tags": [ "note"]
},

{
		"title": "10-apis",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/10-apis/",
		"content": "APIs HTML5: Drag And Drop. Local Storage. Geolocalización. API de Google Maps\n\nAPIs HTML5: Drag And Drop. Local Storage. Geolocalización. API de Google Maps\n\nIntroducción\nHTML Drag And Drop API\nAlmacenamiento en el cliente: API Storage\n\nA tener en cuenta\nStorage vs cookies\nCookies\n\nGeolocation API\nGoogle Maps API\n\nIntroducción\nEn este tema varemos diferentes APIs incluidas en HTML5 (como la de Local Storage) y otras que se han hecho muy populares como la de Google Maps.\nHTML5 incluye un buen número de APIs que facilitan el trabajo con cosas complejas, como\n\nAPIs para manejo de audio y vídeo\nAPIs para manejo de formularios\nAPI de dibujo canvas (en el módulo de DIW)\n\nAquí comentaremos Storage, Drag&amp;Drop, Geolocation, File Access, Communication, Web Workers, History y Offline\nHTML Drag And Drop API\nCon HTML5 es muy sencillo arrastrar y soltar elementos en una página web. Podemos arrastrar y soltar cualquier nodo DOM (una imagen, un archivo, enlaces, texto seleccionado, ...). Para ello sólo es necesario que ese elemento tenga el atributo dragable=&quot;true&quot;. Si le ponemos false no se podrá arrastrar y si no definimos el atributo podrá o no arrastrarse según el valor predeterminado del navegador (en la mayoría son dragables las imágenes, los links y las selecciones de texto).\nAl arrastrar y soltar intervienen 2 elementos diferentes:\n\nel elemento que estamos arrastrando\nel elemento sobre el cual lo soltamos\n\nPara poder realizar la operación event tiene una propiedad llamada dataTransfer que es un objeto en el que almacenamos qué elemento estamos arrastrando (o cualquier otra cosa que queramos) y así cuando se suelte sobre el elemento destino éste último pueda saber quién se le ha soltado.\nLos pasos para arrastrar y soltar un elemento son:\n\nEl elemento debe ser draggable\nCapturamos el evento dragstart. Este evento se produce sobre un elemento cuando comenzamos a arrastrarlo. Deberemos almacenar en el dataTransfer quién está siendo arrastrado (si no guardamos nada se guarda automáticamente su src si es una imagen o su href si es un enlace). Indicaremos el tipo del dato que estamos almacenando (texto plano, HTML, fichero, etc) y su valor. Ej.:\n\n&lt;img id=&quot;imgGoogle&quot; src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Google.png/320px-Google.png&quot;&gt;\n&lt;div id=&quot;zonaDrop1&quot; class=&quot;drop&quot;&gt;\n&lt;p&gt;Puedes soltar aquí la imagen&lt;/p&gt;\n&lt;/div&gt;\n&lt;div id=&quot;zonaDrop2&quot; class=&quot;drop&quot;&gt;\n&lt;p&gt;Y también aquí&lt;/p&gt;\n&lt;/div&gt;\n\ndocument.getElementById('imgGoogle').addEventListener('dragstart', (event) =&gt; {\nevent.dataTransfer.setData('text/plain', event.target.id); // Estamos guardando el texto 'imgGoogle'\n})\n\nCapturamos el evento dragover. Este evento se produce cada pocas décimas de segundo sobre elemento sobre el que se está arrastrando algo. Por defecto no se puede soltar un elemento en ningún sitio así que capturamos este evento para evitar que el navegador haga la acción por defecto e impida que se suelte lo que estamos arrastrando. Ej.:\n\ndocument.getElementById('zonaDrop1').addEventListener('dragover', (event) =&gt; {\nevent.preventDefault();\n})\ndocument.getElementById('zonaDrop2').addEventListener('dragover', (event) =&gt; {\nevent.preventDefault();\n})\n\nCapturamos el evento drop. Este evento se produce sobre elemento sobre el que se suelta lo que estábamos arrastrando. Lo que haremos es evitar el comportamiento por defecto del navegador (que en caso de imágenes o enlaces es cargarlos en la página), obtener quién se ha soltado a partir del objeto dataTransfer y realizar lo que queramos, que normalmente será añadir el objeto arrastrado como hijo del objeto sobre el que se ha hecho el drop. Ej.:\n\ndocument.getElementById('zonaDrop1').addEventListener('drop', (event) =&gt; {\nevent.preventDefault();\nconst data=event.dataTransfer.getData(&quot;text/plain&quot;); // Obtenemos ìmgGoogle'\nevent.target.appendChild(document.getElementById(data));\n})\ndocument.getElementById('zonaDrop2').addEventListener('drop', (event) =&gt; {\nevent.preventDefault();\nconst data=event.dataTransfer.getData(&quot;text/plain&quot;); // Obtenemos ìmgGoogle'\nevent.target.appendChild(document.getElementById(data));\n})\n\nPodéis ver el funcionamiento de este ejemplo:\n\nNOTA: si hacemos draggable un elemento, por ejemplo un párrafo, ya no se puede seleccionar con el ratón ya que al pinchar y arrastrar se mueve, no se selecciona. Para poder seleccionarlo debemos pinchar y arrastrar el ratón con las teclas Ctrl+Alt pulsadas o hacerlo con el teclado. Ejemplo:\n\nPodemos obtener más información de esta API MDN web docs.\n\nEJERCICIO: mira y modifica el ejemplo de w3schools para entender bien el funcionamiento del Drag&amp;Drop (ten en cuenta que en vez de .addEventListener() las llamadas a los escuchadores están puestas como atributos del HTML pero el funcionamiento es el mismo).\n\nAlmacenamiento en el cliente: API Storage\nAntes de HTML5 la única manera que tenían los programadores de guardar algo en el navegador del cliente (como sus preferencias, su idioma predeterminado para nuestra web, etc) era utilizando cookies. Las cookies tienen muchas limitaciones y es engorroso trabajar con ellas.\nHTML5 incorpora la API de Storage para subsanar esto. Además existen otros métodos de almacenamiento en el cliente más avanzados como IndexedDB (es un estándar del W3C pero aún con poco soporte entre los navegadores).\nEl funcionamiento de la API Storage es muy sencillo: dentro del objeto window tendremos los objetos localStorage y sessionStorage donde podremos almacenar información en el espacio de almacenamiento local (5 o 10 MB por sitio web según el navegador, que es mucho más de lo que teníamos con las cookies). La principal diferencia entre ellos es que la información almacenada en localStorage nunca expira, permanece allí hasta que la borremos (nosotros o el usuario) mientras que la almacenada en sessionStorage se elimina automáticamente al cerrar la sesión el usuario.\nSólo los navegadores muy antiguos (Internet Explorer 7 y anteriores) no soportan esta característica. Puedo saber si el navegador soporta o no esta API simplemente mirando su typeof:\nif (typeof(Storage) === 'undefined') // NO está soportado\n\nTanto localStorage como sessionStorage son como un objeto global al que tengo acceso desde el código. Lo que puedo hacer con ellos es:\n\nGuardar un dato: localStorage.setItem('dato', 'valor') o también localStorage.dato = 'valor'\nRecuperar un dato: let miDato=localStorage.getItem('dato') o también let miDato = localStorage.dato\nBorrar datos: localStorage.removeItem('dato') para borrar 'dato'. Si quiero borrar TODO lo que tengo localStorage.clear()\nSaber cuántos datos tenemos: localStorage.length\n\nSólo podemos guardar objetos primitivos (cadenas, números, ...) por lo que si queremos guardar un objeto o un array hay que convertirlo a una cadena JSON con localStorage.setItem('dato', JSON.stringify('objeto')). Para recuperar el objeto haremos let miObjeto = JSON.parse(localStorage.getItem('dato')).\nCada vez que cambia la información que tenemos en nuestro localStorage se produce un evento storage. Si, por ejemplo, queremos que una ventana actualice su información si otra cambia algún dato del storage haremos:\nwindow.addEventListener(&quot;storage&quot;, actualizaDatos);\n\ny la función 'actualizaDatos' podrá leer de nuevo lo que hay y actuar en consecuencia.\n\nEJERCICIO: comprueba qué tienes almacenado en el localStorage y el sessionStorage de tu navegador. Guarda y recupera algunas variables. Luego cierra el navegador y vuelve a abrir la página. ¿Están las variables guardadas en localStorage? ¿Y las de sessionStorage?\n\nPuedes ver un ejemplo en este vídeo de cómo almacenar en el Storage datos del usuario.\nA tener en cuenta\nlocalStorage, sessionStorage y cookies almacenan información en un navegador específico del cliente, y por tanto:\n\nNo podemos asegurar que permanece ahí\nPuede ser borrada/manipulada\nPuede ser leída, por lo que NO es adecuada para almacenar información sensible pero sí para preferencias del usuario, marcadores de juegos, etc\n\nPodríamos usar localStorage para almacenar localmente los datos con los que trabaja una aplicación web. Así conseguiríamos minimizan los accesos al servidor y que la velocidad de la aplicación sea mucho mayor al trabajar con datos locales. Pero periódicamente debemos sincronizar la información con el servidor.\nStorage vs cookies\nVentajas de localStorage:\n\n5 o 10 MB de almacenamiento frente a 4 KB de las cookies\nTodas las cookies del dominio se envían al servidor con cada petición al mismo lo que aumenta el tráfico innecesariamente\n\nVentajas de las cookies:\n\nSoportadas por navegadores muy antiguos\nLas cookies ofrecen algo de protección frente a XSS (Cross-Site Scripting) y Script injection\n\nCookies\nSon pequeños ficheros de texto y tienen las siguientes limitaciones:\n\nMáximo 300 cookies, si hay más se borran las antiguas\nMáximo 4 KB por cookie, si nos pasamos se truncará\nMáximo 20 cookies por dominio\n\nCada cookie almacena los siguientes datos:\n\nNombre de la cookie (obligatorio)\nValor de la misma\nexpires: timestamp en que se borrará (si no pone nada se borra al salir del dominio)\nmax-age: en lugar de expires podemos indicar aquí los segundos que durará la cookie antes de expirar\npath: ruta desde dónde es accesible (/: todo el dominio, /xxx: esa carpeta y subcarpetas). Si no se pone nada sólo lo será desde la carpeta actual\ndomain: dominio desde el que es accesible. Si no ponemos nada lo será desde este dominio y sus subdominios\nsecure: si aparece indica que sólo se enviará esta cookie con https\n\nUn ejemplo de cookie sería:\nusername=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC;\n\nSe puede acceder a las cookies desde document.cookie que es una cadena con las cookies de nuestras páginas. Para trabajar con ellas conviene que creemos funciones para guardar, leer o borrar cookies, por ejemplo:\n\nCrear una nueva cookie\n\nfunction setCookie(cname, cvalue, cexpires, cpath, cdomain, csecure) {\ndocument.cookie = cname + '=' + cvalue +\n(cexpires?';expires='+cexpires.toUTCString():'') +\n(cpath?';path='+cpath:'') +\n(cdomain?';domain='+cdomain:'') +\n(csecure?';secure':'')\n}\n\nLeer una cookie\n\nfunction getCookie(cname) {\nif(document.cookie.length &gt; 0){\nstart = document.cookie.indexOf(cname + '=')\nif (start != -1) { // Existe la cookie, busquemos dónde acaba su valor\n//El inicio de la cookie, el nombre de la cookie mas les simbolo '='\nstart = start + nombre.length + 1\n//Buscamos el final de la cookie (es el simbolo ';')\nend = document.cookie.indexOf(';', start + cname.length + 1)\nif (end === -1) { // si no encuentra el ; es que es la última cookie\nend = document.cookie.length;\n}\nreturn document.cookie.substring(start + cname.length + 1, end)\n}\n}\nreturn '' // Si estamos aquí es que no hemos encontrado la cookie\n}\n\nBorrar una cookie\n\nfunction delCookie(cname) {\nreturn document.cookie = cname + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;'\n}\n\nPodéis ver en este vídeo un ejemplo de cómo trabajar con cookies, aunque como ya hemos dicho lo recomendable es trabajar con Storage.\nGeolocation API\nEsta API permite a la aplicación web acceder a la localización del usuario si éste da su permiso. Muchos navegadores sólo permiten usarlo en páginas seguras (https).\nPodemos acceder a esta API mediante el objeto geolocation de navigator. Para saber si nuestro navegador soporta o no la API podemos hacer:\nif (geolocation in navigator) // devuelve true si está soportado\n\nPara obtener la posición este objeto proporciona el método navigator.geolocation.getCurrentPosition() que hace una petición asíncrona. Cuando se reciba la posición se ejecutará la función callback que pasemos como parámetro y que recibirá las coordenadas de la localización. Podemos pasar otra como segundo parámetro que se ejecutará si se produce algú error y que recibirá un objeto con la propiedad code que indica el error producido. Ej.:\nnavigator.geolocation.getCurrentPosition(\n(position) =&gt; {\npinta_posicion(position.coords.latitude, position.coords.longitude)\n},\n(error) =&gt; {\nswitch(error.code) {\ncase error.PERMISSION_DENIED: // El usuario no autoriza al navegador a acceder a la localización\nmsg = 'El usuario ha denegado la petición de geolocalización'\nbreak\ncase error.POSITION_UNAVAILABLE: // No se puede obtener la localización\nmsg = 'La información de localización no está disponible.'\nbreak\ncase error.TIMEOUT: // Ha expirado el tiempo para obtener la localización\nmsg = 'Ha expirado el tiempo para obtener la localización'\nbreak\ncase error.UNKNOWN_ERROR:\nmsg = 'Se ha producido un error desconocido.'\nbreak\n}\nmuestra_error(msg)\n}\n)\n\nSi queremos ir obteniendo continuamente la posición podemos usar el método .watchPosition() que tiene los mismos parámetros y funciona igual pero se ejecuta repetidamente. Este método devuelve un identificador para que lo podemos detener cuando queremos con .clearWatch(ident). Ej.:\nconst watchIdent = navigator.geolocation.watchPosition(\n(position) =&gt; pinta_posicion(position.coords.latitude, position.coords.longitude),\n(error) =&gt; muestra_error(error)\n)\n...\n// Cuando queremos dejar de obtener la posición haremos\nnavigator.geolocation.clearWatch(watchIdent)\n\nLas principales propiedades del objeto de localización (algunas sólo estarán disponible cuando usemos un GPS) son:\n\ncoords.latitude: latitud\ncoords.longitude: longitud\ncoords.accuracy: precisión (en metros)\ncoords.altitude: altitud (en metros, sobre el nivel del mar)\ncoords.altitudeAccuracy: precisión de la altitud\ncoords.heading: orientación (en grados)\ncoords.speed: velocidad (en metros/segundo)\ntimestamp: tiempo de respuesta UNIX\n\nPodemos pasarle como tercer parámetro al método getCurrentPosition un objeto JSON con una o más de estas propiedades:\n\nenableHighAccuracy: true/false que indica si el dispositivo debe usar todo lo posible para obtener la posición con mayor precisión (por defecto false porque consume más batería y tiempo)\ntimeout: milisegundos a esperar para obtener la posición antes de lanzar un error (por defecto es 0, espera indefinidamente)\nmaximumAge: milisegundos que guarda la última posición en caché. Si se solicita una nueva posición antes de expirar el\ntiempo, el navegador devuelve directamente el dato almacenado\n\nPodemos obtener más información de esta API en MDN web docs y ver y modificar ejemplos en w3schools y muchas otras páginas. i\nGoogle Maps API\nPara poder utilizar la API en primer lugar debemos obtener una API KEY de Google.\nUna vez hecho para incluir un mapa en nuestra web debemos cargar la librería para lo que incluiremos en nuestro código el script:\n&lt;script async defer\nsrc=&quot;https://maps.googleapis.com/maps/api/js?key=ESCRIBE_AQUI_TU_API_KEY&amp;callback=initMap&quot;&gt;\n&lt;/script&gt;\n\n(el parámetro callback será el encargado de llamar a la función initMap() que inicie el mapa)\nAhora incluir un mapa es tán sencillo como crear un nuevo objeto de tipo Map que recibe el elemento DOM donde se pintará (un div normalmente) y un objeto con los parámetros del mapa (como mínimo su centro y el zoom):\nlet map\nfunction initMap() {\nmap = new google.maps.Map(document.getElementById('map'), {\ncenter: { lat: 38.6909085, lng: -0.4963000000000193 },\nzoom: 12\n})\n}\n\nPor su parte añadir un marcador es igual de simple. Creamos una instancia de la clase Marker a la que le pasamos al menos la posición, el mapa en que se creará y un título para el marcador:\nlet marker = new google.maps.Marker({\nposition: { lat: 38.6909085, lng: -0.4963000000000193 },\nmap: map,\ntitle: 'CIP FP Batoi'\n})\n\nAquí tenéis el ejemplo anterior:\n\nPodemos obtener más información de esta API en Google Maps Plataform, en el tutorial de w3schools y en muchas otras páginas.",
		"tags": [ "note"]
},

{
		"title": "11-mas",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/11-mas/",
		"content": "Más cosas a aprender en Javascript\n\nMás cosas a aprender en Javascript\n\nIntroducción\nWebComponents\nWebSockets\nWebWorkers\nTypescript\njQuery\n\nIntroducción\nHace unos años Javscript era considerado un lenguaje de programación de segunda categoría, que se usaba para hacer molestas páginas web. Hoy en día el navegador es la aplicación más importante de un equipo y con él, además de navegar, se ejecutan todo tipo de aplicaciones. Además HTML5 y JavaScript han pasado de estar solo en nuestro navegador a ser un pilar básico de las plataformas móviles, de aplicaciones de escritorio e incluso JavaScript lo encontramos en servidores (con Node.js) o como lenguaje estándar de algunos entornos de escritorio (como GNOME para Linux).\nPor ello HTML5 y Javascript siguen su contínuo crecimiento... y su contínua evolución que les permite hacer cada vez más cosas. En esta página vamos a hablar muy brevemente de algunas de las características que están incorporando.\nWebComponents\nSon distintas tecnologías que podemos usar (todas o alguna de ellas) para crear componentes reutilizables para nuestras páginas HTML. Las tecnologías que hay tras los Web Components son:\n\nCustom Elements: permite crear elementos HTML personalizados, es decir, nuevas etiquetas definidas por nosotros con funcionalidad propia. Por ejemplo\n\n&lt;comp-calendar\nmode=&quot;month&quot;\ndate=&quot;2020-02-23&quot;\non-select=&quot;dateSelected()&quot; &gt;\n&lt;/comp-calendar&gt;\n\nHTML Templates: la etiqueta &lt;template&gt; permite definir fragmentos de código HTML que no serán renderizados y que usaremos más adelante. Pueden incluir slots o huecos a los que se pasa un contenido\nShadow DOM: permite asociar un DOM oculto a un elemento. Esto permite que tenga su propio código JS y estilos CSS aislados del resto del DOM\nES Modules: Es el estándar de ECMAScript para importar módulos Javascript.\n\nUn WebComponent es un elemento que creamos y que tiene su propia representación (HTML) y funcionalidad (establecida con Javascript). Este elemento es reusable y compartible y se contruye sin librerías externas, sólo con HTML5, ES6 y CSS3.\nAlgunos ejemplos de componentes útiles que podríamos usar son:\n\ncomponente para loguearnos mediante Google, Facebook, etc\ncomponente que me muestre el tiempo en una ciudad\ncomponente para hacer un modal\n...\n\nHay infinidad de páginas donde podemos aprender más sobre WebComponents y cómo crear nuestro propio componente, como:\n\nWeb Components | MDN\nIntroduction - webcomponents.org\n¿Qué son los WebComponents? - Javascript en español\nCarlos Azaustre - Cómo crear un WebComponent de forma nativa\n...\n\nEn resumen debemos crear un fichero donde definimos la clase de nuestro componente que debe heredar de HTMLElement. Es conveniente que su nombre (y por tanto el de la etiqueta que usaremos para mostrarlo) tenga al menos 2 palabras para evitar que pueda entrar en conflicto con posibles futuras etiquetas de HTML (por ejemplo podría ser &lt;social-login&gt; o &lt;my-weather&gt;). En esta clase definiremos el HTML y el estilo que tendrá nuestro componente, así como su comportamiento.\nActualmente no todos los navegadores ofrecen soporte para WebComponents. Esto junto al hecho de que frameworks como Vue, Angular o React ofrecen soluciones con sus propios componentes han hecho que el uso de los WebComponents no acabe de despegar. A pesar de ello hay lugares como WebComponents.org donde podemos encontrar un catálogo de componentes hechos y que podemos usar en nuestras páginas.\nPor su parte Google ha desarrollado la librería Polymer para ayudarnos a crear nuestros propios componentes basados en WebComponents y los principales frameworks JS como Angular o Vue permiten crear sus propios componentes de forma muy sencilla, com veremos en el bloque de Vue.\nWebSockets\nWebSockets es una tecnología basada en el protocolo ws que permite establecer una conexión continua full-duplex entre un cliente (puede ser un navegador) y un servidor. La conexión siempre la abre el cliente pero una vez abierta no se cierra por lo que el servidor puede comunicar en cualquier momento con el cliente y enviarle información.\nEjemplo:\nlet exampleSocket=new WebSocket(uri);\nexampleWebsocjet.onopen=function(event) {\nconsole.log('Se ha establecido la conexión');\n}\nexampleSocket.onclose=function(event) {\nconsole.log('Se ha cerrado la conexión');\n}\nexampleSocket.onerror=function(event) {\nconsole.log('Se ha producido un error en la conexión');\n}\nexampleSocket.onmessage=function(event) {\nconsole.log('Se ha recibido el mensaje:' + event.data);\n}\n\nEl uri de la conexión deberá usar el protocolo ws (o wss), no http (ej. &quot;ws://miservidor.com/socketserver&quot;). El evento open se produce cuando la propiedad readyState cambia a OPEN y el close cuando cambia su valor a CLOSED. Cada vez que se reciba algo del servidor se produce el evento message y en la propiedad data del mismo tendremos lo que se nos ha enviado.\nPara enviar algo al servidor usamos el mátodo .send. Lo que le enviamos ex texto en formato utf-8 (o un objeto convertido a JSON):\nexampleSocket.send('Your message');\nexampleSocket.send(JSON.stringify(msg));\n\nTambién podemos enviar (y recibir) imágenes (convertidas a ArrayBuffer) o ficheros como un objeto Blob.\nPara cerrar la conexión llamamos al método .close():\nexampleSocket.close();\nconsole.log('Conexión cerrada');\n\nPara programar la parte del servidor podemos usar librerías que nos ayudan como PHP-WebSockets, SocketIO, ...\nLas aplicaciones de esta tecnología son muchas:\n\nJuegos multjugador\nAplicaciones de chat\nActualización en tiempo real de cotizaciones de bolsa, recursos en uso o cualquier otra información\n...\n\nPodemos practicar con www.websocket.org que tiene un servidor websocket que devuelve lo que le enviamos. En esta web también tenemos ejemplos de aplicaciones.\nSaber más:\n\nMDN: Escribiendo aplicaciones con WebSockets\nWebSocket - El Tutorial de JavaScript Moderno\nCarlos Azaustre: Crear chat con WebSockets\n\nWebWorkers\nEn principio Javascript se ejecuta en un único hilo de ejecución pero esta tecnología permite ejecutar scripts en segundo plano en hilos separados que se ejecutan en segundo plano y se comunican con la tarea que los crea mediante el envío de mensajes.\nCuando se está ejecutando un script la página no responde hasta que finaliza su ejecución. Si el script lo ejecuta un web worker la página será funcional (podemos interactuar con ella) ya que le ejecución del script se realiza en segundo plano en otro hilo.\nHay 3 tipos de WebWorkers:\n\nDedicated Workers: Estos son los más comunes y se ejecutan en un hilo dedicado al contexto del script que los creó. No comparten recursos con otros scripts y son útiles para tareas intensivas que requieren mucho procesamiento.\nShared Workers: Pueden ser compartidos por varios scripts ejecutándose en diferentes ventanas, pestañas o iframes dentro del mismo dominio. Son ideales para aplicaciones que necesitan coordinar tareas entre múltiples instancias de la misma aplicación web.\nService Workers: Actúan como servidores proxy que se ejecutan en segundo plano y gestionan eventos de red como las peticiones HTTP. Son esenciales para crear aplicaciones web progresivas (PWAs) que funcionen sin conexión y mejoren la velocidad de carga.\n\nPodéis ver un ejemplo de cómo crear un WebWorker para generar números primos en el Curso DWEC de Jose Castillo\nSaber más:\n\nCurso DWEC de Jose Castillo\nMDN - Usando WebWorkers\nw3schools - HTML5 Web Workers\n\nTypescript\nTypeScript es un lenguaje de programación libre y de código abierto desarrollado y mantenido por Microsoft. Es un superconjunto de JavaScript, que esencialmente añade tipado estático y objetos basados en clases. TypeScript extiende la sintaxis de JavaScript, por tanto cualquier código JavaScript existente debería funcionar sin problemas.\nPuede que la principal diferencia entre ambos es que Typescript obliga al tipado de las variables (y por supuesto no permite cambios de tipo) lo que evita muchos errores a la hora de programar.\nAlgunos frameworks y librerías, como Angular, utilizan TS en lugar de JS como lenguaje, que luego es transpilado a JS a la hora de generar la aplicación para producción.\nQuizá el inconveniente es que es algo más difícil que JS pero como está basado en él y la sintaxis es prácticamente igual el esfuerzo de aprender TS para un programador JS es muy pequeño.\nSaber más:\n\nWikipedia - Typescript\nTypescriptlang\n\njQuery\nSe trata de una biblioteca que nos facilita enormemente el trabajo con el DOM ya que tiene &quot;atajos&quot; para muchas instrucciones, por ejemplo para poner 'Hola mundo' como contenido de un elemento cuya id es mensaje:\n// Código con Javascript sólo\ndocument.getElementById('mensaje').textContent = 'Hola mundo'\n\n// Código con jQuery\n$('#mensaje').text('Hola mundo')\n\nOtra ventaja de jQuery es que permite trabajar con conjuntos de elementos sin tener que hacer un forEach (lo hace internamente). Por ejemplo para poner un escuchador que muestre un alert 'Párrafo pinchado' al hacer click sobre cualquier párrafo de la clase 'importante' tendríamos que hacer:\n// Código con Javascript sólo\nArray.from(document.querySelectorAll('p.importante'))\n.forEach(parrafo =&gt; parrafo.addEventListener('click', () =&gt; alert('Párrafo pinchado'))\n\n// Código con jQuery\n$('p.importante').click(() =&gt; alert('Párrafo pinchado'))\n\nComo vemos, básicamente nos permite hacer lo mismo pero escribiendo mucho menos código. También incluye funciones para cosas que en Javascript requieren varias líneas de código como animaciones o Ajax. Por ejemplo una pertición para mostrar en una tabla con id posts todos los posts del servidor jsonplaceholder tendremos que hacer:\n// Código con Javascript sólo\nconst SERVER = 'https://jsonplaceholder.typicode.com';\n\nfunction getPosts() { // Función que pide los datos al servidor\nreturn new Promise(function(resolve, reject) {\nlet peticion = new XMLHttpRequest();\npeticion.open('GET', SERVER + '/posts');\npeticion.send();\npeticion.addEventListener('load', function() {\nif (peticion.status === 200) {\nresolve(JSON.parse(peticion.responseText));\n} else {\nreject(&quot;Error &quot; + this.status + &quot; (&quot; + this.statusText + &quot;) en la petición&quot;);\n}\n})\npeticion.addEventListener('error', () =&gt; reject('Error en la petición HTTP'));\n})\n}\n\nfunction renderPosts() { // Función que los muestra en la página\ngetPosts(idUser)\n.then((posts) =&gt; {\ndocument.querySelector('#posts tbody').innerHTML = ''; // borramos su contenido\nposts.forEach((post) =&gt; {\nconst newPost = document.createElement('tr');\nnewPost.innerHTML = `\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;`;\ndocument.querySelector('#posts tbody').appendChild(newPost);\n})\n})\n.catch((error) =&gt; console.error(error))\n}\n\nUsando jQuery es mucho más sencillo. En primer lugar no hay que hacer la función que hace la petición al servidor porque hay uns función que hace eso: $.ajax y sus derivadas $.get, $.post, ... Además la parte de pintar los datos es también mucho más corta:\n// Código con jquery\nconst SERVER = 'https://jsonplaceholder.typicode.com';\n\nfunction renderPosts() { // Función que los muestra en la página\n$.get(SERVER + '/posts')\n.done((posts) =&gt; {\n$('#posts tbody').text(''); // borramos el contenido de la tabla\nposts.forEach(post =&gt; $('#posts tbody').append(\n`&lt;tr&gt;\n&lt;td&gt;${post.userId}&lt;/td&gt;\n&lt;td&gt;${post.id}&lt;/td&gt;\n&lt;td&gt;${post.title}&lt;/td&gt;\n&lt;td&gt;${post.body}&lt;/td&gt;\n&lt;/tr&gt;`\n))\n})\n.fail((error) =&gt; console.error(error))\n}\n\nEncontraréis infinidad de tutoriales por Internet donde aprender jQuery, por ejemplo unos vídeos de Didacticode que podéis encontrar en https://didacticode.com/curso/curso-de-jquery/ (tenéis que registraros para tener acceso a muchos cursos de Javascript y &quot;derivados&quot; pero vale la pena) o directamente en su canal de Youtube.",
		"tags": [ "note"]
},

{
		"title": "12-tests",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/12-tests/",
		"content": "Testing\nTabla de contenidos\n\nTesting\n\nIntroducción al testing\n\nTesting en Javascript\n\nInstalar npm\nInstalar jest\nTranspilar nuestro código\n\nUsando Babel con Jest\n\nUsando Webpack\n\nInstalar webpack\nEjecutar webpack\nEnlazar el fichero generado en el HTML\n\nTestear la UI\n\nUsar jest\n\nMatchers\nTest suites\nMocks\nTestear promesas\nHooks de Jest\n\nDesarrollo guiado por pruebas (TDD)\n\nIntroducción al testing\nEs fundamental que nuestro código tenga un cierto nivel de calidad para minimizar los fallos del programa, más cuanto más compleja es la aplicación que estamos desarrollando. Para ello debemos testearlo y dicho testeo seguramente incluirá test automáticos. Dichos test nos permiten:\n\ncomprobar que nuestro código responde como se espera de él\nevitar los errores de regresión (fallos tras incluir una nueva funcionalidad en cosas que antes funcionaban en nuestro programa)\nincluso mejoran la documentación del proyecto ya que el test indica cómo debe funcionar mi código\n\nComo ya sabéis existen varios tipos de tests:\n\nunitarios: prueban un trozo de código que sólo hace una cosa (habitualmente una función)\nde integración: prueban que varias partes del código funcionan bien juntas\nde aceptación: prueba que el código permite hacer algo que el cliente quiere qu pueda hacerse\n\nDe momento desarrollaremos tests unitarios. Estos tienen 3 partes:\n\nPreparación (Arrange): perparamos el código para poder probarlo, por ejemplo, creamos las variables u objetos a probar\nActuación (Act): realizamos la acción, por ejemplo, llamamos a la función\nAserción (Assert): comprobamos que el resultado es el esperado\n\nEjemplo:\ntest('wordCount() returns 2 when the input is &quot;Hello world&quot;', () =&gt; {\n// Arrange\nconst string = 'Hello world';\n\n// Act\nconst result = wordCount(string);\n\n// Assert\nexpect(result).toBe(2);\n});\n\nTesting en Javascript\nTenemos muchas herramientas para hacer tests unitarios. Usaremos una llamada Jest. Para instalarla usaremos el gestor de paquetes npm que es el más utlizado para usar bibliotecas y sus dependencias en el FrontEnd.\nInstalar npm\nnpm es el gestor de dependencias de nodejs y aprenderemos más de él en el bloque de Vue. Debemos instalar NodeJS para tener npm. Esto podemos hacerlo desde el repositorio de nuestra distribución (con apt install nodejs) pero no se instalará la última versión. Es mejor seguir las indicaciones de la página oficial de NodeJS. Aquí tenéis cómo hacerlo para distribuciones basadas en Debian/Ubuntu.\nInstalar jest\nUna vez instalado npm crearemos una carpeta para cada proyecto que vayamos a hacer y lo inicializamos ejecutando dentro de ella:\nnpm init\n\nEste comando crea un nuevo proyecto y nos pedirá información sobre el mismo. Cuando nos pregunten por la herramienta para hacer tests escribiremos jest. Tras ello tendremos ya creado el fichero package.json de nuestra aplicación (es el fichero donde se configura el proyecto y sus dependencias). En el apartado de scripts encontramos uno llamado test que lo que hace es ejecutar jest:\n&quot;scripts&quot;: {\n&quot;test&quot;: &quot;jest&quot;\n}\n\nAhora falta instalar jest, lo que haremos con:\nnpm install --save-dev jest\n\nEstamos instalando jest sólo como dependencia de desarrollo ya que no lo necesitaremos en producción (lo mismo abreviado sería npm i -D jest).\nAunque, como vamos a utilizar jest en muchos proyectos distintos, es más conveniente instalarlo globalmente con\nnpm i -g jest\n\nDe esta forma no tendremos que instalar jest en cada nuevo proyecto, sólo hacer el npm init.\nLas dependencias que instalemos están en el directorio node_modules. Si estamos usando git debemos asegurarnos de incluir este directorio en nuestro fichero .gitignore (si no tenemos ese fichero podemos crearlo simplemente con echo &quot;node_modules&quot; &gt; .gitignore).\nTranspilar nuestro código\nVamos a crear las funciones de nuestro código en un fichero JS y para que se puedan usar el otro fichero Javascript (el de los tests) debemos exportarlas con module.exports. El fichero de test deberá importarlas con require (se explica más adelante, en el apartado de Usar Jest). Por ejemplo, tenemos un fichero llamado suma.js que contiene la función add que suma 2 números pasados por parámetro:\nfunction add(a, b) {\nreturn a + b;\n}\nmodule.exports = add;\n\nEl fichero de test, suma.test.js (normalmente le llamaremos igual pero anteponiendo .test a la extensión .js) contiene los test a ejecutar:\nconst add = require('./suma')\n\ndescribe('Addition', () =&gt; {\ntest('given 3 and 7 as inputs, should return 10', () =&gt; {\nconst expected = 10;\nconst actual = add(3,7);\nexpect(actual).toEqual(expected)\n});\n\ntest('given -4 and 2 as inputs, should return -2', () =&gt; {\nconst expected = -2;\nconst actual = add(-4,2);\nexpect(actual).toEqual(expected)\n});\n});\n\nLo que hace es:\n\nimporta la función que exporta suma.js y la almacena en la constante add. Ya pude llamar a esa función\nel bloque describe permite agrupar varios tests relacionados bajo un mismo nombre\ncada sentencia test es un test que se realizará\n\nSi ejecutamos los tests en la terminal (npm run test) muestra un error ya que Jest no sabe cómo gestionar las sentencias ECMAScript import y export. Para solucionarlo debemos transpilar nuestro código de manera que Jest pueda entenderlo. Podemos hacerlo de 2 maneras:\n\ninstalando el transpilador Babel y configurando Jest para que transpile el código\nutilizando un bundler como Webpack. En este caso no sólo transpilamos el código sino que juntamos todos nuestros ficheros JS en uno sólo que será el que enlazaremos en el fichero HTML de nuestra aplicación. Es la solución si queremos que nuestro código funcione en el navegador además de poder pasar los tests.\n\nUsando Babel con Jest\nSi queremos sólo poder pasar los tests pero no vamos a usar ese código en el navegador sólo tenemos que instalar el transpilador Babel:\nnpm add jest babel-jest @babel/core @babel/preset-env\n\nY crear 2 ficheros para configurarlo y que sepa trabajar junto a Jest:\n\njest.config.json\n\n{\n&quot;transform&quot;: {\n&quot;^.+\\\\.jsx?$&quot;: &quot;babel-jest&quot;\n}\n}\n\n.babelrc\n\n{\n&quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n}\n\nAhora ya podemos ejecutar los test y comprobar que nuestro código los pasa.\nEn la siguiente página explica cómo configurar npm y jest con babel (sin usar webpack) e integrarlo con Travis-CI, la herramienta de integracion continua de GitHub:\n\nAutomate NPM releases with Jest, codecov.io, Semantic Release, and TravisCI\n\nUsando Webpack\nCon la configuración anterior nuestro código es transpilado para ejecutar los tests, pero dará error si intentamos ejecutarlo en el navegador porque allí no está transpilado. Podemos solucionarlo usando webpack para empaquetar y transpilar el código (por tanto no sería necesario realizar lo indicado en al apartado anterior).\nWebpack el un bundler o empaquetador de código que además puede usar transpiladores para convertir nuestro código que usa versiones modernas de ECMAscript en otro soportado por la mayoría de navegadores.\nPor tanto nos va a permitir, entre otras cosas:\n\nTener en nuestro index.html una sóla entrada de script (&lt;script src=&quot;./dist/main.js'&gt;) en lugar de una para cada archivo que estemos utilizando (index.js, functions.js, ...)\nAdemás podremos usar instrucciones como module.exports para exportar funciones o require para importarlas en otro fichero Javascript, que sin traspilar provocarían errores en el navegador\n\nExisten infinidad de páginas que nos enseñan las mil posibilidades que tiene webpack, pero nosotros por ahora sólo necesitamos:\nInstalar webpack\nTenemos que instalar webpack y webpack-cli. Como son dependencias de desarrollo (en producción no las necesitaremos) ejecutamos:\nnpm i -D webpack webpack-cli\n\nEjecutar webpack\nSe ejecuta con el comando npx webpack y hay que indicarle:\n\ncuál es nuestro archivo Javascript principal de nuestro código (si no lo ponemos supondrá que es ./src/index.js)\ncuál será el archivo que creará de salida (por defecto ./dist/main.js)\nsi estamos en desarrollo o en producción, para permitir o no depurar el código generado\n\nSiguiendo con el ejemplo anterior de la suma crearemos un fichero index.js dentro de src/ que importará el fichero suma.js (con el comando requirecomo se hace en el fichero de tests) y que contendrá el resto de código de la aplicación (como pedir al usuario los números a sumar, mostrar el resultado, ...). Para que webpack empaquete y transpile esos 2 ficheros (index.js y suma.js) ejecutaremos en la terminal:\nnpx webpack --mode=development\n\nEnlazar el fichero generado en el HTML\nPor último, en nuestro index.html debemos incluir sólo el main.js generado por webpack &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;\nTestear la UI\nSi queremos hacer tests unitarios de los cambios que produce nuestro código en la página web hay varios frameworks que podemos usar, pero también podemos hacerlo sin usar ninguno, usando sólo los módulos de Node que ya tenemos instalados y Jest, en concreto su herramienta jsdom que usa para emular un navegador.\nPara usarlo debemos instalar la librería Testing Library. Para ello, tras configurar nuestro proyecto con Babel como hemos visto antes, instalaremos para desarrollo los paquetes @testing-library/dom y @testing-library/jest-dom:\nnpm i -D @testing-library/dom @testing-library/jest-dom\n\nEn el fichero de test debemos poner al principio:\nconst { fireEvent, getByText } = require('@testing-library/dom')\nimport '@testing-library/jest-dom/extend-expect'\nimport { JSDOM } from 'jsdom'\nimport fs from 'fs'\nimport path from 'path'\n\ny antes de ejecutar cada test cargamos nuestra página HTML con:\nconst html = fs.readFileSync(path.resolve(__dirname, '../index.html'), 'utf8');\n\nOJO: sólo debemos cargar así la página si confiamos totalmente en el código que vamos a probar (en este caso es nuestro código) y no deberíamos hacerlo para código de terceros.\nLuego ya podemos acceder al HTML y mirar si existen ciertas etiquetas o su contenido, como en este ejemplo:\nconst { fireEvent, getByText } = require('@testing-library/dom')\nimport '@testing-library/jest-dom/extend-expect'\nimport { JSDOM } from 'jsdom'\nimport fs from 'fs'\nimport path from 'path'\n\nconst html = fs.readFileSync(path.resolve(__dirname, '../index.html'), 'utf8');\n\nlet dom\nlet container\n\ndescribe('index.html', () =&gt; {\nbeforeEach(() =&gt; {\n// Constructing a new JSDOM with this option is the key\n// to getting the code in the script tag to execute.\n// This is indeed dangerous and should only be done with trusted content.\n// https://github.com/jsdom/jsdom#executing-scripts\ndom = new JSDOM(html, { runScripts: 'dangerously' })\ncontainer = dom.window.document.body\n})\n\nit('renders a heading element', () =&gt; {\nexpect(container.querySelector('h1')).not.toBeNull()\nexpect(getByText(container, 'Almacén central - ACME SL')).toBeInTheDocument()\n})\n})\n\nAdemás de getByText para comprobar los elementos de la página tenemos otras queries que podemos utilizar.\nFuente: How to Unit Test HTML and Vanilla JavaScript Without a UI Framework\nUsar jest\nLa documentación oficial proporciona muy buena información de cómo usarlo. En resumen, en los ficheros con las funciones que vayamos a testear debemos 'exportar' esas funciones para que las pueda importar el fichero de test. Lo haremos con module.exports:\nfunction suma(a, b) {\nreturn a + b;\n}\nmodule.exports = suma;\n\nSi tenemos varias funciones podemos exportar un objeto con todas ellas:\nmodule.exports:\nfunction suma(a, b) {\nreturn a + b;\n}\nmodule.exports = { suma, resta, multiplica, divide };\n\nEn el fichero de test (que normalmente se llamará como el original más test antes de la extensión, por ejemplo funciones.test.js) importamos esas funciones con un require:\nconst suma = require('./funciones');\n\ny ya podemos acceder llamar a la función 'suma' desde el fichero de test. Si queremos importar varias funciones haremos:\nconst funciones = require('./funciones');\n\ny accederemos a cada una como 'funciones.suma', ...\nYa podemos crear nuestro primer test para probar la función suma:\ntest('Suma 1 + 1 devuelve 2', () =&gt; {\nexpect(funciones.suma(1, 1)).toBe(2);\n});\n\nPara crear un test usamos la instrucción test (o it) a la que le pasamos como primer parámetro un nombre descriptivo de lo que hace y como segundo parámetro la función que realiza el test. En general usaremos expect y le pasamos como parámetro la llamada a la función a testear y comparamos el resultado devuelto usando un matcher.\nMatchers\nLos más comunes son:\n\ntoBe(): compara el resultado del expect con lo que le pasamos como parámetro. Sólo sirve para valores primitivos (number, string, boolean, ...) no para arrays ni objetos\ntoBeCLoseTo(): se usa para números de punto flotante. expect(0.1 + 0.2).toBe(0.3) fallaría por el error de redondeo\ntoEqual(): como el anterior pero para objetos y arrays. Comprueba cada uno de los elementos el objeto o array\ntoBeLessThan, toBeLessThanOrEqual, toBeGreaterThan, toBeGreaterThanOrEqual: para comparaciones &lt;, &lt;=, &gt;, &gt;=\ntoBeTruthy: el valor devuelvo es verdadero o asimilable a verdadero (si fuera la condición de un if se ejecutaría el then)\ntoBeFalsy: el valor devuelvo es falso o asimilable a falso (si fuera la condición de un if se ejecutaría el else)\ntoBeUndefined: el valor es undefined\ntoBeDefined: el valor NO es undefined\ntoBeNull: el valor devuelto es null\ntoMatch: el valor devuelto debe cumplir con la expresión regular pasada\ntoContain: el array devuelto debe contener el elemento pasado como parámetro\ntoHaveLength: el array o el string devueltos debe tener la longitud indicada\n\nPara comprobar si una función ha lanzado una excepción se usa toThrow. Podemos comprobar sólo que haya lanzado un error, que sea de un tipo determinado, el mensaje exacto que tiene o si el mensaje cumple con una expresión regular:\nfunction compileAndroidCode() {\nthrow new Error('you are using the wrong JDK');\n}\n\ntest('compiling android goes as expected', () =&gt; {\nexpect(compileAndroidCode).toThrow();\nexpect(compileAndroidCode).toThrow(Error);\nexpect(compileAndroidCode).toThrow('you are using the wrong JDK');\nexpect(compileAndroidCode).toThrow(/JDK/);\n});\n\nPodemos obtener la lsita completa de matchers en al documentación oficial de Jest.\nTest suites\nEn muchas ocasiones no vamos a pasar un único test sino un conjunto de ellos. En ese caso podemos agruparlos en un test suite que definimos con la instruacción describe a la que pasamos un nombre que la describa y una función que contiene todos los tests a pasar:\ndescribe('Funciones aritméticas', () =&gt; {\ntest('Suma 1 + 1 devuelve 2', () =&gt; {\nexpect(funciones.suma(1, 1)).toBe(2);\n});\n\ntest('Resta 2 - 1 devuelve 1', () =&gt; {\nexpect(funciones.resta(2, 1)).toBe(1);\n});\n});\n\nMocks\nMuchas veces debemos testear partes del código que llaman a otras funciones pero no nos interesa que se ejecuten esas funciones sino simplemente saber si se han llamado o no y con qué parámetros. Para eso se definen las fuciones mock. Consiste en declarar en nuestro fichero de test una función a la que llama el código como función de jest.\nPor ejemplo, tenemos un método de un controlador llamado addProduct que llama a otro de la vista llamado renderProduct para renderizar algo. Nosotros sólo queremos testear que se llama a la vista y que el parámetro que se le pasa es el adecuado. En nuestro test haremos:\nrenderProduct = jest.fn();\n\ntest('renderProduct called once with product {id: 1, name: &quot;Prod 1&quot;, price: 49.99}', () =&gt; {\nconst product = {id: 1, name: &quot;Prod 1&quot;, price: 49.99};\n\nrenderProduct(product);\nrenderProduct({});\n\n\texpect(renderProduct.mock.calls.length).toBe(2);\n\texpect(renderProduct.mock.calls[0][0]).toEqual(newProd);\n\texpect(renderProduct.mock.calls[1][0]).toEqual({});\n})\n\nEn realidad no se llama a la función real sino a la definida por el mock y podemos ver las veces que ha sido llamada (fn.mock.calls.length) o el primer parámetro pasado en la primera llamada (fn.mock.calls[0][0]) o en la segunda (fn.mock.calls[1][0]).\nPodéis obtener toda la información en la documentación de jest.\nTambién podemos encontrar muchos ejemplos en otras webs, como en adalab\nTestear promesas\nPara testear una función que devuelve una promesa debemos hacerlo de diferente manera. Por ejemplo tenemos una función 'getData' que devuelve una promesa. Para testearla:\ntest('getData devuelve un arrya de 3 elementos', () =&gt; {\nreturn getData().then(data =&gt; expect(data).toHaveLength(3) );\n});\n\nNo olvidéis poner el 'return', si no el test acabará sin esperar a que se resuelva la promesa. Si lo que queremos es comprobar que la promesa es rechazada haremos:\ntest('getData devuelve un arrya de 3 elementos', () =&gt; {\nexpect.assertions(1);\nreturn getData().catch(err =&gt; expect(err).toMatch('404');\n});\n});\n\nEn este caso esperamos que devuelva un error que contenga '404'. Hay que poner la línea de expect.assertions para evitar que una promesa cumplida no haga que falle el test.\nEn la documentación oficial de Jest podemos encontrar información de cómo probar todo tipo de llamadas asíncronas (callback, async/await, ...).\nHooks de Jest\nPermiten ejecutar código antes o depués de pasar cada test o el conjunto de ellos. Son:\n\nafterEach(): Después de cada prueba.\nafterAll(): Después de todas las pruebas.\nbeforeEach(): Antes de cada prueba.\nbeforeAll(): Antes de todas las pruebas.\n\nPor ejemplo podemos querer inicializar la base de datos antes de pasar cada test:\nbeforeAll(() =&gt; {\ninitializeCityDatabase();\n});\n\nSi se trata de una función asíncrona habrá que añadirle un 'return' igual que hacíamos con las promesas:\nbeforeAll(() =&gt; {\nreturn initializeCityDatabase();\n});\n\nafterAll(() =&gt; {\nreturn clearCityDatabase();\n});\n\ntest('city database has Vienna', () =&gt; {\nexpect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () =&gt; {\nexpect(isCity('San Juan')).toBeTruthy();\n});`\n\nDesarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y luego el código que las pase. Por último deberíamos refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el test (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).",
		"tags": [ "note"]
},

{
		"title": "README",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/readme/",
		"content": "BLOQUE 1 - El lenguaje Javascript\nEn este primer bloque vamos a conocer el lenguaje Javascript. El bloque se divide en:\n\nIntroducción a Javascript\n1-Sintaxis: Variables. Funciones. Estructuras y bucles. Tipos de datos. Buenas prácticas\n\nIntroducción a los test en Javascript\n\n2.1-Objetos: Introducción a los objetos en Javascript\n2.2-Arrays: Métodos. Functional Programming. Referencia vs copia. Rest y Spread. Desestructuración de arrays. Map. Set\n\nVite: Cómo usar vite\nWebpack: Cómo usar webpack\n\n3-Programación Orientada a Objetos: Introducción. Clases. POO en JS5\n4-Browser Object Model - BOM: Timers. Objetos del BOM (window,\n5-Ajax. Promesas. SPA\n6-Document Object Model - DOM: Acceso a nodos. Acceso desde otros nodos. Manipular el árbol DOM. Atributos de los nodos\n\n6.1-MVC: Cómo usaremos el patrón MVC para crear la UI de nuestra aplicación\nlocation, history, otros objetos)\n\n7-Eventos: Escuchadores. Tipos de eventos. Los objetos this y event. Propagación de eventos (bubbling)\n8-Objetos nativos: Funciones globales. Objetos nativos del lenguaje: Math, Date, RegExp, ...\n9-Validación de formularios: Validación de formularios. La API de validación de formularios. Expresiones regulares\n\n10-APIs HTML5: Drag and drop. API Storage. Geolocalización. API de Google Maps\n11-Más cosas a aprender...: WebComponents. WebSockets. WebWorkers. Typescript.\n12-Tests: Testear JS con Jest\n\nIntroducción a Javascript\n\nBLOQUE 1 - El lenguaje Javascript\nIntroducción a Javascript\n\nIntroducción\n\nUn poco de historia\nSoporte en los navegadores\n\nHerramientas\n\nLa consola del navegador\nEditores\nEditores on-line\n\nIncluir javascript en una página web\nMostrar información\n\nBibliografía\n\nIntroducción\nEn las páginas web el elemento fundamental es el fichero HTML con la información a mostrar en el navegador. Posteriormente surgió la posibilidad de &quot;decorar&quot; esa información para mejorar su apariencia, lo que dio lugar al CSS. Y también se pensó en dar dinamismo a las páginas y apareció el lenguaje Javascript.\nEn un primer momento las 3 cosas estaban mezcladas en el fichero HTML pero eso complicaba bastante el poder leer esa página a la hora de mantenerla por lo que se pensó en separar los 3 elementos básicos:\n\nHTML: se encarga de estructurar la página y proporciona su información, pero es una información estática\nCSS: es lo que da forma a dicha información, permite mejorar su apariencia, permite que se adapte a distintos dispositivos, ...\nJavascript: es el que da vida a un sitio web y le permite reaccionar a las acciones del usuario\n\nPor tanto nuestras aplicaciones tendrán estos 3 elementos y lo recomendable es que estén separados en distintos ficheros:\n\nEl HTML lo tendremos habitualmente en un fichero index.html, normalmente en una carpeta llamada public\nEl CSS lo tendremos en uno o más ficheros con extensión .css dentro de una carpeta llamada styles\nEL JS estará en ficheros con extensión .js en un directorio llamado scripts\n\nLas características principales de Javascript son:\n\nes un lenguaje interpretado, no compilado\nse ejecuta en el lado cliente (en un navegador web), aunque hay implementaciones como NodeJS para el lado servidor\nes un lenguaje orientado a objetos (podemos crear e isntanciar objetos y usar objetos predefinidos del lenguaje) pero basado en prototipos (por debajo un objeto es un prototipo y nosotros podemos crear objetos sin instanciarlos, haciendo copias del prototipo)\nse trata de un lenguaje débilmente tipado, con tipificación dinámica (no se indica el tipo de datos de una variable al declararla e incluso puede cambiarse)\n\nLo usaremos para:\n\nCambiar el contenido de la página\nCambiar los atributos de un elemento\nCambiar la apariencia de algo\nValidar datos de formularios\n...\n\nSin embargo, por razones de seguridad, Javascript no nos permite hacer cosas como:\n\nAcceder al sistema de ficheros del cliente\nCapturar datos de un servidor (puede pedirlo y el servidor se los servirá, o no)\nModificar las preferencias del navegador\nEnviar e-mails de forma invisible o crear ventanas sin que el usuario lo vea\n...\n\nUn poco de historia\nJavascript es una implementación del lenguaje ECMAScript (el estándar que define sus características). El lenguaje surgió en 1997 y todos los navegadores a partir de 2012 soportan al menos la versión ES5.1 completamente. En 2015 se lanzó la 6ª versión, inicialmente llamada ES6 y posteriormente renombrada como ES2015, que introdujo importantes mejoras en el lenguaje y que es la versión mínima que usaremos nosotros. Desde entonces van saliendo nuevas versiones cada año que introducen cambios pequeños. La última es la ES2024.\nLas principales mejoras que introdujo ES2015 son: clases de objetos, let, for..of, Map, Set, Arrow functions, Promesas, spread, destructuring, ...\nSoporte en los navegadores\nLos navegadores no se adaptan inmediatamente a las nuevas versiones de Javascript por lo que puede ser un problema usar una versión muy moderna ya que puede haber partes de los programas que no funcionen en los navegadores de muchos usuarios. En la página de Kangax podemos ver la compatibilidad de los diferentes navegadores con las distintas versiones de Javascript. También podemos usar CanIUse para buscar la compatibilidad de un elemento concreto de Javascript así como de HTML5 o CSS3.\nSi queremos asegurar la máxima compatibilidad debemos usar la versión ES5 (pero nos perdemos muchas mejoras del lenguaje) o mejor, usar la ES6 (o posterior) y después transpilar nuestro código a la version ES5. De esto se ocupan los transpiladores (Babel es el más conocido) por lo que no suponen un esfuerzo extra para el programador.\nHerramientas\nLa consola del navegador\nEs la herramienta que más nos va a ayudar a la hora de depurar nuestro código. Abrimos las herramientas para el desarrollador (en Chrome y Firefox pulsando la tecla F12) y vamos a la pestaña Consola:\n![Consola](/img/user/notas/Javascript Teoria Batoi/img/Consola.png)\nAllí vemos mensajes del navegador como errores y advertencias que genera el código y todos los mensajes que pongamos en el código para ayudarnos a depurarlo (usando los comandos console.log y console.error).\nAdemás en ella podemos escribir instrucciones Javascript que se ejecutarán mostrando su resultado. También la usaremos para mostrar el valor de nuestras variables y para probar código que, una vez que funcione correctamente, lo copiaremos a nuestro programa.\nPodemos obtener ayuda sobre el funcionamiento de la consola en la web de Mozilla.\n\nEJERCICIO: abre la consola y prueba las funciones alert, confirm y prompt.\n\nSiempre depuraremos los programas desde aquí (ponemos puntos de interrupción, vemos el valor de las variables, ...).\n![Consola - depurar](/img/user/notas/Javascript Teoria Batoi/img/Consola-depurar.png)\nEs fundamental dedicar tiempo a saber utilizar la consola porque nos facilitará enormemente la tarea de depurar nuestro código. Podéis encontrar infinidad de páginas en internet donde nos explican en profundidad el uso de la consola, como Debugging en el navegador.\nEditores\nPodemos usar el que más nos guste, desde editores tan simples como NotePad++ hasta complejos IDEs. La mayoría soportan las últimas versiones de la sintaxis de Javascript (Netbeans, Eclipse, Visual Studio, Sublime, Atom, Kate, Notepad++, ...). Yo voy a utilizar Visual Studio Code o Sublime text por su sencillez y por los plugins que incorpora para hacer más cómodo mi trabajo. En Visual Studio Code instalaré algún plugin como:\n\nSonarLint: es más que un linter y me informa de todo tipo de errores pero también del código que no cumple las recomendaciones (incluye gran número de reglas). Marca el código mientras lo escribimos y además podemos ver todas las advertencias en el panel de Problemas (Ctrl+\nVetur: lo instalaremos en el segundo bloque. Necesario para trabajar con los ficheros de Vue\n\nEditores on-line\nSon muy útiles porque permiten ver el código y el resultado a la vez. Normalmente tienen varias pestañas o secciones de la página donde poner el código HTML, CSS yJavascript y ver su resultado.\nAlgunos de los más conocidos son Codesandbox, Fiddle, Plunker, CodePen, ...aunque hay muchos más.\n\nEjemplo de 'Hello World' en Fiddle:\n\nEjemplo de 'Hello World' en CodePen:\n\nSee the Pen\nHello World Codepen by Kevin Schweickhardt (@kscatcensus)\non CodePen.\n\nIncluir javascript en una página web\nEl código Javascript va entre etiquetas &lt;script&gt;. Puede ponerse en el &lt;head&gt; o en el &lt;body&gt;. Funciona como cualquier otra etiqueta y el navegador la interpreta cuando llega a ella (va leyendo y ejecutando el fichero línea a línea). Podéis ver en este vídeo un ejemplo muy simple de cómo se ejecuta el código en el HEAD y en el BODY.\nLo mejor en cuanto a rendimiento es ponerla al final del &lt;body&gt; para que no se detenga el renderizado de la página mientras se descarga y se ejecuta el código. También podemos ponerlo en el &lt;head&gt; pero usando los atributos async y/o defer (en Internet encontraréis mucha información sobre esta cuestión, por ejemplo aquí.\nComo se ve en el primer vídeo, es posible poner el código directamente entre la etiqueta &lt;script&gt; y su etiqueta de finalización pero lo correcto es que esté en un fichero externo (con extensión .js) que cargamos mediante el atributo src de la etiqueta. Así conseguimos que la página HTML cargue más rápido (si lo ponemos al final del BODY o usamos async) y además no mezclar HTML y JS en el mismo fichero, lo mejora la legibilidad del código y facilita su mantenimento:\n&lt;script src=&quot;./scripts/main.js&quot;&gt;&lt;/script&gt;\n\nMostrar información\nJavascript permite mostrar al usuario ventanas modales para pedirle o mostrarle información. Las funciones que lo hacen son:\n\nwindow.alert(mensaje): Muesta en una ventana modal mensaje con un botón de Aceptar para cerra la ventana.\nwindow.confirm(mensaje): Muesta en una ventana modal mensaje con botones de Aceptar y Cancelar. La función devuelve true o false en función del botón pulsado por el usuario.\nwindow.prompt(mensaje [, valor predeterminado]): Muesta en una ventana modal mensaje y debajo tiene un campo donde el usuario puede escribir, junto con botones de Aceptar y Cancelar. La función devuelve el valor introducido por el usuario como texto (es decir que si introduce 54 lo que se obtiene es &quot;54&quot;) o false si el usuario pulsa Cancelar.\n\nTambién se pueden escribir las funciones sin window. (es decir alert('Hola') en vez de window.alert('Hola')) ya que en Javascript todos los métodos y propiedades de los que no se indica de qué objeto son se ejecutan en el objeto window.\nSi queremos mostrar una información para depurar nuestro código no utilizaremos alert(mensaje) sino console.log(mensaje) o console.error(mensaje). Estas funciones muestran la información pero en la consola del navegador. La diferencia es que console.error la muestra como si fuera un error de Javascript.\nBibliografía\n\nCurso &quot;Programación con JavaScript&quot;. CEFIRE Xest. Arturo Bernal Mayordomo\nCurso de JavaScript y TypeScript de Arturo Bernal en Youtube\nMDN Web Docs. Moz://a. https://developer.mozilla.org/es/docs/Web/JavaScript\nIntroducción a JavaScript. Librosweb. http://librosweb.es/libro/javascript/\nCurso de Javascript (Desarrollo web en entorno cliente). Ada Lovecode - Didacticode (90 vídeos) de Laura Folgado\nApuntes Desarrollo Web en Entorno Cliente (DWEC). Sergi García Barea",
		"tags": [ "note"]
},

{
		"title": "TDD-mocha",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/tdd-mocha/",
		"content": "Desarrollo guiado por pruebas (TDD)\nEs una forma de programar que consiste en escribir primero las pruebas que deba pasar el código (Test Dirve Development) y después refactorizarlo (Refactoring). Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés).\nEl ciclo de programación usando TDD tiene tres fases:\n\nFase roja: escribimos el test que cumpla los requerimientos y lo pasamos. Fallará ya que nuestro código no pasa el est (de hecho la primera vez no tenemos ni código)\nFase verde: conseguimos que nuestro código pase el test. Ya funciona aunque seguramente no estará muy bien escrito\nRefactorización: mejoramos nuestro código\n\nEn primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.\nPara ello debemos en primer lugar se debe definir una lista de requisitos y después se ejecuta el siguiente ciclo:\n\nElegir un requisito: Se elige de una lista el requisito que se cree que nos dará mayor conocimiento del problema y que a la vez sea fácilmente implementable.\nEscribir una prueba: Se comienza escribiendo una prueba para el requisito. Para ello el programador debe entender claramente las especificaciones y los requisitos de la funcionalidad que está por implementar. Este paso fuerza al programador a tomar la perspectiva de un cliente considerando el código a través de sus interfaces.\nVerificar que la prueba falla: Si la prueba no falla es porque el requisito ya estaba implementado o porque la prueba es errónea.\nEscribir la implementación: Escribir el código más sencillo que haga que la prueba funcione. Se usa la expresión &quot;Déjelo simple&quot; (&quot;Keep It Simple, Stupid!&quot;), conocida como principio KISS.\nEjecutar las pruebas automatizadas: Verificar si todo el conjunto de pruebas funciona correctamente.\nEliminación de duplicación: El paso final es la refactorización, que se utilizará principalmente para eliminar código duplicado. Se hace un pequeño cambio cada vez y luego se corren las pruebas hasta que funcionen.\nActualización de la lista de requisitos: Se actualiza la lista de requisitos tachando el requisito implementado. Asimismo se agregan requisitos que se hayan visto como necesarios durante este ciclo y se agregan requisitos de diseño (P. ej que una funcionalidad esté desacoplada de otra).\n\nTener un único repositorio universal de pruebas facilita complementar TDD con otra práctica recomendada por los procesos ágiles de desarrollo, la &quot;Integración Continua&quot;. Integrar continuamente nuestro trabajo con el del resto del equipo de desarrollo permite ejecutar toda batería de pruebas y así descubrir si nuestra última versión es compatible con el resto del sistema. Es recomendable y menos costoso corregir pequeños problemas cada pocas horas que enfrentarse a problemas enormes cerca de la fecha de entrega fijada.\n(Fuente Wikipedia).\nUsar TDD en Javascript\nLo más sencillo es usar alguna librería como Mocha. Se trata de un gramework que se ejecuta sobre Node.js y permite crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado. Luego creamos una carpeta para nuestro proyecto y dentro ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
},

{
		"title": "ejercicios",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/ejercicios/",
		"content": "Ejercicios de Javascript\n\nTable of Contents generated with DocToc\n\nEjercicios de Javascript\n\n1.- Sintaxis\n\n1.1 Frase\n\n2.- Arrays\n3.- POO\n\n3.1.- Productos de un almacén\n3.2.- Carro de compra\n\n4.- DOM\n5.- BOM\n6.- Eventos\n7.- Objetos globales\n8.- Ajax\n9.- APIs\n\n1.- Sintaxis\n1.1 Frase\nVamos a pedir al usuario que introduzca una frase y a continuación mostraremos en la consola:\n\nel número de letras y de palabras que tiene\nla frase en mayúsculas\nla frase con la primera letra de cada palabra en mayúsculas\nla frase escrita con las letras al revés\nla frase escrita con las palabras al revés\nsi es o no un palíndromo (si se lee igual al revés) pero omitiendo espacios en blanco y sin diferenciar mayúsculas y minúsculas.\n\nEj.: con la frase introducida “La ruta nos aporto otro paso natural” se mostraría\n\n36 letras y 7 palabras\nLA RUTA NOS APORTO OTRO PASO NATURAL\nLa Ruta Nos Aporto Otro Paso Natural\nlarutan osap orto otropa son atur aL\nnatural paso otro aporto nos ruta La\nSí es un palíndromo\n\nIntenta usar en cada caso el bucle más adecuado. Las funciones split y join (lo opuesto) de String y Array nos pueden ayudar a algunas cosas.\nRECUERDA:\n\nel código deberá estar en un fichero externo y se incluirá al final del body\ndebes comentarlo para tener claro qué hace\ntanto el código JS como el HTML deben estar correctamente indentados\nten en cuenta los datos que pueden “estropearnos” el programa: introducir un dato de un tipo que no te esperas, omitir algún parámetro, ...\nusa las recomendaciones indicadas: 'use strict', ...\nel código debe ser lo más limpio y claro posible, sin variables o código innecesario\nsiempre es bueno refactorizar el código: cuando nuestro programa ya funciona bien le damos un “repaso” para mejorar su claridad (y lo volvemos a probar)\n\n2.- Arrays\nVamos a hacer un programa que va pidiendo al usuario que introduzca las notas de un examen y las va guardando en un array. El usuario puede introducir una sóla nota o varias separadas por un guión (ej. 4,5 - 6 - 8,75) y se continuará pidiendo notas al usuario hasta que éste pulse 'Cancelar'. Recuerda que en Javascript el símbolo decimal es el punto pero el usuario puede introducir decimales con la coma.\nCada nota introducida se almacenará en un array y una vez que estén todas se mostrará por la consola:\n\nel array con los datos suministrados por el usuario\nel array &quot;limpiado&quot;: quitaremos del mismo todo lo que no sean números o no estén entre 0 y 10\nel nº total de aprobados y sus notas\nel nº total de suspensos y sus notas\nla nota del 1º suspenso y su posición en el array\nla nota media del examen\n\nSiempre que sea posible utilizaremos métodos de arrays en lugar de bucles.\n3.- POO\n3.1.- Productos de un almacén\nEn este ejercicio vamos a trabajar con los productos de un almacén, para lo que crearemos las clases:\n\nProduct: cada producto será un objeto con las propiedades cod, name, price y units (las unidades que tenemos de ese producto). Si no le pasamos unidades al constructor su número por defecto será 1. Esta clase tendrá los siguientes métodos:\n\nchangeUnits: recibe la cantidad a aumentar (positiva o negativa) e incrementa (o decrementa) las unidades en la cantidad recibida. Si se intentan restar más unidades de las que hay no hace nada y devuelve false y en otro caso cambia las unidades y devuelve true\nproductImport: devuelve el importe total del producto (su precio multiplicado por el nº de unidades)\nademás si se intenta imprimir el producto se mostrará su descripción, sus unidades entre paréntesis, su precio y el importe total, como en el siguiente ejemplo: TV Samsung MP45 (5): 235,95 €/u =&gt; 1179,75 €\n\nStore: es el almacén de productos y tendrá las propiedades id (código numérico que nos pasan al crear el almacén) y products (array de productos que al crearlo estará vacío) y los métodos:\n\nfindProduct: recibe un código de producto y devuelve el producto que tiene dicho código o null si ese código no existe en el almacén\naddProduct: recibe como parámetro el código y unidades a añadir y, opcionalmente, el nombre y precio (si se trata de un producto nuevo) y lo añade al almacén. Si ya existe el código suma al producto las unidades indicadas y si no existe crea un nuevo producto en el array. Devuelve true\ndelProduct: recibe como parámetro el código y las unidades a quitar de un producto y lo resta del almacén. Devuelve true a menos que haya menos unidades de las que quieren restarse, en cuyo caso no hace nada y devuelve false\ntotalImport: devuelve el valor total de los productos del almacén\norderByDescrip: devuelve el array de productos ordenado por el nombre\norderByUnits: devuelve el array de productos ordenado por unidades descendente\n\nPara probar que funciona correctamente ejecutaremos en nuestro fichero main.js:\nlet almacen=new Store(1);\nalmacen.addProduct(1, 4, 'TV Samsung MP45', 345.95);\nalmacen.addProduct(2, 8, 'Portátil Acer Travelmate 200', 245.95);\nalmacen.addProduct(3, 15, 'Impresora Epson LX-455', 45.95);\nalmacen.addProduct(4, 25, 'USB Kingston 16GB', 5.95);\n\nconsole.log('LISTADO DEL ALMACÉN');\nalmacen.products.forEach(prod=&gt;console.log(prod.toString()));\n\nalmacen.addProduct(5, 15, 'USB Kingston 64GB', 15.95);\nalmacen.delProduct(3, 11);\nalmacen.delProduct(3, 7);\nalmacen.addProduct(1, 9);\n\nconsole.log('LISTADO DEL ALMACÉN');\nalmacen.products.forEach(prod=&gt;console.log(prod.toString()));\n\nAdemás en nuestro main.js haremos que se muestren por consola todos los productos de los que tenemos menos de 5 unidades en stock o cuyo importe es inferior a 150 €.\n3.2.- Carro de compra\nVamos a permitir que los usuarios hagan compras on-line para lo que crearemos una clase para los carritos de la compra:\n\nCart: esta clase la usaremos para crear carritos de compra con los productos a comprar. Es como la clase Store pero tiene además la propiedad user con el identificador del usuario que hace la compra y que nos lo pasarán al crear el carrito. Respecto a sus métodos son igual que los de la clase Store pero:\n\nel método delProduct eliminará el producto del array de productos si sus unidades son 0\ntendrá dos nuevos métodos addToCart y removeFromCart que nos permitan añadir y quitar productos del carro y que recibirán como parámetros el código del producto y las unidades a añadir o quitar.\n\nNOTA: la variable del almacén será una variable global en el fichero main.js\n4.- DOM\nVamos a mostrar en una tabla los products de nuestro almacén. Cada fila corresponderá a un producto y se mostrará su código, nombre, unidades, precio por unidad e importe. Debajo de la tabla mostraremos el importe total del almacén. En el fichero index.html crearemos la tabla vacía y el párrafo para poner el importe total.\nPara simplificar nuestro código a la clase Product le añadiremos el método toTR que devolverá el código HTML para mostrar una fila con los datos del producto y a la clase Store le añadiremos el método toHTML que devolverá el código HTML que insertaremos dentro de la tabla del almacén.\nAdemás cada vez que creemos un carrito se mostrará en la página una nueva UL con su código y su usuario. Cada artículo del carro será una LI de la UL y al final habrá una LI con el importe total del carro. Ej.:\n\nCarro 2 - juan\n\n1 x TV Samsung MP45 (345.95 €) = 345.95 €\n3 x USB Kingston 16GB (5.95 €) = 17.85 €\nImporte total: 353.80 €\n\nNOTA: podemos hacer algo para que sea más fácil crear los elementos del DOM tal y como hems hecho para crear la tabla???.\nOPCIONAL: mejorar la presentación usando bootstrap. Pondremos la tabla del almacén y debajo los carritos, 2 por fila.\n5.- BOM\n6.- Eventos\nBotones y enlaces para el ejercicio del almacén\n7.- Objetos globales\nFechas, ...\n8.- Ajax\nLeer y guardar el almacén (y los carritos?)\n9.- APIs",
		"tags": [ "note"]
},

{
		"title": "xx-tests",
		"date":"Tue Oct 15 2024 18:18:20 GMT+0000 (Coordinated Universal Time)",
		"url":"/notas/javascript-teoria-batoi/xx-tests/",
		"content": "Usar TDD en Javascript\nLo más sencillo es usar alguna librería como Jest, Mocha o Vitests (una adaptación de Jest para Vite). Se trata de librerías que se ejecutan sobre Node.js y permiten crear tests tanto síncronos como asíncronos. Para usarlo necesitaremos tener npm instalado.\nUso de Vitest\nPodéis obtener información sobre cómo hacer test con Vitest en muchas páginas de Internet como:\n\nCurso DWEC de Jose Castillo\nVitest\n\nUso de Mocha\nPara instalarlo ejecutamos:\nnpm install -g mocha # lo instalamos globalmente para que esté disponible para todos los proyectos\nnpm init # crea en el directorio el package.json\nnpm install chai # en vez de chai podríamos usar assert, should, etc\n\nLa librería Chai permite 3 tipos de sentencias:\n\nasserts\nexpects\nshould\n\nNosotros vamos a usar asserts por lo que es lo que deberemos importar en los ficheros de tests.\nDentro de nuestro proyecto crearemos una carpeta donde guardaremos los ficheros JS de los tests (podemos llamarla 'tests') y en cada fichero importaremos chai y los ficheros necesarios. Ej.:\n\nFichero tests/store.specs.js\n\nconst assert = require('chai').assert;\nconst Store = require('../store.class.js');\n\ndescribe('Store', () =&gt; {\n\n\tit('should had an integer id', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.id, 'integer', 'La id no es un entero')\n\t});\n\n\tit('should had an empty array of products', function() {\n\t\tlet foo = new Store();\n\t\tassert.typeOf(foo.products, 'array', 'Products no es un array')\n\t\tassert.lengthOf(foo.products, 0, 'Products no es un array vacío')\n\t});\n})\n\nPara poder importar un módulo con require debemos haberlo exprtado previamente:\n\nFichero store.js\n\nclass Store {\nconstructor (id) {\nthis.id=id;\nthis.products=[];\n}\n...\n}\nmodule.exports = Store;\n\nPara ejecutar todos los tests de nuestro proyecto ejecutaremos desde la terminal:\nmocha tests\n\nSi sólo queremos pasar uno lo indicamos en el comando: mocha tests/store.specs.js.\nPodemos hacer que mocha escuche en segundo plano y se ejecute automáticamente cada vez que hacemos algún cambio en un fichero con:\nmocha tests --watch\n\nEl fichero de tests\nDebemos importar le librería Chai y el fichero con el código a testear como hemov visto antes. El fichero con el código que debe exportar la clase o función que contiene con module.exports. Si queremos exportar varias funciones exportaremos un objeto con todas ellas:\nmodule.exports = {\naddItem,\nremoveItem\n}\n\nTras importar los ficheros pondremos el describe y los bloques it que queramos y dentro de cada uno los aasert necesarios:\nconst assert = require('chai').assert;\nconst index = require('../index.js');\n\ndescribe('manage items', () =&gt; {\n\tit('add a new item', function() {\n\t\tlet myItem = ...;\n\t\tassert.typeOf(item, 'object', 'No crea un objeto sino '+typeof(item) );\n\t\tassert.equal(item.units, 0);\n\t});\n\t\n\tif ('change an item () =&gt; {\n\t...\n\t});\n})\n\nAlgunas sentecias assert\nEstas\nAquí tenéis un pequeño resumen de algunas de las sentencias que podemos usar. Recordad que todas pueden tener un último parámetro opcional que es un mensaje a mostrar en caso de que falle esta comprobación:\n\n.equal(actual, esperado): comprueba que sea el mismo valor, pero sin comprobar los tupos (usa ==, no ===)\n.notEqual(actual, esperado)\n.strictEqual, .notStrictEqual: igual pero hace la compribaciónestricta (===)\n.deepEqual, notDeepEqual: hace una comprobación de cada propiedad del objeto pasado\n.match(valor, regexp), .notMatch: comprueba si el valor cumple o no la expresión regular pasada\n.isAbove(actual, esperado): comprueba que actual &gt; esperado\n.isAtLeast(actual, esperado): comprueba que actual &gt;= esperado\n.isBelow, .isAtMost: comprueba que sea &lt; o &lt;= respectivamente\n.isTrue, .isNotTrue, .isFalse, .isNotFalse, .isNull, .isNotNull, .isUndefined, .isDefined, .isNaN, .isNotNaN, .isFunction, .isNotFunction, .isObject, .isNotObject, .isArray, .isNotArray, .isString, .isNotString, .isNumber, .isNotNumber, .isBoolean, .isNotBoolean, .isFinite\n.exists(valor), .notExists: comprueba que valor no sea (o sea) null o undefined\n.typeOf(valor, tipo), .notTypeOf: indica si valor es o no del tipo indicado, que puede ser 'string', 'number', boolean', 'array', 'object', 'null', 'undefined', 'regexp', ...\n.instanceOf(objeto, Clase), .notInstanceOf: indica si un objeto es o no una instancia de la clase indicada\n.include(string/array/objeto, substring/elemento/propiedad:valor): comprueba si la subcadena existe en el string o el elemento se encuentra en el array (usa =) o si existe la propiedad o propiedades pasadas y su valor es estrictamente (=) igual al indicado.\n.notInclude\n.property(objeto, propiedad), .notProperty: comprueba si el objeto posee o no la propiedad pasada\n.lengthOf(string/array, num): comprueba que la longitud de la cadena o el array sea la indicada\n.isEmpty(string/array/object), .isNotEmpty: comprueba que la cadena sea '', el array [] o el objeto {}, o no.\n.throws(funcion, [errorLike/string], [string]): para comprobar que la función lanza un error del tipo indicado (TypeError, RangeError, ...) e incluso con el mensaje indicado\n\nMás información en la [página de Chai])https://www.chaijs.com/api/assert/).\nTests de funciones asíncronas con promesas\nSi hacemos llamadas asíncronas Mocha permite testearlas tras el .then o el .catch:\ndescribe('API de artículos', () =&gt; {\n\tit('should return the article 3', function() {\n\t\treturn getArticulo(3)\n\t\t\t.then(art =&gt; {\n\t\t\t\tassert.instanceOf(art, Articulos);\n\t\t\t\tassert.equal(art.id, 3);\n\t\t\t})\n\t});\n\tit('should return an error', function() {\n\t\treturn getArticulo(undefined)\n\t\t\t.catch(err =&gt; {\n\t\t\t\t...\n\t\t\t})\n\t});\n})\n\nHooks de Mocha\nNos permiten ejecutar código en momentos puntuales. Reciben como parámetro la función a ejecutar. Son:\n\nbefore(): el código se ejecutará una vez antes del primer test del bloque describe\nbeforeEach(): se ejecutará antes de cada test\nafter(), afterEach(): lo mismo pero tras ejecutar los tests\n\nTests para la UI\nNecesitaremos alguna librería que nos permita contruir escenarios de navegación como CasperJS y otra que imite al navegador como PhantomJS (para WebKit) o SlimerJS (para Gecko).\nHay muchas páginas que nos enseñan a usar Mocha para testear la UI como:\n\nWeb UI Testing in NodeJS\nUI Test Automation with Node.js, TypeScript, Mocha and Selenium\nAutomated UI Testing with Selenium and JavaScript\nAutomated UI/UX Testing with Puppeteer Mocha and Chai",
		"tags": [ "note"]
}
]